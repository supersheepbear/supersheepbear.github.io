<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>278 - cpp 指针管理类对象示例 | Bear's dream</title><meta name="description" content="278 - cpp 指针管理类对象示例"><meta name="keywords" content="Cpp,Coding,Developer,Class,Object"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="278 - cpp 指针管理类对象示例"><meta name="twitter:description" content="278 - cpp 指针管理类对象示例"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="278 - cpp 指针管理类对象示例"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/278%20-%20cpp%20%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%A4%BA%E4%BE%8B/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="278 - cpp 指针管理类对象示例"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/278%20-%20cpp%20%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%A4%BA%E4%BE%8B/"><link rel="prev" title="277 - IDE 创建 cpp 类方法" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/277%20-%20IDE%20%E5%88%9B%E5%BB%BA%20cpp%20%E7%B1%BB%E6%96%B9%E6%B3%95/"><link rel="next" title="279 - cpp析构函数：对象销毁时的内存释放" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/279%20-%20cpp%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-指针管理类对象示例"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">C++ 指针管理类对象示例</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#1-标题和摘要"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">1. 标题和摘要</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2-详细解释"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">2. 详细解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#4-QA闪卡-QA-Flash-Cards"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">4. QA闪卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#5-常见误解或易犯错误"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">5. 常见误解或易犯错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#6-编码练习"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">6. 编码练习</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#7-用户解答评估、正确答案及解释"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">7. 用户解答评估、正确答案及解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#8-建议与扩展问题"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">8. 建议与扩展问题</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-指针管理类对象示例"><span class="toc-number">1.</span> <span class="toc-text">C++ 指针管理类对象示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-标题和摘要"><span class="toc-number">2.</span> <span class="toc-text">1. 标题和摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-详细解释"><span class="toc-number">3.</span> <span class="toc-text">2. 详细解释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-代码示例"><span class="toc-number">4.</span> <span class="toc-text">3. 代码示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-QA闪卡-QA-Flash-Cards"><span class="toc-number">5.</span> <span class="toc-text">4. QA闪卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-常见误解或易犯错误"><span class="toc-number">6.</span> <span class="toc-text">5. 常见误解或易犯错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-编码练习"><span class="toc-number">7.</span> <span class="toc-text">6. 编码练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">7.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">7.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-用户解答评估、正确答案及解释"><span class="toc-number">8.</span> <span class="toc-text">7. 用户解答评估、正确答案及解释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-建议与扩展问题"><span class="toc-number">9.</span> <span class="toc-text">8. 建议与扩展问题</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">278 - cpp 指针管理类对象示例</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/278%20-%20cpp%20%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%A4%BA%E4%BE%8B/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/278%20-%20cpp%20%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%A4%BA%E4%BE%8B/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="C-指针管理类对象示例"><a href="#C-指针管理类对象示例" class="headerlink" title="C++ 指针管理类对象示例"></a>C++ 指针管理类对象示例</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to see how we can manage our class objects through pointers.And in most cases, we need to manage our class object through pointers if we are using some form ofdynamic memory allocation.Here is a simple example.We have our cylinder class included and down here you see that we can create the cylinder objects onthe stack.If we use the syntax like we do here, the objects are going to be created on the stack and we haveseen that we can access the behaviors or data inside our class object using the dot notation like wedo here.For example, here we are calling our volume function, but sometimes we want to manage our objectsthrough pointers.For example, if you look at the syntax we have here, we are saying cylinder and using the asteriskhere, this is going to say that this is going to be a pointer to a cylinder type and we’re going togive it a name C two and we can allocate our object on the heap using the new operator.This is going to dynamically allocate space from the heap, and that memory space is going to be usedto store our cylinder object.Now, the interesting thing is going to happen when you try to access behaviors from your cylinder object.Here, for example, if we look at this line here, we are trying to print the volume of this cylinderand you notice that we have to go through ugly dereferencing here.We have to dereference the object and then call our method through the dot operator here.But what I want you to see is that we can avoid this ugly dereferencing we are doing here and use thepointer access notation.This dash greater than symbol you see here is going to allow us to access stuff directly using the pointerto an object that is dynamically allocated on the heap.Okay.After we are done using our cylinder object, remember it is memory that was dynamically allocated fromthe heap.We have to release the memory so that it can be used by the operating system and we release the memoryusing the delete operator as we do here.Okay.The idea I wanted to introduce here is that we can use pointers to manage our cylinder objects and thisis one way we can do this.And once we are using a pointer as a handle to our cylinder object, we can use the pointer access operatorhere to access stuff from our class objects easily.And another thing you should know is that we can actually create a cylinder object and storing the addressof objects that we have on the stack.And we’re going to see this in a minute when we hit Visual Studio Code.Now that you have an idea about this, let’s head over to Visual Studio code and play with this a littlemore.Okay.Here we are in our working folder.The current project is managing class objects through pointers.We can see the entire name here and now we’re not going to grab our template project because we wantto start from the project we had in this lecture on class across multiple files.So we’re going to go in that project and grab everything from there except for the executable becausewe obviously don’t want this and we’re going to go in our current project and paste in the code andthis is going to give us a good starting point so we can grab this and open this project in Visual Studiocode, it’s going to open the folder and we’re going to have everything.We want to start doing what we want to do in this lecture here.So now we should have access to our cylinder class.And if you look here, we have an object of cylinder type already created by this line on line numbersix here.And we have seen that we can use the syntax like cylinder volume here using the dot call operator toaccess stuff from our class object.And this is going to work, but we want to see that we can use pointers to manage our object here.And the first thing I want you to see is that we can manage a stack object through pointers and to reallyshow this off, let’s set up a another variable.It’s going to be a cylinder pointer and it’s going to be p cylinder one.It’s going to be a pointer to cylinder one here.That’s what I mean.And we can give it an address of cylinder one as a value.So we can do that, for example, and put in the address of operator.And this is going to work.Now we can go through our pointer here and do stuff with this cylinder object, but the syntax is goingto be pretty ugly.So for example, let’s try and print the volume of a cylinder.We’re going to say stdcout and say volume can save that and we’re going to have to go through the dereferenceoperator.So if we do something like p cylinder one and try to use the dot operator.Later, you’re going to see that we have the volume function.But if we try to call it let’s do that.Let’s make sure we are using the dot operator here.If we try to compile this program, it’s not going to compile because we are trying to call stuff froma pointer.And remember a pointer is just going to store an address.It doesn’t really have information about the type that it is pointing to.If you’re trying to compile this program, you’re going to get a compiler error.So let’s use GCC to do that and we’re going to get request for member volume in cylinder one.Remember, p cylinder one is just a pointer.It’s not an object.So we can’t really call the volume function to it.If we want to use the dot call operator here we have to dereference and actually get to the actual objectthat the pointer is pointing to and we do that using the star operator.You already know how to dereference a pointer so we can dereference our pointer and then call the volumefunction on what the pointer is pointing to.And this is going to work.It’s going to print our volume.Let’s build now, now that we are dereferencing correctly and you see that this is going to work.And if we try to print this, let’s bring up a terminal so that we can run this program.Let’s run Rooster.You’re going to see that we have our volume here.So to really get to what is pointed to, you need to use the dereference operator and then call whatevermethod you want to call on your object.But we can do things even easier.There is a syntax we can use to use the pointer directly here because going through all this dereferencingugliness is really not cool.So we’re going to grab this and show you that we can use the dash greater than operator.That’s how we call it.And if we use that, we don’t need to dereference.All we need to do is use the dash greater than symbol here and it’s going to directly tell the compilerdon’t call stuff on the pointer directly, do dereference the pointer internally and then call the volumefunction on whatever you get after Dereferencing.So this is basically going to push the dereferencing ugliness here behind the curtains of the compilerand we can use a nice syntax like this.And I think this is much better than what we were doing here.So if we try to build now, we’re going to build and print our volume.You’re going to see the world is good.We can clear and run Rooster.You see, we see our volume here.So this is what I want you to see.It is possible to manage your cylinder objects through pointers, and this is one way we can do thisby managing a stack object through pointers.And this is what we are doing here.If you want to call stuff on your class object, you can either do the ugly stuff we do here or youcan use the nice pointer access operator and it is going to be cool.Okay.Now that we have seen this, let’s see another use case in which we’re going to be creating a cylinderobject on the heap through the new operator.Okay.We can go down and say that we’re going to say cylinder pointer.It’s going to be P cylinder two.We can call it like this, and then we’re going to say new cylinder and you’re going to see that wecan call a constructor.We have two types of constructors we can call.We’re going to call our constructor.That takes two parameters and we can pass in 101 hundred.Why not?Oh, let’s put the two.After here, we can put in whatever we want.This is going to create a new cylinder object.The space for the cylinder object is going to be allocated on the heap.So this is a heap object.And because we are using the new operator here, the other thing you should have in mind is that youwill need to release this memory and let’s go and do that directly.This is a good practice because you will forget to release your memory if you don’t really keep thisin mind.So we are going to delete p cylinder two because that’s what we used to allocate our heap memory here.Okay.Now that we have taken care of memory management, we can go in and use our p cylinder to object.And for example, we can print its volume by using the stdcout statement here.So let’s go down and save that.Let’s align this properly and we’re going to say volume cylinder two to really make this super clear,and then we’re going to say p cylinder two and call the volume function here.This is going to work.Let’s try and world the world is good.We can clear and run Rooster.This is going to give us our volume.And if we try and use this information to create a cylinder, we’re going to see that the volume iswhat we see here.We can even try and print its base radius.Let’s do that.I’m going to say Stdcout.We’re going to say p cylinder two and we’re going to say base radius.We can hit the dot operator here.You’re going to see we’re going to have a few options in Visual Studio code here.If we double click on get base radius here, you’re going to see that Visual Studio code is going touse the pointer access operator here.And this is really cool.So we can hit Stdendl.We can close the left pane here because we need some more breathing space.And if we try to build and run this program and we have a compiler error here and the reason is getbase radius is a function.If we go back in our cylinder class, we see that we have a function called get base radius.So if we want to call this in the main function, we need to call that as a function.So we need to put a pair of parentheses here.And if we build, we should build without a problem.Let’s do that again.You see, the build is good and if we run the program, we’re going to see exactly what we expect.Let’s run a rooster.We’re going to see what we expect here.And the message here was really that you can manage your class object through pointers.One case is when you have a pointer that is pointing to a stack object.And we saw that we could do that here.We can also use pointer notation to allocate objects on the heap and point to them with our pointerhere.And whenever we are using a pointer we have the option to use the pointer call operator here to do thingseasily.I am going to be calling this the pointer call operator to mend this from here on.If we happen to knit this and you should know what I mean by that.This is really all I set out to share in this lecture.I hope you found it interesting.We are going to stop here in this lecture and the next one we’re going to learn about Destructors.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，很高兴能成为你的C++启蒙老师！C++是一门功能强大且应用广泛的语言，掌握它会让你受益匪浅。别担心，我会一步一步地引导你，确保你能够理解每一个知识点。</p>
<p>让我们开始今天的学习：通过指针管理类对象。</p>
<hr>
<h1 id="1-标题和摘要"><a href="#1-标题和摘要" class="headerlink" title="1. 标题和摘要"></a>1. 标题和摘要</h1><p><strong>标题：</strong> C++进阶：使用指针管理类对象——深入理解动态内存与访问机制</p>
<p><strong>摘要：</strong><br>本节课我们将学习如何使用 <strong>指针 (pointer)</strong> 来管理C++中的类对象。这在进行 <strong>动态内存分配 (dynamic memory allocation)</strong> 时尤为重要。我们将探讨在 <strong>栈 (stack)</strong> 上创建对象和在 <strong>堆 (heap)</strong> 上动态创建对象的区别，以及如何通过指针（特别是使用 <code>-&gt;</code> <strong>箭头运算符 (arrow operator)</strong>）来访问对象的成员。同时，我们也会强调使用 <code>new</code> 和 <code>delete</code> 进行内存管理的必要性。</p>
<hr>
<h1 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h1><p>在C++中，我们创建和使用对象的方式有多种。之前你可能已经熟悉了直接创建对象的方式，比如 <code>Cylinder c1;</code>。这种方式创建的对象通常位于内存的“栈”区域。现在，我们要学习另一种更灵活的方式：通过指针来管理对象，尤其是那些在内存“堆”区域动态创建的对象。</p>
<p><strong>步骤 1：回顾栈对象的创建和访问</strong></p>
<p>当你像下面这样写代码时：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cylinder <span class="title">cylinder1</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>; <span class="comment">// 假设Cylinder类有一个接受半径和高度的构造函数</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>cylinder1</code> 这个对象是在 <strong>栈 (stack)</strong> 上创建的。</li>
<li>栈是一块内存区域，用于存储局部变量和函数调用的信息。它的特点是管理自动化：当变量超出其作用域（例如，函数执行完毕），它所占用的栈内存会自动释放。</li>
<li>访问这类对象的成员（比如调用它的方法或访问它的公共数据成员），我们使用点运算符 (<code>.</code>)：</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> vol = cylinder1.volume(); <span class="comment">// 调用volume方法</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 1 radius: "</span> &lt;&lt; cylinder1.get_radius(); <span class="comment">// 调用get_radius方法</span></span><br></pre></td></tr></table></figure></div>
<p><strong>步骤 2：为什么需要用指针管理对象？——动态内存分配</strong></p>
<p>有时候，我们希望对象的生命周期不局限于创建它的那个函数的作用域。或者，我们需要在程序运行时才决定要创建多少个对象，或者创建非常大的对象时，栈空间可能不够用。这时，我们就需要在 <strong>堆 (heap)</strong> 上动态地创建对象。</p>
<ul>
<li><strong>堆 (heap)</strong> 是另一块内存区域，与栈不同，堆上的内存分配和释放必须由程序员手动管理。</li>
<li>在堆上创建对象，我们需要使用 <strong><code>new</code> 运算符 (new operator)</strong>。</li>
</ul>
<p><strong>步骤 3：在堆上创建对象并使用指针指向它</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cylinder* p_cylinder2; <span class="comment">// 声明一个指针，它可以指向一个Cylinder类型的对象</span></span><br><span class="line">p_cylinder2 = <span class="keyword">new</span> Cylinder(<span class="number">7</span>, <span class="number">3</span>); <span class="comment">// 使用 new 在堆上创建一个Cylinder对象，</span></span><br><span class="line">                                  <span class="comment">// 并将其地址赋值给指针 p_cylinder2</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>Cylinder* p_cylinder2;</code> 这里的星号 <code>*</code> 表示 <code>p_cylinder2</code> 是一个指针，它存储的是一个 <code>Cylinder</code> 类型对象的内存地址。</li>
<li><code>new Cylinder(7, 3)</code> 这部分做了三件事：<ol>
<li>在堆内存中找到一块足够大的空间来存放一个 <code>Cylinder</code> 对象。</li>
<li>调用 <code>Cylinder</code> 类的构造函数（这里是带两个参数的构造函数）来初始化这块内存空间，使其成为一个有效的 <code>Cylinder</code> 对象。</li>
<li>返回这个新创建对象的内存地址。</li>
</ol>
</li>
<li>这个返回的地址就被存储在了指针变量 <code>p_cylinder2</code> 中。现在，<code>p_cylinder2</code> 就“指向”了堆上的那个 <code>Cylinder</code> 对象。</li>
</ul>
<p><strong>步骤 4：通过指针访问堆上对象的成员——两种方法</strong></p>
<p>现在我们有了一个指向堆上对象的指针 <code>p_cylinder2</code>，如何访问该对象的成员（比如调用 <code>volume()</code> 方法）呢？</p>
<ul>
<li><p><strong>方法一：解引用 (dereference) 和点运算符 (不推荐，繁琐)</strong><br>指针本身存储的是地址，不是对象本身。要获取指针指向的对象，我们需要先对指针进行 <strong>解引用 (dereference)</strong>，使用星号 <code>*</code> 操作符。解引用后，我们就得到了对象本身，然后就可以使用点运算符 <code>.</code>了。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (*p_cylinder2) 首先解引用指针，得到对象本身</span></span><br><span class="line"><span class="comment">// 然后 .volume() 调用该对象的成员函数</span></span><br><span class="line"><span class="keyword">double</span> vol2 = (*p_cylinder2).volume();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Volume of cylinder 2: "</span> &lt;&lt; vol2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></div>
<p>注意这里的括号 <code>(*p_cylinder2)</code> 非常重要！因为点运算符 <code>.</code> 的优先级高于解引用运算符 <code>*</code>。如果不加括号，<code>*p_cylinder2.volume()</code> 会被编译器理解为 <code>*(p_cylinder2.volume())</code>，它会尝试对 <code>p_cylinder2</code>（一个指针）使用点运算符，这是错误的，因为指针没有名为 <code>volume</code> 的成员。</p>
</li>
<li><p><strong>方法二：箭头运算符 <code>-&gt;</code> (推荐，简洁)</strong><br>C++ 提供了一个更简洁、更常用的方式来通过指针访问对象的成员：<strong>箭头运算符 (arrow operator)</strong> <code>-&gt;</code>。它等效于“解引用然后访问成员”。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> vol2_arrow = p_cylinder2-&gt;volume(); <span class="comment">// 等价于 (*p_cylinder2).volume()</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Volume of cylinder 2 (using arrow): "</span> &lt;&lt; vol2_arrow &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 2 radius: "</span> &lt;&lt; p_cylinder2-&gt;get_radius() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></div>
<p>这种方式更易读，也是通过指针访问对象成员的标准做法。</p>
</li>
</ul>
<p><strong>步骤 5：释放堆内存——<code>delete</code> 运算符</strong></p>
<p>当你在堆上使用 <code>new</code> 分配了内存后，这块内存会一直被占用，直到你明确地告诉系统你不再需要它了。如果你忘记释放，就会发生 <strong>内存泄漏 (memory leak)</strong>，即程序占用的内存越来越多，最终可能导致程序或系统崩溃。</p>
<p>为了释放之前用 <code>new</code> 分配的内存，我们使用 <strong><code>delete</code> 运算符 (delete operator)</strong>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p_cylinder2; <span class="comment">// 释放 p_cylinder2 指向的堆内存</span></span><br><span class="line">p_cylinder2 = <span class="literal">nullptr</span>; <span class="comment">// 这是一个好习惯：释放后将指针设为 nullptr，</span></span><br><span class="line">                      <span class="comment">// 防止它成为“悬垂指针” (dangling pointer)，</span></span><br><span class="line">                      <span class="comment">// 即指向一块不再有效或已被回收的内存区域。</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>delete p_cylinder2;</code> 会做两件事：<ol>
<li>首先，它会调用 <code>p_cylinder2</code> 所指向对象的析构函数（我们稍后会学习析构函数，它用于对象销毁前的清理工作）。</li>
<li>然后，它会释放该对象所占用的堆内存，使得这块内存可以被操作系统重新分配给其他程序或当前程序的其他部分使用。</li>
</ol>
</li>
<li><strong>重要规则：</strong> 有 <code>new</code> 就必须有对应的 <code>delete</code>。<code>new</code> 和 <code>delete</code> 必须成对出现（对于数组，是 <code>new[]</code> 和 <code>delete[]</code>，我们以后会学）。</li>
</ul>
<p><strong>步骤 6：指针也可以指向栈上的对象 (了解即可)</strong></p>
<p>虽然指针主要用于管理堆上的动态对象，但它们也可以指向栈上已经存在的对象。这在某些特定场景下可能有用，但不如管理堆对象那么常见。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cylinder <span class="title">cylinder3</span><span class="params">(<span class="number">2</span>, <span class="number">8</span>)</span></span>;        <span class="comment">// cylinder3 在栈上创建</span></span><br><span class="line">Cylinder* p_cylinder3 = &amp;cylinder3; <span class="comment">// p_cylinder3 指向栈上的 cylinder3</span></span><br><span class="line">                                   <span class="comment">// &amp; 是取地址运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样可以使用 -&gt; 运算符</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Volume of cylinder 3: "</span> &lt;&lt; p_cylinder3-&gt;volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 或者使用 (*).</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Radius of cylinder 3: "</span> &lt;&lt; (*p_cylinder3).get_radius() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></div>
<p>需要注意的是，对于指向栈对象的指针，<strong>绝对不能</strong> 对其使用 <code>delete</code>！因为栈对象的内存是由系统自动管理的，<code>delete</code> 只能用于通过 <code>new</code> 分配的堆内存。对栈对象使用 <code>delete</code> 会导致未定义行为，通常是程序崩溃。</p>
<p><strong>总结一下核心思想：</strong></p>
<ol>
<li>直接声明的对象（如 <code>Cylinder c1;</code>）在栈上，使用 <code>.</code> 访问成员，生命周期由作用域决定，自动管理。</li>
<li>使用 <code>new</code> 创建的对象（如 <code>Cylinder* p = new Cylinder();</code>）在堆上，返回一个指向该对象的指针。</li>
<li>通过指针访问堆上对象的成员，推荐使用箭头运算符 <code>-&gt;</code>（如 <code>p-&gt;volume();</code>）。</li>
<li>堆上用 <code>new</code> 创建的对象，必须在不再需要时使用 <code>delete</code> 手动释放（如 <code>delete p;</code>），否则会导致内存泄漏。</li>
</ol>
<hr>
<h1 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h1><p>为了让这些概念更清晰，我们需要一个简单的 <code>Cylinder</code> 类。假设我们有以下文件：</p>
<p><strong>cylinder.h (头文件，类的声明)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CYLINDER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYLINDER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 为了 std::cout</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI &#123;<span class="number">3.1415926535897932384626433832795</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数 (Constructors)</span></span><br><span class="line">    Cylinder() = <span class="keyword">default</span>; <span class="comment">// 默认构造函数</span></span><br><span class="line">    Cylinder(<span class="keyword">double</span> rad_param, <span class="keyword">double</span> height_param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_radius</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_height</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_radius</span><span class="params">(<span class="keyword">double</span> rad_param)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_height</span><span class="params">(<span class="keyword">double</span> height_param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 功能方法</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">volume</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> base_radius &#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> height &#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CYLINDER_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong>cylinder.cpp (源文件，类的实现)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cylinder.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数定义</span></span><br><span class="line">Cylinder::Cylinder(<span class="keyword">double</span> rad_param, <span class="keyword">double</span> height_param) &#123;</span><br><span class="line">    base_radius = rad_param;</span><br><span class="line">    height = height_param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Getter 方法定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cylinder::get_radius</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base_radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cylinder::get_height</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setter 方法定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cylinder::set_radius</span><span class="params">(<span class="keyword">double</span> rad_param)</span> </span>&#123;</span><br><span class="line">    base_radius = rad_param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cylinder::set_height</span><span class="params">(<span class="keyword">double</span> height_param)</span> </span>&#123;</span><br><span class="line">    height = height_param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能方法定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cylinder::volume</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * base_radius * base_radius * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong>main.cpp (主程序，演示指针用法)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cylinder.h"</span> <span class="comment">// 引入 Cylinder 类的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 在栈上创建对象，并使用点运算符 . 访问</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 栈对象 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Cylinder <span class="title">c1</span><span class="params">(<span class="number">3.0</span>, <span class="number">7.0</span>)</span></span>; <span class="comment">// 在栈上创建</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c1 (栈) 半径: "</span> &lt;&lt; c1.get_radius() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c1 (栈) 高度: "</span> &lt;&lt; c1.get_height() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c1 (栈) 体积: "</span> &lt;&lt; c1.volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指针指向栈上的对象 (了解即可，不常用)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 指针指向栈对象 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Cylinder* p_c1 = &amp;c1; <span class="comment">// p_c1 指向栈上的 c1</span></span><br><span class="line">    <span class="comment">// 使用箭头运算符 -&gt;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"通过 p_c1 (指向栈) 访问 c1 半径: "</span> &lt;&lt; p_c1-&gt;get_radius() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 使用解引用和点运算符 (*).</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"通过 p_c1 (指向栈) 访问 c1 体积: "</span> &lt;&lt; (*p_c1).volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 注意：不能 delete p_c1，因为 c1 是栈对象！</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 在堆上动态创建对象，并使用指针管理</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 堆对象 (通过 new 创建) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Cylinder* p_c2 = <span class="keyword">new</span> Cylinder(<span class="number">5.0</span>, <span class="number">2.0</span>); <span class="comment">// 在堆上创建对象，p_c2 指向它</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p_c2) &#123; <span class="comment">// 检查 new 是否成功 (在现代C++中，如果new失败会抛出异常，但检查是个好习惯)</span></span><br><span class="line">        <span class="comment">// 使用箭头运算符 -&gt; 访问成员</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p_c2 (堆) 半径: "</span> &lt;&lt; p_c2-&gt;get_radius() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p_c2 (堆) 高度: "</span> &lt;&lt; p_c2-&gt;get_height() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        p_c2-&gt;set_height(<span class="number">4.0</span>); <span class="comment">// 修改对象的状态</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p_c2 (堆) 修改后高度: "</span> &lt;&lt; p_c2-&gt;get_height() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p_c2 (堆) 体积: "</span> &lt;&lt; p_c2-&gt;volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用解引用和点运算符 (*). 访问成员 (较繁琐)</span></span><br><span class="line">        (*p_c2).set_radius(<span class="number">6.0</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p_c2 (堆) 修改后半径 (使用 (*). ): "</span> &lt;&lt; (*p_c2).get_radius() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p_c2 (堆) 新体积 (使用 (*). ): "</span> &lt;&lt; (*p_c2).volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 释放堆内存</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 释放堆内存 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> p_c2;    <span class="comment">// 释放 p_c2 指向的堆内存</span></span><br><span class="line">        p_c2 = <span class="literal">nullptr</span>; <span class="comment">// 将指针设为 nullptr，防止悬垂指针</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p_c2 指向的内存已释放。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试访问已释放的内存会导致未定义行为 (通常是崩溃)</span></span><br><span class="line">        <span class="comment">// if (p_c2) &#123; // 如果不设为 nullptr，这里可能仍不为0，但访问是危险的</span></span><br><span class="line">        <span class="comment">//     std::cout &lt;&lt; p_c2-&gt;volume() &lt;&lt; std::endl; // 危险操作！</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong>编译和运行说明：</strong><br>你需要将 <code>cylinder.h</code>, <code>cylinder.cpp</code>, 和 <code>main.cpp</code>放在同一个目录下。<br>使用C++编译器（如g++）编译：<br><code>g++ main.cpp cylinder.cpp -o program</code><br>然后运行：<br><code>./program</code></p>
<p>你会看到程序输出各个对象的信息，并演示了不同访问方式。</p>
<hr>
<h1 id="4-QA闪卡-QA-Flash-Cards"><a href="#4-QA闪卡-QA-Flash-Cards" class="headerlink" title="4. QA闪卡 (QA Flash Cards)"></a>4. QA闪卡 (QA Flash Cards)</h1><p><strong>Q1:</strong> 什么是类对象的 <strong>指针 (pointer)</strong>？<br><strong>A1:</strong> 指针是一个变量，它存储的是另一个变量（在这里是类对象）的内存地址。</p>
<p><strong>Q2:</strong> <code>new</code> <strong>运算符 (new operator)</strong> 的作用是什么？<br><strong>A2:</strong> <code>new</code> 在 <strong>堆 (heap)</strong> 内存中为对象分配空间，调用对象的构造函数进行初始化，并返回该对象的地址（一个指针）。</p>
<p><strong>Q3:</strong> 为什么使用 <code>new</code> 分配的内存后需要使用 <code>delete</code>？<br><strong>A3:</strong> <code>new</code> 分配的堆内存不会自动释放。如果不使用 <code>delete</code> <strong>运算符 (delete operator)</strong> 手动释放，会导致 <strong>内存泄漏 (memory leak)</strong>，程序会持续消耗内存。</p>
<p><strong>Q4:</strong> 如何通过指针访问类对象的成员？给出两种方法。<br><strong>A4:</strong></p>
<pre><code>1.  解引用和点运算符：`(*pointer_name).member_name` 或 `(*pointer_name).method_name()`
2.  **箭头运算符 (arrow operator)**：`pointer_name-&gt;member_name` 或 `pointer_name-&gt;method_name()` (推荐)
</code></pre><p><strong>Q5:</strong> 点运算符 (<code>.</code>) 和箭头运算符 (<code>-&gt;</code>) 的主要区别是什么？<br><strong>A5:</strong> 点运算符 (<code>.</code>) 用于直接通过对象名访问其成员。箭头运算符 (<code>-&gt;</code>) 用于通过指向对象的指针访问其成员。<code>ptr-&gt;member</code> 等价于 <code>(*ptr).member</code>。</p>
<p><strong>Q6:</strong> 在 <strong>栈 (stack)</strong> 上创建对象和在 <strong>堆 (heap)</strong> 上创建对象有什么主要区别？<br><strong>A6:</strong></p>
<pre><code>*   **栈对象：** 内存自动管理（随作用域结束而释放），创建速度快，但空间有限。通过对象名直接访问。
*   **堆对象：** 内存手动管理（需 `new` 创建，`delete` 释放），空间较大，创建销毁有开销。通过指针访问。生命周期可控。
</code></pre><hr>
<h1 id="5-常见误解或易犯错误"><a href="#5-常见误解或易犯错误" class="headerlink" title="5. 常见误解或易犯错误"></a>5. 常见误解或易犯错误</h1><ol>
<li><p><strong>忘记 <code>delete</code></strong>：最常见的错误。对每个 <code>new</code> 出来的对象，都必须有一个对应的 <code>delete</code> 操作，否则会导致内存泄漏。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line">Cylinder* c = <span class="keyword">new</span> Cylinder(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">// ... 使用 c ...</span></span><br><span class="line"><span class="comment">// 忘记 delete c; 程序结束时这块内存没有被释放</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>对非 <code>new</code> 创建的指针使用 <code>delete</code></strong>：<code>delete</code> 只能用于通过 <code>new</code> 分配的内存。对栈对象的地址或未初始化的指针使用 <code>delete</code> 会导致程序崩溃或未定义行为。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="function">Cylinder <span class="title">c_stack</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">Cylinder* p_stack = &amp;c_stack;</span><br><span class="line"><span class="comment">// delete p_stack; // 严重错误！p_stack 指向栈内存</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>重复 <code>delete</code></strong>：对同一个指针 <code>delete</code> 两次或多次会导致未定义行为，通常是程序崩溃。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line">Cylinder* c = <span class="keyword">new</span> Cylinder(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span> c;</span><br><span class="line"><span class="comment">// ... 一些代码 ...</span></span><br><span class="line"><span class="comment">// delete c; // 严重错误！重复释放</span></span><br></pre></td></tr></table></figure></div>
<p>将指针在 <code>delete</code> 后立即设为 <code>nullptr</code> (如 <code>c = nullptr;</code>) 可以帮助避免这个问题，因为 <code>delete nullptr;</code> 是安全无害的。</p>
</li>
<li><p><strong>使用已 <code>delete</code> 的指针 (悬垂指针)</strong>：当一个指针指向的内存被 <code>delete</code> 后，该指针就变成了悬垂指针。再通过这个指针去访问或修改内存是非常危险的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line">Cylinder* c = <span class="keyword">new</span> Cylinder(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span> c;</span><br><span class="line"><span class="comment">// c 现在是悬垂指针</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; c-&gt;volume(); // 严重错误！访问已释放的内存</span></span><br></pre></td></tr></table></figure></div>
<p>同样，<code>delete</code> 后将指针设为 <code>nullptr</code> 是个好习惯。</p>
</li>
<li><p><strong>混淆 <code>.</code> 和 <code>-&gt;</code></strong>：</p>
<ul>
<li>对对象使用 <code>-&gt;</code>：<code>Cylinder c1; c1-&gt;volume();</code> (错误)</li>
<li>对指针使用 <code>.</code>：<code>Cylinder* p_c2 = new Cylinder(); p_c2.volume();</code> (错误，除非你写成 <code>(*p_c2).volume();</code> )</li>
</ul>
</li>
<li><p><strong>解引用指针时忘记括号</strong>：当使用 <code>(*ptr).member</code> 形式时，括号是必需的，因为 <code>.</code> 运算符的优先级高于 <code>*</code>。写成 <code>*ptr.member</code> 会被解释为 <code>*(ptr.member)</code>，这通常不是你想要的，且会导致编译错误，因为指针 <code>ptr</code> 没有名为 <code>member</code> 的成员。</p>
</li>
<li><p><strong><code>new</code> 失败未检查 (老旧代码中可能存在)</strong>：在非常早期的C++标准或特定编译环境下，<code>new</code> 失败可能返回 <code>nullptr</code> 而不是抛出异常。现代C++中，<code>new</code> 失败默认会抛出 <code>std::bad_alloc</code> 异常。如果使用 <code>new (std::nothrow) Cylinder(...)</code> 形式，则失败时会返回 <code>nullptr</code>，此时需要检查指针是否为 <code>nullptr</code>。</p>
</li>
</ol>
<hr>
<h1 id="6-编码练习"><a href="#6-编码练习" class="headerlink" title="6. 编码练习"></a>6. 编码练习</h1><p>现在，轮到你动手实践了！下面是一段不完整的代码。你需要根据注释的提示，填补 <code>// TODO:</code> 部分的代码，使其能够正确地在堆上创建 <code>Cylinder</code> 对象，设置其属性，计算并打印其体积，最后正确释放内存。</p>
<p>假设 <code>cylinder.h</code> 和 <code>cylinder.cpp</code> 文件已按上面示例提供。</p>
<p><strong>exercise.cpp:</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cylinder.h"</span> <span class="comment">// 确保 cylinder.h 和 cylinder.cpp 在同一目录或正确配置包含路径</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cylinder* p_my_cylinder = <span class="literal">nullptr</span>; <span class="comment">// 声明一个 Cylinder 指针并初始化为 nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1: 使用 new 运算符在堆上创建一个 Cylinder 对象。</span></span><br><span class="line">    <span class="comment">//         让其半径为 4.0，高度为 6.0。</span></span><br><span class="line">    <span class="comment">//         将返回的地址赋值给 p_my_cylinder。</span></span><br><span class="line">    <span class="comment">// p_my_cylinder = new ... ;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 p_my_cylinder 是否成功分配了内存</span></span><br><span class="line">    <span class="keyword">if</span> (p_my_cylinder) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"堆对象创建成功!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 2: 使用箭头运算符，调用对象的 set_radius 方法，将其半径修改为 5.5。</span></span><br><span class="line">        <span class="comment">// p_my_cylinder-&gt;... ;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 3: 使用箭头运算符，调用对象的 set_height 方法，将其高度修改为 10.2。</span></span><br><span class="line">        <span class="comment">// p_my_cylinder-&gt;... ;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印修改后的半径和高度</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"修改后半径: "</span> &lt;&lt; p_my_cylinder-&gt;get_radius() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"修改后高度: "</span> &lt;&lt; p_my_cylinder-&gt;get_height() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 4: 计算并打印 p_my_cylinder 指向的圆柱体的体积。</span></span><br><span class="line">        <span class="comment">//         使用箭头运算符调用 volume() 方法。</span></span><br><span class="line">        <span class="comment">// double vol = ... ;</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; "圆柱体体积: " &lt;&lt; vol &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 5: 使用 delete 运算符释放 p_my_cylinder 指向的堆内存。</span></span><br><span class="line">        <span class="comment">// delete ... ;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 6: (好习惯) 将 p_my_cylinder 设置为 nullptr，防止悬垂指针。</span></span><br><span class="line">        <span class="comment">// p_my_cylinder = ... ;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"堆内存已释放。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！程序退出。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证指针是否为 nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (p_my_cylinder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p_my_cylinder 现在是 nullptr。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"警告: p_my_cylinder 在释放后不是 nullptr！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>请你尝试填写 <code>// TODO:</code> 部分的代码。完成后，将你的解决方案告诉我，我会帮你检查并给出反馈。<br>祝你编码愉快！</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cylinder.h"</span> <span class="comment">// 确保 cylinder.h 和 cylinder.cpp 在同一目录或正确配置包含路径</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cylinder* p_my_cylinder = <span class="literal">nullptr</span>; <span class="comment">// 声明一个 Cylinder 指针并初始化为 nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1: 使用 new 运算符在堆上创建一个 Cylinder 对象。</span></span><br><span class="line">    <span class="comment">//         让其半径为 4.0，高度为 6.0。</span></span><br><span class="line">    <span class="comment">//         将返回的地址赋值给 p_my_cylinder。</span></span><br><span class="line">    p_my_cylinder = <span class="keyword">new</span> Cylinder(<span class="number">4.0</span>, <span class="number">6.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 p_my_cylinder 是否成功分配了内存</span></span><br><span class="line">    <span class="keyword">if</span> (p_my_cylinder) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"堆对象创建成功!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 2: 使用箭头运算符，调用对象的 set_radius 方法，将其半径修改为 5.5。</span></span><br><span class="line">        p_my_cylinder-&gt;set_radius(<span class="number">5.5</span>) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 3: 使用箭头运算符，调用对象的 set_height 方法，将其高度修改为 10.2。</span></span><br><span class="line">        p_my_cylinder-&gt;set_height(<span class="number">10.2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印修改后的半径和高度</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"修改后半径: "</span> &lt;&lt; p_my_cylinder-&gt;get_radius() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"修改后高度: "</span> &lt;&lt; p_my_cylinder-&gt;get_height() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 4: 计算并打印 p_my_cylinder 指向的圆柱体的体积。</span></span><br><span class="line">        <span class="comment">//         使用箭头运算符调用 volume() 方法。</span></span><br><span class="line">        <span class="keyword">double</span> vol = p_my_cylinder-&gt;volume() ;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"圆柱体体积: "</span> &lt;&lt; vol &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 5: 使用 delete 运算符释放 p_my_cylinder 指向的堆内存。</span></span><br><span class="line">        <span class="keyword">delete</span> p_my_cylinder ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 6: (好习惯) 将 p_my_cylinder 设置为 nullptr，防止悬垂指针。</span></span><br><span class="line">        p_my_cylinder = <span class="literal">nullptr</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"堆内存已释放。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！程序退出。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证指针是否为 nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (p_my_cylinder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p_my_cylinder 现在是 nullptr。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"警告: p_my_cylinder 在释放后不是 nullptr！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>太棒了！你完成得非常好！你的代码几乎是完美的，完全掌握了我们今天学习的知识点。</p>
<hr>
<h1 id="7-用户解答评估、正确答案及解释"><a href="#7-用户解答评估、正确答案及解释" class="headerlink" title="7. 用户解答评估、正确答案及解释"></a>7. 用户解答评估、正确答案及解释</h1><p><strong>用户解答评估:</strong></p>
<ul>
<li><p><strong>评分：5/5 (优秀！)</strong></p>
</li>
<li><p><strong>评价：</strong></p>
<ul>
<li><strong>TODO 1 (创建对象):</strong> <code>p_my_cylinder = new Cylinder(4.0, 6.0);</code> 非常正确！你正确地使用了 <code>new</code> 关键字，并调用了 <code>Cylinder</code> 类的构造函数来在堆上创建对象，同时传递了初始的半径和高度。</li>
<li><strong>TODO 2 (设置半径):</strong> <code>p_my_cylinder-&gt;set_radius(5.5);</code> 完全正确！你熟练地运用了箭头运算符 <code>-&gt;</code> 来通过指针调用对象的成员函数 <code>set_radius</code>。</li>
<li><strong>TODO 3 (设置高度):</strong> <code>p_my_cylinder-&gt;set_height(10.2);</code> 同样完美！继续正确使用箭头运算符。</li>
<li><strong>TODO 4 (计算体积):</strong> <code>double vol = p_my_cylinder-&gt;volume();</code> 和 <code>std::cout &lt;&lt; &quot;圆柱体体积: &quot; &lt;&lt; vol &lt;&lt; std::endl;</code> 非常好！准确调用了 <code>volume()</code> 方法，并将结果存储和打印。</li>
<li><strong>TODO 5 (释放内存):</strong> <code>delete p_my_cylinder;</code> 正确无误！这是至关重要的一步，你正确地使用了 <code>delete</code> 来释放之前通过 <code>new</code> 分配的内存。</li>
<li><strong>TODO 6 (设置nullptr):</strong> <code>p_my_cylinder = nullptr;</code> 优秀的习惯！在释放内存后将指针设为 <code>nullptr</code>，有效防止了悬垂指针的产生。</li>
</ul>
</li>
</ul>
<p>你的代码不仅功能正确，而且遵循了良好的编程实践。继续保持！</p>
<p><strong>正确答案与解释:</strong></p>
<p>你的答案就是标准答案！这里为了完整性，我再贴一次完整的正确代码，和你提供的一样：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cylinder.h"</span> <span class="comment">// 确保 cylinder.h 和 cylinder.cpp 在同一目录或正确配置包含路径</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cylinder* p_my_cylinder = <span class="literal">nullptr</span>; <span class="comment">// 声明一个 Cylinder 指针并初始化为 nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1: 使用 new 运算符在堆上创建一个 Cylinder 对象。</span></span><br><span class="line">    <span class="comment">//         让其半径为 4.0，高度为 6.0。</span></span><br><span class="line">    <span class="comment">//         将返回的地址赋值给 p_my_cylinder。</span></span><br><span class="line">    p_my_cylinder = <span class="keyword">new</span> Cylinder(<span class="number">4.0</span>, <span class="number">6.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 p_my_cylinder 是否成功分配了内存</span></span><br><span class="line">    <span class="keyword">if</span> (p_my_cylinder) &#123; <span class="comment">// 在现代C++中，如果new失败会抛出std::bad_alloc异常</span></span><br><span class="line">                         <span class="comment">// 但检查指针是否为nullptr对于 new(std::nothrow) 或旧代码仍然有用</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"堆对象创建成功!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 2: 使用箭头运算符，调用对象的 set_radius 方法，将其半径修改为 5.5。</span></span><br><span class="line">        p_my_cylinder-&gt;set_radius(<span class="number">5.5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 3: 使用箭头运算符，调用对象的 set_height 方法，将其高度修改为 10.2。</span></span><br><span class="line">        p_my_cylinder-&gt;set_height(<span class="number">10.2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印修改后的半径和高度</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"修改后半径: "</span> &lt;&lt; p_my_cylinder-&gt;get_radius() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"修改后高度: "</span> &lt;&lt; p_my_cylinder-&gt;get_height() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 4: 计算并打印 p_my_cylinder 指向的圆柱体的体积。</span></span><br><span class="line">        <span class="comment">//         使用箭头运算符调用 volume() 方法。</span></span><br><span class="line">        <span class="keyword">double</span> vol = p_my_cylinder-&gt;volume();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"圆柱体体积: "</span> &lt;&lt; vol &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 5: 使用 delete 运算符释放 p_my_cylinder 指向的堆内存。</span></span><br><span class="line">        <span class="keyword">delete</span> p_my_cylinder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 6: (好习惯) 将 p_my_cylinder 设置为 nullptr，防止悬垂指针。</span></span><br><span class="line">        p_my_cylinder = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"堆内存已释放。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这种情况在现代C++中，如果使用标准的 new，通常不会发生，</span></span><br><span class="line">        <span class="comment">// 因为 new 失败会抛出 std::bad_alloc 异常，而不是返回 nullptr。</span></span><br><span class="line">        <span class="comment">// 如果使用的是 new(std::nothrow)，则需要这样的检查。</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败！程序退出。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证指针是否为 nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (p_my_cylinder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p_my_cylinder 现在是 nullptr。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这段代码在正常情况下不应该执行，因为上面已经将 p_my_cylinder 设为 nullptr</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"警告: p_my_cylinder 在释放后不是 nullptr！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释关键点：</strong></p>
<ol>
<li><p><strong><code>new Cylinder(4.0, 6.0)</code></strong>:</p>
<ul>
<li><code>new</code> 是C++中用于在 <strong>自由存储区 (free store)</strong>（通常实现为堆内存）动态分配内存的关键字。</li>
<li><code>Cylinder(4.0, 6.0)</code> 调用了 <code>Cylinder</code> 类的构造函数，并传递了参数 <code>4.0</code> 和 <code>6.0</code> 来初始化新创建的对象。</li>
<li>整个表达式的结果是新创建的 <code>Cylinder</code> 对象的内存地址，该地址被赋值给指针 <code>p_my_cylinder</code>。</li>
</ul>
</li>
<li><p><strong><code>p_my_cylinder-&gt;set_radius(5.5)</code></strong>:</p>
<ul>
<li><code>-&gt;</code> (<strong>箭头运算符 (arrow operator)</strong>) 是通过指针访问对象成员的便捷方式。</li>
<li><code>p_my_cylinder-&gt;set_radius(5.5)</code> 等价于 <code>(*p_my_cylinder).set_radius(5.5)</code>。它首先对指针 <code>p_my_cylinder</code> <strong>解引用 (dereference)</strong> 以获取它所指向的 <code>Cylinder</code> 对象，然后调用该对象的 <code>set_radius</code> 方法。</li>
</ul>
</li>
<li><p><strong><code>delete p_my_cylinder</code></strong>:</p>
<ul>
<li><code>delete</code> 用于释放在自由存储区（堆）上由 <code>new</code> 分配的单个对象的内存。</li>
<li>在释放内存之前，如果对象有 <strong>析构函数 (destructor)</strong>（我们下一课会学到），<code>delete</code> 会先调用该对象的析构函数，用于执行任何必要的清理工作。</li>
<li>然后，内存被返还给系统，可供后续分配使用。</li>
</ul>
</li>
<li><p><strong><code>p_my_cylinder = nullptr</code></strong>:</p>
<ul>
<li><code>nullptr</code> 是C++11引入的关键字，表示空指针。</li>
<li>在 <code>delete</code> 一个指针后，指针变量本身仍然存储着之前那个（现在无效的）内存地址。这个指针被称为 <strong>悬垂指针 (dangling pointer)</strong>。</li>
<li>将指针设置为 <code>nullptr</code> 是一个好习惯，因为：<ul>
<li>它可以防止意外地通过悬垂指针访问已释放的内存。</li>
<li>对 <code>nullptr</code> 调用 <code>delete</code> 是安全无害的（什么也不做）。</li>
<li>可以明确地检查指针是否有效（例如 <code>if (p_my_cylinder != nullptr)</code>）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>你做得非常出色，准确地理解并应用了这些核心概念！</p>
<hr>
<h1 id="8-建议与扩展问题"><a href="#8-建议与扩展问题" class="headerlink" title="8. 建议与扩展问题"></a>8. 建议与扩展问题</h1><p>你已经很好地掌握了通过指针管理单个动态对象的基础知识。为了进一步深化理解和拓展你的技能，可以思考和研究以下问题：</p>
<ol>
<li><p><strong>动态数组 (Dynamic Arrays):</strong></p>
<ul>
<li>如果我想在堆上创建一个包含5个 <code>Cylinder</code> 对象的数组，应该如何做？（提示：使用 <code>new[]</code>）</li>
<li>创建了动态数组后，又该如何释放它们的内存呢？（提示：使用 <code>delete[]</code>）</li>
<li>如何访问动态数组中的特定元素并调用其方法？</li>
</ul>
</li>
<li><p><strong><code>this</code> 指针 (this pointer):</strong></p>
<ul>
<li>在类的成员函数内部，有时需要引用调用该函数的对象本身。C++提供了一个特殊的指针叫做 <code>this</code>。研究一下 <code>this</code> 指针是什么，以及它如何工作。</li>
<li>例如，在 <code>Cylinder</code> 类的 <code>set_radius</code> 方法中，如果参数名也叫 <code>base_radius</code>，你将如何区分成员变量和参数？（<code>this-&gt;base_radius = base_radius;</code>）</li>
</ul>
</li>
<li><p><strong>智能指针 (Smart Pointers):</strong></p>
<ul>
<li>手动管理 <code>new</code> 和 <code>delete</code> 很容易出错（忘记 <code>delete</code> 导致内存泄漏，重复 <code>delete</code> 导致崩溃等）。C++标准库提供了 <strong>智能指针 (smart pointers)</strong> (如 <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>) 来帮助自动管理动态内存的生命周期，大大减少内存管理错误。</li>
<li>尝试了解 <code>std::unique_ptr</code> 是如何工作的，以及它如何能帮助我们避免手动调用 <code>delete</code>。</li>
</ul>
</li>
<li><p><strong>内存泄漏的危害和检测 (Memory Leaks):</strong></p>
<ul>
<li>更深入地理解内存泄漏为什么是个严重的问题。</li>
<li>了解一些可以帮助检测内存泄漏的工具（如 Valgrind on Linux/macOS，或 Visual Studio 内置的调试工具）。</li>
</ul>
</li>
<li><p><strong>RAII 原则 (Resource Acquisition Is Initialization):</strong></p>
<ul>
<li>RAII 是C++中一个非常重要的编程范式，它主张资源的生命周期应与对象的生命周期绑定。智能指针就是RAII的一个典型应用。了解RAII如何帮助编写更安全、更易于管理的代码。</li>
</ul>
</li>
<li><p><strong>指针和引用的对比 (Pointers vs. References):</strong></p>
<ul>
<li>我们已经学习了指针。C++还有 <strong>引用 (reference)</strong> 的概念。它们都可以间接访问对象，但有什么区别和各自的适用场景呢？</li>
</ul>
</li>
</ol>
<p>这些扩展问题会引导你进入C++更高级也更实用的领域。不要急于求成，一步一个脚印地去探索它们。</p>
<p>你今天的表现非常棒！期待你继续学习C++的下一课内容。如果你对这些扩展问题有任何疑问，或者想深入探讨某个点，随时都可以问我！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Developer/">Developer    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Object/">Object    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/277%20-%20IDE%20%E5%88%9B%E5%BB%BA%20cpp%20%E7%B1%BB%E6%96%B9%E6%B3%95/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>277 - IDE 创建 cpp 类方法</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/279%20-%20cpp%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>279 - cpp析构函数：对象销毁时的内存释放</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/277 - IDE 创建 cpp 类方法/" title="277 - IDE 创建 cpp 类方法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">277 - IDE 创建 cpp 类方法</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/283 - cpp 类对象大小探究/" title="283 - cpp 类对象大小探究"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">283 - cpp 类对象大小探究</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/276 - Class across multiple files/" title="276 - Class across multiple files"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">276 - Class across multiple files</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/286 - const 对象问题与指针引用访问/" title="286 - const 对象问题与指针引用访问"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">286 - const 对象问题与指针引用访问</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/304 - 移动构造函数窃取/" title="304 - 移动构造函数窃取"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">304 - 移动构造函数窃取</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/322 - Different Type Members/" title="322 - Different Type Members"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">322 - Different Type Members</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>