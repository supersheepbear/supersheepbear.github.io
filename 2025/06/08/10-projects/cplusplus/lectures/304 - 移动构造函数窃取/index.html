<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>304 - 移动构造函数窃取 | Bear's dream</title><meta name="description" content="304 - 移动构造函数窃取"><meta name="keywords" content="Cpp,Coding,Memory,Class,Object"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="304 - 移动构造函数窃取"><meta name="twitter:description" content="304 - 移动构造函数窃取"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="304 - 移动构造函数窃取"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/304%20-%20%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%AA%83%E5%8F%96/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="304 - 移动构造函数窃取"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/304%20-%20%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%AA%83%E5%8F%96/"><link rel="prev" title="322 - Different Type Members" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/322%20-%20Different%20Type%20Members/"><link rel="next" title="319 - Class Const" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/319%20-%20Class%20Const/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">152</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#移动构造函数窃取"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">移动构造函数窃取</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-深度解析：掌握移动构造函数——“窃取”数据的艺术"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">C++ 深度解析：掌握移动构造函数——“窃取”数据的艺术</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-什么是移动构造函数？为什么我们需要它？"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">1. 什么是移动构造函数？为什么我们需要它？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-深入理解：移动构造函数的工作原理"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">2. 深入理解：移动构造函数的工作原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-Point-类设计"><span class="toc_mobile_items-number">1.5.1.</span> <span class="toc_mobile_items-text">2.1 Point 类设计</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-“窃取”数据的机制"><span class="toc_mobile_items-number">1.5.2.</span> <span class="toc_mobile_items-text">2.2 “窃取”数据的机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-3-移动构造函数的语法"><span class="toc_mobile_items-number">1.5.3.</span> <span class="toc_mobile_items-text">2.3 移动构造函数的语法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-4-std-move-的作用"><span class="toc_mobile_items-number">1.5.4.</span> <span class="toc_mobile_items-text">2.4 std::move 的作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-5-invalidate-函数与“Steal-Getters”（可选）"><span class="toc_mobile_items-number">1.5.5.</span> <span class="toc_mobile_items-text">2.5 invalidate 函数与“Steal Getters”（可选）</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-完整代码示例"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">3. 完整代码示例</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Point-h-如上所示"><span class="toc_mobile_items-number">1.6.1.</span> <span class="toc_mobile_items-text">Point.h (如上所示)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Point-cpp-如上所示"><span class="toc_mobile_items-number">1.6.2.</span> <span class="toc_mobile_items-text">Point.cpp (如上所示)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#main-cpp"><span class="toc_mobile_items-number">1.6.3.</span> <span class="toc_mobile_items-text">main.cpp</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-QA-闪卡"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">4. QA 闪卡</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-常见误解或错误"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">5. 常见误解或错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-编程练习"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">6. 编程练习</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-您的解决方案评分及解释"><span class="toc_mobile_items-number">1.12.</span> <span class="toc_mobile_items-text">7. 您的解决方案评分及解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-扩展问题及建议"><span class="toc_mobile_items-number">1.13.</span> <span class="toc_mobile_items-text">8. 扩展问题及建议</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#移动构造函数窃取"><span class="toc-number">1.</span> <span class="toc-text">移动构造函数窃取</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-深度解析：掌握移动构造函数——“窃取”数据的艺术"><span class="toc-number">1.3.</span> <span class="toc-text">C++ 深度解析：掌握移动构造函数——“窃取”数据的艺术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是移动构造函数？为什么我们需要它？"><span class="toc-number">1.4.</span> <span class="toc-text">1. 什么是移动构造函数？为什么我们需要它？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-深入理解：移动构造函数的工作原理"><span class="toc-number">1.5.</span> <span class="toc-text">2. 深入理解：移动构造函数的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Point-类设计"><span class="toc-number">1.5.1.</span> <span class="toc-text">2.1 Point 类设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-“窃取”数据的机制"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.2 “窃取”数据的机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-移动构造函数的语法"><span class="toc-number">1.5.3.</span> <span class="toc-text">2.3 移动构造函数的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-std-move-的作用"><span class="toc-number">1.5.4.</span> <span class="toc-text">2.4 std::move 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-invalidate-函数与“Steal-Getters”（可选）"><span class="toc-number">1.5.5.</span> <span class="toc-text">2.5 invalidate 函数与“Steal Getters”（可选）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-完整代码示例"><span class="toc-number">1.6.</span> <span class="toc-text">3. 完整代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Point-h-如上所示"><span class="toc-number">1.6.1.</span> <span class="toc-text">Point.h (如上所示)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Point-cpp-如上所示"><span class="toc-number">1.6.2.</span> <span class="toc-text">Point.cpp (如上所示)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main-cpp"><span class="toc-number">1.6.3.</span> <span class="toc-text">main.cpp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-QA-闪卡"><span class="toc-number">1.7.</span> <span class="toc-text">4. QA 闪卡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见误解或错误"><span class="toc-number">1.8.</span> <span class="toc-text">5. 常见误解或错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-编程练习"><span class="toc-number">1.9.</span> <span class="toc-text">6. 编程练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">1.10.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">1.11.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-您的解决方案评分及解释"><span class="toc-number">1.12.</span> <span class="toc-text">7. 您的解决方案评分及解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-扩展问题及建议"><span class="toc-number">1.13.</span> <span class="toc-text">8. 扩展问题及建议</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">304 - 移动构造函数窃取</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/304%20-%20%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%AA%83%E5%8F%96/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/304%20-%20%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%AA%83%E5%8F%96/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="移动构造函数窃取"><a href="#移动构造函数窃取" class="headerlink" title="移动构造函数窃取"></a>移动构造函数窃取</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture we’re going to learn about Move constructors, and this is a special kind of constructorthat is going to steal data from other objects.And those objects we steal from are going to be temporary objects that are going to be killed by thecompiler.Anyway.Let’s look at a simple example.We’re going to use a class called Point.The class is going to have two member variables X and Y, which are pointer to double.So this is going to allow us to see some things we really want to see in this lecture.The class is going to have a constructor and a bunch of other methods that are not shown here becausethey really aren’t important for what we want to see.But let’s look at the syntax we use to build from temporaries.Here we have a point object which is being built from another point object.So this would really use the copy constructor.But notice what we are building from it is a point that we are building in place here.So the constructor is going to be called from what we have in the parentheses here, and we’re goingto build a temporary point object whose sole purpose is to be used to build another point object, whichis going to be p three here.So the point of this entire lecture is to not waste the data that we had in this point that we haveas a parameter or argument here.We want to grab the data and and we don’t want to go through the trouble to build another point becausewe already have it as a temporary here and we want to steal data from it.Okay.So let’s try and really illustrate this better.We’re going to have a temporary object, both somewhere in memory, and it’s going to be a full point.It’s going to have a pointer to X, a pointer to Y, and these are going to be double pointers.The pointer to X is going to have some address which is ending in D three here.The pointer to Y is going to have another address which is ending in D four here and we’re going tohave content stored at these memory locations.So this is our temporary and suppose that what we are pointing to is something really expensive to build.Suppose it is a really heavy object and we don’t want to waste the data if we have it already constructedand it is going to be wasted because the moment we are done building from a temporary, the temporaryis going to be thrown away by the compiler and we don’t want to really waste.So what we can do is steal data from this temporary if we are building another object from it.So for example, here we are trying to build P three from our temporary here.So we’re going to grab the data from temporary and steal that and put that in our P three object.At this moment when we are building P three, it’s going to have these two pointers because these arethe member variables we have.And and the x pointer is going to be pointing to null pointer and the Y pointer is going to be pointingto null pointer by default.It’s not going to have any content, but we don’t want to go through the trouble to put in the contentbecause we already have the content in temporary.So what we can do is steal these pointers and make them stored in P three here.So for example, we can grab this pointer address and put that here in P three.We can grab this pointer address and put that in P three the pointer to Y and then after we are donewe can make these pointers in temporary pointer to nowhere.We can set them to null pointer and we will have effectively stolen data from the temporary and storedthe data in our P three object.And by stealing data like this, we have avoided the heavy work of setting up our own data in p threehere and this is really cool.Okay, so if we steal data, we’re going to have a case like this.The pointers in P three and the temporary are going to be the same.But to really completely steal the data, we’re going to reset the pointers in temporary and we’re goingto set them to null pointer.So in temporary we’re going to have a null pointer and it’s basically not going to be pointing anywhere.It’s not going to have any content.The temporary object is not going to have any content in here and the data will have moved in P threeand this is what we mean by stealing data.So this is all fine and good, but how do we do this in C plus plus?Well, we use a Move constructor.A Move constructor is a special kind of constructor whose sole job is to steal data from other objects.And this is the syntax you use to set it up.You say the name of the constructor and you pass your parameter like this.You say the class name and then you put two ampersand symbols and this is going to be your move constructor.When the compiler sees this syntax, it’s going to know that it is a move constructor and it is goingto use it to steal data from temporaries.So what it is really going to do, we’re going to steal the pointer in X, We store that in our object,we’re going to steal the pointer in Y and we’re going to store.That in our objects here.And then what we need to do is to set the pointers in our temporary to null.And we’re going to do that through a special function that we’re going to set up in our object, whichis going to reset all the pointers.And this is really how you do it.Okay.Before we go off and really try this in Visual Studio code, I want to show you a way we can force thecompiler to treat our object as a temporary and we pass this through a special facility we have in Cplus plus, which is called a Stdmove.We need to do this because sometimes the compiler is going to do some optimizations and it’s not goingto treat our temporary as a temporary and it is going to call the copy constructor.Instead, we want to force the compiler to treat our object here as a temporary.So that’s why we pass this through this stdmove function which is built into the C plus plus standardlibrary.So now that you have an idea about move constructors, let’s head over to Visual Studio code and playwith this a little more.Okay, Here we are in our working folder.The current project is Move Constructors.We’re going to grab our template files and we’re going to put them in place and we are going to openthis in Visual Studio code like we always do by dragging and dropping here.This is going to open our folder and we will open the Main.cpp file and clean it up a little bit.The first thing we want to do is to bring in the class we want to use to learn about this.And we will set up a class called Point as we have seen in the slides.So let’s do that.We’re going to set up a header file.I’m going to say point dot h for our header file and we’re going to put in an implementation file calledpoint dot CPP.Let’s do that and we are going to put in our class.Let’s start by the header file.We’re going to put in the class which is called point here.And let’s go through it a little bit.The class name is Point.It’s going to have a few private member variables.We’re going to have a pointer to double.We’re going to have two variables X and Y, which are of type double pointer.So they are pointers to double.And we have a function we will use to invalidate our null pointers.But we can ignore this for now.We’re going to come back to it in a little bit.So this is our constructor.It’s going to take two parameters.We have a destructor which is going to release the memory and we have a copy constructor here.You see it is taking the parameter by const reference.Let’s say this, here it is a copy constructor and if we go down we have a few setters.The first one is going to set X and it is going to dereference a pointer and put in our value.The second one is going to set y again.It is going to Dereference and put in our value and we are doing this dereferencing because our membervariables are pointers.We need to go through Dereferencing to get to what is pointed to by this pointer.You should know this by now.We will have a few getters.The first one is going to return X because x is a pointer by default and we’re going to return y inget Y here and we have a utility function which is going to print information about our point.So it’s going to print the x coordinate of a point and it’s going to print the y coordinate of a point.And here you see that we are dereferencing again because we are going through pointers.Let’s be consistent here and put the parentheses on this x guy here.Okay, this is our header file.I think it is pretty good and pretty easy to understand at this point in the course.So let’s do the CPP file.We’re going to put in the implementations for our point class here.We have the constructor implemented.We’re going to set up a new memory location because we have pointers in our member variables.We have to initialize them with valid memory.So that’s what we do here.We’re going to dynamically allocate memory on the heap and then we’re going to store in our data.This is the syntax to do that.We also have a copy constructor which is going to also allocate new memory from the heap and we’re goingto store in data from our source object.Notice that we are doing deep copy here.We’re not doing blind member wise copy, which would be shallow copy.We are doing deep copy because we want to have independent data in our constructor point object.Here we also have a destructor which is going to release memory that we have initialized in our constructorsand this class is pretty done by now.Let’s go back in the header and really verify this.Our setters are implemented in place, so this should work.Let’s close the left sidebar here and we’re going to go back to Main.We’re going to include our point, let’s say point dot H, and then we’re going to create a point object.So let’s, for example, create a point P one, and we’re going to put in data.We’re going to put in 10.0 and 15.0.Why not?Okay, let’s do this and we can.Print information about this object through the printing full member function here so we can do that.So let’s print this information here.We’re going to say P one print info and we’re going to try and build.We want to investigate that.Things are really working exactly as we expect.We’re going to bring up a terminal and we’re going to clear and run Rooster.If we do that, we’re going to see that in X, we have ten, in Y, we have 15, which is what we expecthere.Let’s put in 10.4, for example, and 15.6.Why not?And build again.We want to see our decimal points.The build is good.We can clear and run rooster and you see that.We see the data here and this is what we expect.Okay, so let’s try and create a copy of a point from a temporary.So what we’re going to do is say point and we’re going to say P three and we are going to constructthis point from a temporary The way we do that, we’re going to force the compiler to treat what we’regoing to pass here as a temporary.And to do that, we need to pass this through a facility called a Stdmove, as we saw in the slides.So let’s do that.We’re going to say Stdmove, and then we’re going to pass our point here.Again, you will have to just believe me here because we need to learn about the Move constructors,but we don’t have enough tools to really understand what Stdmove does.By now you can treat as something that is going to force the compiler to treat this point here as atemporary so that we can steal data from it.So you are basically telling the compiler this point is going to be destroyed anyway, so steal fromit if you can.This is what we’re telling the compiler.So we’re going to put in data.Let’s put in 20.5 and 5.8 and you can really put in anything.Then we’re going to see what happens here.Okay, So we have our call to build an object from another object.But what we are building from is a temporary.Okay, So let’s comment out the print information we had in front here because we don’t want this toconfuse us.And let’s see what we have in our constructors.We have a print out in the body of the copy constructor and we have an stdcout statement in the constructor,which is taking two parameters here.So let’s see what happens.We’re going to build this and see what we see on the terminal.We’re going to build with GCC and you see that the world is good down here so we can clear and run Rooster.Now we’re going to see that we have two constructors called and now we see that we have two constructorscalled.I think the first one is to build this point here, and this is going to make our code a little moreconfusing.So I am going to comment this out and we’re going to build it down.Okay.So the build is good.We can clear and run Rooster.We’re going to see that we have a constructor called which is going to build this temporary here andwe have the copy constructor called because it’s going to be copying from this temporary.So this is what we expect.If we try to build from a temporary by default, the compiler is going to use the copy constructor.And that’s what we see here.We see that the body of the copy constructor was executed and printed out this message here and we don’treally want to use a copy constructor because the copy constructor is going to do a lot of work.It’s going to allocate new memory locations, it’s going to copy data.But what we are building from is a temporary and it’s going to be thrown away and it’s going to be thrownout anyway.So why not steal data that we have inside?If you look at our model of the point class, you’re going to see that our member variables are pointers.So we can technically still pointers in our temporary and just steal the data and avoid the work todo all this new memory allocation.And we can just steal data that is already there.This is going to become attractive if the pointers you have in your member variables are pointing tosomething really expensive.Suppose you’re suppose your member variables is some string that is really huge and you have a pointerto that and you don’t really want to rebuild a memory location to copy that string into.So we can steal data if we can and avoid all that hard work.And we need to do that through a Move constructor.So we’re going to go in our header file and set up a Move constructor and we have seen that the syntaxfor a Move constructor is really straightforward.All you have to do is say the name of the class, then you specify your parameter by value and thenyou put two ampersand symbols here and then you say your source point and then you give your parametera name.Let’s use source point here.It’s going to work and then we’re going to implement this in the CPP file.And let’s go down and say that we want to do our Move constructor.We can copy the code we have for our copy constructor and adapt this a little bit.So we’re going to grab that and put that here and we’re going to adapt the parameter to make it a propermove constructor and let’s make sure the names are consistent here.So source point and source point here they are consistent and what we want to do in here, we don’twant to allocate for new memory.We’re just going to steal the pointer and what we do is going to say source point, get X, this isgoing to return us a pointer to the memory location in the source object, which is our temporary here.And then we’re going to do the same things for the Y member variable.So let’s do that.We’re going to say source point and get Y.Let’s save this properly.We’re going to call the function here.And by this point we will have stolen the pointers from the source point.But after we do this, why do we have this squiggly line?Do we have more than we need of these parentheses?I think we do.So this is right.Visual Studio code is happy.So now that we have stolen the pointers, we need to do something more.Because at this point our two objects will be pointing to the same memory locations and we don’t wantthat.Remember that after remember that when a point is destroyed, it is going to release the memory it ispointing to in its member variables X and Y.And we don’t want the temporary to release our memory because the memory belongs to us.Now we have stolen these pointers.So what we need to do is to invalidate the pointers in source point here and we can do that througha special function that we have seen here, which is called invalidate.It’s going to invalidate the pointers that the current project is pointing to.So we’re going to use this.You’re going to see that this is going to set the X pointer to null pointer and the Y pointer to nullpointer.And we can call that to do our dirty job here.So we’re going to do that in the copy constructor.So we’re going to say source point invalidate and we are able to access this method, which is privatein point because we are doing this from the point class.You really need to understand this.Some people might think because this method here is private, we wouldn’t have access to it if we calledit like this.But please take a look at where we are calling it from.We are in the point class, so and in the point class, we will have access to any private members ofthis class here and invalidate happens to be a member of this class and it is private so we can useit.And now we have our Move constructor set up.Let’s go down here and say that it is the body of our Move constructor and if we run the code now,the compiler is smart enough to realize that we have a move constructor in our class and it is goingto use it and steal data from the temporary.And this is really cool.So let’s prove this.We’re going to build and see what GCC says about this.We’re going to build and the world is going to be good.You see world finished successfully.We can clear and run roster now you see that we are building our temporary here but we are calling thebody of our move constructor and after we steal from the temporary here it is going to be destroyedbecause it’s no longer needed and it is going to be thrown away and the data is going to be belongingto 0.3.Now, if we print information in P3, let’s do that.We’re going to see that we have the data we had in our temporary here, and this is really cool.X is going to be 20.5 and Y is going to be 5.8.Let’s build and take into account the Printf statement here.We’re going to see that the build is good.We can clear and run roster.We’re going to see that.Our point now is going to have the data that we had in the temporary, but we didn’t go through thetrouble to set up new memory locations.We just stole what we had in our temporary here.And this is the job that move constructors.Do they steal from temporaries?Okay, so this is doing what we want, but I want you to see another trick we can use to really do thisin one step and not have to call the invalidate function.What we can do is set up a special getter functions which are going to steal the pointer and invalidatethe pointer in one go.And the way we can do that is to go back in our class definition and let’s go to where we have our gettersand we’re going to put in another set of getters that are going to steal the data and invalidate thepointer.So here we have Steal X, which is going to set up a new memory location.It’s going to steal X and store that in this new x pointer and then we’re going to invalidate x, we’regoing to set that to null pointer and then we’re going to return a new X here.The benefit of this is that we don’t have to call.Validate in the body of our move function.By the time we steal the pointer, we will also have a chance to invalidate it.And this is going to be pretty cool.We’re going to do the same logic for Steal here.And now that we have this in place, we could go in our Move constructor comment the invalidate callout and then call steal X.We don’t want to call get x.We want to call steal x.So we’re going to do that and we’re going to call steal y.And this is going to do what we want in one go.So some people prefer to do things like this, but it is a little less self-documenting.So I would prefer to use Invalidate here because when people see this call, they will at least havean intuition that we are invalidating data from the source object here and this is pretty cool.So we’re going to build and really prove that this is working and we don’t have any problem with this.You’re going to see that the build is good.We can clear and run Rooster.You’re going to see that we built our object from a temporary and it is working flawlessly.Here.We have the data from the temporary and we didn’t have to go through the job to build another object.We just stole the data that we had in our temporary here.Please remember to use Stdmove here because if you don’t, the compiler is not going to treat this asa temporary, at least in my case here.And you need to put Stdmove in here to make sure that the compiler is going to treat our temporary hereas a proper temporary and use the Move constructor to construct other objects from this temporary here.This is really all I had to share in this lecture.Hopefully you didn’t find it confusing.If you have any problems, please do ask and I will do the best I can to help you out.For now, we’re going to stop here in this lecture.In the next one, we’re going to learn about deleted constructors.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，很高兴能为您详细讲解 C++ 中的移动构造函数！作为您学习 C++ 的向导，我会尽力用最清晰、最易懂的方式来阐述这个重要的概念。</p>
<hr>
<h2 id="C-深度解析：掌握移动构造函数——“窃取”数据的艺术"><a href="#C-深度解析：掌握移动构造函数——“窃取”数据的艺术" class="headerlink" title="C++ 深度解析：掌握移动构造函数——“窃取”数据的艺术"></a><strong>C++ 深度解析：掌握移动构造函数——“窃取”数据的艺术</strong></h2><p><strong>内容摘要：</strong> 本课程将带您深入理解 C++ 中的移动构造函数（[Move Constructor]），这是一种特殊的构造函数，它允许我们“窃取”其他对象（尤其是临时对象）的资源，而不是进行昂贵的复制。我们将通过一个具体的 <code>Point</code> 类示例，学习移动构造函数的工作原理、语法，以及如何通过 <code>std::move</code> 来启用移动语义，从而优化程序性能。</p>
<hr>
<h2 id="1-什么是移动构造函数？为什么我们需要它？"><a href="#1-什么是移动构造函数？为什么我们需要它？" class="headerlink" title="1. 什么是移动构造函数？为什么我们需要它？"></a><strong>1. 什么是移动构造函数？为什么我们需要它？</strong></h2><p>在 C++ 中，当您创建一个新对象并用另一个现有对象来初始化它时，通常会发生两种情况：</p>
<ul>
<li><strong>拷贝构造函数（[Copy Constructor]）</strong>：当您从一个“L值”（[Lvalue]，即有明确内存地址、可以被重复使用的对象）创建另一个对象时，拷贝构造函数会被调用。它的任务是创建一个与源对象完全独立的副本，这意味着它可能会进行一次“深拷贝”（[Deep Copy]），为新的对象分配新的内存，并将源对象的数据复制过来。这在处理大型数据结构或动态分配的内存时，可能会非常耗费资源。</li>
<li><strong>移动构造函数</strong>：而移动构造函数则是一种特殊的构造函数，它专门用于从“R值”（[Rvalue]，通常是临时对象，即表达式的临时结果，生命周期很短，不可重复使用）创建新对象。它的核心思想是：既然源对象是临时对象，反正很快就要被销毁了，为什么不直接“窃取”它的资源（比如它指向的内存）呢？这样就避免了重新分配内存和复制数据的开销，极大地提高了效率。</li>
</ul>
<p><strong>核心问题：</strong> 假设您的类管理着一些动态分配的、非常大的内存资源。当您通过一个临时对象来创建另一个对象时，如果仍然使用拷贝构造函数，那么就会发生一次昂贵的深拷贝：为新对象分配新的内存，然后将旧内存中的大量数据复制过来。而这个临时对象一旦完成其使命，它所持有的旧内存就会被释放。这整个过程就造成了资源的浪费和性能的下降。移动构造函数的出现，正是为了解决这种不必要的开销，实现更高效的资源转移。</p>
<h2 id="2-深入理解：移动构造函数的工作原理"><a href="#2-深入理解：移动构造函数的工作原理" class="headerlink" title="2. 深入理解：移动构造函数的工作原理"></a><strong>2. 深入理解：移动构造函数的工作原理</strong></h2><p>让我们以一个 <code>Point</code> 类为例来具体说明。</p>
<h3 id="2-1-Point-类设计"><a href="#2-1-Point-类设计" class="headerlink" title="2.1 Point 类设计"></a><strong>2.1 <code>Point</code> 类设计</strong></h3><p>在我们的示例中，<code>Point</code> 类将包含两个私有成员变量 <code>m_x</code> 和 <code>m_y</code>，它们都是 <code>double*</code> 类型，即指向 <code>double</code> 类型的指针。这意味着 <code>Point</code> 对象本身并不直接存储坐标值，而是存储指向这些值的内存地址。坐标值 <code>X</code> 和 <code>Y</code> 将被动态地分配在堆（[Heap]）上。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Point.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span>* m_x; <span class="comment">// 指向X坐标的指针</span></span><br><span class="line">    <span class="keyword">double</span>* m_y; <span class="comment">// 指向Y坐标的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数：将指针置空，用于在窃取资源后使源对象无效</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Point(<span class="keyword">double</span> x_val, <span class="keyword">double</span> y_val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（[Destructor]）：释放动态分配的内存</span></span><br><span class="line">    ~Point();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数：执行深拷贝</span></span><br><span class="line">    Point(<span class="keyword">const</span> Point&amp; source);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** 移动构造函数：窃取资源 ***</span></span><br><span class="line">    <span class="comment">// 参数是右值引用（[Rvalue Reference]），表示接受临时对象或可移动的对象</span></span><br><span class="line">    Point(Point&amp;&amp; source) <span class="keyword">noexcept</span>; <span class="comment">// noexcept 关键字表示该函数不抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符 (为了完整性添加，虽然讲座未提及)</span></span><br><span class="line">    Point&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp; source);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符 (为了完整性添加，虽然讲座未提及)</span></span><br><span class="line">    Point&amp; <span class="keyword">operator</span>=(Point&amp;&amp; source) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter 方法 (为简洁起见，放在头文件内联实现)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> x_val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_x) *m_x = x_val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> y_val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_y) *m_y = y_val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (可选) 窃取并返回指针的方法，同时使源对象指针无效</span></span><br><span class="line">    <span class="comment">// double* stealX();</span></span><br><span class="line">    <span class="comment">// double* stealY();</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Point.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数实现</span></span><br><span class="line">Point::Point(<span class="keyword">double</span> x_val, <span class="keyword">double</span> y_val) : m_x(<span class="literal">nullptr</span>), m_y(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用普通构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    m_x = <span class="keyword">new</span> <span class="keyword">double</span>(x_val); <span class="comment">// 动态分配内存</span></span><br><span class="line">    m_y = <span class="keyword">new</span> <span class="keyword">double</span>(y_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数实现</span></span><br><span class="line">Point::~Point() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用析构函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_x) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_x; <span class="comment">// 释放内存</span></span><br><span class="line">        m_x = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_y) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_y;</span><br><span class="line">        m_y = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数实现：执行深拷贝</span></span><br><span class="line">Point::Point(<span class="keyword">const</span> Point&amp; source) : m_x(<span class="literal">nullptr</span>), m_y(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用拷贝构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (source.m_x) &#123;</span><br><span class="line">        m_x = <span class="keyword">new</span> <span class="keyword">double</span>(*source.m_x); <span class="comment">// 为新对象分配新内存并复制数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (source.m_y) &#123;</span><br><span class="line">        m_y = <span class="keyword">new</span> <span class="keyword">double</span>(*source.m_y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：将当前对象的指针置空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_x = <span class="literal">nullptr</span>;</span><br><span class="line">    m_y = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *** 移动构造函数实现：窃取资源 ***</span></span><br><span class="line">Point::Point(Point&amp;&amp; source) <span class="keyword">noexcept</span> : m_x(source.m_x), m_y(source.m_y) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用移动构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 窃取后，必须将源对象的指针置空，防止源对象析构时释放掉已被窃取的内存</span></span><br><span class="line">    <span class="comment">// 方式一：直接置空</span></span><br><span class="line">    source.m_x = <span class="literal">nullptr</span>;</span><br><span class="line">    source.m_y = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 方式二：调用辅助函数</span></span><br><span class="line">    <span class="comment">// source.invalidate(); // 因为invalidate是private，但我们在Point类内部，所以可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值运算符 (为了完整性添加)</span></span><br><span class="line">Point&amp; Point::<span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp; source) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用拷贝赋值运算符 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;source) &#123; <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="comment">// 释放旧资源</span></span><br><span class="line">        <span class="keyword">if</span> (m_x) <span class="keyword">delete</span> m_x;</span><br><span class="line">        <span class="keyword">if</span> (m_y) <span class="keyword">delete</span> m_y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配新资源并深拷贝</span></span><br><span class="line">        m_x = source.m_x ? <span class="keyword">new</span> <span class="keyword">double</span>(*source.m_x) : <span class="literal">nullptr</span>;</span><br><span class="line">        m_y = source.m_y ? <span class="keyword">new</span> <span class="keyword">double</span>(*source.m_y) : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动赋值运算符 (为了完整性添加)</span></span><br><span class="line">Point&amp; Point::<span class="keyword">operator</span>=(Point&amp;&amp; source) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用移动赋值运算符 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;source) &#123; <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="comment">// 释放旧资源</span></span><br><span class="line">        <span class="keyword">if</span> (m_x) <span class="keyword">delete</span> m_x;</span><br><span class="line">        <span class="keyword">if</span> (m_y) <span class="keyword">delete</span> m_y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 窃取资源</span></span><br><span class="line">        m_x = source.m_x;</span><br><span class="line">        m_y = source.m_y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将源对象的指针置空</span></span><br><span class="line">        source.m_x = <span class="literal">nullptr</span>;</span><br><span class="line">        source.m_y = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Getter 方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Point::getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_x) <span class="keyword">return</span> *m_x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>; <span class="comment">// 或者抛出异常，根据需求</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Point::getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_y) <span class="keyword">return</span> *m_y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>; <span class="comment">// 或者抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印信息实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::printInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查指针是否为空，避免解引用空指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Info: X = "</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_x) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *m_x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">", Y = "</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_y) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *m_y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// (可选) 窃取并返回指针的方法，同时使源对象指针无效</span></span><br><span class="line"><span class="comment">double* Point::stealX() &#123;</span></span><br><span class="line"><span class="comment">    double* temp_x = m_x;</span></span><br><span class="line"><span class="comment">    m_x = nullptr; // 将当前对象的X指针置空</span></span><br><span class="line"><span class="comment">    return temp_x;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">double* Point::stealY() &#123;</span></span><br><span class="line"><span class="comment">    double* temp_y = m_y;</span></span><br><span class="line"><span class="comment">    m_y = nullptr; // 将当前对象的Y指针置空</span></span><br><span class="line"><span class="comment">    return temp_y;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-2-“窃取”数据的机制"><a href="#2-2-“窃取”数据的机制" class="headerlink" title="2.2 “窃取”数据的机制"></a><strong>2.2 “窃取”数据的机制</strong></h3><p>考虑以下场景：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p3 = Point(<span class="number">20.5</span>, <span class="number">5.8</span>); <span class="comment">// 这里的 Point(20.5, 5.8) 是一个临时对象</span></span><br></pre></td></tr></table></figure></div>
<ol>
<li><strong>临时对象创建：</strong> 首先，<code>Point(20.5, 5.8)</code> 会创建一个临时 <code>Point</code> 对象。这个对象会在堆上动态分配内存来存储 <code>X</code> 和 <code>Y</code> 的值，并让 <code>m_x</code> 和 <code>m_y</code> 指向这些内存。</li>
<li><strong>默认行为（无移动构造函数时）：</strong> 如果没有定义移动构造函数，编译器会调用拷贝构造函数。这意味着会为 <code>p3</code> 再次分配新的内存，并将临时对象中的 <code>20.5</code> 和 <code>5.8</code> 复制到 <code>p3</code> 的新内存中。然后，临时对象会被销毁，其原始的内存也会被释放。</li>
<li><strong>移动构造函数的行为：</strong> 当定义了移动构造函数后，编译器会识别到它正在从一个临时对象（右值）创建 <code>p3</code>，因此它会选择调用移动构造函数。<ul>
<li><strong>步骤1：窃取指针。</strong> 移动构造函数不会分配新的内存。相反，它会将临时对象 <code>source</code> 的 <code>m_x</code> 和 <code>m_y</code> 指针的值直接复制给 <code>p3</code> 的 <code>m_x</code> 和 <code>m_y</code>。此时，<code>p3</code> 和 <code>source</code> 的指针都指向同一块内存。</li>
<li><strong>步骤2：使源对象无效。</strong> 这是关键一步！为了确保在 <code>source</code> 销毁时不会错误地释放 <code>p3</code> 正在使用的内存（导致“双重释放”或“悬空指针”），移动构造函数会立即将 <code>source</code> 的 <code>m_x</code> 和 <code>m_y</code> 指针设置为 <code>nullptr</code>。这样，当 <code>source</code> 对象被销毁时，由于其指针已为空，就不会尝试释放它不再拥有的内存。</li>
<li><strong>结果：</strong> 此时，原始的 <code>20.5</code> 和 <code>5.8</code> 的内存所有权已经从临时对象安全地转移到了 <code>p3</code>。临时对象在销毁时，不会触及这块内存。我们避免了昂贵的内存分配和数据复制。</li>
</ul>
</li>
</ol>
<h3 id="2-3-移动构造函数的语法"><a href="#2-3-移动构造函数的语法" class="headerlink" title="2.3 移动构造函数的语法"></a><strong>2.3 移动构造函数的语法</strong></h3><p>移动构造函数的声明方式如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName(ClassName&amp;&amp; source) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>ClassName</code>: 您的类名。</li>
<li><code>&amp;&amp;</code>：这就是 <strong>右值引用</strong> 符号，它表明这个构造函数接受一个右值（通常是临时对象）作为参数。</li>
<li><code>source</code>: 源对象的名称，您可以从中窃取资源。</li>
<li><code>noexcept</code>: 这是一个重要的关键字。它表明该函数承诺不会抛出异常。这对于移动操作非常重要，因为如果移动操作在中间抛出异常，C++ 标准库中的某些容器（如 <code>std::vector</code>）可能会选择进行更安全的拷贝操作，而不是移动，从而失去性能优势。</li>
</ul>
<h3 id="2-4-std-move-的作用"><a href="#2-4-std-move-的作用" class="headerlink" title="2.4 std::move 的作用"></a><strong>2.4 <code>std::move</code> 的作用</strong></h3><p>在某些情况下，您可能希望强制编译器将一个 L值（例如一个具名变量）视为一个 R值，从而使其能够被移动构造函数或移动赋值运算符处理。这时就需要用到 <code>std::move</code>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10.0</span>, <span class="number">15.0</span>)</span></span>; <span class="comment">// p1 是一个 L值</span></span><br><span class="line">Point p4 = <span class="built_in">std</span>::move(p1); <span class="comment">// 强制将 p1 视为 R值，调用移动构造函数</span></span><br></pre></td></tr></table></figure></div>
<p><strong>重要！</strong> <code>std::move</code> <strong>本身并不执行任何移动操作</strong>。它仅仅是将一个左值表达式 <strong>转换（[Cast]）</strong> 为一个右值引用。这个转换告诉编译器：“嘿，这个对象我不再需要了，你可以安全地从它那里窃取资源了！”然后，编译器会根据这个右值引用，尝试匹配并调用移动构造函数（或移动赋值运算符），如果匹配成功，才会发生真正的“移动”。</p>
<p>如果 <code>std::move</code> 被省略，而参数又是一个 L值，那么编译器会调用拷贝构造函数（如果可用）或者报错。如果参数是一个 R值（如 <code>Point(20.5, 5.8)</code> 这样的临时对象），即使没有 <code>std::move</code>，编译器也能够自动识别并调用移动构造函数（如果已定义）。</p>
<h3 id="2-5-invalidate-函数与“Steal-Getters”（可选）"><a href="#2-5-invalidate-函数与“Steal-Getters”（可选）" class="headerlink" title="2.5 invalidate 函数与“Steal Getters”（可选）"></a><strong>2.5 <code>invalidate</code> 函数与“Steal Getters”（可选）</strong></h3><p>讲座中提到了两种处理源对象指针的方式：</p>
<ol>
<li><p><strong>在移动构造函数内直接调用 <code>invalidate()</code>：</strong> 这是一种清晰明了的方式。在窃取资源后，显式地调用一个辅助函数（如 <code>invalidate()</code>）将源对象的指针置空。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point::Point(Point&amp;&amp; source) <span class="keyword">noexcept</span> : m_x(source.m_x), m_y(source.m_y) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用移动构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    source.invalidate(); <span class="comment">// 清晰地表明：使源对象无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这种方式的好处是，移动构造函数的主体清晰地展示了“窃取”和“失效”两个步骤，易于理解。</p>
</li>
<li><p><strong>使用“Steal Getters”（如 <code>stealX()</code> / <code>stealY()</code>）：</strong> 这种方法将“获取指针”和“将源指针置空”这两个操作封装在一个 getter 方法中。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Point.h中</span></span><br><span class="line"><span class="comment">// double* stealX();</span></span><br><span class="line"><span class="comment">// double* stealY();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Point.cpp中</span></span><br><span class="line"><span class="comment">// double* Point::stealX() &#123;</span></span><br><span class="line"><span class="comment">//     double* temp_x = m_x;</span></span><br><span class="line"><span class="comment">//     m_x = nullptr; // 将当前对象的X指针置空</span></span><br><span class="line"><span class="comment">//     return temp_x;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在移动构造函数中调用</span></span><br><span class="line"><span class="comment">// Point::Point(Point&amp;&amp; source) noexcept : m_x(source.stealX()), m_y(source.stealY()) &#123;</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; "--- 调用移动构造函数 ---" &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></div>
<p>这种方式可能看起来更简洁，因为它在初始化列表中就完成了指针的获取和源对象的失效。但讲座中提到，它可能“不太自文档化”（less self-documenting），因为它将失效逻辑隐藏在 getter 内部，读者可能需要深入到 getter 的实现才能理解其副作用。通常，更推荐在移动构造函数的主体中显式地将源指针置空或调用 <code>invalidate</code> 函数，以提高代码的可读性。</p>
</li>
</ol>
<h2 id="3-完整代码示例"><a href="#3-完整代码示例" class="headerlink" title="3. 完整代码示例"></a><strong>3. 完整代码示例</strong></h2><p>为了更好地演示，我们将把 <code>Point</code> 类（包含移动构造函数）和 <code>main</code> 函数放在一起。</p>
<h3 id="Point-h-如上所示"><a href="#Point-h-如上所示" class="headerlink" title="Point.h (如上所示)"></a><strong>Point.h</strong> (如上所示)</h3><h3 id="Point-cpp-如上所示"><a href="#Point-cpp-如上所示" class="headerlink" title="Point.cpp (如上所示)"></a><strong>Point.cpp</strong> (如上所示)</h3><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a><strong>main.cpp</strong></h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span> <span class="comment">// 包含Point类的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 示例开始 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建一个普通Point对象</span></span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10.4</span>, <span class="number">15.6</span>)</span></span>;</span><br><span class="line">    p1.printInfo();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1的X地址: "</span> &lt;&lt; p1.getX() &lt;&lt; <span class="string">" (实际内容)"</span>; <span class="comment">// 打印值，而不是地址</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">", p1的Y地址: "</span> &lt;&lt; p1.getY() &lt;&lt; <span class="string">" (实际内容)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 使用临时对象调用移动构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// Point(20.5, 5.8) 是一个临时对象（右值）</span></span><br><span class="line">    <span class="comment">// 编译器会自动识别并调用移动构造函数</span></span><br><span class="line">    Point p3 = Point(<span class="number">20.5</span>, <span class="number">5.8</span>);</span><br><span class="line">    p3.printInfo();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 使用 std::move 强制调用移动构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p1 是一个 L值，需要通过 std::move 转换为右值引用才能调用移动构造函数</span></span><br><span class="line">    Point p4 = <span class="built_in">std</span>::move(p1);</span><br><span class="line">    p4.printInfo();</span><br><span class="line">    <span class="comment">// 此时，p1 的资源已被窃取，其内部指针应为 nullptr</span></span><br><span class="line">    <span class="comment">// 访问 p1 的数据可能会导致未定义行为或返回默认值</span></span><br><span class="line">    p1.printInfo(); <span class="comment">// 预期：X = nullptr, Y = nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 验证 p1 是否被移动 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 尝试修改 p4 的值，看是否影响 p1（应该不影响）</span></span><br><span class="line">    p4.setX(<span class="number">99.0</span>);</span><br><span class="line">    p4.setY(<span class="number">88.0</span>);</span><br><span class="line">    p4.printInfo();</span><br><span class="line">    p1.printInfo(); <span class="comment">// 确认 p1 仍然是无效状态</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 验证拷贝构造函数在L值上的调用 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Point p5 = p4; <span class="comment">// p4 是一个 L值，这里会调用拷贝构造函数</span></span><br><span class="line">    p5.printInfo();</span><br><span class="line">    p4.printInfo(); <span class="comment">// p4 仍然有效</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 示例结束 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>运行上述代码，您将看到类似的输出：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">--- 示例开始 ---</span><br><span class="line">--- 调用普通构造函数 ---</span><br><span class="line">Point Info: X &#x3D; 10.4, Y &#x3D; 15.6</span><br><span class="line">p1的X地址: 10.4 (实际内容), p1的Y地址: 15.6 (实际内容)</span><br><span class="line"></span><br><span class="line">--- 使用临时对象调用移动构造函数 ---</span><br><span class="line">--- 调用普通构造函数 ---</span><br><span class="line">--- 调用移动构造函数 ---</span><br><span class="line">--- 调用析构函数 --- &#x2F;&#x2F; 临时对象 Point(20.5, 5.8) 被销毁</span><br><span class="line">Point Info: X &#x3D; 20.5, Y &#x3D; 5.8</span><br><span class="line"></span><br><span class="line">--- 使用 std::move 强制调用移动构造函数 ---</span><br><span class="line">--- 调用移动构造函数 ---</span><br><span class="line">--- 调用析构函数 --- &#x2F;&#x2F; p1 被销毁，但其内容已移走，析构时不会释放资源</span><br><span class="line">Point Info: X &#x3D; 99, Y &#x3D; 88</span><br><span class="line">Point Info: X &#x3D; nullptr, Y &#x3D; nullptr &#x2F;&#x2F; p1 已经被移动，资源已置空</span><br><span class="line"></span><br><span class="line">--- 验证 p1 是否被移动 ---</span><br><span class="line">Point Info: X &#x3D; 99, Y &#x3D; 88</span><br><span class="line">Point Info: X &#x3D; nullptr, Y &#x3D; nullptr</span><br><span class="line"></span><br><span class="line">--- 验证拷贝构造函数在L值上的调用 ---</span><br><span class="line">--- 调用拷贝构造函数 ---</span><br><span class="line">Point Info: X &#x3D; 99, Y &#x3D; 88</span><br><span class="line">Point Info: X &#x3D; 99, Y &#x3D; 88</span><br><span class="line"></span><br><span class="line">--- 示例结束 ---</span><br><span class="line">--- 调用析构函数 --- &#x2F;&#x2F; p5 销毁</span><br><span class="line">--- 调用析构函数 --- &#x2F;&#x2F; p4 销毁</span><br><span class="line">--- 调用析构函数 --- &#x2F;&#x2F; p3 销毁</span><br></pre></td></tr></table></figure></div>
<p>从输出中可以看到，当从临时对象或通过 <code>std::move</code> 创建新对象时，会调用“移动构造函数”，而不是“拷贝构造函数”，从而避免了不必要的深拷贝。同时，源对象的析构函数在资源被移动后，也不会尝试释放已经不再属于它的内存。</p>
<h2 id="4-QA-闪卡"><a href="#4-QA-闪卡" class="headerlink" title="4. QA 闪卡"></a><strong>4. QA 闪卡</strong></h2><ol>
<li><p><strong>Q:</strong> 移动构造函数的主要目的是什么？<br><strong>A:</strong> 避免不必要的昂贵拷贝操作，通过“窃取”临时对象或即将销毁的对象的资源来提高效率。</p>
</li>
<li><p><strong>Q:</strong> 移动构造函数的参数类型是什么？它与拷贝构造函数有何不同？<br><strong>A:</strong> 移动构造函数的参数是右值引用（<code>ClassName&amp;&amp;</code>），而拷贝构造函数的参数是常量左值引用（<code>const ClassName&amp;</code>）。</p>
</li>
<li><p><strong>Q:</strong> 为什么在移动构造函数中，我们需要将源对象的指针置空？<br><strong>A:</strong> 防止源对象在销毁时，错误地释放掉已经被“窃取”的内存，从而避免“双重释放”（[Double Free]）或“悬空指针”（[Dangling Pointer]）问题。</p>
</li>
<li><p><strong>Q:</strong> <code>std::move</code> 函数的作用是什么？它真的“移动”了数据吗？<br><strong>A:</strong> <code>std::move</code> 不会移动数据，它仅仅是将一个左值强制转换为右值引用，从而告诉编译器这个对象可以被移动。真正的移动是由后续调用的移动构造函数或移动赋值运算符完成的。</p>
</li>
<li><p><strong>Q:</strong> 什么时候编译器会优先选择调用移动构造函数而不是拷贝构造函数？<br><strong>A:</strong> 当初始化新对象时，如果源对象是一个右值（例如，一个临时对象或通过 <code>std::move</code> 转换的左值），并且类定义了移动构造函数，那么编译器会优先调用移动构造函数。</p>
</li>
</ol>
<h2 id="5-常见误解或错误"><a href="#5-常见误解或错误" class="headerlink" title="5. 常见误解或错误"></a><strong>5. 常见误解或错误</strong></h2><ol>
<li><p><strong>误解：<code>std::move</code> 会直接执行移动操作。</strong><br><strong>纠正：</strong> <code>std::move</code> 只是一个类型转换（[Type Cast]），它将表达式转换为右值引用类型，使其<strong>有资格</strong>被移动构造函数或移动赋值运算符调用。实际的移动操作（资源的转移）是在这些特殊的成员函数中完成的。</p>
</li>
<li><p><strong>错误：在移动构造函数中忘记将源对象的指针置空。</strong><br><strong>后果：</strong> 这会导致“双重释放”错误。新对象和源对象会同时指向同一块内存。当源对象销毁时，它会释放这块内存；当新对象销毁时，它会再次尝试释放同一块内存，导致程序崩溃。</p>
</li>
<li><p><strong>误解：移动构造函数总是比拷贝构造函数快。</strong><br><strong>纠正：</strong> 对于那些不管理动态资源（如 <code>int</code>、<code>double</code> 等基本类型）的简单类，或者当对象的拷贝成本非常低时，移动操作可能不会带来显著的性能提升。甚至在某些情况下，编译器可能会进行“返回值优化”（[Return Value Optimization] - RVO）或“命名返回值优化”（[Named Return Value Optimization] - NRVO），直接在目标位置构造对象，此时拷贝或移动构造函数根本不会被调用，性能最高。</p>
</li>
<li><p><strong>错误：将移动构造函数的参数声明为 <code>const ClassName&amp;&amp; source</code>。</strong><br><strong>后果：</strong> <code>const</code> 关键字表示源对象不能被修改。这意味着在移动构造函数内部，您将无法将 <code>source.m_x</code> 和 <code>source.m_y</code> 设置为 <code>nullptr</code>，从而无法正确地“窃取”资源。移动操作的核心就是修改源对象的状态（使其失效）。因此，移动构造函数的参数不能是 <code>const</code>。</p>
</li>
<li><p><strong>误解：只要定义了移动构造函数，编译器就会自动为所有情况选择移动。</strong><br><strong>纠正：</strong> 编译器选择调用移动构造函数的前提是源对象必须是右值。如果源对象是一个具名左值，您仍然需要显式地使用 <code>std::move</code> 来“建议”编译器进行移动操作。</p>
</li>
</ol>
<h2 id="6-编程练习"><a href="#6-编程练习" class="headerlink" title="6. 编程练习"></a><strong>6. 编程练习</strong></h2><p>现在，是时候动手实践了！请完善以下 <code>Point</code> 类中的移动构造函数。</p>
<p><strong>任务：</strong><br>给定了 <code>Point.h</code> 和 <code>Point.cpp</code> 的部分代码，请您在 <code>Point.cpp</code> 中完成 <code>Point(Point&amp;&amp; source)</code> 移动构造函数的实现。您需要完成以下两个关键步骤：</p>
<ol>
<li>将 <code>source</code> 对象所管理的资源（<code>m_x</code> 和 <code>m_y</code> 指针指向的内存）“窃取”到新对象中。</li>
<li>将 <code>source</code> 对象的 <code>m_x</code> 和 <code>m_y</code> 指针设置为 <code>nullptr</code>，以确保 <code>source</code> 对象在销毁时不会错误地释放资源。</li>
</ol>
<p><strong>Point.h (不要修改此文件)：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span>* m_x;</span><br><span class="line">    <span class="keyword">double</span>* m_y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Point(<span class="keyword">double</span> x_val, <span class="keyword">double</span> y_val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Point();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Point(<span class="keyword">const</span> Point&amp; source);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** 请实现此函数：移动构造函数 ***</span></span><br><span class="line">    Point(Point&amp;&amp; source) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong>Point.cpp (请补充 <code>Point::Point(Point&amp;&amp; source)</code> 的实现)：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数实现 (已提供)</span></span><br><span class="line">Point::Point(<span class="keyword">double</span> x_val, <span class="keyword">double</span> y_val) : m_x(<span class="literal">nullptr</span>), m_y(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用普通构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    m_x = <span class="keyword">new</span> <span class="keyword">double</span>(x_val);</span><br><span class="line">    m_y = <span class="keyword">new</span> <span class="keyword">double</span>(y_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数实现 (已提供)</span></span><br><span class="line">Point::~Point() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用析构函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_x) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_x;</span><br><span class="line">        m_x = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_y) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_y;</span><br><span class="line">        m_y = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数实现 (已提供)</span></span><br><span class="line">Point::Point(<span class="keyword">const</span> Point&amp; source) : m_x(<span class="literal">nullptr</span>), m_y(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用拷贝构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (source.m_x) &#123;</span><br><span class="line">        m_x = <span class="keyword">new</span> <span class="keyword">double</span>(*source.m_x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (source.m_y) &#123;</span><br><span class="line">        m_y = <span class="keyword">new</span> <span class="keyword">double</span>(*source.m_y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *** 请在这里实现移动构造函数 ***</span></span><br><span class="line">Point::Point(Point&amp;&amp; source) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="comment">// 步骤1: 窃取源对象的资源</span></span><br><span class="line">    <span class="comment">// 将 source 的 m_x 和 m_y 指针的值直接赋给当前对象的 m_x 和 m_y</span></span><br><span class="line">    <span class="comment">// 例如：this-&gt;m_x = source.m_x;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2: 使源对象无效</span></span><br><span class="line">    <span class="comment">// 将 source 的 m_x 和 m_y 指针置空</span></span><br><span class="line">    <span class="comment">// 例如：source.m_x = nullptr;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用移动构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这一行保留</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Getter 方法实现 (已提供)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Point::getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_x) <span class="keyword">return</span> *m_x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Point::getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_y) <span class="keyword">return</span> *m_y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印信息实现 (已提供)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::printInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Info: X = "</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_x) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *m_x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">", Y = "</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_y) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *m_y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>main.cpp (用于测试您的实现，无需修改)：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 测试移动构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1: 从临时对象构造 (应调用移动构造函数)</span></span><br><span class="line">    Point p1 = Point(<span class="number">10.0</span>, <span class="number">20.0</span>); <span class="comment">// 临时对象 Point(10.0, 20.0) 是右值</span></span><br><span class="line">    p1.printInfo();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 使用 std::move 从左值构造 (应调用移动构造函数) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">temp_point</span><span class="params">(<span class="number">30.0</span>, <span class="number">40.0</span>)</span></span>; <span class="comment">// temp_point 是一个左值</span></span><br><span class="line">    Point p2 = <span class="built_in">std</span>::move(temp_point); <span class="comment">// 强制转换为右值引用</span></span><br><span class="line">    p2.printInfo();</span><br><span class="line">    temp_point.printInfo(); <span class="comment">// 验证 temp_point 是否已被移动（其指针是否为nullptr）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 从左值构造 (应调用拷贝构造函数) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Point p3 = p1; <span class="comment">// p1 是一个左值，应调用拷贝构造函数</span></span><br><span class="line">    p3.printInfo();</span><br><span class="line">    p1.printInfo(); <span class="comment">// p1 应该仍然有效</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 测试结束 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请完成 <code>Point.cpp</code> 中的 <code>Point::Point(Point&amp;&amp; source) noexcept</code> 的实现，然后告诉我您的解决方案。我会在您的解决方案提交后，给出我的评价、正确答案以及进一步的建议。</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数实现 (已提供)</span></span><br><span class="line">Point::Point(<span class="keyword">double</span> x_val, <span class="keyword">double</span> y_val) : m_x(<span class="literal">nullptr</span>), m_y(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用普通构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    m_x = <span class="keyword">new</span> <span class="keyword">double</span>(x_val);</span><br><span class="line">    m_y = <span class="keyword">new</span> <span class="keyword">double</span>(y_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数实现 (已提供)</span></span><br><span class="line">Point::~Point() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用析构函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_x) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_x;</span><br><span class="line">        m_x = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_y) &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_y;</span><br><span class="line">        m_y = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数实现 (已提供)</span></span><br><span class="line">Point::Point(<span class="keyword">const</span> Point&amp; source) : m_x(<span class="literal">nullptr</span>), m_y(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用拷贝构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (source.m_x) &#123;</span><br><span class="line">        m_x = <span class="keyword">new</span> <span class="keyword">double</span>(*source.m_x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (source.m_y) &#123;</span><br><span class="line">        m_y = <span class="keyword">new</span> <span class="keyword">double</span>(*source.m_y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *** 请在这里实现移动构造函数 ***</span></span><br><span class="line">Point::Point(Point&amp;&amp; source) <span class="keyword">noexcept</span></span><br><span class="line">: m_x(source.m_x), m_y(source.m_y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 步骤1: 窃取源对象的资源</span></span><br><span class="line">    <span class="comment">// 将 source 的 m_x 和 m_y 指针的值直接赋给当前对象的 m_x 和 m_y</span></span><br><span class="line">    <span class="comment">// 例如：this-&gt;m_x = source.m_x;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2: 使源对象无效</span></span><br><span class="line">    <span class="comment">// 将 source 的 m_x 和 m_y 指针置空</span></span><br><span class="line">    <span class="comment">// 例如：source.m_x = nullptr;</span></span><br><span class="line">    source.m_x = <span class="literal">nullptr</span>;</span><br><span class="line">    source.m_y = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用移动构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这一行保留</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Getter 方法实现 (已提供)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Point::getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_x) <span class="keyword">return</span> *m_x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Point::getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_y) <span class="keyword">return</span> *m_y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印信息实现 (已提供)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::printInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Info: X = "</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_x) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *m_x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">", Y = "</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_y) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *m_y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"nullptr"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>太棒了！您的解决方案非常出色，完全正确地实现了移动构造函数的逻辑。</p>
<hr>
<h2 id="7-您的解决方案评分及解释"><a href="#7-您的解决方案评分及解释" class="headerlink" title="7. 您的解决方案评分及解释"></a><strong>7. 您的解决方案评分及解释</strong></h2><p><strong>您的解决方案：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Point::Point(Point&amp;&amp; source) <span class="keyword">noexcept</span></span><br><span class="line">: m_x(source.m_x), m_y(source.m_y) <span class="comment">// 在初始化列表中窃取资源</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 步骤1: 窃取源对象的资源 - 已经通过初始化列表完成</span></span><br><span class="line">    <span class="comment">// 将 source 的 m_x 和 m_y 指针的值直接赋给当前对象的 m_x 和 m_y</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2: 使源对象无效</span></span><br><span class="line">    <span class="comment">// 将 source 的 m_x 和 m_y 指针置空</span></span><br><span class="line">    source.m_x = <span class="literal">nullptr</span>; <span class="comment">// 正确！</span></span><br><span class="line">    source.m_y = <span class="literal">nullptr</span>; <span class="comment">// 正确！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 调用移动构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>评分：</strong> 5/5 分！完美！</p>
<p><strong>解释：</strong></p>
<ol>
<li><p><strong>窃取资源（[Resource Acquisition]）的正确性：</strong><br>您在初始化列表 (<code>: m_x(source.m_x), m_y(source.m_y)</code>) 中完成了资源窃取。这是 C++ 中实现移动构造函数的<strong>最佳实践</strong>。它直接使用 <code>source</code> 的指针值来初始化当前对象的 <code>m_x</code> 和 <code>m_y</code>，避免了先默认初始化成员变量再赋值的额外开销（尽管在这个例子中开销很小，但这是一个好习惯）。</p>
</li>
<li><p><strong>源对象失效（[Source Invalidation]）的正确性：</strong><br>您在构造函数体中正确地将 <code>source.m_x</code> 和 <code>source.m_y</code> 设置为 <code>nullptr</code>。这是移动构造函数中至关重要的一步，确保了：</p>
<ul>
<li><strong>所有权转移（[Ownership Transfer]）：</strong> 资源的唯一所有权从 <code>source</code> 转移到了新创建的对象。</li>
<li><strong>避免双重释放（[Double Free Prevention]）：</strong> 当 <code>source</code> 对象生命周期结束并调用其析构函数时，由于其指针已为空 (<code>nullptr</code>)，它不会尝试释放已被新对象“窃取”的内存，从而避免了内存错误和程序崩溃。</li>
<li><strong>源对象安全使用：</strong> <code>source</code> 对象虽然失去了资源，但其内部状态是明确的（指针为 <code>nullptr</code>），即使被误用也不会导致野指针（[Wild Pointer]）解引用等未定义行为（[Undefined Behavior]）。</li>
</ul>
</li>
<li><p><strong><code>noexcept</code> 关键字的使用：</strong><br>虽然在练习中没有明确要求添加 <code>noexcept</code>，但您的 <code>Point::Point(Point&amp;&amp; source) noexcept</code> 声明中包含它，这表明您对移动构造函数的特性有很好的理解。移动构造函数通常被声明为 <code>noexcept</code>，因为它不应该抛出异常。如果移动操作可能抛出异常，那么 <code>std::vector</code> 等标准库容器在需要重新分配内存时，可能会选择调用拷贝构造函数（即使移动构造函数存在），从而失去性能优势。</p>
</li>
</ol>
<p>综上所述，您的代码简洁、高效、正确且符合现代 C++ 的最佳实践。干得漂亮！</p>
<hr>
<h2 id="8-扩展问题及建议"><a href="#8-扩展问题及建议" class="headerlink" title="8. 扩展问题及建议"></a><strong>8. 扩展问题及建议</strong></h2><p>既然您已经掌握了移动构造函数，我们可以进一步探索相关概念，这将帮助您更好地理解 C++ 的移动语义（[Move Semantics]）和资源管理。</p>
<ol>
<li><p><strong>移动赋值运算符（[Move Assignment Operator]）：</strong><br>您已经学会了如何通过移动构造函数从右值创建新对象。那么，当您想将一个右值<strong>赋值</strong>给一个已存在的对象时，C++ 会调用什么？</p>
<ul>
<li><strong>思考：</strong> 移动赋值运算符的声明和实现与移动构造函数有何相似和不同之处？它需要处理哪些额外的情况（例如，目标对象可能已经持有了资源）？</li>
<li><strong>建议：</strong> 尝试为 <code>Point</code> 类实现一个移动赋值运算符 <code>Point&amp; operator=(Point&amp;&amp; source) noexcept;</code>。</li>
</ul>
</li>
<li><p><strong><code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>：</strong><br>在现代 C++ 中，我们通常不直接使用裸指针（[Raw Pointer]）进行资源管理（如 <code>new</code> 和 <code>delete</code>），而是使用智能指针（[Smart Pointer]）。</p>
<ul>
<li><strong>思考：</strong> <code>std::unique_ptr</code> 默认就支持移动语义，但不支持拷贝。这与 <code>Point</code> 类中的移动构造函数概念有何异曲同工之处？它如何防止双重释放？</li>
<li><strong>建议：</strong> 学习 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 的基本用法，并尝试将 <code>Point</code> 类中的 <code>double*</code> 成员替换为 <code>std::unique_ptr&lt;double&gt;</code>。您会发现，一旦使用了智能指针，您通常就不需要手动编写析构函数、拷贝/移动构造函数和赋值运算符了（这被称为“零规则”或“三/五规则”的现代版本）。</li>
</ul>
</li>
<li><p><strong>完美转发（[Perfect Forwarding]）和万能引用（[Universal Reference]）：</strong><br><code>std::move</code> 和 <code>std::forward</code> 是 C++11 引入移动语义时常用的两个工具。<code>std::move</code> 用于将左值转换为右值引用，而 <code>std::forward</code> 则用于实现完美转发。</p>
<ul>
<li><strong>思考：</strong> 万能引用（<code>T&amp;&amp;</code>，当 <code>T</code> 是模板参数时）如何根据传入参数的左右值属性，自动推导出 <code>T</code> 的类型？完美转发如何结合万能引用和 <code>std::forward</code> 来保持参数的左右值属性，将其转发给另一个函数？</li>
<li><strong>建议：</strong> 了解模板函数中万能引用和 <code>std::forward</code> 的工作原理，这对于编写通用的库代码非常重要。</li>
</ul>
</li>
<li><p><strong>编译器优化（[Compiler Optimizations]）：RVO/NRVO：</strong><br>在某些情况下，即使没有移动构造函数，您也可能观察到代码的性能与移动操作类似。这通常是由于编译器进行了“返回值优化”（RVO）或“命名返回值优化”（NRVO）。</p>
<ul>
<li><strong>思考：</strong> RVO/NRVO 是什么？它们是如何工作的？它们何时发生？它们的存在是否意味着我们不需要编写移动构造函数？</li>
<li><strong>建议：</strong> 查阅关于 RVO/NRVO 的资料，理解它们如何减少临时对象的创建和复制，以及它们与移动语义之间的关系。</li>
</ul>
</li>
</ol>
<p>通过深入研究这些主题，您将对 C++ 的性能优化、资源管理和高级特性有更全面的理解。祝您学习愉快！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Memory/">Memory    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Object/">Object    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/322%20-%20Different%20Type%20Members/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>322 - Different Type Members</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/319%20-%20Class%20Const/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>319 - Class Const</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/Cpp 默认构造函数创建对象/" title="Cpp 默认构造函数创建对象"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">Cpp 默认构造函数创建对象</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/278 - cpp 指针管理类对象示例/" title="278 - cpp 指针管理类对象示例"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">278 - cpp 指针管理类对象示例</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/283 - cpp 类对象大小探究/" title="283 - cpp 类对象大小探究"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">283 - cpp 类对象大小探究</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/286 - const 对象问题与指针引用访问/" title="286 - const 对象问题与指针引用访问"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">286 - const 对象问题与指针引用访问</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/左值右值移动语义/" title="左值右值移动语义"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">左值右值移动语义</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/静态成员访问控制/" title="静态成员访问控制"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">静态成员访问控制</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>