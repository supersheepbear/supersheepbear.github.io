<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>287 - const 对象作为函数参数的注意事项 | Bear's dream</title><meta name="description" content="287 - const 对象作为函数参数的注意事项"><meta name="keywords" content="Cpp,Coding,Function,Object,Parameter"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="287 - const 对象作为函数参数的注意事项"><meta name="twitter:description" content="287 - const 对象作为函数参数的注意事项"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="287 - const 对象作为函数参数的注意事项"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/287%20-%20const%20%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="287 - const 对象作为函数参数的注意事项"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/287%20-%20const%20%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"><link rel="prev" title="286 - const 对象问题与指针引用访问" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/286%20-%20const%20%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE/"><link rel="next" title="297 - 构造函数初始化列表" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/297%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">178</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">160</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">23</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Const-对象作为函数参数的注意事项"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Const 对象作为函数参数的注意事项</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-教程：const-常量-对象作为函数参数"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">C++ 教程：const (常量) 对象作为函数参数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-详细解释"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">2. 详细解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-常见误解或易犯错误"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">5. 常见误解或易犯错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-编码练习"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">6. 编码练习</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-2"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#include"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">include </span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#include-1"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">include </span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#include-2"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">include </span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-2"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-评价你的解答并给出正确答案和解释"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">7. 评价你的解答并给出正确答案和解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-扩展问题与调查建议"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">8. 扩展问题与调查建议</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Const-对象作为函数参数的注意事项"><span class="toc-number">1.</span> <span class="toc-text">Const 对象作为函数参数的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-教程：const-常量-对象作为函数参数"><span class="toc-number">2.</span> <span class="toc-text">C++ 教程：const (常量) 对象作为函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-详细解释"><span class="toc-number">2.1.</span> <span class="toc-text">2. 详细解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-代码示例"><span class="toc-number">2.2.</span> <span class="toc-text">3. 代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc-number">2.3.</span> <span class="toc-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见误解或易犯错误"><span class="toc-number">2.4.</span> <span class="toc-text">5. 常见误解或易犯错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-编码练习"><span class="toc-number">2.5.</span> <span class="toc-text">6. 编码练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">2.6.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">2.7.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-2"><span class="toc-number">2.8.</span> <span class="toc-text">🧑‍💻 User</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include"><span class="toc-number">3.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-1"><span class="toc-number">4.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-2"><span class="toc-number">5.</span> <span class="toc-text">include </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-2"><span class="toc-number">5.1.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-评价你的解答并给出正确答案和解释"><span class="toc-number">5.2.</span> <span class="toc-text">7. 评价你的解答并给出正确答案和解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-扩展问题与调查建议"><span class="toc-number">5.3.</span> <span class="toc-text">8. 扩展问题与调查建议</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">287 - const 对象作为函数参数的注意事项</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/287%20-%20const%20%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/287%20-%20const%20%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Const-对象作为函数参数的注意事项"><a href="#Const-对象作为函数参数的注意事项" class="headerlink" title="Const 对象作为函数参数的注意事项"></a>Const 对象作为函数参数的注意事项</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture.We’re going to see what’s going to happen if you try and use a const object as a function argument.We’re going to be using the same class we’ve used in the last lecture.No change at all.We’re going to have a few constructors and we’re going to have the setters and getters and we’re goingto have a principal function and we’re going to have our member variables which are going to be modeledas a string view variables, and the age is going to be a row int variable.So it’s not going to be quite like this, but it’s going to be exactly like what we did in the lastlecture.The main thing we want to see is what happens if you use a const object as a function argument and we’regoing to have a couple of options.We could either pass by value, we could either pass our parameters by Non-const reference, we couldpass by const reference, we could pass by pointer to non const, or we could even pass by pointer tocost.So I want you to pause the video and try to think about what could happen in each of these cases.If we pass a const dog object as a function of parameter, try to think about it and then I am goingto tell you the first case is going to be passing by value.And here we have a simple example of that.We have a function called function taking dog.It’s not going to return anything and it’s going to take a dog object by value inside.We’re going to try and set the name and print the information.And this is what the function here does.In the main function.You see, we have a const dog object and we’re going to pass it by value.The thing is, this is going to work because what we really have inside the function is not the originalvariable, it’s a copy.And we want to have any problem trying to modify a copy because the customers of the original objectis going to be preserved.We’re not going to be modifying it.We’re going to be modifying the copy.So passing by value is going to work fine.So what if you pass by Non-const reference?Here we have another simple example.We have a function taking dog ref.It’s not going to return anything, but it’s going to take a dog object by Non-const reference.Notice that we don’t have a const in front of the dog parameter here, so this is a non-const reference.The compiler is not going to allow this because this reference could be used to modify the originalobject.So this code here won’t even compile.And the reason is because our object is const, we’re not allowed to do any modification on this objectand we are trying to pass that to a function by reference which could allow us to potentially modifythis object.The compiler is going to prevent us from making a call like this.Okay, so this is not going to compile.If we pass by const reference, things are going to be improved a little bit.The function is going to be set up like this.It’s going to be called function taking a const dog ref.It’s not going to return anything, but it’s going to take the parameter by const reference.Here we have a const.This is going to protect from modification from this reference here.So if we didn’t have anything in the body of the function, the code here could compile.But the problem is going to come if we try and do any modification here.For example, if we call set name here, we’re going to be prevented from doing this from this constreference because it is a const reference.We can’t go through it to modify our object that we are referencing.But the call to Printinfo here is also not going to work.And this is the exact same thing we saw in the last lecture.The compiler doesn’t really know that the Printinfo function isn’t modifying our object, but we knowthat.But the compiler doesn’t know that that’s the problem here and the compiler is going to throw a compilererror If we try to call the printinfo function from our reference here.So we are back to the same problem in the last lecture.Our dog object that we passed by reference here is really going to be useless in this function bodyhere.We can’t read from it, we can’t write to it.We can’t basically do anything with it.So passing by const reference isn’t really going to work for you either.Okay.Passing by reference isn’t really working for us.What about passing by Pointer?Well, I hate to disappoint you, but this is also not going to work.Here we are passing by Non-const pointer and this pointer could be used to modify the original thingwe are pointing to.So the compiler is going to prevent the call like this to even compile because we are passing an addressto a const object and the pointer parameter here could be used to modify that object.So we’re going to get a compiler error.If we try to compile this function call, this is not going to work either.Okay.So you might.Be saying, What if we pass our parameter by pointer to const and here we have an example doing that.The function is not returning anything and it’s taking its parameter by const dog pointer.So the compiler is going to allow the signature here to compile.But if we try to do any modification inside, we’re going to get a compiler error on our setter here.And this is expected because this is a pointer to const, so we can’t go through this pointer to modifythe object we are pointing to.But the call to Printinfo here is also not going to work because the compiler thanks plentiful herecould be used to modify the object we are pointing to, but that object happens to be cast, so we reallyare not allowed to modify that and the compiler is going to do everything it can to protect the consumersof this object here.So hopefully you can see that even in function calls, const objects can be problematic to work withbecause the compiler is not going to allow us to read or write through the object.And the object is basically going to be useless in our eyes.So now that you have an idea about this problems, we’re going to head over to Visual Studio code andplay with this a little more.Okay.Here we are in our working folder.The current project is Const Objects as the function parameters.We’re going to grab the code from the last lecture because we’re going to be using that as a startingpoint.We can grab the class header and CPP file and the main function.Let’s copy that and use that in our current project here.So we’re going to do that and we don’t want to forget the VS code folder, which is going to bring usthe settings we can use in our project.So let’s go back to our project here and make sure we have this dot vs code folder.And once we have it set up, we’re going to open it in Visual Studio code by dragging and dropping here.This is going to open our project.You see, we have the main function.We have our dog class which lives in the header and the CPP file here.Now that we have this, we can actually close the left pane because we don’t need it anymore and we’regoing to remove everything and leave our cast dog object here.The first thing we’re going to do is put in a function that takes the parameter by value.So function taking dog is taking the parameter by value here and inside you’re going to see that we’regoing to set the name to our dog object and we’re going to say print info in the function body here.Let’s use this function, let’s say function taking parameter by value.And notice that we are passing our const object as a parameter.We’re going to say function taking dog and passing dog one.So what do you think will happen?This is a const object and we are passing it by value.Notice that the parameter is not const, so because we are passing by value, what we will have in thebody is going to be a copy of this dog object that we passed here.So modifying it is not going to cause any problem because the changes we do in the body of the functionare not going to affect our original const object.So the constantness of the original thing is going to be preserved.If we try to compile this program in GCC, we’re going to see that it’s going to work.We’re not going to have any problem.And if we bring up a terminal to run this program and run Rooster, try to think about what we’re goingto get.We have a const object here and I actually think we should also print eval before we call the function,because this is going to be better.We’re going to say dog one and say principal and we’re going to be able to see that the memory addresses,oh, we can’t call the principal function because it could potentially be modifying our const object.This is really bad.So let’s not do that.We can run the program as is now, So we’re going to run Rooster and we’re going to see the memory addressinside to be ending in D50.We’re going to see that the name has been changed from the inside of the function and we’re going toprint the information after we apply the change to really prove that this is a copy.We could try and print the address ourselves from the outside of this function here so we could saystdcout address of object, and we’re going to put that out.We’re going to say address of dog one.And if we’re bold, we’re going to see that let’s world with GCC.Okay, so let’s clear and run Rooster.We’re going to see that the address on the outside ends in DE0 and the address on the inside ends inD50.So there are two different objects because they live at two different memory locations.And the main message here is if you pass a const dog object as a function parameter.To a function that takes its parameter by value.The code is going to compile and you are going to be allowed to do anything in the body of the functionbecause the function will be basically working on a copy.And the changes you do inside the function body are not going to affect the original object.So this is what I want you to see here.So this is going to work.Okay.So let’s comment this call out and we are going to go on top and put in a function that takes the parameterby reference.We’re going to put this in and let’s say reference properly.Reference.Okay.So this is a function we’re going to set up to do stuff with that and we will try to use it with ourconst object here.So let’s do that.It’s going to be called function taking the ref, let’s call it.We’re going to go down here and do that and we’re going to try and pass in our dog object here.The moment we do that, we’re going to get a squiggly line and this is going to say qualifiers droppedin binding reference of type dog reference to initializer of type const dog.So what this really means is if the compiler allowed this to compile, this is not a const reference,so this is a non const reference.So it could potentially be used to modify the parameter that we pass to it and the compiler is goingto prevent us from doing this because we don’t want to modify our const object here.That’s the reason.So this is not going to compile.We’re going to get a compiler error, so we’re going to build this and pass this through GCC to reallylet you see this.And we’re going to get the same error we have seen before.We’re going to try and bind the reference of dog reference type to cast dog.And this is not going to work.Again, from the context of this function, call our const dog object here is really not working.You can’t use it in this function here.Okay, so if we try and pass our parameter by const reference, so this function here is going to seemto work.Let’s go down and save that here.We’re going to copy the name of this function because I don’t want to type all this here.We’re going to put it in place and we’re going to pass in Dog one.And if we issue a call like this and we’re not doing anything in the body of the function, if we tryto compile, you’re going to see that code is going to compile fine because the parameter is const reference.So this const reference is really going to protect the constants of the object here because we can’tgo through it and modify the object.But if we uncomment what we have inside here, we’re going to get a compiler error which is expectedon the first line here.But because we can’t really go through this const reference to modify the object.But the problem is the second line here is also not going to compile because the compiler doesn’t reallyknow that the printinfo function here isn’t modifying our object.So it’s going to throw an error here.Let’s do that.We’re going to build this with GCC and show you these compiler errors.You’re going to see that we have a problem with our setname function, but we also have a problem withour Printf function because they all use the this pointer and the this pointer could be used to modifythe object.So the compiler is not going to allow us to use a function like this.And again, our const object is really useless in the body of this function.We can’t read from it, we can’t write data into it, we can’t really do anything with it.So it is useless in this context here.So this is the problem I want you to be aware of.Okay, so we have seen that references aren’t really going to work.What about pointers?Let’s pass a parameter which is a pointer to Non-const and we can set up a function like this, whichis going to take a dog pointer parameter.And if we go down and try to call this function, you probably know what is going to happen.The compiler is not going to allow us to even call with the address of our dog object here.The moment we do this, we’re going to get a squiggly line and Visual Studio code is going to say theerror here is not clear.Let’s pass this through the compiler and see the compiler error.And it is basically going to be the same thing we have seen before.It’s going to say invalid conversion from const dog pointer to dog pointer.So what we have in our function parameter here or as a function argument is a const dog pointer becauseit is pointing to a const object.But our function here is taking its parameter clearly as a non const and this pointer could potentiallymodify our object.So the compiler is not going to allow this call here to compile.We can’t use this.Okay, so this is not going to work.And if you try to pass your.By pointer to const.We’re also going to have problems.So let’s go down and put in our function here.It’s going to be called function taking pointer to const the dog and the parameter is going to be takenby pointer to const here.If we go down and call our function, let’s comment out what we have in the body.Show you that this is going to actually compile.So we’re going to call the function here and we don’t want the entire thing.We just want the name of the function.Sorry for this.So let’s take out the void thing here.We just want to call our function and we’re going to give it the address of our dog object.So we’re going to say dog one.If we try to compile this code and we’re not doing anything in the body, the code is going to compileand try to think about why.Why do we have a problem here?Well, finished with errors and which problem do we have here?We have a const dog reference and we are trying to go through it to modify stuff here.So this is going to give us a compiler error.This function here wouldn’t compile.This is the problem here and we’re going to build again.And now you see that we also have another compiler error.So what is the problem here?We have an expected unqualified ID for return and we’re going to see that we have the problem at lineLet’s go there.A curly brace here from the function that we had.That’s the problem here.So what we’re going to see is that this function call here is going to compile.Let’s do that.We’re going to pass this through.JK Now the bolt is good, but if we go into the function body and try to do anything, for example,we try to say to the name, This is not going to work because we can’t go through a pointer to constand modify the object we are pointing to.So this is not going to work.But our printf function is also not going to work because the compiler thinks we could go through thisfunction to modify our object through the this pointer because that’s going to be a pointer to the currentobject.And if we try to compile, we’re going to get a weird error, which is basically going to say that wecould go through the this pointer to modify our object.It’s going to say that this pointer could be used to modify our object in set name and it’s going tosay the same thing in the principal here.Plentiful.We have a problem because we’re not using pointer access notation.So let’s fix this a little bit, but we’re going to build again and we’re going to get the same error.Basically, we’re going to say that this pointer could be used to modify our object from the printingfunction.This is what the compiler is saying here.And you see we have the same problem in set name that this pointer could be used to modify our object.So what I really wanted you to see in this lecture is that you have to be careful If you want to useconst objects of your classes, the object is almost going to be useless because the compiler is goingto thank your getters have potential to modify the object and your setters have the potential to modifythe object and the compiler is going to really stop you from using these guys and your objects are reallygoing to be useless.This is really bad and we’re going to see how we can solve this problem starting in the next lecture.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，没问题！很高兴能帮助你学习 C++。我们会循序渐进，确保你理解每一个概念。</p>
<h1 id="C-教程：const-常量-对象作为函数参数"><a href="#C-教程：const-常量-对象作为函数参数" class="headerlink" title="C++ 教程：const (常量) 对象作为函数参数"></a>C++ 教程：<code>const</code> (常量) 对象作为函数参数</h1><p><strong>摘要：</strong> 本讲座将探讨将 <code>const</code> (常量) <code>object</code> (对象) 作为函数参数传递时的不同情况，包括<code>pass by value</code> (按值传递)、按 <code>reference</code> (引用) 传递（<code>const</code> 和非 <code>const</code>）以及按 <code>pointer</code> (指针) 传递（<code>const</code> 和非 <code>const</code>），并解释 <code>compiler</code> (编译器) 的行为和原因。我们将使用一个简单的 <code>Dog</code> <code>class</code> (类) 来进行演示。</p>
<hr>
<h2 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h2><p>当我们有一个被 <code>const</code> 修饰的对象时，意味着我们不希望这个对象的状态被修改。C++ 编译器会尽力保证这一点。现在，让我们看看当我们将这样一个 <code>const</code> 对象作为参数传递给函数时，会发生什么。</p>
<p>我们将基于以下简单的 <code>Dog</code> 类（假设它在之前的课程中已经定义）：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 Dog 类的定义如下 (为了本讲座的目的简化)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt; // 字符串视图</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">std</span>::string_view name, <span class="keyword">int</span> age) : m_name(name.data(), name.length()), m_age(age) &#123; <span class="comment">// 使用 string_view 初始化 string</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗 \""</span> &lt;&lt; m_name &lt;&lt; <span class="string">"\" 被创建了。\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数，方便观察是否发生拷贝</span></span><br><span class="line">    Dog(<span class="keyword">const</span> Dog&amp; other) : m_name(other.m_name), m_age(other.m_age) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗 \""</span> &lt;&lt; m_name &lt;&lt; <span class="string">"\" 被拷贝创建了。\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="built_in">std</span>::string_view name)</span> </span>&#123;</span><br><span class="line">        m_name = name.data(); <span class="comment">// 修改成员变量</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; (<span class="keyword">void</span>*)<span class="keyword">this</span> &lt;&lt; <span class="string">"] 狗狗的名字被设置为: "</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：这个成员函数目前不是 const 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗信息:名字="</span> &lt;&lt; m_name &lt;&lt; <span class="string">", 年龄="</span> &lt;&lt; m_age</span><br><span class="line">                  &lt;&lt; <span class="string">" (对象地址: "</span> &lt;&lt; (<span class="keyword">void</span>*)<span class="keyword">this</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>现在，让我们来分析不同的参数传递方式：</p>
<p><strong>2.1 按值传递 (Pass by Value)</strong></p>
<ul>
<li><strong>机制</strong>：当按值传递参数时，函数会接收到原始对象的一个 <code>copy</code> (拷贝)。函数内部对这个拷贝的任何修改都不会影响到原始对象。</li>
<li><p><strong>对于 <code>const</code> 对象</strong>：</p>
<ul>
<li>你可以将一个 <code>const</code> 对象按值传递给一个接受非 <code>const</code> 参数的函数。</li>
<li>因为函数操作的是对象的副本，所以原始 <code>const</code> 对象的常量性得到了保证，它本身不会被修改。</li>
<li>函数内部可以自由修改这个副本。</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_pass_by_value</span><span class="params">(Dog dog_param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"进入 function_pass_by_value...\n"</span>;</span><br><span class="line">    dog_param.set_name(<span class="string">"旺财 (副本)"</span>); <span class="comment">// 修改副本是允许的</span></span><br><span class="line">    dog_param.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"离开 function_pass_by_value...\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// const Dog dog1("小白", 2);</span></span><br><span class="line"><span class="comment">// function_pass_by_value(dog1); // 这是允许的</span></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，<code>dog1</code> 是 <code>const</code> 的。当它传递给 <code>function_pass_by_value</code> 时，会调用 <code>Dog</code> 类的拷贝构造函数创建一个新的 <code>Dog</code> 对象 <code>dog_param</code>。函数内部对 <code>dog_param</code> 的修改（例如调用 <code>set_name</code>）只影响这个副本，不影响 <code>dog1</code>。</p>
</li>
</ul>
<p><strong>2.2 按非 <code>const</code> 引用传递 (Pass by Non-const Reference)</strong></p>
<ul>
<li><strong>机制</strong>：引用是对象的别名。传递非 <code>const</code> 引用意味着函数可以通过这个引用修改原始对象。</li>
<li><p><strong>对于 <code>const</code> 对象</strong>：</p>
<ul>
<li><strong>编译器会禁止这种行为</strong>。你不能将一个 <code>const</code> 对象传递给一个接受非 <code>const</code> 引用的函数。</li>
<li>原因很直接：如果允许这样做，函数内部就可能通过这个非 <code>const</code> 引用修改 <code>const</code> 对象，这就违背了 <code>const</code> 的承诺。</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_pass_by_non_const_ref</span><span class="params">(Dog&amp; dog_ref_param)</span> </span>&#123; <span class="comment">//注意是 Dog&amp;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"进入 function_pass_by_non_const_ref...\n"</span>;</span><br><span class="line">    <span class="comment">// dog_ref_param.set_name("小黑 (通过引用)"); // 如果能调用，会修改原始对象</span></span><br><span class="line">    <span class="comment">// dog_ref_param.print_info();</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"离开 function_pass_by_non_const_ref...\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// const Dog dog1("小白", 2);</span></span><br><span class="line"><span class="comment">// function_pass_by_non_const_ref(dog1); // 编译器错误！</span></span><br></pre></td></tr></table></figure></div>
<p>编译器会报错，类似于：”binding ‘const Dog’ to reference of type ‘Dog&amp;’ discards qualifiers” (将 <code>const Dog</code> 类型的对象绑定到 <code>Dog&amp;</code> 类型的引用会丢弃 <code>const</code> 限定符)。</p>
</li>
</ul>
<p><strong>2.3 按 <code>const</code> 引用传递 (Pass by Const Reference)</strong></p>
<ul>
<li><strong>机制</strong>：<code>const</code> 引用也是对象的别名，但它承诺不会通过这个引用来修改对象。这使得它可以安全地引用 <code>const</code> 对象和非 <code>const</code> 对象。</li>
<li><p><strong>对于 <code>const</code> 对象</strong>：</p>
<ul>
<li><strong>这是允许的</strong>。将 <code>const</code> 对象传递给接受 <code>const</code> 引用的函数是安全的，因为函数保证不会修改它。</li>
<li><strong>但有一个陷阱</strong>：即使你通过 <code>const</code> 引用传递了对象，如果尝试调用该对象上的非 <code>const</code> <code>member function</code> (成员函数)，编译器仍然会报错。</li>
<li>这是因为非 <code>const</code> 成员函数理论上可以修改对象的状态（即使它实际上没有修改，比如我们的 <code>print_info</code>）。编译器只看函数的声明，如果一个成员函数没有被声明为 <code>const</code>，编译器就假设它会修改对象。</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_pass_by_const_ref</span><span class="params">(<span class="keyword">const</span> Dog&amp; dog_const_ref_param)</span> </span>&#123; <span class="comment">// 注意是 const Dog&amp;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"进入 function_pass_by_const_ref...\n"</span>;</span><br><span class="line">    <span class="comment">// dog_const_ref_param.set_name("小黄 (通过const引用)"); // 错误！不能通过 const 引用调用修改函数</span></span><br><span class="line">    <span class="comment">// dog_const_ref_param.print_info(); // 错误！因为 print_info() 不是 const 成员函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"离开 function_pass_by_const_ref...\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// const Dog dog1("小白", 2);</span></span><br><span class="line"><span class="comment">// function_pass_by_const_ref(dog1); // 调用本身是允许的</span></span><br></pre></td></tr></table></figure></div>
<p>调用 <code>set_name</code> 会失败，因为 <code>dog_const_ref_param</code> 是 <code>const</code> 引用，不能调用修改器。<br>调用 <code>print_info</code> 也会失败（在当前的 <code>Dog</code> 类定义下），因为 <code>print_info</code> 没有被声明为 <code>const</code> 成员函数。编译器不知道 <code>print_info</code> 是否安全，所以它会阻止这个调用。这是上一讲中提到的问题：<code>const</code> 对象变得“几乎无用”。</p>
</li>
</ul>
<p><strong>2.4 按非 <code>const</code> 指针传递 (Pass by Non-const Pointer)</strong></p>
<ul>
<li><strong>机制</strong>：指针存储对象的内存地址。通过非 <code>const</code> 指针，函数可以修改指针指向的对象。</li>
<li><p><strong>对于 <code>const</code> 对象</strong>：</p>
<ul>
<li><strong>编译器会禁止这种行为</strong>。你不能将一个 <code>const</code> 对象的地址传递给一个接受非 <code>const</code> 指针参数的函数（例如 <code>Dog*</code>）。</li>
<li>原因与非 <code>const</code> 引用类似：如果允许，函数内部就可以通过这个指针修改 <code>const</code> 对象。</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_pass_by_non_const_ptr</span><span class="params">(Dog* dog_ptr_param)</span> </span>&#123; <span class="comment">// 注意是 Dog*</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"进入 function_pass_by_non_const_ptr...\n"</span>;</span><br><span class="line">    <span class="comment">// if (dog_ptr_param) &#123;</span></span><br><span class="line">    <span class="comment">//     dog_ptr_param-&gt;set_name("小灰 (通过指针)");</span></span><br><span class="line">    <span class="comment">//     dog_ptr_param-&gt;print_info();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"离开 function_pass_by_non_const_ptr...\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// const Dog dog1("小白", 2);</span></span><br><span class="line"><span class="comment">// function_pass_by_non_const_ptr(&amp;dog1); // 编译器错误！</span></span><br></pre></td></tr></table></figure></div>
<p>编译器会报错，类似于：”invalid conversion from ‘const Dog<em>‘ to ‘Dog</em>‘“ (从 <code>const Dog*</code> 到 <code>Dog*</code> 的转换无效)。</p>
</li>
</ul>
<p><strong>2.5 按 <code>const</code> 指针传递 (Pass by Const Pointer / Pointer to Const)</strong></p>
<ul>
<li><strong>机制</strong>：这里指的是指向常量的指针 (<code>const Dog*</code> 或 <code>Dog const*</code>)。这意味着你不能通过这个指针来修改它所指向的对象。指针本身可以被修改以指向另一个对象（除非指针本身也是 <code>const</code>，如 <code>const Dog* const</code>）。</li>
<li><p><strong>对于 <code>const</code> 对象</strong>：</p>
<ul>
<li><strong>这是允许的</strong>。你可以将 <code>const</code> 对象的地址传递给一个接受指向常量的指针的函数。</li>
<li><strong>同样的陷阱</strong>：与 <code>const</code> 引用类似，即使你通过指向常量的指针传递了对象，如果尝试调用该对象上的非 <code>const</code> 成员函数，编译器仍然会报错。</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_pass_by_const_ptr</span><span class="params">(<span class="keyword">const</span> Dog* dog_const_ptr_param)</span> </span>&#123; <span class="comment">// 注意是 const Dog*</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"进入 function_pass_by_const_ptr...\n"</span>;</span><br><span class="line">    <span class="comment">// if (dog_const_ptr_param) &#123;</span></span><br><span class="line">    <span class="comment">//     dog_const_ptr_param-&gt;set_name("小紫 (通过const指针)"); // 错误！不能通过 const 指针调用修改函数</span></span><br><span class="line">    <span class="comment">//     dog_const_ptr_param-&gt;print_info(); // 错误！因为 print_info() 不是 const 成员函数</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"离开 function_pass_by_const_ptr...\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// const Dog dog1("小白", 2);</span></span><br><span class="line"><span class="comment">// function_pass_by_const_ptr(&amp;dog1); // 调用本身是允许的</span></span><br></pre></td></tr></table></figure></div>
<p>这里的行为和 <code>const</code> 引用非常相似。调用 <code>set_name</code> 会失败。调用 <code>print_info</code> 也会失败，因为它不是 <code>const</code> 成员函数。</p>
</li>
</ul>
<p><strong>总结一下关键点：</strong></p>
<ol>
<li><strong>按值传递</strong>：总是安全的，因为操作的是副本。<code>const</code> 对象的原始值不会改变。</li>
<li><strong>非 <code>const</code> 引用/指针</strong>：不能用于传递 <code>const</code> 对象，因为它们暗示了修改原始对象的可能性，这会破坏 <code>const</code> 对象的常量性。编译器会阻止你。</li>
<li><strong><code>const</code> 引用/指针</strong>：可以用于传递 <code>const</code> 对象。它们承诺不通过引用或指针修改对象。但是，这引出了一个重要问题：即使你有一个 <code>const</code> 引用或指向 <code>const</code> 对象的指针，你也只能调用该对象上被声明为 <code>const</code> 的成员函数。如果一个成员函数（比如我们的 <code>print_info</code>）没有被标记为 <code>const</code>，编译器就认为它可能会修改对象，因此不允许在 <code>const</code> 上下文中调用它。这使得 <code>const</code> 对象在很多情况下看起来“功能受限”或“无用”，除非类设计者正确地使用了 <code>const</code> 关键字来标记那些真正不会修改对象状态的成员函数。</li>
</ol>
<p>这个问题（如何让 <code>print_info</code> 这样的函数能在 <code>const</code> 对象上被调用）的解决方案，通常是在成员函数声明的末尾加上 <code>const</code> 关键字，我们会在后续的课程中详细探讨。</p>
<hr>
<h2 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h2><p>下面是一个完整的代码示例，演示了上述所有情况。为了能编译通过并观察行为，我会注释掉那些会导致编译错误的代码行，并建议你取消注释来亲自看看编译器的错误信息。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt; // C++17, for std::string_view</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Dog Class Definition ---</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">std</span>::string_view name, <span class="keyword">int</span> age) : m_name(name.data(), name.length()), m_age(age) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog \""</span> &lt;&lt; m_name &lt;&lt; <span class="string">"\" constructed. Address: "</span> &lt;&lt; (<span class="keyword">void</span>*)<span class="keyword">this</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy constructor</span></span><br><span class="line">    Dog(<span class="keyword">const</span> Dog&amp; other) : m_name(other.m_name), m_age(other.m_age) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog \""</span> &lt;&lt; m_name &lt;&lt; <span class="string">"\" COPIED. New address: "</span> &lt;&lt; (<span class="keyword">void</span>*)<span class="keyword">this</span> </span><br><span class="line">                  &lt;&lt; <span class="string">" from old address: "</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;other &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Dog() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog \""</span> &lt;&lt; m_name &lt;&lt; <span class="string">"\" destructed. Address: "</span> &lt;&lt; (<span class="keyword">void</span>*)<span class="keyword">this</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="built_in">std</span>::string_view name)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Attempting to set name for dog at "</span> &lt;&lt; (<span class="keyword">void</span>*)<span class="keyword">this</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        m_name = name.data();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog at "</span> &lt;&lt; (<span class="keyword">void</span>*)<span class="keyword">this</span> &lt;&lt; <span class="string">" name set to: "</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IMPORTANT: print_info is NOT a const member function yet</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="comment">/* no const here */</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog Info (object @ "</span> &lt;&lt; (<span class="keyword">void</span>*)<span class="keyword">this</span> &lt;&lt; <span class="string">"): Name="</span> &lt;&lt; m_name &lt;&lt; <span class="string">", Age="</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let's add a const version of a getter for demonstration later if needed</span></span><br><span class="line">    <span class="comment">// const std::string&amp; get_name() const &#123; return m_name; &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Function Definitions ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Pass by value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_pass_by_value</span><span class="params">(Dog dog_param)</span> </span>&#123; <span class="comment">// A copy is made</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- Inside function_pass_by_value ---\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address of dog_param (copy): "</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;dog_param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    dog_param.set_name(<span class="string">"ValueDog"</span>); <span class="comment">// Modifies the copy</span></span><br><span class="line">    dog_param.print_info();        <span class="comment">// Calls print_info on the copy</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Exiting function_pass_by_value ---\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Pass by non-const reference</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_pass_by_non_const_ref</span><span class="params">(Dog&amp; dog_ref_param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- Inside function_pass_by_non_const_ref ---\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address of object via dog_ref_param: "</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;dog_ref_param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    dog_ref_param.set_name(<span class="string">"NonConstRefDog"</span>);</span><br><span class="line">    dog_ref_param.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Exiting function_pass_by_non_const_ref ---\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Pass by const reference</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_pass_by_const_ref</span><span class="params">(<span class="keyword">const</span> Dog&amp; dog_const_ref_param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- Inside function_pass_by_const_ref ---\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address of object via dog_const_ref_param: "</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;dog_const_ref_param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// dog_const_ref_param.set_name("ConstRefDog"); // COMPILE ERROR: set_name is not const and modifies</span></span><br><span class="line">    <span class="comment">// dog_const_ref_param.print_info();         // COMPILE ERROR: print_info is not a const member function</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123; <span class="comment">// Placeholder to avoid unused parameter warning if lines above are commented</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cannot call non-const member functions like set_name or print_info (as it is currently defined) on a const reference.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Exiting function_pass_by_const_ref ---\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Pass by non-const pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_pass_by_non_const_ptr</span><span class="params">(Dog* dog_ptr_param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- Inside function_pass_by_non_const_ptr ---\n"</span>;</span><br><span class="line">    <span class="keyword">if</span> (dog_ptr_param) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address of object via dog_ptr_param: "</span> &lt;&lt; (<span class="keyword">void</span>*)dog_ptr_param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        dog_ptr_param-&gt;set_name(<span class="string">"NonConstPtrDog"</span>);</span><br><span class="line">        dog_ptr_param-&gt;print_info();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Exiting function_pass_by_non_const_ptr ---\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. Pass by const pointer (pointer to const)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_pass_by_const_ptr</span><span class="params">(<span class="keyword">const</span> Dog* dog_const_ptr_param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- Inside function_pass_by_const_ptr ---\n"</span>;</span><br><span class="line">    <span class="keyword">if</span> (dog_const_ptr_param) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address of object via dog_const_ptr_param: "</span> &lt;&lt; (<span class="keyword">void</span>*)dog_const_ptr_param &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// dog_const_ptr_param-&gt;set_name("ConstPtrDog"); // COMPILE ERROR: set_name is not const and modifies</span></span><br><span class="line">        <span class="comment">// dog_const_ptr_param-&gt;print_info();       // COMPILE ERROR: print_info is not a const member function</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="literal">true</span>) &#123; <span class="comment">// Placeholder</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cannot call non-const member functions like set_name or print_info (as it is currently defined) using a pointer-to-const.\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Exiting function_pass_by_const_ptr ---\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Dog <span class="title">const_dog</span><span class="params">(<span class="string">"Buddy (const)"</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address of const_dog in main: "</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;const_dog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// const_dog.set_name("Tom"); // COMPILE ERROR: cannot call set_name on a const object</span></span><br><span class="line">    <span class="comment">// const_dog.print_info();    // COMPILE ERROR: print_info is not a const member function, cannot be called on const_dog</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n======= Testing Pass by Value =======\n"</span>;</span><br><span class="line">    function_pass_by_value(const_dog); <span class="comment">// OK: A copy is made. const_dog is not affected.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After function_pass_by_value, const_dog is: "</span>;</span><br><span class="line">    <span class="comment">// const_dog.print_info(); // Still can't call directly for the same reason</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Dog <span class="title">non_const_dog</span><span class="params">(<span class="string">"Lucy (non-const)"</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address of non_const_dog in main: "</span> &lt;&lt; (<span class="keyword">void</span>*)&amp;non_const_dog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n======= Testing Pass by Non-const Reference =======\n"</span>;</span><br><span class="line">    <span class="comment">// function_pass_by_non_const_ref(const_dog); // COMPILE ERROR: cannot bind const Dog to Dog&amp;</span></span><br><span class="line">    function_pass_by_non_const_ref(non_const_dog); <span class="comment">// OK for non-const object</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After function_pass_by_non_const_ref, non_const_dog is: "</span>;</span><br><span class="line">    non_const_dog.print_info();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n======= Testing Pass by Const Reference =======\n"</span>;</span><br><span class="line">    function_pass_by_const_ref(const_dog);       <span class="comment">// OK: const Dog can be passed to const Dog&amp;</span></span><br><span class="line">                                                 <span class="comment">// (but inside the function, non-const methods cannot be called)</span></span><br><span class="line">    function_pass_by_const_ref(non_const_dog);   <span class="comment">// OK: non-const Dog can also be passed to const Dog&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n======= Testing Pass by Non-const Pointer =======\n"</span>;</span><br><span class="line">    <span class="comment">// function_pass_by_non_const_ptr(&amp;const_dog); // COMPILE ERROR: cannot convert const Dog* to Dog*</span></span><br><span class="line">    function_pass_by_non_const_ptr(&amp;non_const_dog); <span class="comment">// OK for non-const object</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After function_pass_by_non_const_ptr, non_const_dog is: "</span>;</span><br><span class="line">    non_const_dog.print_info();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n======= Testing Pass by Const Pointer =======\n"</span>;</span><br><span class="line">    function_pass_by_const_ptr(&amp;const_dog);     <span class="comment">// OK: const Dog* can be passed to const Dog*</span></span><br><span class="line">                                                <span class="comment">// (but inside the function, non-const methods cannot be called)</span></span><br><span class="line">    function_pass_by_const_ptr(&amp;non_const_dog); <span class="comment">// OK: Dog* can be converted to const Dog*</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nEnd of main.\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当你编译并运行（或尝试编译）以上代码时，请特别注意：</p>
<ol>
<li><code>const_dog.print_info()</code> 在 <code>main</code> 函数中直接调用也会失败，因为 <code>const_dog</code> 是 <code>const</code> 对象，而 <code>Dog::print_info()</code> 不是 <code>const</code> 成员函数。</li>
<li>在 <code>function_pass_by_const_ref</code> 和 <code>function_pass_by_const_ptr</code> 内部，对 <code>print_info()</code> 的调用（如果取消注释）也会失败，原因相同。</li>
</ol>
<hr>
<h2 id="4-QA-闪卡-QA-Flash-Cards"><a href="#4-QA-闪卡-QA-Flash-Cards" class="headerlink" title="4. QA 闪卡 (QA Flash Cards)"></a>4. QA 闪卡 (QA Flash Cards)</h2><ol>
<li><p><strong>Q:</strong> 将 <code>const</code> 对象按值传递给函数会发生什么？<br><strong>A:</strong> 会创建对象的副本。函数对副本的修改不影响原始 <code>const</code> 对象。编译通过。</p>
</li>
<li><p><strong>Q:</strong> 为什么不能将 <code>const</code> 对象传递给接受非 <code>const</code> 引用的函数？<br><strong>A:</strong> 因为非 <code>const</code> 引用意味着函数可能修改对象，这违反了原始对象的 <code>const</code> 属性。编译器会报错。</p>
</li>
<li><p><strong>Q:</strong> 将 <code>const</code> 对象传递给接受 <code>const</code> 引用的函数，为什么调用非 <code>const</code> 成员函数（如 <code>print_info</code>，如果它未标记为 <code>const</code>）仍可能失败？<br><strong>A:</strong> 因为编译器只看函数签名。如果一个成员函数没有被声明为 <code>const</code>，编译器就假设它可能会修改对象的状态，因此不允许在 <code>const</code> 上下文（如通过 <code>const</code> 引用）中调用它。</p>
</li>
<li><p><strong>Q:</strong> <code>const Dog* p</code> 和 <code>Dog* const p</code> 有什么区别？<br><strong>A:</strong></p>
<ul>
<li><code>const Dog* p</code> (或 <code>Dog const* p</code>)：<code>p</code> 是一个指向 <code>const Dog</code> 对象的指针。你不能通过 <code>p</code> 来修改 <code>Dog</code> 对象（例如 <code>p-&gt;set_name(...)</code> 会报错）。但 <code>p</code> 本身可以指向另一个 <code>Dog</code> 对象（<code>p = &amp;another_dog;</code> 是允许的，只要 <code>another_dog</code> 的类型兼容）。</li>
<li><code>Dog* const p</code>：<code>p</code> 是一个 <code>const</code> 指针，它指向一个 <code>Dog</code> 对象。这意味着 <code>p</code> 必须在初始化时指向一个地址，之后不能再指向其他地址（<code>p = &amp;another_dog;</code> 会报错）。但是，如果它指向的对象不是 <code>const</code> 的，你可以通过 <code>p</code> 修改该对象（例如 <code>p-&gt;set_name(...)</code> 是允许的）。</li>
</ul>
</li>
<li><p><strong>Q:</strong> <code>const</code> 对象在函数参数传递中显得“无用”的主要原因是什么？<br><strong>A:</strong> 如果类的成员函数（尤其是那些本意为只读的函数，如打印信息）没有被正确地声明为 <code>const</code> 成员函数，那么这些函数就不能在 <code>const</code> 对象上被调用，即使是通过 <code>const</code> 引用或 <code>const</code> 指针传递。</p>
</li>
</ol>
<hr>
<h2 id="5-常见误解或易犯错误"><a href="#5-常见误解或易犯错误" class="headerlink" title="5. 常见误解或易犯错误"></a>5. 常见误解或易犯错误</h2><ol>
<li><p><strong>混淆 <code>const T*</code> 和 <code>T* const</code></strong>：</p>
<ul>
<li><code>const T* ptr</code>：指向常量的指针 (pointer to const)。不能通过 <code>ptr</code> 修改 <code>T</code> 对象。<code>ptr</code> 本身可以改变，指向另一个 <code>T</code>。</li>
<li><code>T* const ptr</code>：常量指针 (const pointer)。<code>ptr</code> 初始化后不能改变，即不能指向另一个地址。但可以通过 <code>ptr</code> 修改它所指向的 <code>T</code> 对象（如果 <code>T</code> 本身不是 <code>const</code>）。</li>
<li><code>const T* const ptr</code>：指向常量的常量指针。<code>ptr</code> 不能改变，也不能通过 <code>ptr</code> 修改 <code>T</code> 对象。</li>
</ul>
</li>
<li><p><strong>认为非 <code>const</code> 成员函数只要实际上不修改数据，就可以在 <code>const</code> 对象上调用</strong>：这是错误的。编译器只检查成员函数的声明。如果函数没有 <code>const</code> 关键字修饰，编译器就认为它会修改对象，从而禁止在 <code>const</code> 对象或通过 <code>const</code> 引用/指针调用。</p>
</li>
<li><p><strong>忘记 <code>this</code> 指针的类型</strong>：在非 <code>const</code> 成员函数内部，<code>this</code> 指针的类型是 <code>T* const</code> (对于类 <code>T</code>)。在 <code>const</code> 成员函数内部，<code>this</code> 指针的类型是 <code>const T* const</code>。这就是为什么在 <code>const</code> 成员函数中不能修改成员变量（除非它们被声明为 <code>mutable</code>），也不能调用非 <code>const</code> 成员函数。</p>
</li>
<li><p><strong>对按值传递的误解</strong>：新手有时可能会担心按值传递 <code>const</code> 对象时，<code>const</code> 性质会丢失或导致问题。实际上，按值传递会创建一个副本，原始 <code>const</code> 对象完全不受影响，所以这是安全的。函数内部的副本是不是 <code>const</code> 取决于函数参数的声明。</p>
</li>
<li><p><strong>过度使用 <code>const_cast</code></strong>：虽然 <code>const_cast</code> 可以移除对象的 <code>const</code> 限定，但这通常是危险的，应避免使用。如果原始对象确实是 <code>const</code> 的，通过 <code>const_cast</code> 去掉 <code>const</code> 后再尝试修改它，会导致未定义行为。</p>
</li>
</ol>
<hr>
<h2 id="6-编码练习"><a href="#6-编码练习" class="headerlink" title="6. 编码练习"></a>6. 编码练习</h2><p>现在，这里有一个练习。下面的代码中，<code>main</code> 函数创建了一个 <code>const Dog</code> 对象，并尝试通过一个接受 <code>const Dog&amp;</code> 的函数来调用它的 <code>print_info()</code> 方法。目前，这会导致编译错误。</p>
<p><strong>你的任务是：</strong> 只修改 <code>Dog</code> 类的定义（特别是 <code>print_info</code> 函数的声明和定义），使得 <code>main</code> 函数中的 <code>use_const_dog_ref</code> 函数调用能够成功编译并正确打印狗狗的信息，<strong>不要</strong>修改 <code>main</code> 函数或 <code>use_const_dog_ref</code> 函数的任何代码，也<strong>不要</strong>移除 <code>dog1</code> 的 <code>const</code> 限定符。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Dog Class Definition ---</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 修改 Dog 类的 print_info 方法，使其可以在 const 对象上被调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">std</span>::string_view name, <span class="keyword">int</span> age) : m_name(name.data(), name.length()), m_age(age) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog \""</span> &lt;&lt; m_name &lt;&lt; <span class="string">"\" constructed.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数需要被修改</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> </span>&#123; <span class="comment">// &lt;- 思考这里需要加什么</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog Info: Name="</span> &lt;&lt; m_name &lt;&lt; <span class="string">", Age="</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="built_in">std</span>::string_view name)</span> </span>&#123;</span><br><span class="line">        m_name = name.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 不要修改这个函数 ---</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_const_dog_ref</span><span class="params">(<span class="keyword">const</span> Dog&amp; a_dog)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside use_const_dog_ref:\n"</span>;</span><br><span class="line">    a_dog.print_info(); <span class="comment">// &lt;- 这里应该能够成功调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 不要修改 main 函数 ---</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Dog <span class="title">dog1</span><span class="params">(<span class="string">"Max (const)"</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们希望下面的调用能够工作</span></span><br><span class="line">    use_const_dog_ref(dog1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了对比，一个非 const 对象</span></span><br><span class="line">    <span class="function">Dog <span class="title">dog2</span><span class="params">(<span class="string">"Bella (non-const)"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="comment">// dog2.print_info(); // 这个本来就能工作，但不是练习的重点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请你思考一下，<code>print_info</code> 函数应该如何修改才能在 <code>const Dog&amp; a_dog</code> 上被调用。完成后，将你修改后的 <code>Dog</code> 类定义回复给我。</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>回答之前我问一下， 如果按值传递， 那么如果原来的const 对象里如果包含const 函数， 那么传递后的Local对象那个函数还是Const函数么？</p>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常好的问题！它触及了 <code>const</code> 正确性的核心概念，以及类成员函数的特性。</p>
<p>在你尝试练习之前，我先来解答你的疑问：</p>
<p><strong>问题：</strong> 如果按值传递，那么如果原来的 <code>const</code> 对象里如果包含 <code>const</code> 成员函数 (const member function)，那么传递后的 <code>local object</code> (局部对象) 的那个成员函数还是 <code>const</code> 成员函数么？</p>
<p><strong>回答：</strong></p>
<p>是的，那个成员函数<strong>依然是</strong>一个 <code>const</code> 成员函数。</p>
<p>让我详细解释一下：</p>
<ol>
<li><p><strong>成员函数的 <code>const</code> 属性是类定义的一部分</strong>：<br>当你在类中声明一个成员函数时，比如 <code>void print_info() const;</code>，这个 <code>const</code> 关键字意味着该函数承诺不会修改调用它的对象的任何成员变量（除非这些成员变量被声明为 <code>mutable</code>）。这个 <code>const</code> 属性是函数签名 (function signature) 的一部分，是这个函数在 <code>Dog</code> 类中的固有特性。它不会因为对象是如何创建的（是原始对象还是副本）或对象本身是否为 <code>const</code> 而改变其“<code>const</code> 成员函数”的身份。</p>
</li>
<li><p><strong>按值传递创建副本</strong>：<br>当你将一个对象（无论是 <code>const</code> 还是非 <code>const</code>）按值传递给一个函数时，函数内部会得到这个对象的一个副本。</p>
</li>
<li><p><strong>副本的 <code>const</code> 状态取决于函数参数的声明</strong>：</p>
<ul>
<li>如果函数参数是 <code>void my_func(Dog local_dog)</code>，那么 <code>local_dog</code> 这个副本是<strong>非 <code>const</code></strong> 的。</li>
<li>如果函数参数是 <code>void my_func(const Dog local_dog)</code>（虽然按值传递 <code>const</code> 副本不常见，但语法上是允许的），那么 <code>local_dog</code> 这个副本是 <strong><code>const</code></strong> 的。</li>
</ul>
</li>
<li><p><strong>在副本上调用成员函数</strong>：</p>
<ul>
<li><strong>成员函数本身的定义不变</strong>：<code>Dog</code> 类中定义的 <code>print_info() const</code> 始终是一个 <code>const</code> 成员函数。<code>Dog</code> 类中定义的 <code>set_name()</code> (假设它不是 <code>const</code> 成员函数) 始终是一个非 <code>const</code> 成员函数。</li>
<li><strong>可调用性取决于副本的 <code>const</code> 状态</strong>：<ul>
<li>如果局部副本 <code>local_dog</code> 是<strong>非 <code>const</code></strong> (例如参数是 <code>Dog local_dog</code>)：<ul>
<li>你可以调用 <code>local_dog.print_info()</code>，因为 <code>const</code> 成员函数可以被非 <code>const</code> 对象调用。</li>
<li>你也可以调用 <code>local_dog.set_name(&quot;NewName&quot;)</code>，因为非 <code>const</code> 成员函数可以被非 <code>const</code> 对象调用。</li>
</ul>
</li>
<li>如果局部副本 <code>local_dog</code> 是 <strong><code>const</code></strong> (例如参数是 <code>const Dog local_dog</code>)：<ul>
<li>你可以调用 <code>local_dog.print_info()</code>，因为 <code>const</code> 成员函数可以被 <code>const</code> 对象调用。</li>
<li>你<strong>不能</strong>调用 <code>local_dog.set_name(&quot;NewName&quot;)</code>，因为非 <code>const</code> 成员函数不能被 <code>const</code> 对象调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结一下你的问题：</strong><br>原始的 <code>const</code> 对象拥有一些成员函数，其中一些被定义为 <code>const</code> 成员函数。当你按值传递这个 <code>const</code> 对象时，会创建一个副本。<br>对于这个副本：</p>
<ul>
<li>那些在类定义中被声明为 <code>const</code> 的成员函数（例如 <code>print_info() const</code>）对于这个副本来说<strong>仍然是 <code>const</code> 成员函数</strong>。它们的“身份”没有变。</li>
<li>关键在于这个副本对象本身是 <code>const</code> 还是非 <code>const</code>。如果函数参数是 <code>Dog d</code>，那么副本 <code>d</code> 是非 <code>const</code> 的，你可以对它调用 <code>const</code> 成员函数，也可以调用非 <code>const</code> 成员函数。</li>
</ul>
<p>所以，一个函数是不是 <code>const</code> 成员函数，是由它在类中的声明决定的，而不是由它被调用的对象实例是否为 <code>const</code> 或是否为副本决定的。对象实例的 <code>const</code> 状态决定了你<em>能够</em>在该实例上调用哪些类型的成员函数。</p>
<p>希望这个解释清楚了你的疑问！现在你可以更有信心地尝试那个练习了。</p>
<hr>
<p>现在，回到我们的练习。</p>
<p><strong>7. 评价你的解答并给出正确答案和解释</strong></p>
<p>请你提供你对 <code>Dog</code> 类的修改方案，特别是 <code>print_info</code> 函数。我会根据你的方案给出评价。</p>
<p>如果你还没有完成，这里是提示：为了让 <code>print_info()</code> 可以在一个 <code>const Dog&amp;</code> (常量狗的引用) 上被调用，你需要向编译器保证 <code>print_info()</code> 函数不会修改 <code>Dog</code> 对象的任何成员变量。</p>
<p>等你准备好后，请分享你的代码。</p>
<hr>
<h2 id="🧑‍💻-User-2"><a href="#🧑‍💻-User-2" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></string></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <string_view></string_view></h1><p>// —- Dog Class Definition —-<br>// TODO: 修改 Dog 类的 print_info 方法，使其可以在 const 对象上被调用<br>class Dog {<br>private:<br>    std::string m_name;<br>    int m_age;</p>
<p>public:<br>    Dog(std::string_view name, int age) : m_name(name.data(), name.length()), m_age(age) {<br>        std::cout &lt;&lt; “Dog \”” &lt;&lt; m_name &lt;&lt; “\” constructed.\n”;<br>    }</p>
<pre><code>// 这个函数需要被修改
void print_info() const{ // &lt;- 思考这里需要加什么
    std::cout &lt;&lt; &quot;Dog Info: Name=&quot; &lt;&lt; m_name &lt;&lt; &quot;, Age=&quot; &lt;&lt; m_age &lt;&lt; std::endl;
}

void set_name(std::string_view name) {
    m_name = name.data();
}
</code></pre><p>};</p>
<p>// —- 不要修改这个函数 —-<br>void use_const_dog_ref(const Dog&amp; a_dog) {<br>    std::cout &lt;&lt; “Inside use_const_dog_ref:\n”;<br>    a_dog.print_info(); // &lt;- 这里应该能够成功调用<br>}</p>
<p>// —- 不要修改 main 函数 —-<br>int main() {<br>    const Dog dog1(“Max (const)”, 5);</p>
<pre><code>// 我们希望下面的调用能够工作
use_const_dog_ref(dog1);

// 为了对比，一个非 const 对象
Dog dog2(&quot;Bella (non-const)&quot;, 2);
// dog2.print_info(); // 这个本来就能工作，但不是练习的重点

return 0;
</code></pre><p>}</p>
<hr>
<h2 id="🤖-Assistant-2"><a href="#🤖-Assistant-2" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>太棒了！你的修改完全正确！</p>
<h2 id="7-评价你的解答并给出正确答案和解释"><a href="#7-评价你的解答并给出正确答案和解释" class="headerlink" title="7. 评价你的解答并给出正确答案和解释"></a>7. 评价你的解答并给出正确答案和解释</h2><p><strong>你的解答评价：</strong></p>
<ul>
<li><strong>得分：10/10</strong></li>
<li><strong>评价：</strong> 你准确地找到了问题的关键，并在 <code>print_info</code> 函数的声明和定义末尾添加了 <code>const</code> 关键字。这正是解决这个问题的正确方法。做得非常好！</li>
</ul>
<p><strong>正确答案和解释：</strong></p>
<p>你的代码修改如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Dog Class Definition ---</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">std</span>::string_view name, <span class="keyword">int</span> age) : m_name(name.data(), name.length()), m_age(age) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog \""</span> &lt;&lt; m_name &lt;&lt; <span class="string">"\" constructed.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的修改：在函数声明末尾添加 const</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// &lt;--- 在这里添加了 const</span></span><br><span class="line">        <span class="comment">// 在 const 成员函数内部，成员变量 m_name 和 m_age 被视为 const</span></span><br><span class="line">        <span class="comment">// 因此，你不能在这里做类似 m_age++; 的操作（除非 m_age 是 mutable）</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog Info: Name="</span> &lt;&lt; m_name &lt;&lt; <span class="string">", Age="</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="built_in">std</span>::string_view name)</span> </span>&#123;</span><br><span class="line">        m_name = name.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 不要修改这个函数 ---</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_const_dog_ref</span><span class="params">(<span class="keyword">const</span> Dog&amp; a_dog)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside use_const_dog_ref:\n"</span>;</span><br><span class="line">    a_dog.print_info(); <span class="comment">// &lt;- 现在这里可以成功调用了！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 不要修改 main 函数 ---</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Dog <span class="title">dog1</span><span class="params">(<span class="string">"Max (const)"</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们希望下面的调用能够工作</span></span><br><span class="line">    use_const_dog_ref(dog1); <span class="comment">// 编译通过，运行正常</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Dog <span class="title">dog2</span><span class="params">(<span class="string">"Bella (non-const)"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    dog2.print_info(); <span class="comment">// 非 const 对象也可以调用 const 成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>为什么这样修改有效？</strong></p>
<ol>
<li><p><strong><code>const</code> 成员函数 (Const Member Function)：</strong><br>当你在一个成员函数的声明和定义后面加上 <code>const</code> 关键字时，你是在告诉编译器这个函数是一个“<code>const</code> 成员函数”。</p>
</li>
<li><p><strong>对 <code>this</code> 指针的影响：</strong></p>
<ul>
<li>在<strong>非 <code>const</code></strong> 成员函数内部，<code>this</code> 指针的类型是 <code>Dog* const</code> (一个指向 <code>Dog</code> 类型的常量指针，指针本身不能被修改指向其他对象，但指向的对象可以被修改)。</li>
<li>在<strong><code>const</code></strong> 成员函数内部，<code>this</code> 指针的类型变为 <code>const Dog* const</code> (一个指向 <code>const Dog</code> 类型的常量指针，指针本身不能被修改，并且它指向的对象也被视为 <code>const</code>，因此不能通过 <code>this</code> 修改对象的成员变量)。</li>
</ul>
</li>
<li><p><strong><code>const</code> 对象的兼容性：</strong></p>
<ul>
<li>当你有一个 <code>const Dog dog1;</code> 或者 <code>const Dog&amp; a_dog;</code> 时，你只能调用那些不会修改对象状态的成员函数。</li>
<li>编译器通过检查成员函数是否被声明为 <code>const</code> 来判断这一点。如果一个成员函数被声明为 <code>const</code>，编译器就认为调用它是安全的，因为它承诺不会改变对象的状态。</li>
<li>如果 <code>print_info()</code> 没有 <code>const</code> 修饰，编译器会认为它可能会修改对象（因为 <code>this</code> 是 <code>Dog*</code> 类型），因此不允许在 <code>const Dog</code> 对象上调用它。</li>
<li>通过将 <code>print_info()</code> 声明为 <code>void print_info() const</code>，你明确告诉编译器：“这个函数不会修改对象的任何成员（除非它们是 <code>mutable</code> 的）。”因此，编译器允许在 <code>const Dog</code> 对象（如 <code>dog1</code>）或通过 <code>const Dog&amp;</code> (常量引用)（如 <code>a_dog</code>）调用 <code>print_info() const</code>。</li>
</ul>
</li>
<li><p><strong>非 <code>const</code> 对象也可以调用 <code>const</code> 成员函数：</strong><br>值得注意的是，非 <code>const</code> 对象（如 <code>dog2</code>）也可以调用 <code>const</code> 成员函数。这是完全安全的，因为 <code>const</code> 成员函数只是承诺不修改对象，这对非 <code>const</code> 对象来说也是一个有效的操作。</p>
</li>
</ol>
<p>通过这个修改，<code>Dog</code> 类变得更加 <code>const</code> 正确 (<code>const-correct</code>)，使得 <code>const</code> 对象也能发挥其应有的“只读”作用，而不是变得“无用”。</p>
<hr>
<h2 id="8-扩展问题与调查建议"><a href="#8-扩展问题与调查建议" class="headerlink" title="8. 扩展问题与调查建议"></a>8. 扩展问题与调查建议</h2><p>现在你已经掌握了 <code>const</code> 对象和 <code>const</code> 成员函数的基础，这里有一些可以进一步探索和思考的方向：</p>
<ol>
<li><p><strong><code>mutable</code> 关键字：</strong></p>
<ul>
<li>了解 <code>mutable</code> (可变的) 关键字的用途。在某些情况下，即使在一个 <code>const</code> 成员函数中，你可能也需要修改某个特定的成员变量（例如，用于缓存计算结果或调试的计数器，这些修改不影响对象的外部可见状态）。<code>mutable</code> 关键字允许你在 <code>const</code> 成员函数中修改被它修饰的成员变量。</li>
<li><strong>思考：</strong> 什么时候使用 <code>mutable</code> 是合适的？什么时候应该避免？</li>
</ul>
</li>
<li><p><strong><code>const</code> 重载 (Const Overloading)：</strong></p>
<ul>
<li>一个类可以拥有两个同名成员函数，它们仅在 <code>const</code> 限定符上有所不同。例如：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ResourceType&amp; <span class="title">get_resource</span><span class="params">()</span></span>;       <span class="comment">// 非 const 版本</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> ResourceType&amp; <span class="title">get_resource</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// const 版本</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li>当对象是 <code>const</code> 时，会调用 <code>const</code> 版本；当对象是非 <code>const</code> 时，会调用非 <code>const</code> 版本。</li>
<li><strong>思考：</strong> 这种重载在什么场景下有用？它如何帮助我们编写更灵活和安全的代码？（提示：考虑返回引用的情况）</li>
</ul>
</li>
<li><p><strong>逻辑 <code>const</code> vs 位 <code>const</code> (Logical Constness vs. Bitwise Constness)：</strong></p>
<ul>
<li><strong>位 <code>const</code> (Bitwise constness)</strong>：指成员函数不修改对象的任何一个字节（除了 <code>mutable</code> 成员）。这是编译器通常强制执行的。</li>
<li><strong>逻辑 <code>const</code> (Logical constness)</strong>：指成员函数不修改对象的“抽象状态”或“外部可见状态”，即使它可能修改了某些内部的、非关键的字节（例如，通过 <code>mutable</code> 成员或通过指针修改了其他非对象自身拥有的数据）。</li>
<li><strong>思考：</strong> <code>const</code> 成员函数保证的是哪一种 <code>const</code>？<code>mutable</code> 在这里扮演什么角色？</li>
</ul>
</li>
<li><p><strong><code>const</code> 在迭代器 (iterators) 中的应用：</strong></p>
<ul>
<li>STL (标准模板库) 容器提供了不同类型的迭代器，例如 <code>iterator</code> 和 <code>const_iterator</code>。</li>
<li><strong>调查：</strong> <code>const_iterator</code> 有什么特点？它与 <code>const</code> 成员函数和 <code>const</code> 对象有什么关系？为什么需要 <code>const_iterator</code>？</li>
</ul>
</li>
<li><p><strong>在你的项目中贯彻 <code>const</code> 正确性：</strong></p>
<ul>
<li>尝试回顾你之前写的或看到的 C++ 代码，思考哪些地方可以应用 <code>const</code> 来提高代码的健壮性和可读性。养成在合适的地方使用 <code>const</code> 的习惯，包括：<ul>
<li>将不会被修改的变量声明为 <code>const</code>。</li>
<li>将不会修改所引用或所指向数据的指针/引用参数声明为 <code>const T*</code> 或 <code>const T&amp;</code>。</li>
<li>将不会修改对象状态的成员函数声明为 <code>const</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>通过探索这些问题，你将对 C++ 中的 <code>const</code> 有更深入和全面的理解。继续努力，你做得很好！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Function/">Function    </a><a class="post-meta__tags" href="/tags/Object/">Object    </a><a class="post-meta__tags" href="/tags/Parameter/">Parameter    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/286%20-%20const%20%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>286 - const 对象问题与指针引用访问</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/297%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>297 - 构造函数初始化列表</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/return type for lambda function template/" title="return type for lambda function template"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">return type for lambda function template</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/258 - Non type template parameters/" title="258 - Non type template parameters"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">258 - Non type template parameters</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/259 - Auto Function Templates/" title="259 - Auto Function Templates"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">259 - Auto Function Templates</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/265 - using concept/" title="265 - using concept"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">265 - using concept</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/268 - Combining concepts/" title="268 - Combining concepts"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">268 - Combining concepts</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/283 - cpp 类对象大小探究/" title="283 - cpp 类对象大小探究"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">283 - cpp 类对象大小探究</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>