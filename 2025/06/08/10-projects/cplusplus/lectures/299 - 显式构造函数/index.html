<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>299 - 显式构造函数 | Bear's dream</title><meta name="description" content="299 - 显式构造函数"><meta name="keywords" content="Coding,Cpp,Function,Class,Programming"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="299 - 显式构造函数"><meta name="twitter:description" content="299 - 显式构造函数"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="299 - 显式构造函数"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/299%20-%20%E6%98%BE%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="299 - 显式构造函数"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/299%20-%20%E6%98%BE%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"><link rel="prev" title="297 - 构造函数初始化列表" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/297%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"><link rel="next" title="296 - 构造函数默认参数" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/296%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#显式构造函数"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">显式构造函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#1-标题与简介"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">1. 标题与简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2-详细解释"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">2. 详细解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#5-常见误解或易犯错误"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">5. 常见误解或易犯错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#6-编码练习"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">6. 编码练习</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#显式构造函数"><span class="toc-number">1.</span> <span class="toc-text">显式构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-标题与简介"><span class="toc-number">2.</span> <span class="toc-text">1. 标题与简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-详细解释"><span class="toc-number">3.</span> <span class="toc-text">2. 详细解释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-代码示例"><span class="toc-number">4.</span> <span class="toc-text">3. 代码示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc-number">5.</span> <span class="toc-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-常见误解或易犯错误"><span class="toc-number">6.</span> <span class="toc-text">5. 常见误解或易犯错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-编码练习"><span class="toc-number">7.</span> <span class="toc-text">6. 编码练习</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">299 - 显式构造函数</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/299%20-%20%E6%98%BE%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/299%20-%20%E6%98%BE%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="显式构造函数"><a href="#显式构造函数" class="headerlink" title="显式构造函数"></a>显式构造函数</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about explicit constructors.And to really drive the point home, we’re going to look at a simple example.Here is a class which is called Square.It is going to be modeling a square.So we’re going to use a member variable, which is going to represent the size of our square, and wecan use this.Then we’re going to have a function which is going to compute the surface of this square here, andit is going to be a cast member function.This function is really simple and there is really nothing more one can say about this.Let’s look at how we can implement the functions we have and we could implement our constructor usinginitializer list like this.So we’re going to take the side member variable and we’re going to initialize this with our side param.Then we’re going to compute the surface.The surface is going to basically be side multiplied by side and then we’re going to return this.And whoever called this surface function on our class object is going to be able to use the return valuehere.The destructor is going to be empty.It’s basically going to do nothing.It’s just going to be in there.So this is how we could set up our square class.Okay, so suppose we have our square class like we have seen, and we set up a function which is goingto compare two squares.So we have the compare function here and it’s going to take two square parameters by const referencebecause we don’t want to be copying squares here and we just want to use the original values and readfrom them and do some computation in the body.Here in the body you see that we are comparing the surfaces for the squares.So we are basically saying if the surface of square one is greater, then we’re going to consider thatas the greater square.And then if the surface of square two is greater, we’re going to consider that as the greater square.So what’s the function here will be doing is checking if square one is greater than square two.So what we have in the first position here is going to be compared to what we have in position two hereand in the body.What we’re going to say is ask if the surface of square one is greater than the surface of square twohere.If that’s true, we’re going to return true.If it’s not true, we’re going to return false.This is what the function here is doing.So once we have the function here, we can call it in the main function.We’re going to have two squares, square one and square two, and we can compare them like we do here.But the problem is going to come if we use arguments that may involve implicit conversions.And look at the example we have here.We are basically comparing square one with 45.5, which is a double literal here.When we issue a call like this, the compiler is going to say that the second parameter to this functionis really a square and it’s going to ask itself, Can I do an implicit conversion from this argumentI have here to a square?And the fact is it can because our constructor is only taking one parameter.So what the compiler is going to do is convert this guy into a square object and then it is going tocompare these two square objects.And if these implicit conversions are what you want, this is going to be fine.But sometimes the color of this function will really want to compare a square to a number.So they want to take the square one and compare that to 44.5, if this makes sense for whatever youare doing in your application.And in that case, implicit conversions are not going to be what you want and you’re going to get wrongresults.If you don’t want these implicit conversions, it is possible to mark your constructor as explicit,and what this tells the compiler is to never use this constructor in implicit conversions.So if we have this constructor here and this explicit and we try to issue a call like this, we’re goingto get a compiler error because the constructor for our square object can never be used in implicitconversions.And what we are doing here is really going to set up implicit conversions so you can use explicit constructorsif you don’t want your constructor to be involved in implicit conversions that are done by the compiler.Okay.I really hope you understand this.So we may also fall in the same case if we have a constructor which doesn’t take only one parameters,but we have a single parameter which is not using a default parameter.Let’s show you what I mean here.Here we have our side parameter, but we have a second parameter which is specified by default.So if we have this set up and we have the same call we have in the main function with the second parameterset up as 44.5 the.Compiler is going to see that it can still use this constructor to do implicit conversions from a numberto this square object here.And it’s going to also use this constructor.So if we don’t want implicit conversions, we can also mark this constructor as an explicit constructorand it is going to be prevented from being used in implicit conversions.This can be confusing, and if you still don’t really understand this, please bear with me.We’re going to head over to Visual Studio code and play with this a little more.Okay.Here we are in our working folder.The current project is explicit constructors.We’re going to use our template files here, so let’s grab them and we’re going to paste them in placeand we’re going to open this little guy in Visual Studio code by dragging and dropping here.This is going to open our folder.We’re going to have our main function and we need to create our square class because we want to playwith it in here.So what we’re going to do is create the header file and the CPP file for that.Let’s do square dot h for the header and we’re going to add a new file for square dot CPP.This is done and we are going to head in our header file and put in our class.So we don’t want to type this.I am just going to put it in here.Then we’re going to explain it a little bit.We have our include guards and then we have our class which is declared and defined Here.We have two sections in the class.We have a public section and we have a private section.And our private section we have our member variable which is declared to be inside.It’s type is double.And in the public section, we’re going to have a constructor which is going to take one parameter.We have a destructor which is going to destroy our object and we have a function which is going to computeour surface here.Nothing special here so far.We are going to head in square dot CPP and put in the implementation for our class so we have the implementationfor the constructor.It is going to be using initializer list.You see the syntax here we have our colon, we have our member variable and we are using curly bracesto do that.So you can use curly braces with your initializer list.This is going to work down here.You see we have the surface function.It is a cast member function.We need to specify that here and it is basically going to return M side multiplied by M side becausethat’s going to be the surface and the destructor is really not doing anything.So it is going to be empty here, but we’re going to leave this in.Okay.So now that we have this little guy here, let’s head over to the main function and play with it.So we’re going to close the left sidebar here because we don’t need it anymore.We’re going to take out whatever we don’t need in the main CPP file.We’re going to include our square class.We can do that and then we’re going to put in the function, which is going to compare two squares.We have the function called compare.It’s going to compare square one and square two.The parameters are passed by const reference because we don’t want to copy our square objects.We just want to read the data from them, compare them and return the result.So we’re going to ask, is the surface of square one greater than the surface of square two?That’s what this function here is doing.If square one is greater than two in terms of surface, we’re going to return.True.If square one is not greater, we’re going to return false.That’s what we are doing here.So we can set up two square objects and try this function here.We’re going to say square and we’re going to call this s one.We’re going to put in a 10.0 and we’re going to do a second one.This one is going to be S two and we’re going to put in a 20.0.You already know which one is greater.So we’re going to try and use our function here and see that it is actually working.We’re going to say S one greater than S two and we’re going to do that using the call here.Compare s one to S two.We’re going to be passing this by reference, by the way, and we want the output to be in the formof true and false.So we’re going to put our bool alpha manipulator here.So we’re going to say Stdcout, STD Bull Alpha, and we’re going to build and run this program.We expect to see a false because the surface of square one is really not going to be greater than thesurface of square two here.So we’re going to see a false printed out here.Let’s world we’re going to bring up a terminal and then we’re going to use the task to build with GCC.This is going to build define we can clear and run rooster and we’re going to see that square one isnot greater than square two.This is what we expect.We can change the side of square one to be 100 and build again.And we see that our function is doing what we want.We’re going to clear the build is good, by the way.We can clear and run Rooster.Now we’re.To see that square one is greater than square two because its surface is definitely going to be greaterthan that of square two.Here, this is working, but we may have problems if we set up a call that involves implicit conversions.So let’s do a call in which we want to compare square one to a double literal.We can do that.So we’re going to put our stdcout statement here and we want to see if square one is greater than 45.9.For example, we can do this.So we’re going to put 45.9 here and notice that we don’t have a squiggly line or any problem.And if we go back to our compare function, you see that we don’t have any overload.That takes the second parameter as a double.So the compiler is going to look at the call here and it’s going to say, Let me see if I can use asecond parameter as a double here.And it’s going to say, Oh, I cannot do that because the second parameter is a square object.The compiler isn’t going to give up easily.So it’s going to say, I can’t use a double argument for the second parameter here directly, but it’sgoing to ask is it possible that I can convert from this double to a square object?And it’s going to look at the constructors we have in here?It’s going to say, Huh, I have one constructor which is going to take a double parameter.I can use this and convert from this double argument I have here to a square object and the compileris going to do that and create a temporary somewhere, which is going to be a square object and it isgoing to pass that square object in this function here and do the comparison and then it’s going tothrow the temporary away and it’s going to give you the result.So what we will be doing here is really comparing two squares, one square, whose side is 100 and anotherwhose side is 45.9.And this can really be hard to see because what you see here is a number.And you might think that the compiler is really comparing square one to a number, but it is going tobe comparing two squares because it inserted an implicit conversion from this double here to a square.If this is what you want, we’re going to see that this is going to compare two squares and we’re goingto see our output in a minute.So let’s do that.We’re going to build this with GCC so that you see that this is going to build without a problem.The world is good and we can see our output here.We’re going to run Rooster and we’re going to see that square one is actually greater than 45.9 becausesquare one has a side which is 100, and the square two is going to be having a side of 45.9 here.But we have an implicit conversion and sometimes this is not what we want.So if we don’t want these implicit conversions, we can mark our constructor as explicit.And what this tells the compiler is don’t use my constructor here in implicit conversions.If somebody wants to use my constructor here, they have to call it explicitly like they have createdan object here and then use that object to call the compare function.So we can do that using the explicit keyword like we see here.So if we mark this constructor as explicit, we’re going to see that at this line.Now we’re going to have a squiggly line because the compiler is not allowed to insert an implicit conversionfrom double to our square object using our constructor here.So if we use this now, we’re going to get a compiler error.You see, Visual Studio code already has a problem.If we look at the problems tab here, we’re going to see no suitable constructor exists to convert fromdouble to square.And this is a hint that the compiler is actually trying to convert from double to square and we havedisallowed that or prevented that through the explicit keyword here.And this is really cool.So we can build with GCC and see the compiler error.We’re going to see that the compiler error is going to say invalid initialization of reference constsquare.The second parameter couldn’t be initialized properly.So the second thing here is not going to work and it’s going to basically say, I can’t really figureout how to use a double argument and compare that as we are doing in the compare function here.So you’re going to get a compiler error and this is good if you don’t want your constructor involvedin implicit conversions, We may also face the same problem if we are using default arguments.And I am going to show you that here we’re going to include the string object, the string class, Ishould say, and we’re going to set up a second member variable in our class, which is going to beof string type, and we’re going to say color.This is going to be the color of our square.We might model our square like this and give it a color, and we’re going to specify a second parameterto the constructor, which is going to initialize our member variable with the default parameter.So if we do something like this, we might say const STD string reference, and then we’re going tosay color param, we can save that and we’re going to set this to black.For example, let’s say our square is going to be black by default and we need to specify the secondparameter in our implementation in the CPP file.So let’s copy that and we’re going to put that in place here.And this is right.And we need to put our initializer list to the second line and then we’re going to put in another line,which is going to initialize our color.So we’re going to take the color and initialize this with color param.Okay, We can do this and you’re going to see that the compiler is going to take this because we arejust initializing our member variables using this initializer lists.But what we want to see is that even if you have a lot of parameters, but the first one isn’t usinga default parameter and the other ones are going to be using the default parameter.This can also be used in implicit conversions and the compiler might pick this up to convert from adouble to a square object because it’s just going to use that double for the first parameter.And for the others it’s going to use the defaults.So we can also protect this and make this explicit and the compiler is not going to use it in implicitconversions.And now if we build, we’re going to get the same error we had.We’re going to build with GCC and we are basically going to be told the compiler can’t use this constructorin implicit conversions because it is explicit and this is really all explicit.Constructors are all about you.Mark your constructor explicit if you don’t want it involved in implicit conversions that are done bythe compiler.So this is all for this lecture.I hope you found it interesting.We are going to stop here in this one.In the next one we’re going to learn about copy constructors.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，没问题！作为你的C++向导，我会用最清晰、最友好的方式，带你一步步探索 <code>explicit</code> 构造函数的奥秘。让我们开始吧！</p>
<hr>
<h1 id="1-标题与简介"><a href="#1-标题与简介" class="headerlink" title="1. 标题与简介"></a>1. 标题与简介</h1><p><strong>标题：</strong> C++ 探秘：显式构造函数 (<code>explicit constructor</code>) —— 防止意外的类型转换</p>
<p><strong>简介：</strong><br>本节课我们将学习C++中的一个重要关键字 <code>explicit</code>，它用于修饰类的构造函数 (<code>constructor</code>)。我们将通过一个简单的 <code>Square</code> (正方形) 类的例子，深入理解为什么以及如何使用 <code>explicit</code> 构造函数来避免编译器 (<code>compiler</code>) 进行一些我们可能不期望的隐式类型转换 (<code>implicit conversion</code>)，从而写出更安全、更可控的代码。</p>
<hr>
<h1 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h1><p>想象一下，我们正在设计一个表示正方形的程序。</p>
<p><strong>步骤 1: 创建 <code>Square</code> 类基础结构</strong></p>
<p>首先，我们需要一个 <code>Square</code> 类 (<code>class</code>)。一个正方形最重要的属性是什么？是它的边长。所以，我们会有一个私有的成员变量 (<code>member variable</code>) <code>m_side</code> 来存储边长。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.h (头文件)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQUARE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_side; <span class="comment">// 边长</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：用于创建 Square 对象并初始化边长</span></span><br><span class="line">    Square(<span class="keyword">double</span> side);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数：用于对象销毁前进行清理 (这里为空)</span></span><br><span class="line">    ~Square();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数：计算并返回正方形的面积</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_surface</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// const 表示此函数不会修改对象的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//SQUARE_H</span></span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong><code>#ifndef SQUARE_H ... #define SQUARE_H ... #endif</code></strong>：这些是头文件保护宏 (header guards)，防止同一个头文件被多次包含，导致编译错误。</li>
<li><strong><code>private:</code></strong>：这部分定义的成员变量和成员函数只能在类的内部访问。<code>m_side</code> 是私有的，意味着外部代码不能直接修改它，只能通过类提供的公共接口。</li>
<li><strong><code>public:</code></strong>：这部分定义的成员变量和成员函数可以从类的外部访问。</li>
<li><strong><code>Square(double side);</code></strong>：这是构造函数。它的名字和类名相同，没有返回类型。它接收一个 <code>double</code> 类型的参数 (<code>parameter</code>) <code>side</code>，用于初始化正方形的边长。</li>
<li><strong><code>~Square();</code></strong>：这是析构函数。它的名字是类名前面加一个波浪号 <code>~</code>。当一个 <code>Square</code> 对象 (<code>object</code>) 的生命周期结束时，析构函数会被自动调用。在这个简单的例子里，它什么也不做。</li>
<li><strong><code>double get_surface() const;</code></strong>：这是一个公共成员函数，用于计算正方形的面积。<code>const</code> 关键字表示这个函数不会修改调用它的 <code>Square</code> 对象的任何成员变量。</li>
</ul>
<p><strong>步骤 2: 实现 <code>Square</code> 类的成员函数</strong></p>
<p>现在我们来实现这些函数，通常在一个对应的 <code>.cpp</code> 文件中。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.cpp (源文件)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Square.h"</span> <span class="comment">// 包含头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的实现</span></span><br><span class="line">Square::Square(<span class="keyword">double</span> side)</span><br><span class="line">    : m_side&#123;side&#125; &#123; <span class="comment">// 使用成员初始化列表初始化 m_side</span></span><br><span class="line">    <span class="comment">// 构造函数体，这里为空，因为初始化已在初始化列表中完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数的实现</span></span><br><span class="line">Square::~Square() &#123;</span><br><span class="line">    <span class="comment">// 清理代码，这里不需要</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get_surface 函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Square::get_surface</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_side * m_side; <span class="comment">// 面积 = 边长 * 边长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong><code>Square::Square(double side) : m_side{side}</code></strong>：这是构造函数的实现。冒号 <code>:</code> 后面的是成员初始化列表 (initializer list)。这是一种推荐的初始化成员变量的方式，它在构造函数体执行之前就完成了成员变量的初始化。这里，<code>m_side{side}</code> 表示用传入的 <code>side</code> 参数的值来初始化 <code>m_side</code> 成员变量。花括号 <code>{}</code> 是C++11引入的统一初始化语法。</li>
<li><strong><code>Square::~Square() {}</code></strong>：析构函数体为空，因为它不需要做任何特殊的清理工作。</li>
<li><strong><code>double Square::get_surface() const { return m_side * m_side; }</code></strong>：计算面积很简单，就是边长的平方。</li>
</ul>
<p><strong>步骤 3: 引入比较函数和隐式转换的问题</strong></p>
<p>假设我们有一个函数，用来比较两个正方形的面积大小：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp 或其他地方</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Square.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数：如果 s1 的面积大于 s2，返回 true，否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_squares</span><span class="params">(<span class="keyword">const</span> Square&amp; s1, <span class="keyword">const</span> Square&amp; s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.get_surface() &gt; s2.get_surface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong><code>const Square&amp; s1</code></strong>: 参数 <code>s1</code> 是一个对 <code>Square</code> 对象的常量引用 (const reference)。使用引用可以避免复制整个对象，提高效率。<code>const</code> 确保函数不会修改传入的对象。</li>
</ul>
<p>现在，在 <code>main</code> 函数中使用它：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Square <span class="title">sq1</span><span class="params">(<span class="number">10.0</span>)</span></span>; <span class="comment">// 创建一个边长为10的正方形</span></span><br><span class="line">    <span class="function">Square <span class="title">sq2</span><span class="params">(<span class="number">5.0</span>)</span></span>;  <span class="comment">// 创建一个边长为5的正方形</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (compare_squares(sq1, sq2)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sq1 is larger than sq2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sq1 is NOT larger than sq2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题来了！</span></span><br><span class="line">    <span class="keyword">double</span> side_value = <span class="number">7.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (compare_squares(sq1, side_value)) &#123; <span class="comment">// 尝试将 sq1 与一个 double 值比较</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sq1 is larger than a square of side "</span> &lt;&lt; side_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sq1 is NOT larger than a square of side "</span> &lt;&lt; side_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>看到 <code>compare_squares(sq1, side_value)</code> 这一行了吗？<code>compare_squares</code> 函数期望第二个参数是 <code>Square</code> 类型的，但我们传递了一个 <code>double</code> 类型的 <code>side_value</code>。</p>
<p>奇怪的是，这段代码通常能够编译通过并且运行！为什么呢？</p>
<p>这就是<strong>隐式转换 (implicit conversion)</strong> 在作祟。<br>编译器看到 <code>compare_squares</code> 函数需要一个 <code>Square</code> 对象，而我们提供了一个 <code>double</code>。它会检查 <code>Square</code> 类是否有办法从一个 <code>double</code> “构造” 出一个 <code>Square</code> 对象。它找到了我们的构造函数 <code>Square(double side)</code>，这个构造函数正好接受一个 <code>double</code> 参数。<br>于是，编译器会<strong>偷偷地</strong>、<strong>自动地</strong>使用这个 <code>double</code> 值 <code>7.0</code> 调用 <code>Square(7.0)</code> 来创建一个临时的 <code>Square</code> 对象，然后将这个临时对象传递给 <code>compare_squares</code> 函数。</p>
<p>这种行为有时候是我们想要的，但很多时候，它可能隐藏了逻辑错误。程序员的意图可能是比较 <code>sq1</code> 的面积和一个数字 <code>7.0</code> (也许这个7.0代表的是另一个面积值)，但实际上代码却创建了一个边长为 <code>7.0</code> 的新正方形并用它进行比较。这可能导致难以察觉的bug。</p>
<p><strong>步骤 4: 使用 <code>explicit</code> 关键字阻止隐式转换</strong></p>
<p>为了防止这种不期望的隐式转换，我们可以在构造函数声明前加上 <code>explicit</code> 关键字。</p>
<p>修改 <code>Square.h</code>：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.h</span></span><br><span class="line"><span class="comment">// ... 其他代码 ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Square</span><span class="params">(<span class="keyword">double</span> side)</span></span>; <span class="comment">// 在这里添加了 explicit</span></span><br><span class="line"><span class="comment">// ... 其他代码 ...</span></span><br></pre></td></tr></table></figure></div><br><code>explicit</code> 告诉编译器：“嘿，这个构造函数不能用于隐式转换。如果想用它，必须明确地、显式地调用它。”</p>
<p>加上 <code>explicit</code> 后，之前的 <code>compare_squares(sq1, side_value)</code> 这行代码就会导致编译错误！编译器会抱怨说，它无法将 <code>double</code> 转换为 <code>Square</code>。</p>
<p>例如，错误信息可能类似于：<br><code>error: could not convert &#39;side_value&#39; from &#39;double&#39; to &#39;Square&#39;</code><br>或者<br><code>error: no matching function for call to &#39;compare_squares(Square&amp;, double&amp;)&#39;</code><br><code>note: candidate: &#39;bool compare_squares(const Square&amp;, const Square&amp;)&#39;</code><br><code>note:   no known conversion for argument 2 from &#39;double&#39; to &#39;const Square&amp;&#39;</code></p>
<p>这正是我们想要的！编译器现在帮助我们捕获了一个潜在的逻辑错误。</p>
<p>如果我们确实想用 <code>side_value</code> 创建一个 <code>Square</code> 对象并进行比较，我们必须<strong>显式地</strong>这样做：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp (修改后)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">double</span> side_value = <span class="number">7.0</span>;</span><br><span class="line">    <span class="comment">// 错误：compare_squares(sq1, side_value); // 现在这行会编译失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的方式：显式创建 Square 对象</span></span><br><span class="line">    <span class="keyword">if</span> (compare_squares(sq1, Square(side_value))) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sq1 is larger than a square of side "</span> &lt;&lt; side_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sq1 is NOT larger than a square of side "</span> &lt;&lt; side_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>
<p>或者使用 <code>static_cast</code> (虽然对于构造函数调用，直接写 <code>Square(value)</code> 更常见和清晰)：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (compare_squares(sq1, static_cast&lt;Square&gt;(side_value))) &#123; ... &#125;</span></span><br></pre></td></tr></table></figure></div></p>
<p><strong>步骤 5: 涉及默认参数的构造函数</strong></p>
<p><code>explicit</code> 关键字对于那些“看起来不像”单参数构造函数，但实际上可以被单参数调用的构造函数也同样重要。</p>
<p>假设我们的 <code>Square</code> 类构造函数接受第二个参数，比如颜色，并且这个颜色参数有默认值：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.h (修改)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQUARE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 需要包含 string 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_side;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_color; <span class="comment">// 新增颜色成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 修改构造函数，增加一个带默认值的颜色参数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Square</span><span class="params">(<span class="keyword">double</span> side, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color = <span class="string">"black"</span>)</span></span>; <span class="comment">// 注意 explicit 还在</span></span><br><span class="line"></span><br><span class="line">    ~Square();</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_surface</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">get_color</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 获取颜色的函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//SQUARE_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.cpp (修改)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Square.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改构造函数实现</span></span><br><span class="line">Square::Square(<span class="keyword">double</span> side, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color)</span><br><span class="line">    : m_side&#123;side&#125;, m_color&#123;color&#125; &#123; <span class="comment">// 初始化两个成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Square::~Square() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Square::get_surface</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_side * m_side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Square::get_color</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>即使构造函数现在是 <code>Square(double side, const std::string&amp; color = &quot;black&quot;)</code>，如果我们只提供一个 <code>double</code> 值来调用它，例如 <code>Square my_sq(10.0);</code>，编译器仍然会使用默认的颜色值 <code>&quot;black&quot;</code>。<br>因此，如果这个构造函数<strong>没有</strong> <code>explicit</code> 关键字，它仍然可以被用于从 <code>double</code> 到 <code>Square</code> 的隐式转换！编译器会用提供的 <code>double</code> 作为第一个参数，用默认值 <code>&quot;black&quot;</code> 作为第二个参数。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 Square 构造函数没有 explicit:</span></span><br><span class="line"><span class="comment">// Square s = 10.0; // 隐式转换！等同于 Square s = Square(10.0, "black");</span></span><br><span class="line"><span class="comment">// compare_squares(sq1, 25.0); // 隐式转换！用 25.0 和默认颜色创建临时 Square</span></span><br></pre></td></tr></table></figure></div>
<p>所以，只要一个构造函数可以通过提供单个参数（其他参数都有默认值）来调用，<code>explicit</code> 关键字对于防止不期望的隐式转换就是有意义的。</p>
<p><strong>总结一下 <code>explicit</code> 的核心作用：</strong></p>
<ol>
<li><strong>用于构造函数前。</strong></li>
<li><strong>阻止编译器使用该构造函数进行隐式类型转换。</strong></li>
<li><strong>鼓励更清晰的代码，因为类型转换必须是显式的。</strong></li>
<li><strong>有助于防止因意外的类型转换而导致的细微错误。</strong></li>
</ol>
<p>通常，一个好的经验法则是：<strong>除非你有充分的理由允许构造函数进行隐式转换，否则都应该将其声明为 <code>explicit</code>。</strong> 特别是对于接受单个参数的构造函数，或者其他参数都有默认值的构造函数。</p>
<hr>
<h1 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h1><p>我们将整合上面讨论的所有内容，并提供一个完整的可运行示例。</p>
<p><strong><code>Square.h</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQUARE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // For std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // For std::cout in example</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_side;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 显式构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Square</span><span class="params">(<span class="keyword">double</span> side, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color = <span class="string">"black"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数 (通常默认的就够用，这里为了完整性写出来)</span></span><br><span class="line">    ~Square();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取面积</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_surface</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取颜色</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">get_color</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印信息，方便演示</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个独立的比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_squares_by_surface</span><span class="params">(<span class="keyword">const</span> Square&amp; s1, <span class="keyword">const</span> Square&amp; s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//SQUARE_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>Square.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Square.h"</span> <span class="comment">// Ensure to include the header</span></span></span><br><span class="line"></span><br><span class="line">Square::Square(<span class="keyword">double</span> side, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color)</span><br><span class="line">    : m_side&#123;side&#125;, m_color&#123;color&#125; &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Square("</span> &lt;&lt; m_side &lt;&lt; <span class="string">", \""</span> &lt;&lt; m_color &lt;&lt; <span class="string">"\") constructed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Square::~Square() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Square("</span> &lt;&lt; m_side &lt;&lt; <span class="string">", \""</span> &lt;&lt; m_color &lt;&lt; <span class="string">"\") destructed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Square::get_surface</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_side * m_side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Square::get_color</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Square::print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Square Info: Side = "</span> &lt;&lt; m_side</span><br><span class="line">              &lt;&lt; <span class="string">", Color = "</span> &lt;&lt; m_color</span><br><span class="line">              &lt;&lt; <span class="string">", Surface = "</span> &lt;&lt; get_surface() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_squares_by_surface</span><span class="params">(<span class="keyword">const</span> Square&amp; s1, <span class="keyword">const</span> Square&amp; s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Comparing s1 (surface "</span> &lt;&lt; s1.get_surface()</span><br><span class="line">              &lt;&lt; <span class="string">") and s2 (surface "</span> &lt;&lt; s2.get_surface() &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> s1.get_surface() &gt; s2.get_surface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>main.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Square.h"</span> <span class="comment">// 包含我们定义的 Square 类</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了让输出 true/false 更易读</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // For std::boolalpha</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha; <span class="comment">// 设置输出 bool 值为 "true" 或 "false"</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Square <span class="title">sq1</span><span class="params">(<span class="number">10.0</span>, <span class="string">"red"</span>)</span></span>; <span class="comment">// 边长10，红色</span></span><br><span class="line">    <span class="function">Square <span class="title">sq2</span><span class="params">(<span class="number">20.0</span>)</span></span>;       <span class="comment">// 边长20，颜色使用默认值 "black"</span></span><br><span class="line"></span><br><span class="line">    sq1.print_info();</span><br><span class="line">    sq2.print_info();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Is sq1 larger than sq2? "</span></span><br><span class="line">              &lt;&lt; compare_squares_by_surface(sq1, sq2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试隐式转换 (如果 Square 构造函数没有 explicit，这会通过)</span></span><br><span class="line">    <span class="comment">// 由于构造函数是 explicit 的，下面这行代码会导致编译错误：</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "Is sq1 larger than 15.0 (implicitly converted)? "</span></span><br><span class="line">    <span class="comment">//           &lt;&lt; compare_squares_by_surface(sq1, 15.0) &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// 编译器会报错，例如："no matching function for call to 'compare_squares_by_surface(Square&amp;, double)'"</span></span><br><span class="line">    <span class="comment">// 或者 "cannot convert 'double' to 'const Square&amp;'"</span></span><br><span class="line">    <span class="comment">// 这很好！它阻止了潜在的错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们确实想比较 sq1 和一个边长为 15.0 的临时正方形，必须显式构造：</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Explicitly creating a temporary Square for comparison ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Is sq1 larger than a Square(15.0)? "</span></span><br><span class="line">              &lt;&lt; compare_squares_by_surface(sq1, Square(<span class="number">15.0</span>)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 注意上面一行中 Square(15.0) 的构造和析构输出</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- End of explicit temporary Square comparison ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一种显式创建的方式</span></span><br><span class="line">    <span class="function">Square <span class="title">sq_temp</span><span class="params">(<span class="number">15.0</span>, <span class="string">"blue"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Is sq1 larger than sq_temp (15.0, blue)? "</span></span><br><span class="line">              &lt;&lt; compare_squares_by_surface(sq1, sq_temp) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Main function ending. Objects will be destructed in reverse order of creation."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong>编译和运行指南 (假设使用 g++)：</strong></p>
<ol>
<li>保存文件：<code>Square.h</code>, <code>Square.cpp</code>, <code>main.cpp</code> 到同一个目录下。</li>
<li>打开终端或命令行。</li>
<li>编译：<code>g++ main.cpp Square.cpp -o explicit_demo -std=c++11</code> (或更高版本如 <code>-std=c++17</code>)</li>
<li>运行：<code>./explicit_demo</code></li>
</ol>
<p><strong>预期输出 (大致如此，构造/析构顺序可能因临时对象稍有不同)：</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Square(10, &quot;red&quot;) constructed.</span><br><span class="line">Square(20, &quot;black&quot;) constructed.</span><br><span class="line">Square Info: Side &#x3D; 10, Color &#x3D; red, Surface &#x3D; 100</span><br><span class="line">Square Info: Side &#x3D; 20, Color &#x3D; black, Surface &#x3D; 400</span><br><span class="line">Comparing s1 (surface 100) and s2 (surface 400)</span><br><span class="line">Is sq1 larger than sq2? false</span><br><span class="line"></span><br><span class="line">--- Explicitly creating a temporary Square for comparison ---</span><br><span class="line">Square(15, &quot;black&quot;) constructed.</span><br><span class="line">Comparing s1 (surface 100) and s2 (surface 225)</span><br><span class="line">Is sq1 larger than a Square(15.0)? false</span><br><span class="line">Square(15, &quot;black&quot;) destructed.</span><br><span class="line">--- End of explicit temporary Square comparison ---</span><br><span class="line"></span><br><span class="line">Square(15, &quot;blue&quot;) constructed.</span><br><span class="line">Comparing s1 (surface 100) and s2 (surface 225)</span><br><span class="line">Is sq1 larger than sq_temp (15.0, blue)? false</span><br><span class="line"></span><br><span class="line">Main function ending. Objects will be destructed in reverse order of creation.</span><br><span class="line">Square(15, &quot;blue&quot;) destructed.</span><br><span class="line">Square(20, &quot;black&quot;) destructed.</span><br><span class="line">Square(10, &quot;red&quot;) destructed.</span><br></pre></td></tr></table></figure></div><br>如果你把 <code>Square.h</code> 中的 <code>explicit Square(double side, const std::string&amp; color = &quot;black&quot;);</code> 改为 <code>Square(double side, const std::string&amp; color = &quot;black&quot;);</code> (去掉 <code>explicit</code>)，然后取消 <code>main.cpp</code> 中那段被注释掉的隐式转换代码的注释，你会发现程序可以编译通过，并且会有一个边长为 <code>15.0</code>、颜色为 <code>&quot;black&quot;</code> 的临时 <code>Square</code> 对象被创建用于比较。</p>
<hr>
<h1 id="4-QA-闪卡-QA-Flash-Cards"><a href="#4-QA-闪卡-QA-Flash-Cards" class="headerlink" title="4. QA 闪卡 (QA Flash Cards)"></a>4. QA 闪卡 (QA Flash Cards)</h1><p><strong>Q1: 什么是构造函数中的隐式转换 (implicit conversion)？</strong><br>A1: 当一个构造函数可以用单个参数调用时（或者其他参数都有默认值），编译器可能会自动使用这个构造函数将该参数类型的值转换为类类型的对象，而无需程序员显式请求。</p>
<p><strong>Q2: <code>explicit</code> 关键字用在C++中的什么地方？有什么作用？</strong><br>A2: <code>explicit</code> 关键字用在类的构造函数声明之前。它的作用是告诉编译器，这个构造函数不能被用于隐式类型转换。</p>
<p><strong>Q3: 为什么我们要阻止隐式转换？</strong><br>A3: 为了避免因编译器自动执行的、程序员可能未预料到的类型转换而导致的潜在逻辑错误和行为混淆，从而提高代码的清晰度、可读性和安全性。</p>
<p><strong>Q4: 如果一个构造函数有多个参数，<code>explicit</code> 还有用吗？</strong><br>A4: 有用，前提是该构造函数的第二个及以后的所有参数都有默认值。这样，它仍然可以用单个参数调用，从而可能参与隐式转换。<code>explicit</code> 可以阻止这种情况。例如 <code>explicit MyClass(int a, bool b = true, std::string s = &quot;&quot;);</code>。</p>
<p><strong>Q5: 使用 <code>explicit</code> 后，我还能创建对象吗？</strong><br>A5: 当然！你仍然可以通过显式调用构造函数来创建对象，例如 <code>Square s(10.0);</code> 或者 <code>Square s = Square(10.0);</code> (注意，对于 <code>explicit</code> 构造函数，<code>Square s = 10.0;</code> 是不允许的，但 <code>Square s = Square(10.0);</code> 是显式调用构造函数然后进行拷贝/移动初始化，这是允许的)。</p>
<hr>
<h1 id="5-常见误解或易犯错误"><a href="#5-常见误解或易犯错误" class="headerlink" title="5. 常见误解或易犯错误"></a>5. 常见误解或易犯错误</h1><ol>
<li><p><strong>误解：<code>explicit</code> 会禁止所有类型的转换。</strong></p>
<ul>
<li><strong>纠正：</strong> <code>explicit</code> 只禁止<strong>隐式</strong>转换。你仍然可以进行<strong>显式</strong>转换，例如 <code>Square(10.0)</code> 或 <code>static_cast&lt;Square&gt;(10.0)</code> (尽管后者对于构造函数不常用)。</li>
</ul>
</li>
<li><p><strong>忘记对“实际上”的单参数构造函数使用 <code>explicit</code>。</strong></p>
<ul>
<li><strong>易犯错误：</strong> 构造函数如 <code>MyClass(int mandatory_param, std::string optional_param = &quot;default&quot;)</code> 如果没有 <code>explicit</code>，依然可以由一个 <code>int</code> 值隐式转换而来，因为 <code>optional_param</code> 有默认值。很多初学者可能只关注严格只有一个参数的构造函数。</li>
</ul>
</li>
<li><p><strong>不理解隐式转换的潜在危害。</strong></p>
<ul>
<li><strong>易犯错误：</strong> 认为隐式转换总是方便的，而忽略了它可能引入的细微的、难以调试的bug，或者使代码意图变得模糊。例如，一个期望 <code>Angle</code> 对象的函数，如果 <code>Angle</code> 有一个 <code>explicit Angle(double degrees);</code>，那么传递一个 <code>double</code> 就会报错。如果没有 <code>explicit</code>，它可能会默默地把 <code>double</code> 当作角度值创建一个 <code>Angle</code>，这可能不是调用者的本意。</li>
</ul>
</li>
<li><p><strong>过度使用或在不必要的地方使用 <code>explicit</code>。</strong></p>
<ul>
<li><strong>说明：</strong> 虽然通常建议使用 <code>explicit</code>，但如果一个类的设计确实就是为了能和某种基础类型无缝、安全地进行隐式转换（例如一个简单的字符串包装类可能希望从 <code>const char*</code> 隐式构造），那么可以不使用 <code>explicit</code>。但这需要仔细考虑。对于大多数情况，特别是当转换可能不直观或有歧义时，<code>explicit</code> 是更安全的选择。</li>
</ul>
</li>
<li><p><strong>混淆 <code>explicit</code> 构造函数和拷贝构造函数/赋值运算符。</strong></p>
<ul>
<li><strong>说明：</strong> <code>explicit</code> 主要用于控制从其他类型到类类型的转换型构造函数。它通常不用于（也不应该用于）拷贝构造函数或移动构造函数，尽管在C++11之后理论上可以，但这样做会阻止很多自然的拷贝和移动场景，通常不是期望的行为。</li>
</ul>
</li>
<li><p><strong>认为 <code>Square s = 10.0;</code> 和 <code>Square s(10.0);</code> 在有 <code>explicit</code> 构造函数时行为一致。</strong></p>
<ul>
<li><strong>纠正：</strong><ul>
<li><code>Square s(10.0);</code> 是直接初始化 (direct initialization)，总是调用构造函数，即使是 <code>explicit</code> 的也可以。</li>
<li><code>Square s = 10.0;</code> 是拷贝初始化 (copy initialization)。它首先尝试将 <code>10.0</code> 隐式转换为 <code>Square</code> 类型（创建一个临时对象），然后用这个临时对象拷贝（或移动）初始化 <code>s</code>。如果构造函数是 <code>explicit</code>，第一步的隐式转换就会失败。</li>
<li>但是，<code>Square s = Square(10.0);</code> 也是拷贝初始化，但因为 <code>Square(10.0)</code> 是显式构造，所以这是允许的（尽管现代编译器通常会优化掉这个拷贝，直接在 <code>s</code> 的位置构造）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="6-编码练习"><a href="#6-编码练习" class="headerlink" title="6. 编码练习"></a>6. 编码练习</h1><p>下面是一个简单的 <code>Distance</code> 类，它有一个接受 <code>double</code> 类型（表示米）的构造函数。当前，它可以从 <code>double</code> 隐式转换。</p>
<p>你的任务是：修改这个类，使得它不能从 <code>double</code> 值隐式转换，但仍然可以通过显式调用构造函数来创建 <code>Distance</code> 对象。</p>
<p><strong><code>Distance.h</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DISTANCE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISTANCE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_meters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在下一行合适的位置添加一个关键字，以防止隐式转换</span></span><br><span class="line">    Distance(<span class="keyword">double</span> meters) : m_meters(meters) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Distance of "</span> &lt;&lt; m_meters &lt;&lt; <span class="string">"m created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_distance</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Distance is: "</span> &lt;&lt; m_meters &lt;&lt; <span class="string">" meters."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅为演示隐式转换的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display_length_implicitly</span><span class="params">(Distance d)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Implicitly displayed: "</span>;</span><br><span class="line">        d.print_distance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display_length_explicitly</span><span class="params">(<span class="keyword">const</span> Distance&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Explicitly displayed: "</span>;</span><br><span class="line">        d.print_distance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISTANCE_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>main.cpp</code> (在你修改 <code>Distance.h</code> 后，这个 <code>main</code> 函数中的某一行应该会导致编译错误)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Distance.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Distance <span class="title">d1</span><span class="params">(<span class="number">100.5</span>)</span></span>; <span class="comment">// 显式构造，总是可以的</span></span><br><span class="line">    d1.print_distance();</span><br><span class="line"></span><br><span class="line">    Distance d2 = <span class="number">200.75</span>; <span class="comment">// 拷贝初始化，目前会发生隐式转换</span></span><br><span class="line">    d2.print_distance();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Trying implicit conversion in function call ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 下面这行调用依赖于从 double到 Distance 的隐式转换</span></span><br><span class="line">    <span class="comment">// 在你修改 Distance.h 之后，这行应该会产生编译错误</span></span><br><span class="line">    Distance::display_length_implicitly(<span class="number">300.0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- End of implicit conversion test ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Trying explicit conversion in function call ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这种方式总是可以的，因为我们显式创建了 Distance 对象</span></span><br><span class="line">    Distance::display_length_explicitly(Distance(<span class="number">400.25</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- End of explicit conversion test ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你想让 display_length_implicitly 在修改后也能工作，你需要这样做：</span></span><br><span class="line">    <span class="comment">// Distance::display_length_implicitly(Distance(300.0));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>请你思考一下，应该在 <code>Distance.h</code> 的 <code>// TODO:</code> 下一行添加哪个关键字？然后尝试编译并观察结果。</p>
<hr>
<p>等你准备好后，请告诉我你的答案（你添加的关键字），或者如果你有任何疑问，随时提出！我会在这里指导你。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Function/">Function    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Programming/">Programming    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/297%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>297 - 构造函数初始化列表</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/296%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>296 - 构造函数默认参数</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/312 - cpp 友元函数详解/" title="312 - cpp 友元函数详解"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">312 - cpp 友元函数详解</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/323 - cpp静态成员函数/" title="323 - cpp静态成员函数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">323 - cpp静态成员函数</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/321 - 类内变量自引用/" title="321 - 类内变量自引用"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">321 - 类内变量自引用</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/301 - 拷贝构造函数深拷贝/" title="301 - 拷贝构造函数深拷贝"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">301 - 拷贝构造函数深拷贝</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/return type for lambda function template/" title="return type for lambda function template"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">return type for lambda function template</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/259 - Auto Function Templates/" title="259 - Auto Function Templates"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">259 - Auto Function Templates</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>