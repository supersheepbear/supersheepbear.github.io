<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>302 - 对象数组复制陷阱 | Bear's dream</title><meta name="description" content="302 - 对象数组复制陷阱"><meta name="keywords" content="Coding,Cpp,Software,Class,Objects"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="302 - 对象数组复制陷阱"><meta name="twitter:description" content="302 - 对象数组复制陷阱"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="302 - 对象数组复制陷阱"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/302%20-%20%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E9%99%B7%E9%98%B1/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="302 - 对象数组复制陷阱"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/302%20-%20%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E9%99%B7%E9%98%B1/"><link rel="prev" title="304 - 移动构造函数窃取" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/304%20-%20%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%AA%83%E5%8F%96/"><link rel="next" title="312 - cpp 友元函数详解" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/312%20-%20cpp%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#好的，这是您对话的标题：-对象数组复制陷阱"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">好的，这是您对话的标题： 对象数组复制陷阱</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-对象复制行为：数组与范围for循环中的陷阱与优化"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">C++ 对象复制行为：数组与范围for循环中的陷阱与优化</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#详细讲解：理解C-中的对象复制行为"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">详细讲解：理解C++中的对象复制行为</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-复制构造函数-Copy-Constructor-的作用"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">1. 复制构造函数 (Copy Constructor) 的作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-场景一：将对象放入数组-Array-中"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">2. 场景一：将对象放入数组 (Array) 中</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-场景二：范围for循环-Range-based-For-Loop-中的隐式复制"><span class="toc_mobile_items-number">2.1.3.</span> <span class="toc_mobile_items-text">3. 场景二：范围for循环 (Range-based For Loop) 中的隐式复制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-如何避免复制：使用引用-Reference"><span class="toc_mobile_items-number">2.1.4.</span> <span class="toc_mobile_items-text">4. 如何避免复制：使用引用 (Reference)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-场景三：传统for循环-Traditional-For-Loop-不会复制"><span class="toc_mobile_items-number">2.1.5.</span> <span class="toc_mobile_items-text">5. 场景三：传统for循环 (Traditional For Loop) 不会复制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-为什么理解这些很重要？"><span class="toc_mobile_items-number">2.1.6.</span> <span class="toc_mobile_items-text">6. 为什么理解这些很重要？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#详细代码示例"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">详细代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#QA-闪存卡-Flash-Cards"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">QA 闪存卡 (Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#常见的误解或编程错误"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">常见的误解或编程错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#编程练习"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">编程练习</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-解决方案评估与讲解"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">7. 解决方案评估与讲解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#实际答案与详细讲解"><span class="toc_mobile_items-number">2.9.</span> <span class="toc_mobile_items-text">实际答案与详细讲解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-建议与扩展问题-Suggestions-and-Extended-Questions"><span class="toc_mobile_items-number">2.10.</span> <span class="toc_mobile_items-text">8. 建议与扩展问题 (Suggestions and Extended Questions)</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#好的，这是您对话的标题：-对象数组复制陷阱"><span class="toc-number">1.</span> <span class="toc-text">好的，这是您对话的标题： 对象数组复制陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-对象复制行为：数组与范围for循环中的陷阱与优化"><span class="toc-number">2.</span> <span class="toc-text">C++ 对象复制行为：数组与范围for循环中的陷阱与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#详细讲解：理解C-中的对象复制行为"><span class="toc-number">2.1.</span> <span class="toc-text">详细讲解：理解C++中的对象复制行为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-复制构造函数-Copy-Constructor-的作用"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 复制构造函数 (Copy Constructor) 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-场景一：将对象放入数组-Array-中"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 场景一：将对象放入数组 (Array) 中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-场景二：范围for循环-Range-based-For-Loop-中的隐式复制"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. 场景二：范围for循环 (Range-based For Loop) 中的隐式复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-如何避免复制：使用引用-Reference"><span class="toc-number">2.1.4.</span> <span class="toc-text">4. 如何避免复制：使用引用 (Reference)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-场景三：传统for循环-Traditional-For-Loop-不会复制"><span class="toc-number">2.1.5.</span> <span class="toc-text">5. 场景三：传统for循环 (Traditional For Loop) 不会复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-为什么理解这些很重要？"><span class="toc-number">2.1.6.</span> <span class="toc-text">6. 为什么理解这些很重要？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#详细代码示例"><span class="toc-number">2.2.</span> <span class="toc-text">详细代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QA-闪存卡-Flash-Cards"><span class="toc-number">2.3.</span> <span class="toc-text">QA 闪存卡 (Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的误解或编程错误"><span class="toc-number">2.4.</span> <span class="toc-text">常见的误解或编程错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编程练习"><span class="toc-number">2.5.</span> <span class="toc-text">编程练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">2.6.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">2.7.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-解决方案评估与讲解"><span class="toc-number">2.8.</span> <span class="toc-text">7. 解决方案评估与讲解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实际答案与详细讲解"><span class="toc-number">2.9.</span> <span class="toc-text">实际答案与详细讲解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-建议与扩展问题-Suggestions-and-Extended-Questions"><span class="toc-number">2.10.</span> <span class="toc-text">8. 建议与扩展问题 (Suggestions and Extended Questions)</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">302 - 对象数组复制陷阱</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/302%20-%20%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E9%99%B7%E9%98%B1/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/302%20-%20%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E9%99%B7%E9%98%B1/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="好的，这是您对话的标题：-对象数组复制陷阱"><a href="#好的，这是您对话的标题：-对象数组复制陷阱" class="headerlink" title="好的，这是您对话的标题： 对象数组复制陷阱"></a>好的，这是您对话的标题： <strong>对象数组复制陷阱</strong></h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture.We’re going to see that if we try and pass objects in an array, these objects are going to be copied.And we are seeing that exactly here, because now we can prove this with copy constructors.So here is a simple example.We have a few person objects S1 all the way to S3 and we are using these person objects to put datain an array which is called student.It is an array of person objects and we’re going to put our person objects inside and we’re going tosee what happens.So what is going to happen?What we have inside the array are going to be copies of the objects that we put in here, and we’regoing to see copy constructors called as this array is being set up in our C plus plus program.This is what I want you to see here.Putting objects in an array is going to create copies and you need to be aware of that.Another place where we’re going to be making copies is if we use a range based for loop like we do here.So we are basically having this array and we are looping around it trying to set the first name to whateverwe want.So what this is going to do at each iteration, it’s going to create a copy of the person object itis at from this array here.So this copy is going to be scoped to our for loop, the body of the for loop.And when the iteration is done, the local copy is going to be destroyed.When we hit the next iteration, a new copy for the new element is going to be created and we’re goingto keep going until we hit the end of the range based for loop.So this is something you need to be aware of.If you want to avoid copies, you can use references in your range based for loop, and this is notgoing to create a copy and you’re going to see that the copy constructor is not being called as yourloop execute.But you should know that regular loops don’t make any copies.So if you set up something like this, you’re going to be using the actual elements that are storedin the array.You won’t be making copies in the for loop here.Okay, Now that you know this, let’s head over to Visual Studio code and play with this a little more.Okay.Here we are in our working folder.The current project is Objects in Arrays are copies.What a good title.We’re going to grab the template files here and we’re going to paste them in place and we’re going tograb the person class from the last lecture because we don’t want to redo this.We already have done this so we can reuse this.We’re going to put that in our current project and then we’re going to open this in Visual Studio code.Let’s do that.This is going to open our folder with our files and we see the main CPP file here.We can clean this up a little bit and we have our person class, which has some things we don’t reallyneed, so we just need the copy constructor here.So let’s put this in.So we’re going to delete all the other things we don’t need here to keep this class clean and nice.And we’re going to head over to the person CPP file and we’re going to remove all the dirty things thatare not used here.Everything that is commented out, we’re going to remove.Let’s do that and we’re going to keep the copy constructor that is dedicated to the other constructorhere.This is going to work.Okay, so now what we want to do is to set up an array of person objects.But for that to work in main, we need to include the person class in our main file here.So let’s do person dot H and we are going to create a few person objects.We’re going to say person 1P1 and we’re going to pass in John and we’re going to say snow And we’regoing to say age is 25.Why not?We’re going to do person two and we’re going to say, let’s say Johnny Drill is five here.We can do this so we can go down here and create an array of person objects.So let’s do that.We’re going to say person and we’re going to say students and we’re going to make this an array andwe’re going to initialize this with data that we have in the objects here.So we’re going to just put in P one, P, two and P three.Let’s see what happens if we build and run this code.Let’s put a little separator here to be able to separate what we get from the constructors here, fromwhat we get from the array setup here.We can build our program.We’re going to use GCC.You’re going to see that the world is good.We’re going to bring up a terminal and we are going to go up and clear.Let’s clear and run Rooster.You’re going to see that it’s saying copy constructor called copy constructor called copy constructorcalled.So what this is going to do after we set up our person objects, It’s going to copy each of these guysand keep a local copy in the array here.This is what is happening and I wanted you to see this with your own eyes.We can even make the message in our copy constructor.Are more descriptive so we can say copy constructor for the name and say the last name for example.So we can say code for and we can say the last name here.I think we can say that last name.We have access to this and the person object we just constructed so we can print this out.Let’s put a space here so that we can really see this.So we’re going to build with GCC again for these changes to be taken into account and we’re going toclear and run.Rooster, You see that the copy constructor is going to be called for John because John is the firstelement we copy into the array P one here.The copy constructor is going to be called for Sam because that’s the second person object.And we have John who is going to be copied in the first position here.And what we have inside our array are going to be copies from the outside here.I think we can really prove this, that they are going to be living at different memory locations sowe can go on top here and say P one print info can print the information and we’re going to say P twoprint info and P three print info and we can loop through this array and print at each iteration andprint the information and really prove that what we have is a copy.So let’s do that.We’re going to use a regular loop.We’re going to say for size t I and we’re going to initialize this to zero.We’re going to keep looping as long as I is less than STD size and we’re going to increment here inour incrementation part.And inside what we want to do is just print the information from the current element in the array.So we’re going to say students, we’re going to access the elements in the array, we’re going to saystudent and we’re going to say print info and we’re going to print information from the inside.So let’s do that.We’re going to build with GCC and the build is good.We can clear and run.Rooster Let’s run Rooster And you’re going to see that before we set up the array.This is going to be the information.So the person object is going to live at this address.P one.So that’s P one here.P two is going to live at this address.P three is going to live at this address because we are printing this information here.But once we hit the body of the loop, we’re going to see that John Snow is living at this address here.And he was living at this address from the outside of the array.So you see that what we have inside the array are going to be copies.It’s not going to be the original stuff.And you need to be aware of these copies.Okay.The second place where we’re going to have unintended copies is if we use a range based for loop.Okay.So what we’re going to do to really prove that we’re going to put another separator and we’re goingto put a few dashes in here, how many did we use there?Let’s say it’s four.I think this is four.So we’re going to use the same thing here and we’re going to set up a range based for loop, which isgoing to loop through this array here, printing the information.It’s going to do the same thing we do here, but it’s not going to be using a regular loop like we didon top here.I just want you to see that that’s going to create copies and you need to be aware of them.So let’s do that.We’re going to say for person P in our array of students and we’re going to grab this P person and printthe information.This is how easy a range based for loop can really be and it is really cool.But we’re going to see that after this dashes.We’re going to be calling the copy constructors.Let’s build and really prove this.So we’re going to build with GCC.Okay, The build is good.We can clear and run Rooster.We’re going to see that.We’re going to call the copy constructor for John and Sam and Johnny when we set up the array.That’s what we see when we set up this array here.And after we print each of the elements in the array, we’re going to print the second dashes, whichis here, and we see that we have a couple of copy constructor calls.We’re going to see the copy constructor called for John and we’re going to print the information aboutJohn.We’re going to see the copy constructor called for Sam.We’re going to print the information about Sam.We’re going to see the copy constructor called for Johnny and we’re going to print information for Johnny.What this is really doing at each iteration, we’re going to set up a copy of the current element weare at in this array here, and this is what we see and you need to be aware of these copies.Again, you need to know this because sometimes you don’t want copies and you need to do something moreto avoid those copies.In this case, in our range based loop, it is really easy.We can pass the current iteration element by reference.So for example, we can say person reference P here and this is going to be a reference.It’s no longer going to be a copy.If we build it now, we’re going to see that the copy constructors are no longer being called becausewhat we have inside the loop is going to be a reference to the original data that we.Half in the array here.Okay, so this is what we have.Let’s try and build and really prove that this is not going to create copies.You see, the build is good.With our reference, we’re going to clear and run Rooster.Now, you see that after the second pair of dashes, we’re not using the copy constructors anymore becausewhat we have are real references to the data we have in the array.And if you look here, you see that the address in memory are the same.Okay, so this is really cool.If we go back and look at what we printed earlier before this run here, you’ll see that the data wehave in our and it should be gone.It’s gone.We don’t have this, but we can take out the reference here and build again and show you that the datawe have in the array is going to be different from the data we have in the loop here, because whatwe have in the loop is a copy.So they are going to be living at different memory addresses.Let’s run and really prove this to you.You need to see this.So the build is good.We can clear and run Rooster.So look at what we have in our range based for loop.The person object is going to be living at this address.This is John Snow.He’s going to be living at an address that ends in A70, but in the array.John Snow is living at an address that ends in a zero.So this two things are different copies we have and we are making a copy in the range based for loophere or to be exact, we are copying whatever we have in the array when we loop through this range basedfor loop here.But we can avoid these copies again using references.We can do this and if we run the test to build with GCC, we’re going to see that we’re not going tocall the copy constructor, but we are also not going to be making copies, which is really cool.So we’re going to run Rooster and we see that now the person we have in the range based for loop isthe same person we have in the array because the addresses are the same.You can see this right here and this is really cool.So one thing you should really be careful about is these copies.You can avoid them with range based for loops using references, and you have to know that with regularloops like we did on top here, we’re not going to be making any copies.We basically going to be referencing exactly the same thing we have in the array.Okay, So this is something you need to keep in mind.And this is really all I wanted to share with you in this lecture.I hope you found it interesting.We are going to stop here in this one and the next one we’re going to learn about shallow copies anddeep copies, and we’re going to really see the difference between these two things.So go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，作为您的C++专业开发导师和全球顶尖的教师，我将以最清晰、最易懂的方式，带您深入理解C++中对象复制的奥秘。本节课我们将聚焦在数组和范围for循环中对象的复制行为。</p>
<hr>
<h1 id="C-对象复制行为：数组与范围for循环中的陷阱与优化"><a href="#C-对象复制行为：数组与范围for循环中的陷阱与优化" class="headerlink" title="C++ 对象复制行为：数组与范围for循环中的陷阱与优化"></a>C++ 对象复制行为：数组与范围for循环中的陷阱与优化</h1><p><strong>课程概要：</strong> 本课程将深入探讨在C++中，当您将对象放入数组或通过范围for循环遍历对象时，C++是如何处理对象复制的。我们将通过观察复制构造函数（[copy constructor]）的调用和内存地址（[memory address]）的变化来证明这些行为。同时，我们也将学习如何通过使用引用（[reference]）来避免不必要的对象复制，从而优化程序性能并确保代码行为的正确性。</p>
<hr>
<h2 id="详细讲解：理解C-中的对象复制行为"><a href="#详细讲解：理解C-中的对象复制行为" class="headerlink" title="详细讲解：理解C++中的对象复制行为"></a>详细讲解：理解C++中的对象复制行为</h2><p>C++中对象的复制是一个核心概念，尤其是在您处理集合（如数组）和使用循环来遍历这些集合时。理解何时会发生隐式的对象复制对于编写高效、正确且无内存问题的代码至关重要。</p>
<p>在深入细节之前，我们先来了解一个关键的类成员函数：<strong>复制构造函数</strong>。</p>
<h3 id="1-复制构造函数-Copy-Constructor-的作用"><a href="#1-复制构造函数-Copy-Constructor-的作用" class="headerlink" title="1. 复制构造函数 (Copy Constructor) 的作用"></a>1. 复制构造函数 (Copy Constructor) 的作用</h3><p>复制构造函数是C++类的一种特殊构造函数。当您使用一个已存在的对象来初始化（或创建）另一个相同类型的新对象时，复制构造函数就会被自动调用。它的主要任务是确保新对象是原对象的一个独立副本。</p>
<p><strong>基本形式：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName(<span class="keyword">const</span> ClassName&amp; source);</span><br></pre></td></tr></table></figure></div>
<p>例如，如果您有一个 <code>Person</code> 类，它的复制构造函数可能是这样：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他构造函数和成员 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person&amp; source) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"复制构造函数被调用！复制 "</span> &lt;&lt; source.m_first_name &lt;&lt; <span class="string">" "</span> &lt;&lt; source.m_last_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        m_first_name = source.m_first_name;</span><br><span class="line">        m_last_name = source.m_last_name;</span><br><span class="line">        m_age = source.m_age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他成员 ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_first_name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_last_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>每当 <code>Person</code> 对象被复制时，我们就能通过打印信息看到这个函数被调用了。</p>
<h3 id="2-场景一：将对象放入数组-Array-中"><a href="#2-场景一：将对象放入数组-Array-中" class="headerlink" title="2. 场景一：将对象放入数组 (Array) 中"></a>2. 场景一：将对象放入数组 (Array) 中</h3><p>当您创建一个对象数组，并使用已存在的对象来初始化这个数组的元素时，C++并不会直接把那些已存在的对象“搬”进数组。相反，它会为每个数组元素创建原始对象的一个<strong>副本</strong>（[copy]）。这意味着数组中存储的是原始对象内容的独立拷贝，而不是原始对象本身。</p>
<p><strong>如何证明？</strong></p>
<ul>
<li><strong>观察复制构造函数的调用：</strong> 如果您在对象的复制构造函数中添加一条打印语句，您会发现每当一个对象被用来初始化数组中的某个元素时，复制构造函数就会被调用一次。</li>
<li><strong>内存地址（[memory address]）比较：</strong> 原始对象和数组中对应的对象将位于不同的内存地址。这意味着它们是两个完全独立的对象。</li>
</ul>
<p><strong>举例说明：</strong><br>假设您有 <code>P1</code>、<code>P2</code>、<code>P3</code> 三个 <code>Person</code> 对象。当您声明 <code>Person students[] = {P1, P2, P3};</code> 时：</p>
<ol>
<li><code>P1</code> 的内容被复制一份，用来构造 <code>students[0]</code>。</li>
<li><code>P2</code> 的内容被复制一份，用来构造 <code>students[1]</code>。</li>
<li><code>P3</code> 的内容被复制一份，用来构造 <code>students[2]</code>。<br>这个过程中，<code>students</code> 数组中的元素是 <code>P1</code>、<code>P2</code>、<code>P3</code> 的独立副本。</li>
</ol>
<h3 id="3-场景二：范围for循环-Range-based-For-Loop-中的隐式复制"><a href="#3-场景二：范围for循环-Range-based-For-Loop-中的隐式复制" class="headerlink" title="3. 场景二：范围for循环 (Range-based For Loop) 中的隐式复制"></a>3. 场景二：范围for循环 (Range-based For Loop) 中的隐式复制</h3><p>范围for循环是C++11引入的一种方便的循环语法，用于遍历容器（如数组、<code>std::vector</code> 等）中的所有元素。它的基本形式是 <code>for (Type var : collection)</code>。</p>
<p><strong>默认行为：</strong> 当您使用这种形式遍历一个对象集合时，循环变量 <code>var</code> 在每次迭代时都会是集合中当前元素的一个<strong>副本</strong>。</p>
<p><strong>如何证明？</strong></p>
<ul>
<li><strong>观察复制构造函数的调用：</strong> 类似于数组初始化，在每次循环迭代开始时，集合中当前元素的复制构造函数会被调用，用于构造 <code>var</code>。</li>
<li><strong>内存地址比较：</strong> 循环变量 <code>var</code> 的内存地址将与集合中原始元素的内存地址不同。</li>
<li><strong>生命周期：</strong> 这个副本的生命周期仅限于单次循环迭代。当该次迭代结束时，副本会被销毁（其析构函数 [destructor] 会被调用）。这意味着如果您在循环中修改了 <code>var</code>，您修改的只是副本，原始集合中的元素不会受到影响。</li>
</ul>
<p><strong>举例说明：</strong><br>假设 <code>students</code> 是一个 <code>Person</code> 对象数组。当您编写 <code>for (Person p : students)</code> 时：</p>
<ul>
<li>第一次迭代：<code>students[0]</code> 被复制，生成 <code>p</code>。<code>p</code> 是 <code>students[0]</code> 的副本。</li>
<li>第二次迭代：<code>students[1]</code> 被复制，生成新的 <code>p</code>。<code>p</code> 是 <code>students[1]</code> 的副本。</li>
<li>依此类推…</li>
</ul>
<h3 id="4-如何避免复制：使用引用-Reference"><a href="#4-如何避免复制：使用引用-Reference" class="headerlink" title="4. 如何避免复制：使用引用 (Reference)"></a>4. 如何避免复制：使用引用 (Reference)</h3><p>在某些情况下，对象复制可能是我们不想要的，因为它会带来性能开销和额外的内存使用。幸运的是，C++提供了一种方式来避免这种隐式复制：使用引用。</p>
<p><strong>在范围for循环中避免复制：</strong></p>
<p>通过将循环变量声明为引用 <code>for (Type&amp; var : collection)</code>，您可以避免创建副本。此时，<code>var</code> 不再是一个独立的副本，而是直接<strong>引用</strong>集合中的原始元素。</p>
<ul>
<li><strong>效果：</strong> 不会调用复制构造函数，且 <code>var</code> 的内存地址将与原始元素相同。</li>
<li><strong>优势：</strong><ul>
<li><strong>性能提升：</strong> 对于大型对象，避免复制可以显著提高程序运行效率。</li>
<li><strong>直接操作原始数据：</strong> 您在循环中对 <code>var</code> 所做的任何修改都将直接作用于集合中的原始元素。</li>
</ul>
</li>
</ul>
<p><strong>常量引用 (Const Reference) 的最佳实践：</strong></p>
<p>如果您只想读取元素的内容而不想修改它，最佳实践是使用常量引用 <code>for (const Type&amp; var : collection)</code>。这不仅避免了复制，还通过 <code>const</code> 关键字保证了您不会在循环中意外地修改原始数据，提高了代码的安全性。</p>
<h3 id="5-场景三：传统for循环-Traditional-For-Loop-不会复制"><a href="#5-场景三：传统for循环-Traditional-For-Loop-不会复制" class="headerlink" title="5. 场景三：传统for循环 (Traditional For Loop) 不会复制"></a>5. 场景三：传统for循环 (Traditional For Loop) 不会复制</h3><p>与范围for循环不同，使用传统的基于索引的 <code>for</code> 循环（例如 <code>for (size_t i = 0; i &lt; size; ++i)</code>）并通过 <code>array[i]</code> 访问数组元素时，C++并不会创建副本。您直接操作的就是数组中存储的原始元素。</p>
<ul>
<li><strong>效果：</strong> 不会调用复制构造函数。</li>
<li><strong>优势：</strong> 这种方式是处理数组时最直接且最高效的方法之一，因为它不涉及任何隐式复制。</li>
</ul>
<h3 id="6-为什么理解这些很重要？"><a href="#6-为什么理解这些很重要？" class="headerlink" title="6. 为什么理解这些很重要？"></a>6. 为什么理解这些很重要？</h3><p>理解对象复制行为不仅仅是理论知识，它对您编写实际代码具有深远的影响：</p>
<ul>
<li><strong>性能 (Performance) 开销：</strong> 对象的复制可能涉及大量数据的拷贝。对于大型或复杂的对象，频繁的复制会显著降低程序的运行性能。</li>
<li><strong>内存使用 (Memory Usage)：</strong> 每次复制都会占用额外的内存。如果复制的对象数量庞大，可能导致不必要的内存消耗甚至内存溢出。</li>
<li><strong>行为正确性：</strong> 如果您期望在循环中修改集合中的原始元素，但却使用了默认的按值传递的范围for循环（创建了副本），那么您的修改将只会作用于副本，原始元素不会改变，这可能导致难以发现的逻辑错误。</li>
<li><strong>资源管理 (Resource Management) 问题：</strong> 如果您的对象管理着动态分配的内存或其他系统资源（例如文件句柄、网络连接等），简单的<strong>浅拷贝</strong>（[shallow copy]）可能导致多个对象共享同一资源，这在对象销毁时可能引发<strong>双重释放</strong>（[double free]）或内存泄漏（[memory leak]）等严重问题。这引出了<strong>深拷贝</strong>（[deep copy]）的概念，我们将在后续课程中详细探讨。正确理解复制行为是避免这类问题的基础。</li>
</ul>
<hr>
<h2 id="详细代码示例"><a href="#详细代码示例" class="headerlink" title="详细代码示例"></a>详细代码示例</h2><p>我们将创建一个 <code>Person</code> 类，其中包含一个复制构造函数和一个 <code>print_info</code> 方法来打印对象信息及其内存地址，以便您亲眼观察复制行为。</p>
<p><strong><code>Person.h</code> 文件:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PERSON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt; // C++17 引入，轻量级字符串视图，避免不必要的字符串复制</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;    // For std::addressof (C++11) or just use 'this'</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Person(<span class="built_in">std</span>::string_view first, <span class="built_in">std</span>::string_view last, <span class="keyword">int</span> age)</span><br><span class="line">        : m_first_name(first), m_last_name(last), m_age(age) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造函数被调用！创建 "</span> &lt;&lt; m_first_name &lt;&lt; <span class="string">" "</span> &lt;&lt; m_last_name &lt;&lt; <span class="string">"，地址: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制构造函数</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person&amp; source)</span><br><span class="line">        : m_first_name(source.m_first_name), m_last_name(source.m_last_name), m_age(source.m_age) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"复制构造函数被调用！复制 "</span> &lt;&lt; source.m_first_name &lt;&lt; <span class="string">" "</span> &lt;&lt; source.m_last_name &lt;&lt; <span class="string">"，新地址: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数 (用于观察对象生命周期结束)</span></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数被调用！销毁 "</span> &lt;&lt; m_first_name &lt;&lt; <span class="string">" "</span> &lt;&lt; m_last_name &lt;&lt; <span class="string">"，地址: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印信息的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; m_first_name &lt;&lt; <span class="string">" "</span> &lt;&lt; m_last_name</span><br><span class="line">                  &lt;&lt; <span class="string">", 年龄: "</span> &lt;&lt; m_age &lt;&lt; <span class="string">", 地址: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新年龄的方法 (用于练习)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取姓名，用于复制构造函数中打印</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">get_first_name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_first_name; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">get_last_name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_last_name; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_first_name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_last_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PERSON_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code> 文件:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;    // 使用 std::array 来定义固定大小的数组</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;   // 也可以使用 std::vector，行为类似</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;  // For size_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span> <span class="comment">// 包含我们定义的 Person 类</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"------ 原始 Person 对象创建 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"张"</span>, <span class="string">"三"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"李"</span>, <span class="string">"四"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"王"</span>, <span class="string">"五"</span>, <span class="number">22</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 原始 Person 对象信息 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p1.print_info();</span><br><span class="line">    p2.print_info();</span><br><span class="line">    p3.print_info();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 场景一：将 Person 对象放入数组 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 当数组初始化时，会调用复制构造函数</span></span><br><span class="line">    <span class="comment">// 使用 std::array&lt;Person, 3&gt; 比 C 风格数组更安全、方便</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;Person, 3&gt; students = &#123;p1, p2, p3&#125;; </span><br><span class="line">    <span class="comment">// 或者 C 风格数组: Person students[] = &#123;p1, p2, p3&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 数组中 Person 对象的信息 (通过传统for循环) ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 传统for循环不会创建副本，直接操作数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; students.size(); ++i) &#123;</span><br><span class="line">        students[i].print_info();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 场景二：范围for循环 (按值传递，创建副本) ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 每次迭代都会创建 Person 对象的副本，会调用复制构造函数</span></span><br><span class="line">    <span class="keyword">int</span> iteration_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Person p : students) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  - 迭代 "</span> &lt;&lt; ++iteration_count &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        p.print_info(); <span class="comment">// 这里的 p 是副本，地址与数组中的原始元素不同</span></span><br><span class="line">        p.set_age(p.get_last_name().length() + <span class="number">100</span>); <span class="comment">// 尝试修改副本</span></span><br><span class="line">    &#125; <span class="comment">// 每次迭代结束，副本 p 会被销毁，调用析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 验证数组中原始对象是否被修改 (通过传统for循环) ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 再次打印数组元素，证明上面的修改只作用于副本</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; students.size(); ++i) &#123;</span><br><span class="line">        students[i].print_info(); <span class="comment">// 原始年龄未变</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 场景三：范围for循环 (按引用传递，避免复制) ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 每次迭代都会直接引用 Person 元素，不会调用复制构造函数</span></span><br><span class="line">    iteration_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Person&amp; p_ref : students) &#123; <span class="comment">// 注意这里的 &amp;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  - 迭代 "</span> &lt;&lt; ++iteration_count &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        p_ref.print_info(); <span class="comment">// 这里的 p_ref 是引用，地址与数组中的原始元素相同</span></span><br><span class="line">        p_ref.set_age(p_ref.get_last_name().length() + <span class="number">50</span>); <span class="comment">// 尝试修改原始元素</span></span><br><span class="line">    &#125; <span class="comment">// 循环结束，没有副本销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 验证数组中原始对象是否被修改 (通过传统for循环) ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 再次打印数组元素，证明上面的修改已作用于原始元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; students.size(); ++i) &#123;</span><br><span class="line">        students[i].print_info(); <span class="comment">// 年龄已被修改</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 使用常量引用遍历 (只读，避免复制) ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 每次迭代都是常量引用，无法修改原始元素，也不会创建副本</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Person&amp; p_const_ref : students) &#123; <span class="comment">// 注意这里的 const &amp;</span></span><br><span class="line">        p_const_ref.print_info();</span><br><span class="line">        <span class="comment">// p_const_ref.set_age(1); // 编译错误！不能修改常量引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ main 函数结束，对象销毁 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// p1, p2, p3 和 students 数组中的对象会在这里被销毁</span></span><br></pre></td></tr></table></figure></div>
<p><strong>编译和运行：</strong><br>在终端中使用 <code>g++</code> 编译：<br><code>g++ main.cpp Person.cpp -o my_program -std=c++17</code> (如果使用 string_view)<br>或 <code>g++ main.cpp Person.cpp -o my_program</code> (如果只使用 C++98/03)<br>然后运行：<code>./my_program</code></p>
<p>观察输出，您会清楚地看到复制构造函数在何时被调用，以及对象的内存地址何时变化。</p>
<hr>
<h2 id="QA-闪存卡-Flash-Cards"><a href="#QA-闪存卡-Flash-Cards" class="headerlink" title="QA 闪存卡 (Flash Cards)"></a>QA 闪存卡 (Flash Cards)</h2><ol>
<li><strong>问：</strong> 将现有对象放入C++数组中时，会发生什么？<br><strong>答：</strong> 会创建原始对象的<strong>副本</strong>，并为每个副本调用其<strong>复制构造函数</strong>。数组中存储的是副本，而不是原始对象本身。</li>
<li><strong>问：</strong> 默认情况下，范围for循环（<code>for (Type var : collection)</code>）如何遍历对象集合？<br><strong>答：</strong> 每次迭代时，它会为当前元素创建一个<strong>副本</strong>，并将该副本赋给循环变量<code>var</code>。每次迭代都会调用复制构造函数。</li>
<li><strong>问：</strong> 如何在范围for循环中避免对象复制？<br><strong>答：</strong> 使用<strong>引用</strong>或<strong>常量引用</strong>。例如，<code>for (Type&amp; var : collection)</code> 或 <code>for (const Type&amp; var : collection)</code>。这样循环变量将直接引用原始元素，而不是创建副本。</li>
<li><strong>问：</strong> 传统的for循环（<code>for (size_t i = 0; i &lt; size; ++i)</code>）在访问数组元素时会创建对象副本吗？<br><strong>答：</strong> 不会。它直接通过索引访问数组中的<strong>原始元素</strong>，不涉及任何副本的创建。</li>
<li><strong>问：</strong> 为什么理解和避免不必要的对象复制在C++中很重要？<br><strong>答：</strong> 重要的原因包括：<strong>提高程序性能</strong>（尤其对于大型对象），<strong>减少内存使用</strong>，确保您在循环中<strong>正确修改原始数据</strong>（而不是副本），以及避免因不当复制导致的<strong>资源管理问题</strong>（如双重释放）。</li>
</ol>
<hr>
<h2 id="常见的误解或编程错误"><a href="#常见的误解或编程错误" class="headerlink" title="常见的误解或编程错误"></a>常见的误解或编程错误</h2><ol>
<li><p><strong>误解：以为对象放入数组是直接存储原始对象。</strong></p>
<ul>
<li><strong>正确理解：</strong> 数组初始化时会创建副本。例如，<code>Person students[] = {p1, p2, p3};</code> 会调用 <code>p1</code>, <code>p2</code>, <code>p3</code> 的复制构造函数，在 <code>students</code> 数组中生成三个独立的 <code>Person</code> 对象。</li>
<li><strong>可能导致的问题：</strong> 如果 <code>p1</code> 后续被修改，<code>students[0]</code> 不会随之改变，因为它们是独立的。</li>
</ul>
</li>
<li><p><strong>误解：以为范围for循环中的循环变量直接就是原数组元素。</strong></p>
<ul>
<li><strong>正确理解：</strong> 默认情况下（<code>for (Type var : collection)</code>），循环变量 <code>var</code> 是原始元素的一个副本。</li>
<li><strong>可能导致的问题：</strong> 在循环中对 <code>var</code> 进行修改，但却发现原始数组中的元素没有任何变化。这是因为您修改的是副本，而不是原始数据。</li>
</ul>
</li>
<li><p><strong>错误：在范围for循环中修改了副本，却期望原始对象也被修改。</strong></p>
<ul>
<li><strong>场景：</strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;Person, 3&gt; students = &#123;p1, p2, p3&#125;;</span><br><span class="line"><span class="keyword">for</span> (Person p : students) &#123; <span class="comment">// p 是副本</span></span><br><span class="line">    p.set_age(p.get_age() + <span class="number">1</span>); <span class="comment">// 修改的是副本的年龄</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 期望：students 数组中的年龄都加了1</span></span><br><span class="line"><span class="comment">// 实际：students 数组中的年龄没有变化</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>解决方法：</strong> 使用引用 <code>for (Person&amp; p : students)</code>。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;Person, 3&gt; students = &#123;p1, p2, p3&#125;;</span><br><span class="line"><span class="keyword">for</span> (Person&amp; p : students) &#123; <span class="comment">// p 是引用</span></span><br><span class="line">    p.set_age(p.get_age() + <span class="number">1</span>); <span class="comment">// 修改的是原始元素的年龄</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 期望：students 数组中的年龄都加了1</span></span><br><span class="line"><span class="comment">// 实际：students 数组中的年龄确实加了1</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li><p><strong>误解：对于大型复杂对象，忽视复制带来的性能开销。</strong></p>
<ul>
<li><strong>问题：</strong> 如果一个对象包含大量数据（例如一个图像处理类，里面有几兆字节的像素数据），每次复制都会导致这些大量数据被完整拷贝一份。这会严重影响程序的运行速度和内存使用。</li>
<li><strong>正确实践：</strong> 尽可能通过引用（<code>&amp;</code> 或 <code>const &amp;</code>）或智能指针（如 <code>std::shared_ptr</code>, <code>std::unique_ptr</code>）来传递或存储大型对象，以避免不必要的昂贵复制操作。</li>
</ul>
</li>
<li><p><strong>误解：混淆了浅拷贝和深拷贝的概念，尤其是在涉及动态内存管理时。</strong></p>
<ul>
<li><strong>问题：</strong> 如果您的类中包含指向动态分配内存的指针，而您没有自定义复制构造函数（或赋值运算符），C++默认生成的复制构造函数只会执行<strong>浅拷贝</strong>——它只复制指针本身，而不是指针所指向的数据。这将导致两个对象拥有同一个内存块的所有权。当其中一个对象被销毁时，它会释放该内存块；而当另一个对象被销毁时，它会尝试再次释放同一个内存块，导致<strong>双重释放</strong>错误。</li>
<li><strong>解决方案（预告，下一讲）：</strong> 需要实现<strong>深拷贝</strong>。深拷贝的复制构造函数会为新对象重新分配内存，并将原始对象的数据复制到这块新内存中，确保每个对象拥有自己独立的资源。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h2><p>现在，是时候动手实践一下了！</p>
<p>请根据我们上面提供的 <code>Person.h</code> 文件（请自行创建并确保内容正确）。</p>
<p>在 <code>main.cpp</code> 中，您需要完成以下任务：</p>
<ol>
<li>在 <code>main</code> 函数中，创建三个 <code>Person</code> 对象，例如 <code>personA(&quot;爱&quot;, &quot;丽丝&quot;, 20)</code>, <code>personB(&quot;鲍&quot;, &quot;勃&quot;, 35)</code>, <code>personC(&quot;查理&quot;, &quot;周&quot;, 28)</code>。</li>
<li>声明并初始化一个 <code>std::array&lt;Person, 3&gt;</code> 类型的数组 <code>myStudents</code>，并使用您刚刚创建的三个 <code>Person</code> 对象来初始化它。</li>
<li>使用一个<strong>不创建副本</strong>的范围for循环遍历 <code>myStudents</code> 数组。<ul>
<li>在循环体内，将每个学生的年龄都<strong>增加 3 岁</strong>。</li>
<li>在更新年龄后，打印每个学生的完整信息（姓名、年龄和内存地址），以验证年龄是否已更新，并且是作用于原始数组中的元素。</li>
</ul>
</li>
</ol>
<p>请将您的 <code>main.cpp</code> 代码填充完整，并确保它能正确编译和运行。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span> <span class="comment">// 确保 Person.h 文件与本文件在同一目录下</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"------ 原始 Person 对象创建 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 1. 在这里创建三个 Person 对象: personA, personB, personC</span></span><br><span class="line">    <span class="comment">// 例如: Person personA("爱", "丽丝", 20);</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 数组初始化 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 2. 声明并初始化一个 std::array&lt;Person, 3&gt; 类型的数组 myStudents，</span></span><br><span class="line">    <span class="comment">//    使用 personA, personB, personC 进行初始化。</span></span><br><span class="line">    <span class="comment">// 例如: std::array&lt;Person, 3&gt; myStudents = &#123; /* 您的对象 */ &#125;;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 使用不创建副本的范围for循环更新年龄并打印 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 3. 使用一个不创建副本的范围for循环遍历 myStudents 数组。</span></span><br><span class="line">    <span class="comment">//    在循环体内，将每个学生的年龄都增加 3 岁，然后打印他们的信息。</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ main 函数结束 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请您完成 <code>main.cpp</code> 中的空白部分，然后我会检查您的解决方案。</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">           <span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span> <span class="comment">// 确保 Person.h 文件与本文件在同一目录下</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"------ 原始 Person 对象创建 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 1. 在这里创建三个 Person 对象: personA, personB, personC</span></span><br><span class="line">    <span class="comment">// 例如: Person personA("爱", "丽丝", 20);</span></span><br><span class="line">    <span class="function">Person <span class="title">personA</span><span class="params">(<span class="string">"爱"</span>, <span class="string">"丽丝"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">personB</span><span class="params">(<span class="string">"鲍"</span>, <span class="string">"勃"</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">personC</span><span class="params">(<span class="string">"查理"</span>, <span class="string">"周"</span>, <span class="number">28</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 数组初始化 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 2. 声明并初始化一个 std::array&lt;Person, 3&gt; 类型的数组 myStudents，</span></span><br><span class="line">    <span class="comment">//    使用 personA, personB, personC 进行初始化。</span></span><br><span class="line">    <span class="comment">// 例如: std::array&lt;Person, 3&gt; myStudents = &#123; /* 您的对象 */ &#125;;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;Person, 3&gt; myStudents = &#123;personA, personB, personC&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 使用不创建副本的范围for循环更新年龄并打印 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 3. 使用一个不创建副本的范围for循环遍历 myStudents 数组。</span></span><br><span class="line">    <span class="comment">//    在循环体内，将每个学生的年龄都增加 3 岁，然后打印他们的信息。</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (Person&amp; person: myStudents)</span><br><span class="line">    &#123;</span><br><span class="line">        person.set_age(person.get_age() + <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Person&amp; person: myStudents)</span><br><span class="line">    &#123;</span><br><span class="line">        person.print_info();</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ main 函数结束 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，您提交了非常棒的解决方案！作为您的导师，我很高兴地告诉您，您完全理解了本次课程的核心概念，并且代码编写得非常正确。</p>
<hr>
<h2 id="7-解决方案评估与讲解"><a href="#7-解决方案评估与讲解" class="headerlink" title="7. 解决方案评估与讲解"></a>7. 解决方案评估与讲解</h2><p><strong>您的得分：5/5</strong></p>
<p><strong>评估：</strong></p>
<ul>
<li><strong>完全正确！</strong> 您的代码完美地实现了所有要求，创建了 <code>Person</code> 对象，正确地初始化了 <code>std::array</code>，并最关键地，使用了<strong>引用（<code>Person&amp; person</code>）</strong>的范围for循环来遍历数组，成功地在不创建副本的情况下修改了原始数组中的元素。</li>
<li><strong>概念理解透彻：</strong> 您通过 <code>Person&amp;</code> 避免了复制，这直接证明了您对范围for循环中引用（[reference]）作用的理解。</li>
<li><strong>代码清晰：</strong> 您的代码结构清晰，易于阅读和理解。</li>
</ul>
<p><strong>小建议（非错误）：</strong></p>
<p>您将更新年龄和打印信息分成了两个独立的循环。虽然功能上完全正确，但为了更紧凑地展示“更新后立即打印”的效果，并且避免第二次遍历的额外开销（尽管对于小数组影响微乎其微），通常会把这两步放在同一个循环中。这只是一个风格和效率上的微小优化，您的做法没有任何功能性错误。</p>
<hr>
<h2 id="实际答案与详细讲解"><a href="#实际答案与详细讲解" class="headerlink" title="实际答案与详细讲解"></a>实际答案与详细讲解</h2><p>以下是整合了年龄更新和打印的解决方案，以及对您代码的详细讲解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt; // For size_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span> <span class="comment">// 确保 Person.h 文件与本文件在同一目录下</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"------ 原始 Person 对象创建 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 1. 在这里创建三个 Person 对象: personA, personB, personC</span></span><br><span class="line">    <span class="function">Person <span class="title">personA</span><span class="params">(<span class="string">"爱"</span>, <span class="string">"丽丝"</span>, <span class="number">20</span>)</span></span>; <span class="comment">// 调用 Person 的构造函数，创建对象 personA</span></span><br><span class="line">    <span class="function">Person <span class="title">personB</span><span class="params">(<span class="string">"鲍"</span>, <span class="string">"勃"</span>, <span class="number">35</span>)</span></span>; <span class="comment">// 调用 Person 的构造函数，创建对象 personB</span></span><br><span class="line">    <span class="function">Person <span class="title">personC</span><span class="params">(<span class="string">"查理"</span>, <span class="string">"周"</span>, <span class="number">28</span>)</span></span>; <span class="comment">// 调用 Person 的构造函数，创建对象 personC</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 数组初始化 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 2. 声明并初始化一个 std::array&lt;Person, 3&gt; 类型的数组 myStudents，</span></span><br><span class="line">    <span class="comment">//    使用 personA, personB, personC 进行初始化。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;Person, 3&gt; myStudents = &#123;personA, personB, personC&#125;; <span class="comment">// 这一行将调用 Person 类的复制构造函数3次</span></span><br><span class="line">                                                                     <span class="comment">// 分别将 personA, personB, personC 的内容复制到 myStudents[0], myStudents[1], myStudents[2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ 使用不创建副本的范围for循环更新年龄并打印 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 3. 使用一个不创建副本的范围for循环遍历 myStudents 数组。</span></span><br><span class="line">    <span class="comment">//    在循环体内，将每个学生的年龄都增加 3 岁，然后打印他们的信息。</span></span><br><span class="line">    <span class="keyword">for</span> (Person&amp; person_ref : myStudents) <span class="comment">// **关键点：使用 Person&amp; person_ref**</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里的 person_ref 是对 myStudents 数组中原始元素的引用。</span></span><br><span class="line">        <span class="comment">// 它没有创建新的 Person 对象副本，因此不会调用复制构造函数。</span></span><br><span class="line">        <span class="comment">// person_ref 的内存地址与数组中对应元素的内存地址相同。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前年龄并增加 3 岁</span></span><br><span class="line">        person_ref.set_age(person_ref.get_age() + <span class="number">3</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印更新后的学生信息</span></span><br><span class="line">        person_ref.print_info(); <span class="comment">// 验证年龄已更新，且地址与数组中的原始元素一致</span></span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n------ main 函数结束 ------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>代码解析：</strong></p>
<ol>
<li><p><strong>对象创建 (<code>personA</code>, <code>personB</code>, <code>personC</code>)：</strong><br>当您声明 <code>Person personA(&quot;爱&quot;, &quot;丽丝&quot;, 20);</code> 时，<code>Person</code> 类的构造函数被调用，在内存中为 <code>personA</code> 分配空间并初始化其成员。您会看到打印出 <code>构造函数被调用！创建 爱 丽丝，地址: [某个地址]</code>。<code>personB</code> 和 <code>personC</code> 也是如此。</p>
</li>
<li><p><strong>数组初始化 (<code>myStudents</code>)：</strong><br><code>std::array&lt;Person, 3&gt; myStudents = {personA, personB, personC};</code><br>这行代码是本次课程中一个重要观察点。它会<strong>三次</strong>调用 <code>Person</code> 类的<strong>复制构造函数</strong>。</p>
<ul>
<li><code>personA</code> 的内容被复制到 <code>myStudents[0]</code>。</li>
<li><code>personB</code> 的内容被复制到 <code>myStudents[1]</code>。</li>
<li><code>personC</code> 的内容被复制到 <code>myStudents[2]</code>。<br>您会看到类似 <code>复制构造函数被调用！复制 爱 丽丝，新地址: [myStudents[0]的地址]</code> 的输出。这里的 <code>myStudents</code> 数组中存储的是原始 <code>personA</code>, <code>personB</code>, <code>personC</code> 对象的独立副本，它们的内存地址与原始对象不同。</li>
</ul>
</li>
<li><p><strong>使用引用进行范围for循环 (<code>for (Person&amp; person_ref : myStudents)</code>)：</strong><br>这是您解决方案的精髓所在。<code>Person&amp; person_ref</code> 中的 <code>&amp;</code> 符号至关重要。它表示 <code>person_ref</code> 是一个<strong>引用</strong>。</p>
<ul>
<li><strong>不创建副本：</strong> 当循环遍历 <code>myStudents</code> 数组时，<code>person_ref</code> 直接绑定到数组中的每个原始 <code>Person</code> 元素（例如 <code>myStudents[0]</code>, <code>myStudents[1]</code>, <code>myStudents[2]</code>），而<strong>不会创建新的 <code>Person</code> 副本</strong>。因此，您不会在循环中看到“复制构造函数被调用”的信息。</li>
<li><strong>直接操作原始元素：</strong> 对 <code>person_ref</code> 调用的 <code>set_age()</code> 方法会直接修改 <code>myStudents</code> 数组中对应元素的 <code>m_age</code> 成员。</li>
<li><strong>验证：</strong> <code>person_ref.print_info()</code> 打印出的内存地址将与 <code>myStudents</code> 数组中对应元素的实际内存地址完全一致，进一步证明了我们操作的是原始数据，而不是副本。</li>
</ul>
</li>
</ol>
<p>您的解决方案完美地展示了如何通过使用引用来避免不必要的对象复制，以及如何直接操作容器中的原始数据。非常棒！</p>
<hr>
<h2 id="8-建议与扩展问题-Suggestions-and-Extended-Questions"><a href="#8-建议与扩展问题-Suggestions-and-Extended-Questions" class="headerlink" title="8. 建议与扩展问题 (Suggestions and Extended Questions)"></a>8. 建议与扩展问题 (Suggestions and Extended Questions)</h2><p>您已经掌握了C++中对象复制和引用的基本概念，这为您未来的学习打下了坚实的基础。接下来，我建议您深入思考以下问题，这将有助于您更好地理解C++中的内存管理和性能优化：</p>
<ol>
<li><p><strong>析构函数的调用时机：</strong></p>
<ul>
<li>在您目前的 <code>Person</code> 类中，我们添加了析构函数 <code>~Person()</code>。</li>
<li>请思考，当您的 <code>main</code> 函数运行结束时，哪些 <code>Person</code> 对象的析构函数会被调用？它们被调用的顺序大概是怎样的？</li>
<li>如果您在范围for循环中<strong>不</strong>使用引用 (<code>for (Person p : myStudents)</code>)，那么在每次循环迭代结束时，会发生什么？为什么会发生？（提示：观察析构函数的调用）。</li>
</ul>
</li>
<li><p><strong>常量引用 (<code>const Person&amp;</code>) 的应用：</strong></p>
<ul>
<li>在您的 <code>main.cpp</code> 代码中，您已经成功地使用 <code>Person&amp;</code> 修改了数组中的元素。</li>
<li>现在，如果您的目标只是<strong>读取</strong>数组中每个学生的信息，而<strong>不希望修改</strong>它们，您会如何修改 <code>for</code> 循环的声明？</li>
<li>请尝试使用 <code>const Person&amp;</code> 遍历数组并打印信息。如果尝试在循环中调用 <code>set_age()</code>，会发生什么？为什么？</li>
</ul>
</li>
<li><p><strong><code>std::vector</code> 与对象复制：</strong></p>
<ul>
<li>目前我们使用的是 <code>std::array</code>。<code>std::vector</code> 是C++中更常用的一种动态数组。</li>
<li>当您将 <code>Person</code> 对象 <code>push_back</code> 到 <code>std::vector</code> 中时，会发生对象复制吗？请编写一个小程序来验证您的猜测（同样通过观察复制构造函数的调用）。</li>
<li><code>std::vector</code> 的 <code>emplace_back</code> 方法与 <code>push_back</code> 在某些情况下可以避免复制。您可以尝试研究并比较它们之间的差异。</li>
</ul>
</li>
<li><p><strong>浅拷贝与深拷贝 (Shallow Copy vs. Deep Copy)：</strong></p>
<ul>
<li>在本节课中，我们提到了“浅拷贝”和“深拷贝”的概念，并指出默认的复制构造函数可能导致“双重释放”等问题。</li>
<li>请您设想一个 <code>Book</code> 类，它有一个 <code>char* title</code> 成员，用于存储书名（假设是动态分配的）。如果您不对 <code>Book</code> 类进行任何特殊处理，直接使用默认的复制构造函数，然后尝试复制一个 <code>Book</code> 对象，您认为会发生什么问题？</li>
<li>如果要在这种情况下正确复制 <code>Book</code> 对象，您需要如何修改 <code>Book</code> 类？（这会是下一节课的重点，但您可以提前思考）。</li>
</ul>
</li>
</ol>
<p>希望这些扩展问题能激发您更深入的思考，并帮助您构建更强大的C++知识体系！期待您在下一节课中的表现。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Software/">Software    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Objects/">Objects    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/304%20-%20%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%AA%83%E5%8F%96/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>304 - 移动构造函数窃取</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/312%20-%20cpp%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>312 - cpp 友元函数详解</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/323 - cpp静态成员函数/" title="323 - cpp静态成员函数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">323 - cpp静态成员函数</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/Cpp 默认构造函数创建对象/" title="Cpp 默认构造函数创建对象"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">Cpp 默认构造函数创建对象</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/275 - getter and setter/" title="275 - getter and setter"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">275 - getter and setter</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/261 - Type traits/" title="261 - Type traits"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">261 - Type traits</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/274 - default constructor/" title="274 - default constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">274 - default constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/273 - constructor/" title="273 - constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">273 - constructor</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>