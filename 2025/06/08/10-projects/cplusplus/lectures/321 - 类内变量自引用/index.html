<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>321 - 类内变量自引用 | Bear's dream</title><meta name="description" content="321 - 类内变量自引用"><meta name="keywords" content="Cpp,Coding,Developer,Class,Programming"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="321 - 类内变量自引用"><meta name="twitter:description" content="321 - 类内变量自引用"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="321 - 类内变量自引用"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/321%20-%20%E7%B1%BB%E5%86%85%E5%8F%98%E9%87%8F%E8%87%AA%E5%BC%95%E7%94%A8/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="321 - 类内变量自引用"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/321%20-%20%E7%B1%BB%E5%86%85%E5%8F%98%E9%87%8F%E8%87%AA%E5%BC%95%E7%94%A8/"><link rel="prev" title="344  - cpp 内联变量函数解决 ODR" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/344%20%20-%20cpp%20%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%20ODR/"><link rel="next" title="Pandas_Basic_Command_Quick_Check_Table" href="https://yxiong.org/2025/06/08/30-resources/coding/python/Pandas_Basic_Command_Quick_Check_Table/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">152</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#类内变量自引用"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">类内变量自引用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-类成员变量的“自我引用”之谜：深入解析不完整类型"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">C++ 类成员变量的“自我引用”之谜：深入解析不完整类型</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-详细讲解"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">1. 详细讲解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-引言：你可能遇到的困境"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">1.1 引言：你可能遇到的困境</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-问题根源：“不完整类型”错误"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">1.2 问题根源：“不完整类型”错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-解决方案一：使用指针"><span class="toc_mobile_items-number">2.1.3.</span> <span class="toc_mobile_items-text">1.3 解决方案一：使用指针</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-4-解决方案二：使用静态成员变量"><span class="toc_mobile_items-number">2.1.4.</span> <span class="toc_mobile_items-text">1.4 解决方案二：使用静态成员变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-5-总结与最佳实践"><span class="toc_mobile_items-number">2.1.5.</span> <span class="toc_mobile_items-text">1.5 总结与最佳实践</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-详细代码示例"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">2. 详细代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-问答闪卡-QA-Flash-Cards"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">3. 问答闪卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-常见误解或错误"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">4. 常见误解或错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-编程练习"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">5. 编程练习</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-2"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-2"><span class="toc_mobile_items-number">2.9.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-评分与答案解析"><span class="toc_mobile_items-number">2.10.</span> <span class="toc_mobile_items-text">7. 评分与答案解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Point-h-文件"><span class="toc_mobile_items-number">2.10.1.</span> <span class="toc_mobile_items-text">Point.h 文件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Point-cpp-文件"><span class="toc_mobile_items-number">2.10.2.</span> <span class="toc_mobile_items-text">Point.cpp 文件</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#实际答案"><span class="toc_mobile_items-number">2.11.</span> <span class="toc_mobile_items-text">实际答案</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-建议与扩展问题"><span class="toc_mobile_items-number">2.12.</span> <span class="toc_mobile_items-text">8. 建议与扩展问题</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#类内变量自引用"><span class="toc-number">1.</span> <span class="toc-text">类内变量自引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-类成员变量的“自我引用”之谜：深入解析不完整类型"><span class="toc-number">2.</span> <span class="toc-text">C++ 类成员变量的“自我引用”之谜：深入解析不完整类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-详细讲解"><span class="toc-number">2.1.</span> <span class="toc-text">1. 详细讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-引言：你可能遇到的困境"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 引言：你可能遇到的困境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-问题根源：“不完整类型”错误"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 问题根源：“不完整类型”错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-解决方案一：使用指针"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 解决方案一：使用指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-解决方案二：使用静态成员变量"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 解决方案二：使用静态成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-总结与最佳实践"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.5 总结与最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-详细代码示例"><span class="toc-number">2.2.</span> <span class="toc-text">2. 详细代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-问答闪卡-QA-Flash-Cards"><span class="toc-number">2.3.</span> <span class="toc-text">3. 问答闪卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-常见误解或错误"><span class="toc-number">2.4.</span> <span class="toc-text">4. 常见误解或错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-编程练习"><span class="toc-number">2.5.</span> <span class="toc-text">5. 编程练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">2.6.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">2.7.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-2"><span class="toc-number">2.8.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-2"><span class="toc-number">2.9.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-评分与答案解析"><span class="toc-number">2.10.</span> <span class="toc-text">7. 评分与答案解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Point-h-文件"><span class="toc-number">2.10.1.</span> <span class="toc-text">Point.h 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Point-cpp-文件"><span class="toc-number">2.10.2.</span> <span class="toc-text">Point.cpp 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实际答案"><span class="toc-number">2.11.</span> <span class="toc-text">实际答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-建议与扩展问题"><span class="toc-number">2.12.</span> <span class="toc-text">8. 建议与扩展问题</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">321 - 类内变量自引用</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/321%20-%20%E7%B1%BB%E5%86%85%E5%8F%98%E9%87%8F%E8%87%AA%E5%BC%95%E7%94%A8/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/321%20-%20%E7%B1%BB%E5%86%85%E5%8F%98%E9%87%8F%E8%87%AA%E5%BC%95%E7%94%A8/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="类内变量自引用"><a href="#类内变量自引用" class="headerlink" title="类内变量自引用"></a>类内变量自引用</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to explore the case where you are declaring the class, but at the sametime you want to use member variables of the same class.Let’s look at an example here We have a point class.It is an innocent point class.We have a public section inside.We have a private section inside and down here.You see we have a bunch of problematic member variables.You see, we are setting up member variables of type point in the declaration of the class point.And sometimes you want to do this.And a possible example of this is, for example, if you want to set up the origin point and you wantto model something like line, you will need the origin point or the starting point for the line, andyou might model that as a member variable inside the point class here.So this is something possible.But if you try to set up your member variables in any of these ways, if you set up like an origin pointone here or make it const or make it a static inline const variable, you’re going to get a compilererror that says that the type is incomplete here.And what this really means is that you are trying to set up a variable of the class you haven’t finishedbuilding yet or setting up yet, so the compiler isn’t really going to have enough information to setup this member variables.This is the message here.Okay.So if you try to use any of these syntaxes, this is not going to work and you need to be aware of this.However, there are ways we can make this work.For example, if we make the member variable a pointer like you see here, the compiler is going totake this because a pointer really is not a pointer type.It is just a pointer to a point.And we have the option to specify this point later when our program is running.So again, this is going to work because the PM origin point for here is not a point type.It is a pointer to a point type.So this is going to work.If we have a setup like this, we might want to initialize our pointer member variable like we see hereand initialize this with null pointer.And this is going to work if you use null pointer, but if you don’t use null pointer and for exampleinside your initializer you say new point you’re trying to set up a new point you’re going to get somethingwrong.Try to think about this.You are trying to build a point.This is a constructor for the point class and in the same constructor we are trying to call anotherconstructor.We say New point here and this is going to call the constructor again.So what this is going to do is really set up a chain of recursive calls to the constructor for pointand it will keep calling itself, for example, billions of times.And at some point you’re going to run out of heap memory and your program is going to crash.Please note that C plus plus is not going to protect you from this, or I should say C plus plus compilersare not going to protect you from this.A solution to this is to initialize our pointer with null pointer and later set it up if we really needto do this when the object has already been constructed, we’re going to see an example of this in awhile If this is not making sense yet.So bear with me.This is going to work in a minute.Another way we can set up member variables of point here is to use static member variables like this.The static member variables can either be constant or not const.This is going to work because this is going to delegate the initialization of point at some later pointin an implementation file or a CPP file.And the linker is going to look for this later when the program actually gets to run.So the compiler is basically going to say, okay, I see a setup for a member variable for a point,but I can leave it for later to really put in a value and I’m going to accept this.The syntax is going to work because the C plus plus compiler is going to see that it can initializethis properly later when we hit the linker stage and we are building our program.So this syntax is going to work here, but you need to be aware of the syntaxes that are going to giveyou compiler errors and you need to be aware of these errors here.Okay.With these member variables in place, we can initialize them in a CPP file.For example, here we are initializing M origin 0.5 and here we are putting value inside M origin 0.6.And this is going to work just fine.Now that you know this, I think it is time we headed over to Visual Studio code and play with thisa little more.Okay, Here we are in our working folder.The current project is Member Variables of Type Self.We are going to reuse a project we have done before, and that’s what we see here in line static membervariables.And we’re going to grab whatever we have inside.We’re going to grab the VS code folder here.We’re going to grab the main CPP file and the point class, but we’re going to leave out the binaryhere for Rooster because we’re going to be generating our own.We’re going to grab those files and put them in the current project and we are going to open this upa little bit in Visual Studio Code.This is going to open our project and we will have our main CPP file.We can remove anything we have inside because we’re going to be setting up things later and we’re goingto open the point class, the header and the CPP file.Let’s do that.Okay, so we have our class here and we want to set up a member variables of the point class that weare declaring here and we’re going to see how this plays out.I am going to go on top here and put all this in its own public section.It’s not going to matter if it is public or private, but I want this to be separate from our privatemember variables here.So we’re going to set up a point member variable.It’s going to be point and we’re going to call this end point one.And if we try to do this, notice what we have here.Okay?So let’s try and build before we put this in to try and prove that the program is just going to workfine and it is going to be the change that we have here that is going to break our program.You see, the build is good.So let’s put our point one in here.And the moment we do this, we’re going to get a squiggly line from Visual Studio code.This is going to be a warning and it is going to say incomplete type is not allowed because at thispoint we are trying to set up a point member variable, but the class is not declared to completionyet, so the compiler won’t really know how to set up this.You’re going to get an incomplete type compiler error.Okay, so this is what I want you to be aware of.If we ignore the warning from Visual Studio code and just move on with whatever we want to do, we’regoing to get a compiler error and it is going to say the same thing.Failed End Point one has incomplete type point because we haven’t finished building the point classyet and we want to set up its own member variable.So this is not going to work.If we try and make this const, for example, we say const point M point two here.This is also not going to work.We’re going to get the same compiler error.Let’s wait for Visual Studio code to realize the problem.We’re going to get a squiggly line and again, we’re going to say failed point two, incomplete type.We should say point two, let’s build again.We’re going to use GCC and now the problem should be updated.Point two has incomplete type and the compiler error is going to say the same thing.M 0.1 or M point two has an incomplete type, so we can’t do this either.So this is also going to give us the same compiler error.But if we try to set up a static variable and make it inline, we’re also going to get the same problembecause that will force the compiler to initialize the variable in place here.And that’s not going to work.We’re going to get the same compiler error here.Let’s give you an example.We’re going to say static inline const and say point and say M point three, let’s say three here.So if we try to say static inline const point and say M point three and try to initialize this for example,because we can do this, if the variable is inline, we’re going to get the same compiler error becausethe type is incomplete.We’re going to get this because the compiler will try to initialize this guy, but we don’t have enoughinformation to build a point object.So we’re going to get an incomplete type compiler error.Let’s build this so that you can really see this with your own eyes.The build is going to give us an error because we don’t have enough information to build a point objectlike we do here yet.So we’re going to get the same compiler error.Okay, so now you know this, but there is a way we can have member variables of the same type, evenif the type is not complete yet.One way to do this is to use a pointer.So for example, if we say point pointer and say p m point and say for here you see that this is notgoing to give us a compiler error.In fact it is going to compile.We’re going to build with GCC and we’re going to see that the world is good.So this is valid syntax.The reason this is working is because the pointer to a point is really not a point.So the compiler has no problem setting up this guy because all it really needs to know is that thisis a pointer.It is going to have the size of a point.Later on my system and the compiler can leave the details it doesn’t have for later when somebody triesto store something in this pointer.So this is going to work.We’re not going to get the same compiler error we had here.Let’s save the errors for all the other cases here so that it is super clear let’s do that.But this is going to work.Okay.So if this is taken in, we can grab this and try to initialize this when we build any point objectthrough the constructor.So for example, we can come here and say we can put this in front.I think we can do that and we can initialize this with null pointer, for example.And this is going to work through our initializer list.Let’s use curly braces because we want to be consistent here and this is going to work.You see, if we try to build, the build is going to be good.Okay.This is building successfully.But one problem some people might have is if they try, for example, to initialize this using the newoperator and try to construct a point in place.I know some people are going to do this.Let’s take out null pointer here and say new point.Okay, if we do this this is going to call our constructor here and we’re going to land in this placehere.But try to think about what we are doing here.If we come in main, for example, and say point P one and we say something like this, this is goingto come and call our constructor here, which is not taking any parameter.We’re going to delegate to our constructor on top here, and this constructor will try to set up a newpoint object because that’s what we are saying here.But this is also going to call this constructor again and we will keep calling this constructor endlesslyand at some point the compiler is going to see that this function is calling itself repeatedly, andwe’re going to be allocating memory.For example, for billions of times, and we are going to run out of heap memory for our program andwe are going to get a crash.Let’s try and run it to really show you this.The compiler is not going to protect us from this.So the world is really good.We can clear.But if we run Rooster, notice what happens here.The program is basically going to keep creating new point objects because the constructor is callingitself billions of times.And at some point we’re going to crash the program.The operating system is going to say, this program is crazy.It is creating billions and billions of objects of point type.So it is going to die.If we wait, we’re going to see that this program is going to die.But I don’t want to wait.All this time you have seen the main message here.It is crashing.It is not doing anything.We can hit Ctrl C to stop this.And now you know that this is really bad.You shouldn’t do this.If you want to do something like this, it is advised to initialize your pointer to null pointer andthen do the work to put in some data later.When you want to do this, for example, we can go in our point class here, the declaration for thisand we can set up a function to initialize that pointer member variable.For example, we can say initialize our pointer, let’s say initialize pointer and we’re going to putin the values we can use to initialize that and we’re going to initialize our pointer member variable,for example, we can grab that here.I think it is this little guy here.We can grab that and say we want to initialize this pointer and we’re going to create a point objectand we’re going to let this pointer point to this.When you do this, the initialization of this memory location is going to be left for later when a pointerobject has been already created.For example, here, if we have 0.1 here, we can come down and say 0.1 and say initialize.How did we call the method?We can grab the name here.I don’t remember the name and we can say initialize our guy using ten and ten, for example, and thisis going to work.Let’s world you’re going to see that the compiler is going to accept this and we have a problem here.Which problem do we have request for member initialized pointer in P one which is of non-class typepoint.For example, if we use the point here and here we have a problem.What we put here is not really good syntax to create a point object.This is not going to create our point object.This is basically going to be interpreted by the compiler as the function called P one, which is notgoing to take any parameter and it’s going to return a point object by value.So sorry for this.This is referred to in C plus plus as the most vexing course and it is basically a.Situation in which Cplusplus can’t really know if we are declaring a point.Object or declaring a function.And this is a situation in which Cplusplus is going to be confused and think we are creating a declarationfor a function when we really want to create a point object to remove this confusion.For example, we can either remove the parentheses here.This is going to be a point.This is going to call the default constructor that we have declared here.Or we could just pass in parameters.We can, for example, pass in five and five.We can do this.This is going to be a valid point.Now that the valid point is created, we’re going to take it and say initialize pointer and we can passin whatever we want.Let’s pass in ten and ten and our pointer member variable is now going to be initialized to a pointobject that is pointing to a point with these values inside.And if we print it, we’re going to get the information for our point in place.For example, if we say this guy and say print info, we’re going to see the information and this isgoing to work just fine.If we build this is going to build fine.Let’s see this.You’re going to see that the build is good.We don’t really care to print the information because if we do, this is just going to give us let’ssee what we’re going to get.If we print information, we’re just going to print the addresses for the member variables.And this is really not what we are interested in.But the important bit is that we had to initialize our pointer member variable after a point objectwas already created because if we go in the constructor and try to say new point here, we’re goingto get a problem because we’re going to get the constructor to call itself multiple times and we’renot even going to hit the body.We’re going to be basically keeping calling the point constructor and the program is basically goingto hang and eventually it is going to crash When we run out of memory for the point objects here.So we don’t want this.We want to initialize this to a null pointer here and then initialize that pointer through some memberfunction if we need to do that.Okay.This covers the point where we want to set up a pointer member variable.We’re going to comment this out and I am going to show you two other scenarios where this is going towork and this is basically going to work if we use static member variables, but we don’t make theminline, we leave the initialization for them in some CPP file.So let’s do that.We’re going to say static const point and we’re going to say End point four and we’re going to set upanother one, which is not cost.We’re going to say static point and say end point five, this is going to work and we can head overin the CPP file and initialize these guys.We can copy them and put them in the CPP file and we can come on top here and we can say const point.We’re going to remove the static here and we’re going to say that this is declared in the point classand we’re going to initialize this to a point object.We can do that.We can say point, for example, and put in a value of four and five.Why not?This is going to work and we can do the same for this little guy here.So let’s take out the static.This is going to be our type and we’re going to say that this is a variable from the point class andwe’re going to initialize this to some point, let’s say point, for example, and use curly bracesand put in three and eight.This is going to work.If we try to use these guys, we’re going to get what we expect.And we took out this pointer.I think we should bring it back because it’s not going to crash our program or give us a compiler errorso we can build again.If we build, you’re going to see that this is going to work.You see, the build is good.We can use member variables of type self if we are declaring static variables and not making them inline.This is really all I wanted you to see in this lecture.I hope you found it interesting.If you happen to want to set up a member variables of the same class you are declaring, you shouldreally be careful because if you use the syntax we see here, you’re going to get a compiler error.But if you avoid this syntaxes and for example, use pointers or static member variables that are notin line, this is going to work because for pointers, the C plus plus compiler is going to say, okay,this is a pointer, I can leave it for later to put in the details and you can initialize the pointerlater when you are creating your object here.This is going to work for static member variables.You’re going to leave the proper initialization of the variables in some CPP file and the compiler isgoing to take this.And it is going to work really well.So, for example, we have these guys initialized here.We have M 0.4.I think we can grab this in the main function and use it.For example, we can say P1M 0.4.We can have access to that and we can say print a full let’s change what printing full does think thisis going to be educational?Let’s go in and change that to say and print the member variables instead instead of printing the addressesdirectly, we can do that.So we’re going to say M, y and m X here and we’re going to build again.The world should be good, so we’re going to clear and run Rooster and we’re going to print the informationin 0.4.And if we go in our CPP file, we’re going to see that we initialized that to four and five, and that’swhat we see here.It is working exactly like we want.We are going to stop here in this lecture.In the next one, we’re going to see that we don’t have this limitations.If the member variable is not of self type and we are using our own class types.So go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，很高兴能为您揭开 C++ 中“类成员变量自我引用”这个有趣而又常见的谜团。作为您专属的 C++ 导师，我将尽力用最清晰、最易懂的方式来讲解，并确保您能掌握所有关键概念。</p>
<hr>
<h1 id="C-类成员变量的“自我引用”之谜：深入解析不完整类型"><a href="#C-类成员变量的“自我引用”之谜：深入解析不完整类型" class="headerlink" title="C++ 类成员变量的“自我引用”之谜：深入解析不完整类型"></a>C++ 类成员变量的“自我引用”之谜：深入解析不完整类型</h1><p><strong>摘要</strong>：本讲座将深入探讨 C++ 中一个常见的编译问题：在类声明（<a href="class declaration">class declaration</a>）中，尝试将自身类型作为成员变量（<a href="member variable">member variable</a>）时，编译器会报告“不完整类型”（<a href="incomplete type">incomplete type</a>）错误。我们将详细解释其原因，并提供两种有效的解决方案：使用指针（<a href="pointer">pointer</a>）或静态成员变量（<a href="static member variable">static member variable</a>），同时揭示相关陷阱与最佳实践。</p>
<hr>
<h2 id="1-详细讲解"><a href="#1-详细讲解" class="headerlink" title="1. 详细讲解"></a>1. 详细讲解</h2><h3 id="1-1-引言：你可能遇到的困境"><a href="#1-1-引言：你可能遇到的困境" class="headerlink" title="1.1 引言：你可能遇到的困境"></a>1.1 引言：你可能遇到的困境</h3><p>在 C++ 编程中，我们经常会创建类（<a href="class">class</a>）来模拟现实世界的概念。例如，一个 <code>Point</code> 类可以代表一个二维坐标点。有时，你可能会遇到一种特殊的需求：你希望在一个类内部，声明一个该类自身类型的成员变量。</p>
<p>举个例子，假设你正在设计一个 <code>Point</code> 类，但你又想在 <code>Point</code> 类中预设一个“原点”（<a href="origin point">origin point</a>）作为其成员。或者，如果你正在建模一条线（<a href="line">line</a>），你可能会认为 <code>Point</code> 类内部需要一个 <code>startPoint</code> 或 <code>endPoint</code>。虽然对于 <code>Point</code> 类本身来说，这种设计可能不常见（通常原点是全局常量或静态成员），但它确实是我们在更复杂的场景中可能遇到的情况，例如链表（<a href="linked list">linked list</a>）节点，其中每个节点包含一个指向下一个节点的指针。</p>
<p>那么，如果我们尝试这样做，会发生什么呢？</p>
<h3 id="1-2-问题根源：“不完整类型”错误"><a href="#1-2-问题根源：“不完整类型”错误" class="headerlink" title="1.2 问题根源：“不完整类型”错误"></a>1.2 问题根源：“不完整类型”错误</h3><p>当你尝试在 <code>Point</code> 类的声明中直接定义一个 <code>Point</code> 类型的成员变量时，比如像这样：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point m_problematicPoint; <span class="comment">// 尝试声明自身类型的成员变量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>C++ 编译器会立即报错，提示“不完整类型”（<a href="incomplete type">incomplete type</a>）。这是为什么呢？</p>
<p><strong>什么是“不完整类型”？</strong></p>
<p>简单来说，一个类型被认为是“不完整”的，意味着编译器在当前点还没有掌握这个类型的<strong>完整定义信息</strong>。具体来说，它不知道这个类型占多大内存空间（<a href="size">size</a>）、内部有哪些成员以及它们的内存布局（<a href="memory layout">memory layout</a>）。</p>
<p><strong>为什么会发生？</strong></p>
<p>想象一下编译器正在逐行阅读你的 <code>Point</code> 类定义：</p>
<ol>
<li>它看到了 <code>class Point {</code>，知道你正在定义一个名为 <code>Point</code> 的类。</li>
<li>然后它读到 <code>Point m_problematicPoint;</code>。此时，编译器需要为 <code>m_problematicPoint</code> 分配内存空间。但问题是，<code>Point</code> 类本身的定义<strong>还没有结束</strong>！编译器不知道 <code>Point</code> 到底有多大，它还在等待 <code>{ ... };</code> 之间的内容来完成 <code>Point</code> 的定义。</li>
<li>这就形成了一个“鸡生蛋，蛋生鸡”的死循环：为了定义 <code>Point</code>，编译器需要知道 <code>m_problematicPoint</code> 的大小；但为了知道 <code>m_problematicPoint</code> 的大小，它需要知道 <code>Point</code> 的完整大小，而 <code>Point</code> 的完整大小又依赖于 <code>m_problematicPoint</code> 的大小。</li>
</ol>
<p>由于这种循环依赖，编译器无法确定 <code>Point</code> 类的总大小和内存布局，因此它会给出“不完整类型”的错误。</p>
<p><strong>失败的例子</strong></p>
<p>以下几种尝试都会导致相同的“不完整类型”编译错误：</p>
<ul>
<li><strong>直接声明非指针/引用类型的成员变量：</strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point m_point1; <span class="comment">// 错误：不完整类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>声明 <code>const</code> 类型的成员变量：</strong> <code>const</code> 关键字并不能解决问题，因为编译器仍然需要知道 <code>Point</code> 的完整大小。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> Point m_point2; <span class="comment">// 错误：不完整类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>声明 <code>static inline const</code> 类型的成员变量：</strong> <code>static</code> 成员变量的定义通常在类外，但 <code>inline</code> 关键字（尤其在 C++17 之后）会强制要求变量在类声明时就地（<a href="in-place">in-place</a>）定义和初始化。这就回到了不完整类型的问题。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> Point m_point3 = Point(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 错误：不完整类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
对于 <code>static inline</code> 变量，编译器在遇到它时就需要知道其完整的类型信息以便进行初始化，但此时 <code>Point</code> 仍未完整定义。</li>
</ul>
<h3 id="1-3-解决方案一：使用指针"><a href="#1-3-解决方案一：使用指针" class="headerlink" title="1.3 解决方案一：使用指针"></a>1.3 解决方案一：使用指针</h3><p>尽管不能直接声明自身类型的成员变量，但我们可以使用<strong>指针</strong>来解决这个问题。</p>
<p><strong>工作原理</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point* pm_origin_point; <span class="comment">// 正确：声明一个指向 Point 类型的指针</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>为什么使用指针就可以呢？</p>
<p>指针的奥秘在于：一个指针变量它本身的大小是<strong>固定</strong>的（通常是 4 字节或 8 字节，取决于你的系统架构），无论它指向什么类型。当你声明 <code>Point* pm_origin_point;</code> 时，编译器只需要知道 <code>pm_origin_point</code> 是一个指针，就可以确定它在 <code>Point</code> 对象中需要占用多大空间。它不需要知道 <code>Point</code> 类的完整定义，因为它现在只关心“指针”本身的大小。</p>
<p>真正的 <code>Point</code> 对象可以在 <code>Point</code> 类定义完成后，在程序运行时动态地（<a href="dynamically">dynamically</a>）创建，并将其地址赋值给这个指针。</p>
<p><strong>陷阱：在构造函数中 <code>new Point()</code></strong></p>
<p>虽然使用指针解决了编译问题，但这里有一个非常重要的陷阱需要避免：<strong>不要在类的构造函数中直接使用 <code>new Point()</code> 来初始化这个指针成员变量。</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point* pm_origin_point;</span><br><span class="line"></span><br><span class="line">    Point() &#123;</span><br><span class="line">        pm_origin_point = <span class="keyword">new</span> Point(); <span class="comment">// 极度危险！会导致无限递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>让我们分析一下为什么危险：</p>
<ol>
<li>当你创建一个 <code>Point</code> 对象（例如 <code>Point p1;</code>）时，<code>Point</code> 的构造函数会被调用。</li>
<li>进入构造函数后，它会执行 <code>pm_origin_point = new Point();</code>。</li>
<li><code>new Point()</code> 这行代码的含义是<strong>再次调用 <code>Point</code> 类的构造函数</strong>来创建一个新的 <code>Point</code> 对象。</li>
<li>这个新的 <code>Point</code> 对象被创建时，它的构造函数又会再次被调用，然后它又会尝试 <code>new Point()</code>…</li>
</ol>
<p>这就形成了一个<strong>无限递归</strong>（<a href="infinite recursion">infinite recursion</a>）的循环。每次递归调用都会在内存中分配一个新的 <code>Point</code> 对象，并且会占用栈（<a href="stack">stack</a>）空间来存储当前的函数调用信息。很快，你的程序就会：</p>
<ul>
<li><strong>耗尽堆内存</strong>（<a href="heap memory exhaustion">heap memory exhaustion</a>）：因为不断地 <code>new</code> 新对象。</li>
<li><strong>栈溢出</strong>（<a href="stack overflow">stack overflow</a>）：因为无限的函数调用导致栈空间耗尽。</li>
</ul>
<p>最终，你的程序会崩溃（<a href="crash">crash</a>）。C++ 编译器通常<strong>不会</strong>检测这种运行时逻辑错误并保护你，它只会按照你写的代码去执行。</p>
<p><strong>非代码示例</strong>：<br>想象你是一家玩具厂的工人，正在组装一个叫做“点”的复杂玩具。这个“点”玩具的说明书上写着：“玩具内部包含一个叫做‘子点’的小玩具。”然后，“子点”的说明书上又写着：“‘子点’玩具内部包含一个叫做‘子子点’的小玩具。”如果你按照这个说明书开始组装，你就会陷入一个永无止境的组装过程，永远完不成第一个“点”玩具的组装，直到你用光了所有零件和工作台空间。这就是在构造函数中 <code>new Point()</code> 的问题。</p>
<p><strong>正确做法</strong></p>
<p>为了避免上述问题，正确的做法是：</p>
<ol>
<li>在构造函数中，将指针成员变量初始化为 <code>nullptr</code>（空指针），表示它当前不指向任何有效的 <code>Point</code> 对象。</li>
<li>在 <code>Point</code> 对象<strong>已经完全构造成功后</strong>，通过一个单独的成员函数来动态创建 <code>Point</code> 对象并赋值给指针。</li>
</ol>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point* pm_origin_point;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Point() : pm_origin_point(<span class="literal">nullptr</span>) &#123; <span class="comment">// 使用初始化列表将指针初始化为 nullptr</span></span><br><span class="line">        <span class="comment">// 构造函数体</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于初始化指针成员变量的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializePointer</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pm_origin_point == <span class="literal">nullptr</span>) &#123; <span class="comment">// 避免重复分配</span></span><br><span class="line">            pm_origin_point = <span class="keyword">new</span> Point(x, y); <span class="comment">// 这里可以安全地创建新 Point 对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数（重要！别忘了释放动态分配的内存）</span></span><br><span class="line">    ~Point() &#123;</span><br><span class="line">        <span class="keyword">delete</span> pm_origin_point;</span><br><span class="line">        pm_origin_point = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这样，<code>Point</code> 对象的构造函数不会陷入递归，只有在需要时才通过 <code>initializePointer</code> 函数动态创建并分配内存。</p>
<h3 id="1-4-解决方案二：使用静态成员变量"><a href="#1-4-解决方案二：使用静态成员变量" class="headerlink" title="1.4 解决方案二：使用静态成员变量"></a>1.4 解决方案二：使用静态成员变量</h3><p>另一种解决“不完整类型”问题的方法是使用<strong>静态成员变量</strong>。</p>
<p><strong>工作原理</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Point sm_point4; <span class="comment">// 正确：静态常量成员变量</span></span><br><span class="line">    <span class="keyword">static</span> Point sm_point5;       <span class="comment">// 正确：静态非常量成员变量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>为什么静态成员变量可以呢？</p>
<p>静态成员变量与普通成员变量有本质区别：</p>
<ul>
<li><strong>不属于对象实例</strong>：静态成员变量不属于任何一个 <code>Point</code> 对象实例。它们是属于类本身的，在整个程序运行期间只存在一份。</li>
<li><strong>定义在类外部</strong>：静态成员变量的声明在类内部，但它们的<strong>定义和初始化</strong>通常发生在类定义之外，通常是在一个 <code>.cpp</code> 源文件中。</li>
</ul>
<p>当编译器处理 <code>Point</code> 类的声明时，它看到 <code>static Point sm_point4;</code>。它只知道 <code>Point</code> 类有一个静态成员 <code>sm_point4</code>，但它不需要立即知道 <code>sm_point4</code> 的完整定义来确定 <code>Point</code> 类的总大小，因为它不包含在每个 <code>Point</code> 对象中。<code>sm_point4</code> 的实际内存分配和初始化被推迟到<strong>链接阶段</strong>（<a href="linker stage">linker stage</a>）。此时，<code>Point</code> 类已经完全定义，所以链接器能够正确地找到并初始化 <code>sm_point4</code>。</p>
<p><strong>初始化方式</strong></p>
<p>静态成员变量的定义和初始化需要在 <code>.cpp</code> 文件中进行（如果它们不是 <code>const</code> 整型或枚举类型且在类内初始化）。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Point.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span> <span class="comment">// 确保包含 Point 类的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态常量成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Point <span class="title">Point::sm_point4</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>; <span class="comment">// 此时 Point 类已完整定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态非常量成员变量</span></span><br><span class="line"><span class="function">Point <span class="title">Point::sm_point5</span><span class="params">(<span class="number">3</span>, <span class="number">8</span>)</span></span>; <span class="comment">// 此时 Point 类已完整定义</span></span><br></pre></td></tr></table></figure></div>
<h3 id="1-5-总结与最佳实践"><a href="#1-5-总结与最佳实践" class="headerlink" title="1.5 总结与最佳实践"></a>1.5 总结与最佳实践</h3><ul>
<li><strong>不要直接声明自身类型的非指针/非引用成员变量。</strong> 这会导致“不完整类型”编译错误，因为编译器无法在类定义完成前确定其大小。</li>
<li><strong>使用指针成员变量。</strong> 这是常见的解决方案，因为指针的大小是固定的，不依赖于其所指向类型的完整定义。<ul>
<li><strong>切记！</strong> 避免在构造函数中 <code>new</code> 自身类型，这会导致无限递归和程序崩溃。</li>
<li><strong>最佳实践：</strong> 在构造函数中将指针初始化为 <code>nullptr</code>，并在对象构造完成后通过单独的成员函数或外部逻辑进行动态分配和初始化。同时，不要忘记在析构函数中 <code>delete</code> 释放动态分配的内存，以避免内存泄漏（<a href="memory leak">memory leak</a>）。</li>
</ul>
</li>
<li><strong>使用静态成员变量。</strong> 静态成员变量在类外部定义和初始化，它们的初始化被推迟到链接阶段，此时类已完整定义。<ul>
<li><code>static inline</code> 的情况需要注意，因为 <code>inline</code> 会强制就地初始化，可能再次引入不完整类型问题（尽管在某些特定场景下，如果类型足够简单，它可能允许）。但为了安全起见，通常不推荐对自身类型的 <code>static inline</code> 成员使用。</li>
</ul>
</li>
</ul>
<p>通过理解这些原则，你可以自信地处理 C++ 中类成员变量的“自我引用”场景。</p>
<h2 id="2-详细代码示例"><a href="#2-详细代码示例" class="headerlink" title="2. 详细代码示例"></a>2. 详细代码示例</h2><p>我们将创建一个 <code>Point</code> 类，展示各种情况。</p>
<p><strong><code>Point.h</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once <span class="comment">// 确保头文件只被编译一次</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x; <span class="comment">// X 坐标</span></span><br><span class="line">    <span class="keyword">int</span> m_y; <span class="comment">// Y 坐标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数 (为了防止隐式拷贝导致的问题，这里简单声明)</span></span><br><span class="line">    Point(<span class="keyword">const</span> Point&amp; other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Point();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印信息函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 尝试失败的成员变量声明 ---</span></span><br><span class="line">    <span class="comment">// Point m_point1_fail;                    // 错误：不完整类型</span></span><br><span class="line">    <span class="comment">// const Point m_point2_fail;              // 错误：不完整类型</span></span><br><span class="line">    <span class="comment">// static inline const Point m_point3_fail = Point(0, 0); // 错误：不完整类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 解决方案一：使用指针成员变量 ---</span></span><br><span class="line">    Point* pm_self_pointer; <span class="comment">// 指向自身类型的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于初始化指针成员变量的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeSelfPointer</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 解决方案二：使用静态成员变量 ---</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Point sm_point_static_const; <span class="comment">// 静态常量成员变量 (声明)</span></span><br><span class="line">    <span class="keyword">static</span> Point sm_point_static_non_const;   <span class="comment">// 静态非常量成员变量 (声明)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>Point.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span> <span class="comment">// 包含 Point 类的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  // 用于输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量的定义和初始化</span></span><br><span class="line"><span class="comment">// 注意：这里 Point 类已经完整定义，所以可以安全地创建 Point 对象</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Point <span class="title">Point::sm_point_static_const</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">Point::sm_point_static_non_const</span><span class="params">(<span class="number">300</span>, <span class="number">400</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数实现</span></span><br><span class="line">Point::Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : m_x(x), m_y(y), pm_self_pointer(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Constructor called for ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 警告：以下是错误示范，切勿在实际代码中使用</span></span><br><span class="line">    <span class="comment">// pm_self_pointer = new Point(); // 导致无限递归！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数实现（简单示例）</span></span><br><span class="line">Point::Point(<span class="keyword">const</span> Point&amp; other) : m_x(other.m_x), m_y(other.m_y), pm_self_pointer(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Copy Constructor called for ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 如果原对象指针有值，可能需要深拷贝，这里为了演示，只初始化为 nullptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数实现</span></span><br><span class="line">Point::~Point() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Destructor called for ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (pm_self_pointer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  - Deleting pm_self_pointer..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> pm_self_pointer; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">        pm_self_pointer = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印信息函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::printInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Info: (X: "</span> &lt;&lt; m_x &lt;&lt; <span class="string">", Y: "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (pm_self_pointer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  pm_self_pointer points to: "</span>;</span><br><span class="line">        pm_self_pointer-&gt;printInfo(); <span class="comment">// 递归调用打印，注意防止无限递归</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  pm_self_pointer is nullptr."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于初始化指针成员变量的函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::initializeSelfPointer</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pm_self_pointer == <span class="literal">nullptr</span>) &#123; <span class="comment">// 避免重复创建和内存泄漏</span></span><br><span class="line">        pm_self_pointer = <span class="keyword">new</span> Point(x, y); <span class="comment">// 安全地创建新 Point 对象</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  pm_self_pointer initialized to new Point("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  pm_self_pointer already initialized. Skipping."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span> <span class="comment">// 包含 Point 类的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 演示指针成员变量的正确使用 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">myPoint</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 创建一个 Point 对象</span></span><br><span class="line">    myPoint.printInfo(); <span class="comment">// 此时 pm_self_pointer 为 nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过成员函数安全地初始化指针</span></span><br><span class="line">    myPoint.initializeSelfPointer(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    myPoint.printInfo(); <span class="comment">// 此时 pm_self_pointer 已指向新 Point 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试再次初始化（会被跳过，因为已检查 nullptr）</span></span><br><span class="line">    myPoint.initializeSelfPointer(<span class="number">15</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 演示静态成员变量的使用 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 静态成员变量可以通过类名直接访问</span></span><br><span class="line">    Point::sm_point_static_const.printInfo();</span><br><span class="line">    Point::sm_point_static_non_const.printInfo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员变量也可以通过对象访问，但不推荐，因为容易误解其属性</span></span><br><span class="line">    <span class="comment">// myPoint.sm_point_static_const.printInfo(); // 语法上允许，但不推荐</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 演示构造函数中 `new Point()` 的危险性 (请勿取消注释运行!) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 如果你在 Point::Point() 构造函数中取消注释 `pm_self_pointer = new Point();`</span></span><br><span class="line">    <span class="comment">// 下面这行代码会导致程序无限循环并最终崩溃</span></span><br><span class="line">    <span class="comment">// Point problematicPoint; // 运行这行会崩溃！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 程序结束 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="3-问答闪卡-QA-Flash-Cards"><a href="#3-问答闪卡-QA-Flash-Cards" class="headerlink" title="3. 问答闪卡 (QA Flash Cards)"></a>3. 问答闪卡 (QA Flash Cards)</h2><ol>
<li><p><strong>Q1: 为什么不能直接在 C++ 类中声明一个自身类型的成员变量（例如 <code>Point p;</code>）？</strong><br><strong>A1:</strong> 因为这会导致“不完整类型”编译错误。编译器在处理类定义时，需要知道每个成员变量的完整大小和内存布局，但如果成员变量是自身类型，则其定义尚未完成，编译器无法确定其大小。</p>
</li>
<li><p><strong>Q2: 有哪些方法可以声明自身类型的成员变量并避免“不完整类型”问题？</strong><br><strong>A2:</strong> 主要有两种方法：</p>
<ul>
<li>使用<strong>指针</strong>（<a href="pointer">pointer</a>）类型（例如 <code>Point* p;</code>）。</li>
<li>使用<strong>静态成员变量</strong>（<a href="static member variable">static member variable</a>）（例如 <code>static Point p;</code>）。</li>
</ul>
</li>
<li><p><strong>Q3: 在类的构造函数中，对指针成员变量使用 <code>new ClassType()</code>（例如 <code>new Point()</code>）会带来什么问题？</strong><br><strong>A3:</strong> 这会导致<strong>无限递归</strong>（<a href="infinite recursion">infinite recursion</a>）调用该类的构造函数。每次调用都会尝试创建新的对象，最终耗尽堆内存和栈空间，导致程序崩溃（<a href="crash">crash</a>）。</p>
</li>
<li><p><strong>Q4: 为什么静态成员变量可以避免“不完整类型”问题？</strong><br><strong>A4:</strong> 静态成员变量不属于任何对象实例，它们在类外部（通常在 <code>.cpp</code> 文件中）进行定义和初始化。它们的内存分配和初始化被推迟到<strong>链接阶段</strong>（<a href="linker stage">linker stage</a>），此时该类已经完整定义，因此编译器和链接器都能正确处理。</p>
</li>
</ol>
<h2 id="4-常见误解或错误"><a href="#4-常见误解或错误" class="headerlink" title="4. 常见误解或错误"></a>4. 常见误解或错误</h2><ol>
<li><p><strong>误解 1：认为 <code>Point p;</code> 只是一个声明，应该没问题，编译器会自己解决。</strong></p>
<ul>
<li><strong>解释：</strong> 对于非指针或引用类型的成员变量，它们是类实例的一部分。这意味着每个 <code>Point</code> 对象创建时，都需要为 <code>p</code> 分配内存。为了确定 <code>Point</code> 对象的总大小，编译器必须知道 <code>p</code> 的完整大小。在类定义期间，<code>Point</code> 尚未完整定义，因此无法确定 <code>p</code> 的大小。</li>
</ul>
</li>
<li><p><strong>误解 2：认为 <code>static inline</code> 的静态成员变量可以解决所有问题，因为 <code>static</code> 允许在类外定义。</strong></p>
<ul>
<li><strong>解释：</strong> <code>inline</code> 关键字（尤其在 C++17 之后）表示变量可以在多个编译单元中定义，并且其初始化可能会被要求<strong>就地</strong>（<a href="in-place">in-place</a>）完成。这意味着编译器在解析类声明时，会尝试对 <code>static inline const Point m_point3 = Point(0, 0);</code> 进行初始化。此时 <code>Point</code> 类型仍不完整，所以仍然会报错。</li>
</ul>
</li>
<li><p><strong>误解 3：天真地在构造函数中 <code>new Point()</code>，并期望编译器或运行时环境会聪明地阻止无限递归。</strong></p>
<ul>
<li><strong>解释：</strong> C++ 编译器通常专注于语法和类型检查，而不会智能地检测这种运行时逻辑错误（如无限递归）。当你尝试运行这种代码时，操作系统会在程序耗尽内存或栈空间时强制终止它。这是程序员需要<strong>主动规避</strong>的陷阱。</li>
</ul>
</li>
<li><p><strong>误解 4：在 C++ 中，<code>Point p1();</code> 是创建 <code>Point</code> 对象的方式。</strong></p>
<ul>
<li><strong>解释：</strong> 这是 C++ 中著名的“<strong>最令人烦恼的解析</strong>”（<a href="most vexing parse">most vexing parse</a>）。<code>Point p1();</code> 会被编译器解析为一个名为 <code>p1</code> 的函数声明，该函数不接受任何参数并返回一个 <code>Point</code> 类型的对象，而不是创建一个 <code>Point</code> 类型的对象。要创建一个 <code>Point</code> 对象并调用其默认构造函数，你应该写 <code>Point p1;</code>（C++98 风格）或 <code>Point p1{};</code>（C++11 统一初始化风格）。</li>
</ul>
</li>
</ol>
<h2 id="5-编程练习"><a href="#5-编程练习" class="headerlink" title="5. 编程练习"></a>5. 编程练习</h2><p>现在，是时候将所学知识付诸实践了！</p>
<p>请您完善下面的 <code>Point</code> 类的代码，使其能够：</p>
<ol>
<li>成功声明并使用一个指向自身类型的<strong>指针成员变量</strong>。</li>
<li>成功声明并使用一个<strong>静态成员变量</strong>（非 <code>const</code>）。</li>
<li>确保指针成员变量在构造函数中正确初始化为 <code>nullptr</code>。</li>
<li>实现一个成员函数来<strong>安全地</strong>为指针成员变量动态分配 <code>Point</code> 对象。</li>
<li>在 <code>.cpp</code> 文件中<strong>正确地</strong>定义和初始化静态成员变量。</li>
</ol>
<p><strong><code>Point.h</code> (请在标记处填写代码)</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 引入必要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Point();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印信息函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1: 声明一个指向 Point 类型的指针成员变量，命名为 'm_next_point'</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2: 声明一个静态成员变量，类型为 Point，命名为 's_default_point'</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 3: 声明一个成员函数，用于安全地初始化 'm_next_point' 指针。</span></span><br><span class="line">    <span class="comment">//         该函数应接受 x 和 y 坐标作为参数。</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>Point.cpp</code> (请在标记处填写代码)</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span> <span class="comment">// 包含 Point 类的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 4: 在这里定义和初始化静态成员变量 's_default_point'。</span></span><br><span class="line"><span class="comment">//         例如，可以将其初始化为 Point(0, 0)。</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数实现 (请确保 m_next_point 在这里被初始化为 nullptr)</span></span><br><span class="line">Point::Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : m_x(x), m_y(y) <span class="comment">/* TODO 5: 在这里初始化 m_next_point 为 nullptr */</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Constructor called for ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数实现 (请确保在这里释放 m_next_point 指向的内存)</span></span><br><span class="line">Point::~Point() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Destructor called for ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// TODO 6: 如果 m_next_point 不是 nullptr，释放其指向的内存，并将其设为 nullptr。</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印信息函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::printInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Info: (X: "</span> &lt;&lt; m_x &lt;&lt; <span class="string">", Y: "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// TODO 7: 如果 m_next_point 不是 nullptr，打印它所指向的 Point 对象的信息。</span></span><br><span class="line">    <span class="comment">//         否则，打印 "  m_next_point is nullptr."</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 8: 实现 initializeNextPoint 函数。</span></span><br><span class="line"><span class="comment">//         - 检查 m_next_point 是否为 nullptr。</span></span><br><span class="line"><span class="comment">//         - 如果是 nullptr，动态创建一个新的 Point 对象，并让 m_next_point 指向它。</span></span><br><span class="line"><span class="comment">//         - 否则，打印一条消息说明它已被初始化。</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code> (用于测试，无需修改)</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 测试 Point 类 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    p1.printInfo();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 初始化 p1 的 m_next_point ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p1.initializeNextPoint(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    p1.printInfo(); <span class="comment">// 应该显示 p1 和它指向的 m_next_point 的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 再次尝试初始化 p1 的 m_next_point (应被跳过) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p1.initializeNextPoint(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 访问静态成员变量 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Point::s_default_point.printInfo(); <span class="comment">// 应该显示静态默认点的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 程序即将结束，观察析构函数调用顺序 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请您填写上述代码中的 <code>TODO</code> 部分，完成后我会为您提供答案和反馈！</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>我想问下先， </p>
<p>// 打印信息函数实现<br>void Point::printInfo() const {<br>    std::cout &lt;&lt; “Point Info: (X: “ &lt;&lt; m_x &lt;&lt; “, Y: “ &lt;&lt; m_y &lt;&lt; “)” &lt;&lt; std::endl;<br>    if (pm_self_pointer != nullptr) {<br>        std::cout &lt;&lt; “  pm_self_pointer points to: “;<br>        pm_self_pointer-&gt;printInfo(); // 递归调用打印，注意防止无限递归<br>    } else {<br>        std::cout &lt;&lt; “  pm_self_pointer is nullptr.” &lt;&lt; std::endl;<br>    }</p>
<p>这个难道没有无限递归？</p>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常棒的问题！您观察得非常仔细，并且提出了一个关键的思考点。</p>
<p>您说得没错，<code>printInfo</code> 函数中的 <code>pm_self_pointer-&gt;printInfo();</code> 确实是一个<strong>递归调用</strong>（<a href="recursive call">recursive call</a>）。在某些情况下，递归调用<strong>确实可能导致无限循环和崩溃</strong>。</p>
<p>但在这里，我们为什么说它<strong>不会</strong>导致无限递归呢？这与我们如何<strong>初始化</strong>和<strong>管理</strong> <code>pm_self_pointer</code> 有关。</p>
<p>让我们来详细分析一下：</p>
<ol>
<li><p><strong>构造函数中的无限递归 (<code>new Point()</code>):</strong></p>
<ul>
<li>之前我们讨论的在构造函数中 <code>pm_self_pointer = new Point();</code> 导致无限递归，是因为每次调用 <code>Point</code> 构造函数时，它都会<strong>创建</strong>（<code>new</code>）一个新的 <code>Point</code> 对象，并且这个新对象的构造函数又会接着创建下一个 <code>Point</code> 对象。这个过程是<strong>不断产生新的内存分配和新的对象实例</strong>，直到内存耗尽。</li>
</ul>
</li>
<li><p><strong><code>printInfo</code> 中的递归 (<code>pm_self_pointer-&gt;printInfo()</code>):</strong></p>
<ul>
<li>在 <code>printInfo</code> 函数中，<code>pm_self_pointer-&gt;printInfo();</code> 仅仅是调用 <code>pm_self_pointer</code> 所<strong>指向的那个已经存在的 <code>Point</code> 对象</strong>的 <code>printInfo</code> 方法。它<strong>不会创建</strong>新的 <code>Point</code> 对象。</li>
<li><code>printInfo</code> 的递归会停止，因为它有一个<strong>终止条件</strong>（<a href="termination condition">termination condition</a>）：<code>if (pm_self_pointer != nullptr)</code>。<ul>
<li>当 <code>pm_self_pointer</code> 是 <code>nullptr</code> 时，递归就停止了，它会打印 “m_next_point is nullptr.”。</li>
<li>在我们给出的示例代码中，当一个 <code>Point</code> 对象被创建时，它的 <code>pm_self_pointer</code> 默认被初始化为 <code>nullptr</code>。只有通过 <code>initializeNextPoint</code> 方法，我们才会<strong>有一次机会</strong>让它指向一个新的 <code>Point</code> 对象。</li>
<li>也就是说，一个 <code>Point</code> 对象 <code>A</code> 最多只能指向一个 <code>Point</code> 对象 <code>B</code>。对象 <code>B</code> 的 <code>pm_self_pointer</code> 默认情况下也是 <code>nullptr</code>，除非我们手动去初始化 <code>B.initializeNextPoint()</code>。</li>
<li>因此，<code>printInfo</code> 最多只会递归调用一次（从 <code>A</code> 打印 <code>B</code>，然后 <code>B</code> 发现自己的 <code>pm_self_pointer</code> 是 <code>nullptr</code>，于是停止）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>举例说明</strong>：</p>
<p>假设你有这样的调用链：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>; <span class="comment">// p1.m_next_point = nullptr</span></span><br><span class="line">p1.initializeNextPoint(<span class="number">5</span>, <span class="number">5</span>); <span class="comment">// p1.m_next_point 指向了一个新创建的 Point(5,5)，我们称之为 p2</span></span><br><span class="line">                               <span class="comment">// 此时 p2.m_next_point = nullptr (默认值)</span></span><br><span class="line"></span><br><span class="line">p1.printInfo(); <span class="comment">// 调用过程：</span></span><br><span class="line">    <span class="comment">// 1. p1.printInfo() 被调用。</span></span><br><span class="line">    <span class="comment">// 2. 打印 p1 的信息 (X:1, Y:1)。</span></span><br><span class="line">    <span class="comment">// 3. 检查 p1.m_next_point (它指向 p2)，不为 nullptr。</span></span><br><span class="line">    <span class="comment">// 4. 调用 p2.printInfo()。</span></span><br><span class="line">        <span class="comment">// 5. p2.printInfo() 被调用。</span></span><br><span class="line">        <span class="comment">// 6. 打印 p2 的信息 (X:5, Y:5)。</span></span><br><span class="line">        <span class="comment">// 7. 检查 p2.m_next_point (它为 nullptr)。</span></span><br><span class="line">        <span class="comment">// 8. 打印 "  m_next_point is nullptr."。</span></span><br><span class="line">        <span class="comment">// 9. p2.printInfo() 执行完毕，返回。</span></span><br><span class="line">    <span class="comment">// 10. p1.printInfo() 执行完毕，返回。</span></span><br></pre></td></tr></table></figure></div>
<p>正如您所看到的，递归深度是有限的，并且最终会遇到 <code>nullptr</code> 作为终止条件。</p>
<p><strong>然而，您提出的警示是完全正确的！</strong></p>
<p>如果你的 <code>pm_self_pointer</code> 形成了一个<strong>循环引用</strong>（<a href="circular reference">circular reference</a>），例如：</p>
<ul>
<li><code>Point A</code> 的 <code>m_next_point</code> 指向 <code>Point B</code>。</li>
<li><code>Point B</code> 的 <code>m_next_point</code> 又指向 <code>Point A</code>。</li>
</ul>
<p>那么，当你调用 <code>A.printInfo()</code> 时：</p>
<ol>
<li><code>A.printInfo()</code> 打印 <code>A</code>，然后调用 <code>B.printInfo()</code>。</li>
<li><code>B.printInfo()</code> 打印 <code>B</code>，然后调用 <code>A.printInfo()</code>。</li>
<li>这将导致无限递归打印，最终耗尽栈空间并崩溃，因为 <code>printInfo</code> 没有机制检测到循环。</li>
</ol>
<p>这种<strong>循环引用</strong>是链表（<a href="linked list">linked list</a>）、图（<a href="graph">graph</a>）等数据结构中需要特别小心处理的问题，尤其是在实现打印、遍历或析构函数时。对于这种情况，通常需要额外的逻辑（例如使用 <code>std::set</code> 或 <code>std::unordered_set</code> 存储已访问的指针地址）来检测并避免无限循环。</p>
<p><strong>总结</strong>：</p>
<ul>
<li><strong><code>new Point()</code> 在构造函数中导致无限递归</strong>：是因为它<strong>无限创建新对象</strong>。</li>
<li><strong><code>printInfo</code> 在本例中不导致无限递归</strong>：是因为它只在<strong>已存在对象</strong>上进行操作，并且默认情况下 <code>pm_self_pointer</code> 只被初始化一次，形成一个有限的链条，且有 <code>nullptr</code> 作为明确的终止条件。</li>
<li><strong><code>printInfo</code> 可能导致无限递归</strong>：如果 <code>pm_self_pointer</code> 形成了<strong>循环引用</strong>，那就真的会无限递归。</li>
</ul>
<p>您的提问非常敏锐，它帮助我们更深入地理解了递归的风险和控制。请继续保持这种批判性思维！</p>
<hr>
<h2 id="🧑‍💻-User-2"><a href="#🧑‍💻-User-2" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>Point.h<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 引入必要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Point();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印信息函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1: 声明一个指向 Point 类型的指针成员变量，命名为 'm_next_point'</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    Point *m_next_point;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2: 声明一个静态成员变量，类型为 Point，命名为 's_default_point'</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">static</span> Point s_default_point;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 3: 声明一个成员函数，用于安全地初始化 'm_next_point' 指针。</span></span><br><span class="line">    <span class="comment">//         该函数应接受 x 和 y 坐标作为参数。</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeNextPoint</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p>
<p>Point.cpp<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span> <span class="comment">// 包含 Point 类的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 4: 在这里定义和初始化静态成员变量 's_default_point'。</span></span><br><span class="line"><span class="comment">//         例如，可以将其初始化为 Point(0, 0)。</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"><span class="function">Point <span class="title">Point::s_default_point</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数实现 (请确保 m_next_point 在这里被初始化为 nullptr)</span></span><br><span class="line">Point::Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : m_x(x), m_y(y) <span class="comment">/* TODO 5: 在这里初始化 m_next_point 为 nullptr */</span> &#123;</span><br><span class="line">    m_next_point = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Constructor called for ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数实现 (请确保在这里释放 m_next_point 指向的内存)</span></span><br><span class="line">Point::~Point() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Destructor called for ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// TODO 6: 如果 m_next_point 不是 nullptr，释放其指向的内存，并将其设为 nullptr。</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (m_next_point != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_next_point;</span><br><span class="line">        m_next_point = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destructor is called, release memory of m_next_point"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destructor is called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印信息函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::printInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Info: (X: "</span> &lt;&lt; m_x &lt;&lt; <span class="string">", Y: "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// TODO 7: 如果 m_next_point 不是 nullptr，打印它所指向的 Point 对象的信息。</span></span><br><span class="line">    <span class="comment">//         否则，打印 "  m_next_point is nullptr."</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (m_next_point != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_next_point-&gt;printInfo(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"m_next_point is nullptr"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 8: 实现 initializeNextPoint 函数。</span></span><br><span class="line"><span class="comment">//         - 检查 m_next_point 是否为 nullptr。</span></span><br><span class="line"><span class="comment">//         - 如果是 nullptr，动态创建一个新的 Point 对象，并让 m_next_point 指向它。</span></span><br><span class="line"><span class="comment">//         - 否则，打印一条消息说明它已被初始化。</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::initializeNextPoint</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_next_point == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_next_point = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"m_next_point has been initialized already"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<hr>
<h2 id="🤖-Assistant-2"><a href="#🤖-Assistant-2" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，我已经仔细审阅了您的代码。总的来说，您的解决方案非常出色，涵盖了所有要求，并且正确地应用了我们之前学到的知识。这表明您对这些概念理解得很好！</p>
<h2 id="7-评分与答案解析"><a href="#7-评分与答案解析" class="headerlink" title="7. 评分与答案解析"></a>7. 评分与答案解析</h2><p><strong>总体评分：4.5/5 星</strong></p>
<p>做得非常棒！您正确地解决了“不完整类型”的问题，并使用了指针和静态成员变量两种解决方案。内存管理（析构函数中的 <code>delete</code>）也处理得很好。</p>
<p>让我们逐一看看您的代码，并给出一些 C++ 最佳实践和细节优化建议。</p>
<hr>
<h3 id="Point-h-文件"><a href="#Point-h-文件" class="headerlink" title="Point.h 文件"></a><code>Point.h</code> 文件</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 引入必要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Point();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印信息函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1: 声明一个指向 Point 类型的指针成员变量，命名为 'm_next_point'</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    Point *m_next_point; <span class="comment">// 正确！声明了指向自身类型的指针。</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2: 声明一个静态成员变量，类型为 Point，命名为 's_default_point'</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">static</span> Point s_default_point; <span class="comment">// 正确！声明了静态成员变量。</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 3: 声明一个成员函数，用于安全地初始化 'm_next_point' 指针。</span></span><br><span class="line">    <span class="comment">//         该函数应接受 x 和 y 坐标作为参数。</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeNextPoint</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>; <span class="comment">// **建议优化：**参数类型应与 Point 构造函数匹配。</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>Point.h</code> 评价：</strong></p>
<ul>
<li><strong>TODO 1 和 TODO 2</strong>：完美！您正确声明了指针成员变量和静态成员变量。</li>
<li><strong>TODO 3</strong>：逻辑正确，但有个小细节可以优化。<code>Point</code> 类的构造函数是 <code>Point(int x, int y)</code>，它接受的是 <code>int</code> 类型。因此，<code>initializeNextPoint</code> 函数的参数最好也使用 <code>int</code> 类型，以避免潜在的浮点数到整数的隐式转换和精度丢失。虽然这里 <code>double</code> 到 <code>int</code> 的转换在大多数情况下会正常工作（直接截断小数部分），但在严谨的类型匹配上，使用 <code>int</code> 会更好。</li>
</ul>
<hr>
<h3 id="Point-cpp-文件"><a href="#Point-cpp-文件" class="headerlink" title="Point.cpp 文件"></a><code>Point.cpp</code> 文件</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span> <span class="comment">// 包含 Point 类的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 4: 在这里定义和初始化静态成员变量 's_default_point'。</span></span><br><span class="line"><span class="comment">//         例如，可以将其初始化为 Point(0, 0)。</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"><span class="function">Point <span class="title">Point::s_default_point</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 完美！正确在类外部定义并初始化了静态成员变量。</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数实现 (请确保 m_next_point 在这里被初始化为 nullptr)</span></span><br><span class="line">Point::Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : m_x(x), m_y(y) <span class="comment">/* TODO 5: 在这里初始化 m_next_point 为 nullptr */</span> &#123;</span><br><span class="line">    m_next_point = <span class="literal">nullptr</span>; <span class="comment">// 正确实现了初始化为 nullptr。</span></span><br><span class="line">                            <span class="comment">// **建议优化：** 最好使用成员初始化列表。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Constructor called for ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数实现 (请确保在这里释放 m_next_point 指向的内存)</span></span><br><span class="line">Point::~Point() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Destructor called for ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// TODO 6: 如果 m_next_point 不是 nullptr，释放其指向的内存，并将其设为 nullptr。</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (m_next_point != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_next_point;</span><br><span class="line">        m_next_point = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destructor is called, release memory of m_next_point"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destructor is called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 这行输出是多余的，但无害。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印信息函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::printInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Info: (X: "</span> &lt;&lt; m_x &lt;&lt; <span class="string">", Y: "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// TODO 7: 如果 m_next_point 不是 nullptr，打印它所指向的 Point 对象的信息。</span></span><br><span class="line">    <span class="comment">//         否则，打印 "  m_next_point is nullptr."</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (m_next_point != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  m_next_point points to: "</span>; <span class="comment">// **建议优化：** 增加此行，使输出更清晰。</span></span><br><span class="line">        m_next_point-&gt;printInfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  m_next_point is nullptr"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// -------------------------------------------------------------</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 8: 实现 initializeNextPoint 函数。</span></span><br><span class="line"><span class="comment">//         - 检查 m_next_point 是否为 nullptr。</span></span><br><span class="line"><span class="comment">//         - 如果是 nullptr，动态创建一个新的 Point 对象，并让 m_next_point 指向它。</span></span><br><span class="line"><span class="comment">//         - 否则，打印一条消息说明它已被初始化。</span></span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::initializeNextPoint</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> <span class="comment">// **建议优化：**参数类型应为 int。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_next_point == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_next_point = <span class="keyword">new</span> Point(x, y); <span class="comment">// 这里 double 到 int 的隐式转换。</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  m_next_point initialized to new Point("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// **建议优化：**增加此行，更清晰。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"m_next_point has been initialized already"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// **建议优化：** 增加 std::endl。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------------------------------------------------------</span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>Point.cpp</code> 评价：</strong></p>
<ul>
<li><strong>TODO 4</strong>：完美。</li>
<li><strong>TODO 5 (构造函数)</strong>：您正确地将 <code>m_next_point</code> 初始化为 <code>nullptr</code>。但是，在 C++ 中，对于成员变量的初始化，<strong>成员初始化列表</strong>（<a href="member initializer list">member initializer list</a>）是更推荐和更高效的方式。它在对象构造时直接初始化成员，而不是先默认构造（如果存在）再赋值。<ul>
<li><strong>您的写法：</strong> <code>Point(int x, int y) : m_x(x), m_y(y) { m_next_point = nullptr; ... }</code></li>
<li><strong>更佳写法：</strong> <code>Point(int x, int y) : m_x(x), m_y(y), m_next_point(nullptr) { ... }</code></li>
</ul>
</li>
<li><strong>TODO 6 (析构函数)</strong>：逻辑非常正确，确保了内存的释放，避免了内存泄漏（<a href="memory leak">memory leak</a>）。判断 <code>nullptr</code> 和置空指针都是好习惯。那句 <code>else</code> 分支的 <code>std::cout &lt;&lt; &quot;Destructor is called&quot; &lt;&lt; std::endl;</code> 是多余的，因为析构函数总是会被调用，这个输出没有提供额外的信息，反而可能造成混淆。</li>
<li><strong>TODO 7 (printInfo)</strong>：核心逻辑正确。为了输出更清晰，建议在递归调用 <code>m_next_point-&gt;printInfo()</code> 前也加上 <code>std::cout &lt;&lt; &quot; m_next_point points to: &quot;;</code> 这样可以清楚地看到层级关系。</li>
<li><strong>TODO 8 (initializeNextPoint)</strong>：<ul>
<li>逻辑非常正确，完美地实现了“只初始化一次”并避免了重复分配。</li>
<li>参数类型问题：与 <code>Point.h</code> 中的建议相同，将 <code>double x, double y</code> 改为 <code>int x, int y</code> 会与构造函数更匹配。</li>
<li>输出优化：在 <code>if</code> 和 <code>else</code> 分支中都加上 <code>std::endl</code> 会让输出更整洁，避免不同 <code>cout</code> 输出混在同一行。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="实际答案"><a href="#实际答案" class="headerlink" title="实际答案"></a>实际答案</h2><p>这是按照最佳实践和您的改进点修改后的代码：</p>
<p><strong><code>Point.h</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Point(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Point();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印信息函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1: 声明一个指向 Point 类型的指针成员变量，命名为 'm_next_point'</span></span><br><span class="line">    Point *m_next_point;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2: 声明一个静态成员变量，类型为 Point，命名为 's_default_point'</span></span><br><span class="line">    <span class="keyword">static</span> Point s_default_point;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 3: 声明一个成员函数，用于安全地初始化 'm_next_point' 指针。</span></span><br><span class="line">    <span class="comment">//         该函数应接受 x 和 y 坐标作为参数。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializeNextPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// 参数改为 int</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>Point.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 4: 在这里定义和初始化静态成员变量 's_default_point'。</span></span><br><span class="line"><span class="function">Point <span class="title">Point::s_default_point</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数实现</span></span><br><span class="line"><span class="comment">// TODO 5: 在这里初始化 m_next_point 为 nullptr</span></span><br><span class="line">Point::Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : m_x(x), m_y(y), m_next_point(<span class="literal">nullptr</span>) &#123; <span class="comment">// 使用成员初始化列表</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Constructor called for ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数实现</span></span><br><span class="line">Point::~Point() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Destructor called for ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// TODO 6: 如果 m_next_point 不是 nullptr，释放其指向的内存，并将其设为 nullptr。</span></span><br><span class="line">    <span class="keyword">if</span> (m_next_point != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  - Releasing memory for m_next_point..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 更具体的输出</span></span><br><span class="line">        <span class="keyword">delete</span> m_next_point;</span><br><span class="line">        m_next_point = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印信息函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::printInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Info: (X: "</span> &lt;&lt; m_x &lt;&lt; <span class="string">", Y: "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// TODO 7: 如果 m_next_point 不是 nullptr，打印它所指向的 Point 对象的信息。</span></span><br><span class="line">    <span class="comment">//         否则，打印 "  m_next_point is nullptr."</span></span><br><span class="line">    <span class="keyword">if</span> (m_next_point != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  m_next_point points to: "</span>; <span class="comment">// 增加此行，输出更清晰</span></span><br><span class="line">        m_next_point-&gt;printInfo();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  m_next_point is nullptr."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 8: 实现 initializeNextPoint 函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::initializeNextPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// 参数改为 int</span></span><br><span class="line">    <span class="keyword">if</span> (m_next_point == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_next_point = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  m_next_point initialized to new Point("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 增加此行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  m_next_point has been initialized already. Skipping."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 增加 std::endl</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="8-建议与扩展问题"><a href="#8-建议与扩展问题" class="headerlink" title="8. 建议与扩展问题"></a>8. 建议与扩展问题</h2><p>您已经很好地掌握了 C++ 中类成员变量自我引用的基本处理方法。接下来，为了让您的 C++ 技能更上一层楼，我建议您深入研究以下几个重要的概念：</p>
<ol>
<li><p><strong>“三/五/零法则”（Rule of Three/Five/Zero）</strong></p>
<ul>
<li><strong>概念：</strong> 当一个类管理着动态内存（比如我们的 <code>Point</code> 类中的 <code>m_next_point</code> 指针），通常需要显式地定义：<ul>
<li><strong>拷贝构造函数</strong>（<a href="Copy Constructor">Copy Constructor</a>）</li>
<li><strong>拷贝赋值运算符</strong>（<a href="Copy Assignment Operator">Copy Assignment Operator</a>）</li>
<li><strong>析构函数</strong>（<a href="Destructor">Destructor</a>）（您已经正确实现了）</li>
</ul>
</li>
<li>C++11 之后引入了<strong>移动构造函数</strong>（<a href="Move Constructor">Move Constructor</a>）和<strong>移动赋值运算符</strong>（<a href="Move Assignment Operator">Move Assignment Operator</a>），形成了“五法则”。而如果您的类不直接管理资源（例如使用智能指针），则可能不需要自定义这些，这就是“零法则”。</li>
<li><strong>思考：</strong> 如果您不定义拷贝构造函数和拷贝赋值运算符，当 <code>Point</code> 对象被拷贝（例如 <code>Point p2 = p1;</code> 或 <code>Point p2; p2 = p1;</code>）时会发生什么？会是深拷贝还是浅拷贝？这可能导致双重释放（<a href="double-free">double-free</a>）错误！</li>
</ul>
</li>
<li><p><strong>智能指针（<a href="Smart Pointers">Smart Pointers</a>）</strong></p>
<ul>
<li><strong>概念：</strong> C++11 引入的 <code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code> 是 RAII（<a href="Resource Acquisition Is Initialization">Resource Acquisition Is Initialization</a>）原则的体现。它们自动管理动态内存的生命周期，大大减少了内存泄漏和悬垂指针（<a href="dangling pointer">dangling pointer</a>）的风险。</li>
<li><strong>思考：</strong> 如何用 <code>std::unique_ptr&lt;Point&gt; m_next_point;</code> 或 <code>std::shared_ptr&lt;Point&gt; m_next_point;</code> 来替换您当前的原始指针？使用智能指针后，析构函数中的 <code>delete</code> 还需要手动编写吗？它们如何帮助简化代码并提高安全性？</li>
</ul>
</li>
<li><p><strong>前向声明（<a href="Forward Declaration">Forward Declaration</a>）</strong></p>
<ul>
<li><strong>概念：</strong> 当两个类相互引用（例如 <code>ClassA</code> 包含 <code>ClassB</code> 的指针，<code>ClassB</code> 也包含 <code>ClassA</code> 的指针）时，有时不需要在头文件中包含完整的类定义，只需要进行“前向声明”（<code>class ClassB;</code>）。</li>
<li><strong>思考：</strong> 在本例中，<code>Point</code> 类内部直接使用了 <code>Point*</code>，所以 <code>Point</code> 类的定义必须是已知的。但如果 <code>Point</code> 只是作为另一个类 <code>Line</code> 的成员（<code>Line</code> 包含 <code>Point</code> 成员），而 <code>Point</code> 又需要知道 <code>Line</code>（例如 <code>Point</code> 内部有 <code>Line*</code>），那么前向声明就变得很重要了。</li>
</ul>
</li>
<li><p><strong><code>const</code> 正确性与指针</strong></p>
<ul>
<li><strong>概念：</strong> <code>const</code> 关键字与指针结合时有多种含义：<ul>
<li><code>const Point* p;</code> (指向常量的指针)：指针指向的对象不能通过该指针修改，但指针本身可以改变指向。</li>
<li><code>Point* const p;</code> (常量指针)：指针不能改变指向，但指向的对象可以通过该指针修改。</li>
<li><code>const Point* const p;</code> (指向常量的常量指针)：指针和其指向的对象都不能通过该指针修改。</li>
</ul>
</li>
<li><strong>思考：</strong> 您的 <code>printInfo()</code> 方法被标记为 <code>const</code>，这意味着它不能修改对象的成员变量。您的 <code>m_next_point</code> 如果希望它不能被 <code>printInfo</code> 修改，或者您希望 <code>m_next_point</code> 始终指向同一个对象，可以如何使用 <code>const</code> 关键字？</li>
</ul>
</li>
<li><p><strong>循环引用与<code>printInfo</code>的递归安全</strong></p>
<ul>
<li><strong>概念：</strong> 您之前提出的问题非常关键。如果 <code>Point</code> 对象可能形成循环链（例如 A -&gt; B -&gt; C -&gt; A），那么您的 <code>printInfo</code> 方法将陷入无限递归。</li>
<li><strong>思考：</strong> 如何修改 <code>printInfo</code> 函数，使其能够检测并阻止无限递归？一种常见的方法是在递归调用时，维护一个“已访问节点”的集合，如果尝试访问一个已访问过的节点，就停止递归。</li>
</ul>
</li>
</ol>
<p>通过深入学习这些扩展问题，您将对 C++ 的内存管理、面向对象设计以及如何编写更健壮、更安全的 C++ 代码有更深刻的理解。</p>
<p>期待您在未来的学习中取得更大的进步！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Developer/">Developer    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Programming/">Programming    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/344%20%20-%20cpp%20%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%20ODR/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>344  - cpp 内联变量函数解决 ODR</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/30-resources/coding/python/Pandas_Basic_Command_Quick_Check_Table/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202104250.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Pandas_Basic_Command_Quick_Check_Table</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/静态成员访问控制/" title="静态成员访问控制"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">静态成员访问控制</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/277 - IDE 创建 cpp 类方法/" title="277 - IDE 创建 cpp 类方法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">277 - IDE 创建 cpp 类方法</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/278 - cpp 指针管理类对象示例/" title="278 - cpp 指针管理类对象示例"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">278 - cpp 指针管理类对象示例</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/299 - 显式构造函数/" title="299 - 显式构造函数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">299 - 显式构造函数</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/276 - Class across multiple files/" title="276 - Class across multiple files"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">276 - Class across multiple files</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/322 - Different Type Members/" title="322 - Different Type Members"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">322 - Different Type Members</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>