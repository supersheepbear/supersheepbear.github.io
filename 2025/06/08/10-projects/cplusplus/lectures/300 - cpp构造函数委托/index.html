<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>300 - cpp构造函数委托 | Bear's dream</title><meta name="description" content="300 - cpp构造函数委托"><meta name="keywords" content="Coding,Cpp,Development,Class,Constructor"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="300 - cpp构造函数委托"><meta name="twitter:description" content="300 - cpp构造函数委托"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="300 - cpp构造函数委托"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/300%20-%20cpp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A7%94%E6%89%98/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="300 - cpp构造函数委托"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/300%20-%20cpp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A7%94%E6%89%98/"><link rel="prev" title="319 - Class Const" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/319%20-%20Class%20Const/"><link rel="next" title="324 - Nested class" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/324%20-%20Nested%20class/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-构造函数委托"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">C++构造函数委托</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#1-标题和简介"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">1. 标题和简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2-详细解释"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">2. 详细解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#5-常见误解或易犯错误"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">5. 常见误解或易犯错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#6-编码练习"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">6. 编码练习</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#7-评价你的解答、正确答案及解释"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">7. 评价你的解答、正确答案及解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#8-建议和扩展问题"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">8. 建议和扩展问题</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-构造函数委托"><span class="toc-number">1.</span> <span class="toc-text">C++构造函数委托</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-标题和简介"><span class="toc-number">2.</span> <span class="toc-text">1. 标题和简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-详细解释"><span class="toc-number">3.</span> <span class="toc-text">2. 详细解释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-代码示例"><span class="toc-number">4.</span> <span class="toc-text">3. 代码示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc-number">5.</span> <span class="toc-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-常见误解或易犯错误"><span class="toc-number">6.</span> <span class="toc-text">5. 常见误解或易犯错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-编码练习"><span class="toc-number">7.</span> <span class="toc-text">6. 编码练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">7.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">7.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-评价你的解答、正确答案及解释"><span class="toc-number">8.</span> <span class="toc-text">7. 评价你的解答、正确答案及解释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-建议和扩展问题"><span class="toc-number">9.</span> <span class="toc-text">8. 建议和扩展问题</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">300 - cpp构造函数委托</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/300%20-%20cpp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A7%94%E6%89%98/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/300%20-%20cpp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A7%94%E6%89%98/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="C-构造函数委托"><a href="#C-构造函数委托" class="headerlink" title="C++构造函数委托"></a>C++构造函数委托</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture we’re going to learn about constructor delegation, and this is a technique we havein C plus plus To have a constructor, use another constructor and avoid code duplication.Suppose we have two constructors for our square class here we have one that takes a single parameterand we have another that takes three parameters.We have modified the class now to have many member variables.We have the side, we have the color, we have an integer which is going to represent the shading ofthe square and we have another double member variable for the position of the square on the screen.For example, suppose we are doing some visual application so we can set up our constructors like thisand they are going to work.They are going to be two separate constructors.We can look at the implementations of this constructors.The one parameter constructor is going to only initialize the side parameter and the others are goingto be left uninitialized in the body here and it is possible to do this, but I don’t recommend it.But it is possible.So the second one is going to take three parameters.It’s going to have side parameter, the color and the shading.But notice that it is also leaving out the position and I have left this out on purpose because I havesomething to show you a little later in this lecture.So this constructor is also using our initializer list here.So side is going to be initialized with side param color is going to be initialized with color paramand shading is going to be initialized with shading parameter.This is going to work.But we are really duplicating work because we have two constructors really doing almost the same thing.It is possible for the single parameter constructor here to reuse the constructor that is taking threeparameters and this is what we call constructor delegation.The one parameter constructor on top is going to delegate the construction of its object to anotherconstructor and the syntax to do that is really simple.We can do constructor delegation using the syntax we see here.We have the constructor here.You see we have the function name, we have the parameters.Then we’re going to put a colon and specify the constructor.We want to call and specify the arguments we want to call it with.Okay, so this really looks like initializer list and it is an initializer list, but it is callinganother constructor and which constructor it is called.And if we look down, we’re going to see that we have a constructor that exactly takes three parametersand it is what we are passing here side param, the color and the shading information.And that’s what we pass in this constructor here.And the construction work for our object is no longer going to be done by this constructor here.It’s going to be done by the three parameter constructor.And when the job is done, we’re going to hit the body of the one parameter constructor here.So we need to think about the sequence of events when we have a constructor delegation involved.So what is going to happen here?The one parameter constructor is going to be called if you pass one parameter when you are creatingyour object.So before we get into the body of the one parameter constructor, the compiler is going to realize theconstructor delegation and it is going to call the three parameter constructor to do the actual objectcreation.Then the three parameter constructor is going to construct the object and it’s going to initialize theobject with the provided data.So we’re going to use the arguments that are passed in the initializer list of our one parameter constructorhere.And then after the object is created, we’re going to hit the body of the three parameter constructorbecause that’s the constructor that was called After the body of the three parameter constructor.We’re going to hit the body of the single parameter constructor and control is going to go back to Mainwhere we created the object.And one thing you should know is that all these calls to this constructor was can be seen in the callstack with the debugger.And you’re going to see this in a minute.But now what we really want to know is the syntax to do constructor delegation and understand what thisis going to do.It is going to delegate the work to build the object to another constructor.And the syntax to do this is to use an initializer list which is going to call the other constructor.And this is really cool.Okay, some of you might be asking, okay, constructor delegation is good and we have seen that wecould use initializer list to do that.But what if I call the three parameter constructor myself like I do here?Well, I hate to break this to you, but this is not going to do what you want.This is not going to do constructor delegation.This is just going to create a local object of square and it is going to be thrown away when the bodyof this function finishes executing.So if you really want to do constructor.Delegation initializer lists are your only bet.This is one cases where we can only do this using initializer lists and the importance of initializerlist is only getting better.And this is a case where we can only do this thing using initializer lists.Another thing you should note with constructor delegation is that if you have done a constructor delegationin your class, you can’t do any further initialization before or after the delegation call.So for example, if we look at the line here, we have our constructor delegation.We can’t put up another initializer which is going to initialize the position.If we do this, the compiler is going to throw a compiler error.It’s not allowed.The line here is going to try and put the initialization for the position in front of the delegationcall.But this is also going to be a compiler error and you can’t do that.This is disallowed by the compiler.Okay.So this is really how constructor delegation is going to work.And after you have done your constructor delegation, you can really do anything you want in the bodyof your one parameter constructor.Here, for example, we can take this chance to initialize the position member variable, which wasn’tinitialized by any of the initializer list.And we can do this and it is going to work.Now that you know this, we’re going to head over to Visual Studio code and show you this things inaction.Okay, Here we are in our working folder.The current project is constructor delegation.We are going to be reusing the code from the last lecture where we set up a square class.So let’s grab the code from there.We’re going to grab our classes and we’re going to grab the VS code folder because we’re going to beusing this for our settings and then we’re going to put this in our current project, which is constructeddelegation.Again, we’re going to grab this and open this in Visual Studio code and this is going to open our folder.The first thing we want to do is to open up the main CPP file and see that we have everything we needthere.We don’t really need to do the second call here because it’s going to just give us a compiler error.What we want to learn about here is constructor delegation and we’re just going to use our code likethis.We just want to use constructor delegation here.So let’s head over to our square class and really modify it.We’re going to add a net variable, which is going to be our shading and we’re going to add a doublevariable member variable, I should say, which is going to be our position.And we can open our square CPP file and close the left pane here because it is taking up space.So let’s go to the header file and we’re going to set up a constructor which is going to initializethree of these guys here.So let’s do that.We’re going to put in a constructor which is going to take three parameters.Let’s do that.We’re going to say Square and we’re going to say double side parameters.We’re going to say const STD string, we can do this.We’re going to use a reference and this is going to be color param and we’re going to say int shadingparam, this is going to be our thing and it’s not going to have anything by default here.And I think we can even take out the constructor we have in front here and make it a one param constructor.This is going to help us better in what we want to show in this lecture here.Can’t take out this semicolon.Let’s do this and this is it.Let’s go back to the CPP file and make sure that we have the implementations for these two constructors.We’re going to go to square dot CPP and we’re going to see that we no longer have a one parameter constructor.We can change this and change this to only initialize the first guy and the others are going to be leftout.But we can put in another constructor which is going to initialize three parameters or three membervariables I should say.So we’re going to say square and square and we’re going to have a double side.Param I should go to the header and copy these parameters and because I can’t remember how I named them,I can do that.So I’m going to put them in here and then we’re going to let’s check how we named our things.This should be m shading because it’s a member variable and this should be M position because it isa member variable.This is just trying to stay consistent with our naming convention here.We’re going to put in our initializer list.So we’re going to say M side, we’re going to initialize this with side param and we’re going to doM color and we’re going to initialize this with color param and we’re going to do M shading and we’regoing to initialize this with shading param.Hopefully you see that naming your things consistently is going to help out.Okay, now we have the constructor.In place.But we really have two constructors that are different and they are going to be constructing.Objects here.But sometimes we want to make one constructor reuse the work that we have done in another constructor.So suppose, for example, the three parameter constructor here is doing some heavy computations andwe don’t want to repeat all these computations in all these constructors and repeat our work.So a reasonable thing to do is to make the first constructor here, which is going to take one parameter.Use the constructor that is taking more parameters because we can pass default parameters when we callthe other constructor here, which takes more parameters.I realize this is a little bit convoluted, but stay with me.We’re going to explain these things step by step.Okay?So let’s go down here and put in a few stdcout statements.We’re going to say iostream here because we want to print things out and we’re going to say that theone parameter constructor was called.And down here we’re going to say that the three parameter constructor was called.So let’s go down here and put our body and make it aligned with what we did here.And our initializer list calls are not consistent here.We are using curlies, here we are using parentheses.I like to use curlies.So let’s do that so that we really stay consistent here.Let’s do this.We’re going to change this to use curly braces.And the last one is also going to use curly braces.This is going to be consistent here.So we have this we’re going to go inside and put in our Stdcout statement and we’re going to say thatthe three parameter constructor was called Let’s go back in Main and see what we have there.We don’t really want all this junk because we don’t need this anymore.We just want to see what is used to build our object here.So let’s take out the function here because we don’t really need it anymore either.And we can build we’re going to use GCC to build this.And you see, the build is good.If we bring up a terminal to run our program, we can clear and run Rooster.We’re going to see that one param constructor is called to build our object here, but we don’t wantthe one param to do the job alone.We want to reuse the three param constructor, to use the logic we have in here to build our objectand we can do constructor delegation.The syntax to do constructor delegation is really simple.You just use initializer lists.So we’re going to take out the initializer list we have here and we’re going to change it to call thethree parameter constructor.So we’re going to say Square and we’re going to pass it all the parameters that it expects.We only have one.So we can, for example, say side parameter here, let’s use Curly because that’s consistent.We’re going to say side param because that’s what we have here.So let’s do that.And for the others we’re going to just specify some values here to make the other constructor happy.So for example, we can specify a default value we want, let’s say black.You just need to be able to handle all this information in your three parameter constructor.So we just want to make it happy here.And for shading, let’s pass in a sex.Let’s suppose this makes sense for whatever application we are building here and you see that VisualStudio code is going to accept this syntax.We have no squiggly lines, so this must be working here.But I want you to understand the sequence of events when we set up a call like this.But before we analyze that, let’s build and see what is going to happen here.So let’s build with GCC.We’re going to see that the world is good.So the calls here are going to be working.But let’s see what we see in the terminal here.If we run our executable, we’re going to see that the three parameter constructor was called.Then the one parameter constructor was called.So this hopefully proves that even if we call the single parameter constructor, the compiler is goingto use the three parameter constructor to build our object.After the object is created, we’re going to hit the body of the three parameter constructor becausethat’s what constructed our object.Then control is to go back to our constructor and give us a chance to do whatever we want to do in ourone parameter constructor here.We can even prove this with a debugger.So let’s put a breakpoint on line seven here and put a breakpoint on line 13 here in the body of eachconstructor.And then we’re going to try and run this through the debugger.We are going to go to our run tab here, which is what we always use to run the debugger.And by the way, you can go to the run menu here and hit start debugging.This is going to start debugging your application just like we do here.But I like to do things explicitly by coming here.So I.I am going to start my debugging session and we don’t really need to see any other thing.The first thing we see is that we have hit the body of the three parameter constructor and look at whatwe have in Main.In Main we are calling the one parameter constructor, but we have hit the body of our three parameterconstructor.So what is going to happen is when we call the one parameter constructor, the compiler is going tohit the constructor here, but it’s going to see that it is delegating the construction work to thethree parameter constructor.Then the three parameter constructor is going to be called.We’re going to hit its body.If we execute and get out of it, you’re going to see that we’re going to hit the body of the one parameterconstructor I just hit next a couple of times, and then I’m going to come in here.And if we hit step over, we’re going to print the message here.And if we go to our terminal, we’re going to see that the messages were printed out.And if we come out of this, we’re going to come back to Main and our object is going to be alreadyconstructed.And if we look inside, we’re going to see our information that was used to create the object here.This is really cool.And we can see all this data in our local variables here.So, for example, you’re going to see that the color let’s see if we can see this.You’re going to see that the color is black.It is really hidden in all these options here.But we can hunt that down and find that.So we have the color, we have the shading, we have the position, which is really a junk value becausewe didn’t really initialize this, but you see that we can see our data.And the main message in this lecture is that we can do constructor delegation and the syntax to do thatis in our square CPP file.We can bring this back and you have to use the initializer list as you see here.So this is the syntax and you need to know this.Okay, so now that you know this, we’re going to address the problem that some of you might be askingabout what we are doing here.So what if we don’t use our initializer list?Let’s comment this out anyway.So we’re going to take out all this.We can comment this out and we don’t use an initializer list and we call the constructor directly inour body, the body of our one parameter constructor.What if we do that?Let’s do that.So we’re going to say square and we’re going to pass in side param because we have access to that andthen we’re going to pass the other parameters here.The color is going to be black and the shading is going to be six.Let’s do this and you’re going to see that the compiler is really not going to complain, but it isnot going to do what you think it is going to do.Let’s try and build the program and really see what is happening here.Hopefully we can see that we are going to build with JCC.You’re going to see that the world is good, but we’re going to run Rooster and we’re going to see thatthree parameter constructor called one parameter constructor called This still looks like what we hadin the last few runs, but what this is really doing, it’s not doing the constructor delegation.This is constructing your object and destroying it on the spot because this is going to be a local objectfor our square class.We can prove this by putting some message in our destructor.So let’s say Stdcout Square object destroyed and we’re going to see that the three parameter constructoris going to be called, but its destructor is going to be called before we hit the end of this functionbody here.Let’s build and see if this actually is easier to see.You’re going to see that the world is good and we’re going to clear and run Rooster.We’re going to see that once we hit the body of the square constructor.The three parameter constructor is going to be called, which is what we have here.And the output statement is going to be coming from this guy here.But because the compiler sees that this guy will never be used, it is a temporary object.The compiler is going to destroy it right away and we’re going to see square object destroyed here.Then we’re going to print this one parameter constructor called Message here.And then we’re going to say that the square object that we built in the main function here was destroyed.You really need to understand these things.Hopefully you see that if you call your constructor directly in the body of your constructor here,this is not going to do constructor delegation.And I want you to know this.So let’s take this out and bring in our initializer list back.And this is going to do proper constructor delegation and let’s try and build and run this program tosee if we see different output.We’re going to clear and run Rooster.We’re going to see that only the three parameter constructor is going to be called The one parameterconstructor is going to be called.After we do the proper object initialization, we’re going to hit this body here.We’re going to hit.One param constructor called and we see that we destroy only one square object because we don’t havea local object constructed in the body of one param constructor here.Hopefully this is clear now.Another thing I want you to see is that we can’t do further initialization if we are doing constructordelegation here.So for example on this one param constructor of ours, we can’t try and initialize the position membervariable here.If we do that, we’re going to get a compiler error.So let’s try and do that before.So we’re going to say M position and we’re going to put in any position.Let’s put in 8.0 and put a comma here and we’re going to put a comma after this.And let’s use curly braces here.I can’t really remember using curly braces here, so let’s do that.If we do this, we’re going to get a compiler error.You see that we have a squiggly line.The compiler is not going to support this.If you are using constructor delegation, the constructor delegation should be the only thing you havein your initializer list.If we build this, we’re going to get some weird compiler error.And let’s see that constructor delegation follows Member initializer list for square position and thisis not allowed.We’re going to have a compiler error if we try and put this position after the constructor delegation,we’re also going to get the same thing because the compiler doesn’t allow this.This is just how the compilers are wired and we have to live with this.If we do this, we’re also going to get a squiggly line because this is not allowed.Let’s world with GCC to show you this.We’re going to see a build error and it is basically going to be the same thing and you shouldn’t reallydo this.So we can’t have any further initialization before or after our constructor delegation here.Let’s build and see that.Now this is building fine because we should prove this.We see the build is good, so the compiler is happy.Okay, So I think this really wraps up what I had to share with you in this lecture.But before I let you go, I want you to see that you can really do anything once you hit the body ofyour one parameter constructor.Here, for example, we can take this chance to initialize our position member variable, which is notinitialized by any of the initializer lists we have in here.So we can go in here and for example, put a value in our M position member variable.We can do this.So we’re going to say M position equals 45.8, for example, and this is going to be accepted by thecompiler.If we build, we’re going to see that the build is going to be good.Okay, the build is good and this is really all I hope now you know that you can do constructor delegationto offload the job to build your object to other constructors.Those constructors are going to take over your job to do construction and when they are done doing thejob, they are going to give you a chance to do whatever you want in your delegating constructor.As we see in this one Param constructor here, this is really all I had to share in this lecture.I hope you found it interesting.We are going to stop here in this one.In the next one we’re going to learn about copy constructors.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，没问题！非常乐意帮助你学习 C++ 中的构造函数委托 (constructor delegation)。这确实是一个非常有用的特性，能让你的代码更简洁、更易于维护。</p>
<p>让我们开始吧！</p>
<hr>
<h1 id="1-标题和简介"><a href="#1-标题和简介" class="headerlink" title="1. 标题和简介"></a>1. 标题和简介</h1><p><strong>标题：</strong> C++ 构造函数委托 (Constructor Delegation) 精讲：让构造函数互相协作</p>
<p><strong>简介：</strong> 本节课我们将学习 C++ 中的一个重要特性——构造函数委托。它允许一个构造函数 (constructor) 调用同一个类中的另一个构造函数来完成对象的初始化，从而避免代码重复，提高代码的可维护性。</p>
<hr>
<h1 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h1><p>想象一下，你在设计一个类，比如一个 <code>Square</code> (正方形) 类。这个类可能有很多成员变量 (member variables)，例如边长、颜色、阴影样式、屏幕位置等等。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设的 Square 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_side;         <span class="comment">// 边长</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_color;   <span class="comment">// 颜色</span></span><br><span class="line">    <span class="keyword">int</span> m_shading;         <span class="comment">// 阴影样式 (整数表示)</span></span><br><span class="line">    <span class="keyword">double</span> m_position_x;   <span class="comment">// X轴位置</span></span><br><span class="line">    <span class="comment">// 可能还有 m_position_y 等等</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 构造函数和其他方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>现在，你可能需要提供多种方式来创建 <code>Square</code> 对象：</p>
<ul>
<li>只提供边长，其他使用默认值。</li>
<li>提供边长、颜色和阴影样式，位置使用默认值。</li>
<li>提供所有参数。</li>
</ul>
<p>如果为每种情况都写一个完整的构造函数，并且在每个构造函数中都分别初始化这些成员变量，你会发现很多初始化逻辑是重复的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用构造函数委托的例子 (冗余代码)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_side;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_color;</span><br><span class="line">    <span class="keyword">int</span> m_shading;</span><br><span class="line">    <span class="keyword">double</span> m_position_x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数1: 只接受边长</span></span><br><span class="line">    Square(<span class="keyword">double</span> side_param) &#123;</span><br><span class="line">        m_side = side_param;</span><br><span class="line">        m_color = <span class="string">"black"</span>;    <span class="comment">// 默认颜色</span></span><br><span class="line">        m_shading = <span class="number">0</span>;        <span class="comment">// 默认阴影</span></span><br><span class="line">        m_position_x = <span class="number">0.0</span>;   <span class="comment">// 默认位置</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"单参数构造函数被调用 (独立实现)\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数2: 接受边长、颜色、阴影</span></span><br><span class="line">    Square(<span class="keyword">double</span> side_param, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color_param, <span class="keyword">int</span> shading_param) &#123;</span><br><span class="line">        m_side = side_param;</span><br><span class="line">        m_color = color_param;</span><br><span class="line">        m_shading = shading_param;</span><br><span class="line">        m_position_x = <span class="number">0.0</span>;   <span class="comment">// 默认位置 (仍然有重复的默认值设置)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"三参数构造函数被调用 (独立实现)\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 可能还有其他构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Side: "</span> &lt;&lt; m_side</span><br><span class="line">                  &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color</span><br><span class="line">                  &lt;&lt; <span class="string">", Shading: "</span> &lt;&lt; m_shading</span><br><span class="line">                  &lt;&lt; <span class="string">", Position X: "</span> &lt;&lt; m_position_x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>上面这种方式，<code>m_position_x = 0.0;</code> 这行代码，以及其他可能的默认值设置，就可能在多个构造函数中重复出现。如果以后 <code>m_position_x</code> 的默认值需要修改，你就得修改所有相关的构造函数，很容易遗漏。</p>
<p><strong>构造函数委托 (Constructor Delegation) 就是为了解决这个问题而生的。</strong></p>
<p>它允许一个构造函数将对象的实际构建工作“委托”给同一个类中的另一个构造函数。</p>
<p><strong>语法：</strong></p>
<p>构造函数委托的语法非常简洁，它发生在构造函数的 <strong>初始化列表 (initializer list)</strong> 位置。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassName(parameters_for_this_constructor) : AnotherConstructorInSameClass(arguments_for_delegated_constructor) &#123;</span><br><span class="line">    <span class="comment">// 这个构造函数自己的函数体 (body)</span></span><br><span class="line">    <span class="comment">// 在被委托的构造函数执行完毕后，这里的代码才会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>ClassName(parameters_for_this_constructor)</code>: 这是定义当前构造函数（我们称之为“委托构造函数 (delegating constructor)”）。</li>
<li><code>:</code>: 冒号，标志着初始化列表的开始。</li>
<li><code>AnotherConstructorInSameClass(arguments_for_delegated_constructor)</code>: 这就是委托的核心。它看起来像是在调用同一个类的另一个构造函数（我们称之为“目标构造函数 (target constructor)”或“被委托的构造函数”）。你传递给目标构造函数的参数可以是委托构造函数的参数，也可以是常量值或默认值。</li>
<li><code>{ ... }</code>: 委托构造函数的函数体。</li>
</ul>
<p><strong>执行顺序：</strong></p>
<p>当你使用构造函数委托时，执行顺序非常重要：</p>
<ol>
<li>当你调用一个委托构造函数来创建对象时，编译器首先会识别出这是一个委托调用。</li>
<li><strong>目标构造函数 (被委托的那个) 会首先被执行。</strong><ul>
<li>目标构造函数自己的初始化列表（如果有的话，但它不能再委托给别的构造函数了，除非是不同的委托链）会先执行。</li>
<li>然后目标构造函数的函数体会执行。</li>
</ul>
</li>
<li>在目标构造函数完全执行完毕后，<strong>控制权返回到委托构造函数</strong>。</li>
<li><strong>委托构造函数的函数体 (body) 才会执行。</strong></li>
</ol>
<p><strong>一个关键点：</strong> 如果一个构造函数使用了委托，那么在它的初始化列表中，<strong>不能再对其他成员变量进行初始化了</strong>。委托调用必须是初始化列表中的唯一项（相对于成员初始化而言）。</p>
<p>例如，这是 <strong>错误</strong> 的：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> val_a) : MyClass(val_a, <span class="number">100</span>), b(val_a) &#123; <span class="comment">// 错误！不能同时委托和初始化其他成员</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    MyClass(<span class="keyword">int</span> val_a, <span class="keyword">int</span> val_b) : a(val_a), b(val_b) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>正确的做法是，将所有初始化工作都交给目标构造函数，或者在委托构造函数的 <em>函数体</em> 内进行某些操作（但此时成员变量已经被目标构造函数初始化过了）。</p>
<p><strong>为什么不能在构造函数体内部直接调用另一个构造函数来实现委托？</strong></p>
<p>你可能会想：“我能不能在一个构造函数的函数体里，像调用普通函数一样调用另一个构造函数呢？” 比如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个常见的误解，并不能实现构造函数委托！</span></span><br><span class="line">Square(<span class="keyword">double</span> side_param) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"单参数构造函数的函数体开始\n"</span>;</span><br><span class="line">    Square(side_param, <span class="string">"default_color"</span>, <span class="number">0</span>); <span class="comment">// 警告！这不是委托！</span></span><br><span class="line">    <span class="comment">// m_side = side_param; // 假设这个构造函数原本是想做这些事的</span></span><br><span class="line">    <span class="comment">// m_color = "default_color";</span></span><br><span class="line">    <span class="comment">// m_shading = 0;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"单参数构造函数的函数体结束\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果你这样做，<code>Square(side_param, &quot;default_color&quot;, 0);</code> <strong>并不会</strong> 在当前正在构造的对象上调用另一个构造函数。相反，它会创建一个全新的、临时的、局部的 <code>Square</code> 对象。这个临时对象在这一行代码执行完毕后，如果没有任何引用指向它，它通常会立即被销毁。你原本想要初始化的那个对象，其成员变量可能仍然是未初始化或者处于不确定状态（除非你在后续代码中手动赋值）。</p>
<p><strong>所以，实现构造函数委托的唯一正确方法就是使用初始化列表的特殊语法。</strong></p>
<p><strong>在委托构造函数的函数体中可以做什么？</strong></p>
<p>虽然在使用了委托的构造函数的初始化列表中不能再初始化其他成员，但你仍然可以在它的 <strong>函数体 (body)</strong> 中执行其他逻辑。这个时候，对象已经被目标构造函数完全构建好了。你可以在这里进行一些额外的设置、打印日志、或者执行一些不适合放在目标构造函数中的特定于此委托构造函数的逻辑。</p>
<p>例如，在我们的 <code>Square</code> 例子中，假设目标构造函数没有初始化 <code>m_position_x</code>，我们可以在委托构造函数的函数体中完成：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Square.h</span></span><br><span class="line"><span class="comment">// class Square &#123;</span></span><br><span class="line"><span class="comment">// private:</span></span><br><span class="line"><span class="comment">//     double m_side;</span></span><br><span class="line"><span class="comment">//     std::string m_color;</span></span><br><span class="line"><span class="comment">//     int m_shading;</span></span><br><span class="line"><span class="comment">//     double m_position_x;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     Square(double side_param); // 委托构造函数</span></span><br><span class="line"><span class="comment">//     Square(double side_param, const std::string&amp; color_param, int shading_param); // 目标构造函数</span></span><br><span class="line"><span class="comment">//     // ...</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Square.cpp</span></span><br><span class="line">Square::Square(<span class="keyword">double</span> side_param, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color_param, <span class="keyword">int</span> shading_param)</span><br><span class="line">    : m_side&#123;side_param&#125;, m_color&#123;color_param&#125;, m_shading&#123;shading_param&#125;, m_position_x&#123;<span class="number">0.0</span>&#125; &#123; <span class="comment">// 目标构造函数初始化所有（或大部分）</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"目标 (三参数) 构造函数被调用。\n"</span>;</span><br><span class="line">    <span class="comment">// m_position_x = 0.0; // 或者在这里初始化，如果逻辑更复杂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Square::Square(<span class="keyword">double</span> side_param)</span><br><span class="line">    : Square(side_param, <span class="string">"default_black"</span>, <span class="number">1</span>) &#123; <span class="comment">// 委托给三参数构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"委托 (单参数) 构造函数被调用。\n"</span>;</span><br><span class="line">    <span class="comment">// 此时，m_side, m_color, m_shading 已经被目标构造函数初始化</span></span><br><span class="line">    <span class="comment">// m_position_x 也被目标构造函数初始化为 0.0</span></span><br><span class="line">    <span class="comment">// 如果需要，可以在这里覆盖或做额外处理</span></span><br><span class="line">    <span class="comment">// 比如: this-&gt;m_position_x = specific_value_for_this_constructor;</span></span><br><span class="line">    <span class="comment">// 但通常，如果目标构造函数已经处理了所有必要的初始化，这里可能为空。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>总结一下构造函数委托的好处：</strong></p>
<ol>
<li><strong>减少代码重复 (Code Duplication)：</strong> 这是最主要的好处。核心的初始化逻辑只需要写在一个（或少数几个）目标构造函数中。</li>
<li><strong>提高可维护性：</strong> 如果需要修改初始化逻辑（比如某个成员的默认值），只需要修改目标构造函数，所有委托给它的构造函数都会自动受益。</li>
<li><strong>更清晰的意图：</strong> 它清楚地表明某些构造函数是基于其他构造函数来构建对象的。</li>
</ol>
<hr>
<h1 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h1><p>让我们用一个更完整的 <code>Square</code> 类来演示构造函数委托。</p>
<p><strong>Square.h (头文件)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SQUARE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 为了在构造函数中打印信息</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_side;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_color;</span><br><span class="line">    <span class="keyword">int</span> m_shading;</span><br><span class="line">    <span class="keyword">double</span> m_position_x; <span class="comment">// 假设还有一个位置成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 目标构造函数: 初始化所有核心成员</span></span><br><span class="line">    Square(<span class="keyword">double</span> side_param, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color_param, <span class="keyword">int</span> shading_param, <span class="keyword">double</span> position_x_param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造函数1: 只提供边长，颜色、阴影和位置使用默认值</span></span><br><span class="line">    <span class="comment">// 它将委托给上面的四参数构造函数</span></span><br><span class="line">    Square(<span class="keyword">double</span> side_param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造函数2: 提供边长和颜色，阴影和位置使用默认值</span></span><br><span class="line">    <span class="comment">// 它也将委托给上面的四参数构造函数</span></span><br><span class="line">    Square(<span class="keyword">double</span> side_param, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color_param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数 (destructor)，用于演示临时对象问题</span></span><br><span class="line">    ~Square();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SQUARE_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong>Square.cpp (实现文件)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Square.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标构造函数 (Target Constructor)</span></span><br><span class="line">Square::Square(<span class="keyword">double</span> side_param, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color_param, <span class="keyword">int</span> shading_param, <span class="keyword">double</span> position_x_param)</span><br><span class="line">    : m_side&#123;side_param&#125;, m_color&#123;color_param&#125;, m_shading&#123;shading_param&#125;, m_position_x&#123;position_x_param&#125; &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"目标构造函数 (4个参数) 被调用. Side: "</span> &lt;&lt; m_side &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color &lt;&lt; <span class="string">", Shading: "</span> &lt;&lt; m_shading &lt;&lt; <span class="string">", PosX: "</span> &lt;&lt; m_position_x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托构造函数1 (Delegating Constructor)</span></span><br><span class="line">Square::Square(<span class="keyword">double</span> side_param)</span><br><span class="line">    : Square(side_param, <span class="string">"Default Black"</span>, <span class="number">0</span>, <span class="number">0.0</span>) &#123; <span class="comment">// 委托给四参数构造函数</span></span><br><span class="line">    <span class="comment">// 上面那行是委托调用，它必须是初始化列表中的唯一（关于成员初始化）的项</span></span><br><span class="line">    <span class="comment">// 不能在这里写 : m_some_other_member(value)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"委托构造函数 (1个参数) 的函数体被调用. Side: "</span> &lt;&lt; m_side &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 此时对象已经由目标构造函数构建完毕</span></span><br><span class="line">    <span class="comment">// 你可以在这里做一些这个构造函数特有的额外事情</span></span><br><span class="line">    <span class="comment">// 例如，如果 m_position_x 需要根据 side_param 做特殊计算，而目标构造函数只设置了通用默认值</span></span><br><span class="line">    <span class="comment">// this-&gt;m_position_x = side_param * 0.5; // 举例，覆盖或调整</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托构造函数2 (Delegating Constructor)</span></span><br><span class="line">Square::Square(<span class="keyword">double</span> side_param, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color_param)</span><br><span class="line">    : Square(side_param, color_param, <span class="number">5</span>, <span class="number">0.0</span>) &#123; <span class="comment">// 委托给四参数构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"委托构造函数 (2个参数) 的函数体被调用. Side: "</span> &lt;&lt; m_side &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Square::~Square() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数被调用 for Square with side: "</span> &lt;&lt; m_side &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Square::print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Square Info -&gt; Side: "</span> &lt;&lt; m_side</span><br><span class="line">              &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color</span><br><span class="line">              &lt;&lt; <span class="string">", Shading: "</span> &lt;&lt; m_shading</span><br><span class="line">              &lt;&lt; <span class="string">", Position X: "</span> &lt;&lt; m_position_x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示在构造函数体内“调用”构造函数的错误做法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demonstrate_wrong_delegation_attempt</span><span class="params">(<span class="keyword">double</span> side)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 演示错误委托尝试 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这个构造函数本身是正确的，我们只是用它来演示一个错误的调用方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TempSquare</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> val;</span><br><span class="line">        TempSquare(<span class="keyword">double</span> v) : val(v) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  TempSquare("</span> &lt;&lt; v &lt;&lt; <span class="string">") 构造函数被调用 (为了演示错误做法)."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TempSquare(<span class="keyword">double</span> v, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; c) : val(v) &#123;</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  TempSquare("</span> &lt;&lt; v &lt;&lt; <span class="string">", "</span> &lt;&lt; c &lt;&lt; <span class="string">") 构造函数被调用."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~TempSquare() &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  TempSquare("</span> &lt;&lt; val &lt;&lt; <span class="string">") 析构函数被调用."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 错误尝试：在函数体内调用构造函数</span></span><br><span class="line">        TempSquare(<span class="keyword">double</span> v, <span class="keyword">int</span> <span class="comment">/*dummy to differentiate*/</span>) : val(<span class="number">0.0</span>) &#123; <span class="comment">// 初始化 val 以避免未定义行为</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  TempSquare("</span> &lt;&lt; v &lt;&lt; <span class="string">", int) 构造函数体开始. 当前 val: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            TempSquare(v, <span class="string">"red"</span>); <span class="comment">// 这会创建一个临时对象，然后立即销毁它！</span></span><br><span class="line">                                  <span class="comment">// 它不会修改当前正在构造的 TempSquare 对象的 val</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  TempSquare("</span> &lt;&lt; v &lt;&lt; <span class="string">", int) 构造函数体结束. 当前 val: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;val &lt;&lt; <span class="string">" (注意，没有被修改成 "</span> &lt;&lt; v &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">TempSquare <span class="title">ts1</span><span class="params">(side, <span class="number">123</span>)</span></span>; <span class="comment">// 调用那个演示错误委托的构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  ts1.val after construction: "</span> &lt;&lt; ts1.val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 演示错误委托尝试结束 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong>main.cpp (主程序)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Square.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建 s1 (使用1个参数的构造函数):\n"</span>;</span><br><span class="line">    <span class="function">Square <span class="title">s1</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line">    s1.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建 s2 (使用2个参数的构造函数):\n"</span>;</span><br><span class="line">    <span class="function">Square <span class="title">s2</span><span class="params">(<span class="number">5.0</span>, <span class="string">"Blue"</span>)</span></span>;</span><br><span class="line">    s2.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建 s3 (使用4个参数的构造函数 - 目标构造函数直接调用):\n"</span>;</span><br><span class="line">    <span class="function">Square <span class="title">s3</span><span class="params">(<span class="number">2.0</span>, <span class="string">"Green"</span>, <span class="number">3</span>, <span class="number">25.5</span>)</span></span>;</span><br><span class="line">    s3.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示错误委托尝试</span></span><br><span class="line">    demonstrate_wrong_delegation_attempt(<span class="number">7.7</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"程序结束前，s1, s2, s3 将按逆序销毁。\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong>编译和运行：</strong><br>你需要将 <code>Square.cpp</code> 和 <code>main.cpp</code> 一起编译。例如使用 g++：<br><code>g++ main.cpp Square.cpp -o constructor_delegation_demo -std=c++11</code><br>(构造函数委托是 C++11 引入的特性，所以确保你的编译器支持 C++11 或更高版本，并可能需要指定 <code>-std=c++11</code> 或更高，如 <code>-std=c++17</code>)</p>
<p>然后运行: <code>./constructor_delegation_demo</code></p>
<p><strong>预期输出分析：</strong><br>你会看到：</p>
<ol>
<li>创建 <code>s1</code> 时：<ul>
<li>首先输出 “目标构造函数 (4个参数) 被调用…” (因为 <code>Square(double)</code> 委托给了它)。</li>
<li>然后输出 “委托构造函数 (1个参数) 的函数体被调用…”。</li>
</ul>
</li>
<li>创建 <code>s2</code> 时：<ul>
<li>首先输出 “目标构造函数 (4个参数) 被调用…” (因为 <code>Square(double, string)</code> 委托给了它)。</li>
<li>然后输出 “委托构造函数 (2个参数) 的函数体被调用…”。</li>
</ul>
</li>
<li>创建 <code>s3</code> 时：<ul>
<li>只输出 “目标构造函数 (4个参数) 被调用…” (因为它就是目标构造函数，没有委托)。</li>
</ul>
</li>
<li>在 <code>demonstrate_wrong_delegation_attempt</code> 中：<ul>
<li>你会看到 <code>TempSquare(v, &quot;red&quot;)</code> 确实调用了对应的构造函数，但紧接着它的析构函数也被调用了，表明它是一个生命周期短暂的临时对象。原对象的 <code>val</code> 并没有被这个临时对象的构造所影响。</li>
</ul>
</li>
<li>最后，当 <code>main</code> 函数结束时，<code>s3</code>, <code>s2</code>, <code>s1</code> (按栈的逆序) 的析构函数会被调用。</li>
</ol>
<p>这个例子清晰地展示了构造函数委托的流程和好处，以及错误尝试的后果。</p>
<hr>
<h1 id="4-QA-闪卡-QA-Flash-Cards"><a href="#4-QA-闪卡-QA-Flash-Cards" class="headerlink" title="4. QA 闪卡 (QA Flash Cards)"></a>4. QA 闪卡 (QA Flash Cards)</h1><p><strong>闪卡 1</strong><br>Q: 什么是 C++ 中的构造函数委托 (constructor delegation)？<br>A: 一个构造函数调用同一个类中的另一个构造函数来完成对象的初始化。</p>
<p><strong>闪卡 2</strong><br>Q: 使用构造函数委托的主要目的是什么？<br>A: 避免构造函数之间的代码重复，提高代码的可维护性。</p>
<p><strong>闪卡 3</strong><br>Q: 如何在 C++ 中实现构造函数委托 (语法)？<br>A: 在委托构造函数的初始化列表 (initializer list) 中，使用 <code>: ClassName(arguments)</code> 的形式调用目标构造函数。</p>
<p><strong>闪卡 4</strong><br>Q: 当使用构造函数委托时，哪个构造函数的函数体先执行？目标构造函数还是委托构造函数？<br>A: 目标构造函数的函数体先执行，然后是委托构造函数的函数体。</p>
<p><strong>闪卡 5</strong><br>Q: 如果一个构造函数委托给另一个构造函数，它还能在自己的初始化列表中初始化其他成员变量吗？<br>A: 不可以。委托调用必须是初始化列表中关于成员初始化的唯一项。</p>
<p><strong>闪卡 6</strong><br>Q: 在一个构造函数的函数体 (body) 中直接调用 <code>ClassName(...)</code> 会实现委托吗？<br>A: 不会。这会创建一个临时的、局部的 <code>ClassName</code> 对象，而不是委托给当前对象的另一个构造函数。</p>
<hr>
<h1 id="5-常见误解或易犯错误"><a href="#5-常见误解或易犯错误" class="headerlink" title="5. 常见误解或易犯错误"></a>5. 常见误解或易犯错误</h1><ol>
<li><p><strong>在函数体内调用构造函数进行委托：</strong></p>
<ul>
<li><strong>误解：</strong> <code>MyClass() { MyClass(defaultValue); }</code> 可以实现委托。</li>
<li><strong>事实：</strong> 这会创建一个新的、临时的 <code>MyClass</code> 对象，它与当前正在构造的对象无关，并且通常会立即被销毁。当前对象的成员可能仍未初始化或初始化不正确。</li>
<li><strong>正确做法：</strong> 必须使用初始化列表语法 <code>MyClass() : MyClass(defaultValue) {}</code>。</li>
</ul>
</li>
<li><p><strong>在委托的同时尝试初始化其他成员变量：</strong></p>
<ul>
<li><strong>误解：</strong> <code>MyClass(int x) : MyClass(x, 0), m_someOtherMember(10) {}</code> 是允许的。</li>
<li><strong>事实：</strong> 这是编译错误。如果一个构造函数使用了委托，那么该委托调用必须是其初始化列表中唯一负责（直接或间接）成员初始化的项。你不能既委托构造，又在同一个初始化列表中初始化其他成员。</li>
<li><strong>正确做法：</strong> 要么让目标构造函数负责所有初始化，要么在委托构造函数的 <em>函数体</em> 中进行后续的赋值操作（此时对象已被目标构造函数初始化）。</li>
</ul>
</li>
<li><p><strong>对执行顺序的困惑：</strong></p>
<ul>
<li><strong>误解：</strong> 委托构造函数的函数体先执行，然后再调用目标构造函数。</li>
<li><strong>事实：</strong> 顺序是：委托构造函数被调用 -&gt; 目标构造函数的初始化列表和函数体被执行 -&gt; 委托构造函数的函数体被执行。</li>
</ul>
</li>
<li><p><strong>忘记提供所有必要的参数给目标构造函数：</strong></p>
<ul>
<li>如果目标构造函数需要多个参数，你在委托时必须提供所有这些参数，无论是通过传递委托构造函数的参数，还是使用默认值/常量。</li>
</ul>
</li>
<li><p><strong>过度委托或形成委托环路 (虽然编译器通常会捕捉到直接环路)：</strong></p>
<ul>
<li>例如：<code>C1() : C2() {}</code>，<code>C2() : C1() {}</code>。这会导致无限递归，编译器会报错。设计委托链时要确保有一个明确的“最终”目标构造函数。</li>
</ul>
</li>
<li><p><strong>不理解委托构造函数的函数体的执行时机：</strong></p>
<ul>
<li>委托构造函数的函数体是在对象已经由目标构造函数完全构建之后才执行的。这意味着在委托构造函数的函数体内，所有成员变量（至少那些由目标构造函数初始化的）都已经有了有效的值。你可以利用这一点来进行一些只有这个特定委托构造函数才需要的额外调整或操作。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="6-编码练习"><a href="#6-编码练习" class="headerlink" title="6. 编码练习"></a>6. 编码练习</h1><p>现在，轮到你来试试身手了！下面是一个 <code>Rectangle</code> (矩形) 类的骨架。你需要完成它，使得其中一个构造函数委托给另一个构造函数。</p>
<p><strong>Rectangle.h</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RECTANGLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECTANGLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_width;</span><br><span class="line">    <span class="keyword">double</span> m_height;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_color;</span><br><span class="line">    <span class="keyword">int</span> m_border_style; <span class="comment">// 0 for none, 1 for solid, 2 for dashed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 目标构造函数: 初始化所有成员</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color, <span class="keyword">int</span> border_style)</span><br><span class="line">        : m_width&#123;width&#125;, m_height&#123;height&#125;, m_color&#123;color&#125;, m_border_style&#123;border_style&#125; &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"目标 Rectangle 构造函数 (4个参数) 被调用.\n"</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Width: "</span> &lt;&lt; m_width &lt;&lt; <span class="string">", Height: "</span> &lt;&lt; m_height</span><br><span class="line">                  &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color &lt;&lt; <span class="string">", Border: "</span> &lt;&lt; m_border_style &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习1: 这是一个只接受宽度和高度的构造函数。</span></span><br><span class="line">    <span class="comment">// 请让它委托给上面的四参数构造函数。</span></span><br><span class="line">    <span class="comment">// 为 color 提供默认值 "Red"。</span></span><br><span class="line">    <span class="comment">// 为 border_style 提供默认值 1 (solid)。</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height)</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加构造函数委托调用，替换掉下面的空初始化列表</span></span><br><span class="line">        : <span class="comment">/* <span class="doctag">TODO:</span> 你的代码在这里 */</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"委托 Rectangle 构造函数 (2个参数) 的函数体被调用.\n"</span>;</span><br><span class="line">        <span class="comment">// 你可以在这里添加一些额外的逻辑，如果需要的话</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习2: 这是一个只接受宽度、高度和颜色的构造函数。</span></span><br><span class="line">    <span class="comment">// 请让它也委托给四参数构造函数。</span></span><br><span class="line">    <span class="comment">// 为 border_style 提供默认值 0 (none)。</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color)</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加构造函数委托调用，替换掉下面的空初始化列表</span></span><br><span class="line">        : <span class="comment">/* <span class="doctag">TODO:</span> 你的代码在这里 */</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"委托 Rectangle 构造函数 (3个参数) 的函数体被调用.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle Info -&gt; Width: "</span> &lt;&lt; m_width</span><br><span class="line">                  &lt;&lt; <span class="string">", Height: "</span> &lt;&lt; m_height</span><br><span class="line">                  &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color</span><br><span class="line">                  &lt;&lt; <span class="string">", Border Style: "</span> &lt;&lt; m_border_style &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Rectangle() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle ("</span> &lt;&lt; m_width &lt;&lt; <span class="string">"x"</span> &lt;&lt; m_height &lt;&lt; <span class="string">") 析构.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// RECTANGLE_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong>main.cpp (用于测试你的代码)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Rectangle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 创建 rect1 (使用2个参数) ---\n"</span>;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect1</span><span class="params">(<span class="number">10.0</span>, <span class="number">5.0</span>)</span></span>;</span><br><span class="line">    rect1.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 创建 rect2 (使用3个参数) ---\n"</span>;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect2</span><span class="params">(<span class="number">7.0</span>, <span class="number">3.0</span>, <span class="string">"Blue"</span>)</span></span>;</span><br><span class="line">    rect2.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 创建 rect3 (使用4个参数) ---\n"</span>;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect3</span><span class="params">(<span class="number">2.0</span>, <span class="number">2.0</span>, <span class="string">"Green"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    rect3.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"程序即将结束。\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>请你修改 <code>Rectangle.h</code> 中标记为 <code>/* TODO: 你的代码在这里 */</code> 的部分，实现构造函数委托。完成后，将你修改后的 <code>Rectangle.h</code> 文件内容告诉我，我会帮你检查并给出反馈。</p>
<p>祝你编码愉快！</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RECTANGLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECTANGLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_width;</span><br><span class="line">    <span class="keyword">double</span> m_height;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_color;</span><br><span class="line">    <span class="keyword">int</span> m_border_style; <span class="comment">// 0 for none, 1 for solid, 2 for dashed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 目标构造函数: 初始化所有成员</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color, <span class="keyword">int</span> border_style)</span><br><span class="line">        : m_width&#123;width&#125;, m_height&#123;height&#125;, m_color&#123;color&#125;, m_border_style&#123;border_style&#125; &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"目标 Rectangle 构造函数 (4个参数) 被调用.\n"</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Width: "</span> &lt;&lt; m_width &lt;&lt; <span class="string">", Height: "</span> &lt;&lt; m_height</span><br><span class="line">                  &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color &lt;&lt; <span class="string">", Border: "</span> &lt;&lt; m_border_style &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习1: 这是一个只接受宽度和高度的构造函数。</span></span><br><span class="line">    <span class="comment">// 请让它委托给上面的四参数构造函数。</span></span><br><span class="line">    <span class="comment">// 为 color 提供默认值 "Red"。</span></span><br><span class="line">    <span class="comment">// 为 border_style 提供默认值 1 (solid)。</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height)</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加构造函数委托调用，替换掉下面的空初始化列表</span></span><br><span class="line">        : Rectangle(width, height, <span class="string">"red"</span>, <span class="number">1</span>)<span class="comment">/* <span class="doctag">TODO:</span> 你的代码在这里 */</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"委托 Rectangle 构造函数 (2个参数) 的函数体被调用.\n"</span>;</span><br><span class="line">        <span class="comment">// 你可以在这里添加一些额外的逻辑，如果需要的话</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习2: 这是一个只接受宽度、高度和颜色的构造函数。</span></span><br><span class="line">    <span class="comment">// 请让它也委托给四参数构造函数。</span></span><br><span class="line">    <span class="comment">// 为 border_style 提供默认值 0 (none)。</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color)</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加构造函数委托调用，替换掉下面的空初始化列表</span></span><br><span class="line">        : Rectangle(width, height, color, <span class="number">1</span>)<span class="comment">/* <span class="doctag">TODO:</span> 你的代码在这里 */</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"委托 Rectangle 构造函数 (3个参数) 的函数体被调用.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle Info -&gt; Width: "</span> &lt;&lt; m_width</span><br><span class="line">                  &lt;&lt; <span class="string">", Height: "</span> &lt;&lt; m_height</span><br><span class="line">                  &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color</span><br><span class="line">                  &lt;&lt; <span class="string">", Border Style: "</span> &lt;&lt; m_border_style &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Rectangle() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle ("</span> &lt;&lt; m_width &lt;&lt; <span class="string">"x"</span> &lt;&lt; m_height &lt;&lt; <span class="string">") 析构.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// RECTANGLE_H</span></span></span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>太棒了！你已经尝试完成了这个练习，这非常好！我们一起来看看你的代码。</p>
<hr>
<h1 id="7-评价你的解答、正确答案及解释"><a href="#7-评价你的解答、正确答案及解释" class="headerlink" title="7. 评价你的解答、正确答案及解释"></a>7. 评价你的解答、正确答案及解释</h1><p>你的解答：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RECTANGLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECTANGLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_width;</span><br><span class="line">    <span class="keyword">double</span> m_height;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_color;</span><br><span class="line">    <span class="keyword">int</span> m_border_style; <span class="comment">// 0 for none, 1 for solid, 2 for dashed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 目标构造函数: 初始化所有成员</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color, <span class="keyword">int</span> border_style)</span><br><span class="line">        : m_width&#123;width&#125;, m_height&#123;height&#125;, m_color&#123;color&#125;, m_border_style&#123;border_style&#125; &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"目标 Rectangle 构造函数 (4个参数) 被调用.\n"</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Width: "</span> &lt;&lt; m_width &lt;&lt; <span class="string">", Height: "</span> &lt;&lt; m_height</span><br><span class="line">                  &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color &lt;&lt; <span class="string">", Border: "</span> &lt;&lt; m_border_style &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习1: 这是一个只接受宽度和高度的构造函数。</span></span><br><span class="line">    <span class="comment">// 请让它委托给上面的四参数构造函数。</span></span><br><span class="line">    <span class="comment">// 为 color 提供默认值 "Red"。</span></span><br><span class="line">    <span class="comment">// 为 border_style 提供默认值 1 (solid)。</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height)</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加构造函数委托调用，替换掉下面的空初始化列表</span></span><br><span class="line">        : Rectangle(width, height, <span class="string">"red"</span>, <span class="number">1</span>)<span class="comment">/* 你的代码在这里 */</span> &#123; <span class="comment">// &lt;-- 你的实现1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"委托 Rectangle 构造函数 (2个参数) 的函数体被调用.\n"</span>;</span><br><span class="line">        <span class="comment">// 你可以在这里添加一些额外的逻辑，如果需要的话</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习2: 这是一个只接受宽度、高度和颜色的构造函数。</span></span><br><span class="line">    <span class="comment">// 请让它也委托给四参数构造函数。</span></span><br><span class="line">    <span class="comment">// 为 border_style 提供默认值 0 (none)。</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color)</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加构造函数委托调用，替换掉下面的空初始化列表</span></span><br><span class="line">        : Rectangle(width, height, color, <span class="number">1</span>)<span class="comment">/* 你的代码在这里 */</span> &#123; <span class="comment">// &lt;-- 你的实现2</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"委托 Rectangle 构造函数 (3个参数) 的函数体被调用.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle Info -&gt; Width: "</span> &lt;&lt; m_width</span><br><span class="line">                  &lt;&lt; <span class="string">", Height: "</span> &lt;&lt; m_height</span><br><span class="line">                  &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color</span><br><span class="line">                  &lt;&lt; <span class="string">", Border Style: "</span> &lt;&lt; m_border_style &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Rectangle() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle ("</span> &lt;&lt; m_width &lt;&lt; <span class="string">"x"</span> &lt;&lt; m_height &lt;&lt; <span class="string">") 析构.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// RECTANGLE_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong>评价：</strong></p>
<ul>
<li><p><strong>练习1 (<code>Rectangle(double width, double height)</code>)：</strong></p>
<ul>
<li><code>: Rectangle(width, height, &quot;red&quot;, 1)</code></li>
<li><strong>做得非常好！</strong> 这里的委托调用是完全正确的。你正确地将 <code>width</code> 和 <code>height</code> 参数传递了下去，并为 <code>color</code> 提供了字符串字面量 <code>&quot;red&quot;</code> (它会隐式转换为 <code>std::string</code>)，为 <code>border_style</code> 提供了整数 <code>1</code>。这完全符合题目要求。</li>
</ul>
</li>
<li><p><strong>练习2 (<code>Rectangle(double width, double height, const std::string&amp; color)</code>)：</strong></p>
<ul>
<li><code>: Rectangle(width, height, color, 1)</code></li>
<li><strong>这里有一个小小的偏差。</strong> 题目要求是为 <code>border_style</code> 提供默认值 <code>0</code> (none)，但你的代码中提供的是 <code>1</code>。不过，委托的语法本身是正确的，只是提供的默认值与要求不符。</li>
</ul>
</li>
</ul>
<p><strong>总体评分：4.5 / 5 星</strong> ⭐⭐⭐⭐✨</p>
<p>你对构造函数委托的语法和基本用法掌握得很好！只是在练习2中对题目要求的细节稍有疏忽。这是一个很容易修正的小问题。</p>
<hr>
<p><strong>正确答案及解释：</strong></p>
<p>下面是修正了练习2中默认值的 <code>Rectangle.h</code>：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RECTANGLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECTANGLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_width;</span><br><span class="line">    <span class="keyword">double</span> m_height;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_color;</span><br><span class="line">    <span class="keyword">int</span> m_border_style; <span class="comment">// 0 for none, 1 for solid, 2 for dashed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 目标构造函数 (Target Constructor): 初始化所有成员</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color, <span class="keyword">int</span> border_style)</span><br><span class="line">        : m_width&#123;width&#125;, m_height&#123;height&#125;, m_color&#123;color&#125;, m_border_style&#123;border_style&#125; &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"目标 Rectangle 构造函数 (4个参数) 被调用.\n"</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Width: "</span> &lt;&lt; m_width &lt;&lt; <span class="string">", Height: "</span> &lt;&lt; m_height</span><br><span class="line">                  &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color &lt;&lt; <span class="string">", Border: "</span> &lt;&lt; m_border_style &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习1: 委托构造函数 (Delegating Constructor)</span></span><br><span class="line">    <span class="comment">// 为 color 提供默认值 "Red"。</span></span><br><span class="line">    <span class="comment">// 为 border_style 提供默认值 1 (solid)。</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height)</span><br><span class="line">        : Rectangle(width, height, <span class="string">"Red"</span>, <span class="number">1</span>) &#123; <span class="comment">// 正确: 委托给四参数构造函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"委托 Rectangle 构造函数 (2个参数) 的函数体被调用.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习2: 委托构造函数 (Delegating Constructor)</span></span><br><span class="line">    <span class="comment">// 为 border_style 提供默认值 0 (none)。</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> height, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; color)</span><br><span class="line">        : Rectangle(width, height, color, <span class="number">0</span>) &#123; <span class="comment">// 正确: 委托给四参数构造函数，border_style 修正为 0</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"委托 Rectangle 构造函数 (3个参数) 的函数体被调用.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle Info -&gt; Width: "</span> &lt;&lt; m_width</span><br><span class="line">                  &lt;&lt; <span class="string">", Height: "</span> &lt;&lt; m_height</span><br><span class="line">                  &lt;&lt; <span class="string">", Color: "</span> &lt;&lt; m_color</span><br><span class="line">                  &lt;&lt; <span class="string">", Border Style: "</span> &lt;&lt; m_border_style &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Rectangle() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle ("</span> &lt;&lt; m_width &lt;&lt; <span class="string">"x"</span> &lt;&lt; m_height &lt;&lt; <span class="string">") 析构.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// RECTANGLE_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong>解释：</strong></p>
<ol>
<li><p><strong><code>Rectangle(double width, double height)</code> 的委托：</strong></p>
<ul>
<li><code>: Rectangle(width, height, &quot;Red&quot;, 1)</code></li>
<li>我们调用了 <code>Rectangle(double, double, const std::string&amp;, int)</code> 这个目标构造函数。</li>
<li><code>width</code> (来自两参数构造函数的参数) 被传递给目标构造函数的第一个参数。</li>
<li><code>height</code> (来自两参数构造函数的参数) 被传递给目标构造函数的第二个参数。</li>
<li><code>&quot;Red&quot;</code> (一个C风格字符串字面量，会自动转换为 <code>std::string</code> 类型) 作为颜色传递给目标构造函数的第三个参数。</li>
<li><code>1</code> 作为边框样式传递给目标构造函数的第四个参数。</li>
<li>之后，<code>委托 Rectangle 构造函数 (2个参数) 的函数体被调用.</code> 这行会打印出来。</li>
</ul>
</li>
<li><p><strong><code>Rectangle(double width, double height, const std::string&amp; color)</code> 的委托：</strong></p>
<ul>
<li><code>: Rectangle(width, height, color, 0)</code></li>
<li>同样，我们调用了四参数的目标构造函数。</li>
<li><code>width</code> 和 <code>height</code> 直接传递。</li>
<li><code>color</code> (来自三参数构造函数的参数) 被传递给目标构造函数的第三个参数。</li>
<li><code>0</code> (根据题目修正后的值) 作为边框样式传递给目标构造函数的第四个参数。</li>
<li>之后，<code>委托 Rectangle 构造函数 (3个参数) 的函数体被调用.</code> 这行会打印出来。</li>
</ul>
</li>
</ol>
<p>使用 <code>main.cpp</code> 测试修正后的代码，你会得到如下输出，清晰地展示了委托的流程：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- 创建 rect1 (使用2个参数) ---</span><br><span class="line">目标 Rectangle 构造函数 (4个参数) 被调用.</span><br><span class="line">  Width: 10, Height: 5, Color: Red, Border: 1</span><br><span class="line">委托 Rectangle 构造函数 (2个参数) 的函数体被调用.</span><br><span class="line">Rectangle Info -&gt; Width: 10, Height: 5, Color: Red, Border Style: 1</span><br><span class="line"></span><br><span class="line">--- 创建 rect2 (使用3个参数) ---</span><br><span class="line">目标 Rectangle 构造函数 (4个参数) 被调用.</span><br><span class="line">  Width: 7, Height: 3, Color: Blue, Border: 0</span><br><span class="line">委托 Rectangle 构造函数 (3个参数) 的函数体被调用.</span><br><span class="line">Rectangle Info -&gt; Width: 7, Height: 3, Color: Blue, Border Style: 0</span><br><span class="line"></span><br><span class="line">--- 创建 rect3 (使用4个参数) ---</span><br><span class="line">目标 Rectangle 构造函数 (4个参数) 被调用.</span><br><span class="line">  Width: 2, Height: 2, Color: Green, Border: 2</span><br><span class="line">Rectangle Info -&gt; Width: 2, Height: 2, Color: Green, Border Style: 2</span><br><span class="line"></span><br><span class="line">程序即将结束。</span><br><span class="line">Rectangle (2x2) 析构.</span><br><span class="line">Rectangle (7x3) 析构.</span><br><span class="line">Rectangle (10x5) 析构.</span><br></pre></td></tr></table></figure></div>
<p>这个输出完美地展示了：</p>
<ul>
<li>即使我们调用的是两参数或三参数的构造函数，四参数的目标构造函数总是先被执行。</li>
<li>然后，相应的委托构造函数的函数体才被执行。</li>
<li>对象的成员变量确实是根据我们提供的参数和默认值被正确初始化的。</li>
</ul>
<hr>
<h1 id="8-建议和扩展问题"><a href="#8-建议和扩展问题" class="headerlink" title="8. 建议和扩展问题"></a>8. 建议和扩展问题</h1><p><strong>建议：</strong></p>
<ol>
<li><strong>保持一致性：</strong> 当你为委托构造函数提供默认值时，确保这些值与你的设计意图和类的整体行为一致。比如例子中的颜色字符串，”Red” 和 “red” 虽然在这里效果一样，但在大小写敏感的比较中会有差异。保持一种风格（比如都用首字母大写）会更好。</li>
<li><strong>明确目标构造函数：</strong> 在设计具有多个构造函数的类时，可以考虑将一个功能最全、能初始化所有核心成员的构造函数作为主要的“目标构造函数”。其他构造函数则通过委托并提供默认值来调用它。</li>
<li><strong>善用 <code>const</code> 和引用：</strong> 对于像 <code>std::string</code> 这样的类型，如果只是读取它们的值，在参数传递时使用 <code>const std::string&amp;</code> 通常比传值 <code>std::string</code> 更高效，可以避免不必要的拷贝。你的目标构造函数已经这样做了，非常好！</li>
</ol>
<p><strong>扩展问题供你思考和研究：</strong></p>
<ol>
<li><strong>委托链 (Delegation Chain)：</strong> 一个构造函数 <code>A</code> 可以委托给构造函数 <code>B</code>，构造函数 <code>B</code> 能否再委托给构造函数 <code>C</code>？（提示：可以，但要小心不要形成循环委托。）如果可以，执行顺序是怎样的？</li>
<li><strong>构造函数委托与默认参数 (Default Arguments)：</strong> 在某些情况下，你可能发现使用构造函数的默认参数也能达到类似减少代码重复的效果。例如：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gadget</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Gadget(<span class="keyword">int</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; n = <span class="string">"DefaultGadget"</span>) : id(i), name(n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Gadget("</span> &lt;&lt; id &lt;&lt; <span class="string">", "</span> &lt;&lt; name &lt;&lt; <span class="string">") constructed.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Gadget(int i) : Gadget(i, "DefaultGadget") &#123;&#125; // 也可以用委托</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
构造函数委托和默认参数在哪些场景下各有优势？什么时候你会倾向于使用其中一种而不是另一种？（提示：考虑当默认值的确定逻辑比较复杂，或者你想在不同的“入口”构造函数体中执行不同逻辑时。）</li>
<li><strong>构造函数委托与 <code>explicit</code> 关键字：</strong> <code>explicit</code> 关键字用于防止单参数构造函数的隐式类型转换。它与构造函数委托如何相互作用？一个 <code>explicit</code> 的构造函数可以委托给另一个构造函数吗？一个构造函数可以委托给一个 <code>explicit</code> 的构造函数吗？</li>
<li><strong>错误处理：</strong> 如果在目标构造函数中（或者它调用的任何函数中）抛出异常 (exception)，委托链会如何表现？委托构造函数的函数体还会执行吗？</li>
</ol>
<p>这些问题可以帮助你更深入地理解构造函数委托及其在C++类设计中的应用。</p>
<p>你做得非常棒！继续努力，C++的世界还有很多奇妙的特性等着你去探索！如果你有任何其他问题，随时问我。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Constructor/">Constructor    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/319%20-%20Class%20Const/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>319 - Class Const</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/324%20-%20Nested%20class/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>324 - Nested class</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/273 - constructor/" title="273 - constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">273 - constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/305 - 已删除构造 函数使用/" title="305 - 已删除构造 函数使用"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">305 - 已删除构造 函数使用</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/275 - getter and setter/" title="275 - getter and setter"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">275 - getter and setter</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/274 - default constructor/" title="274 - default constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">274 - default constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/280 - 构造与析构顺序 倒序析构/" title="280 - 构造与析构顺序 倒序析构"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">280 - 构造与析构顺序 倒序析构</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/277 - IDE 创建 cpp 类方法/" title="277 - IDE 创建 cpp 类方法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">277 - IDE 创建 cpp 类方法</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>