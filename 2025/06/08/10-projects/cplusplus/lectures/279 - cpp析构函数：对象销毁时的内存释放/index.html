<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>279 - cpp析构函数：对象销毁时的内存释放 | Bear's dream</title><meta name="description" content="279 - cpp析构函数：对象销毁时的内存释放"><meta name="keywords" content="Cpp,Coding,Tutorial,Development,Memory"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="279 - cpp析构函数：对象销毁时的内存释放"><meta name="twitter:description" content="279 - cpp析构函数：对象销毁时的内存释放"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="279 - cpp析构函数：对象销毁时的内存释放"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/279%20-%20cpp%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="279 - cpp析构函数：对象销毁时的内存释放"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/279%20-%20cpp%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/"><link rel="prev" title="282 - cpp结构体与类的区别和用法" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/282%20-%20cpp%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/"><link rel="next" title="278 - cpp 指针管理类对象示例" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/278%20-%20cpp%20%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%A4%BA%E4%BE%8B/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">178</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">160</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">23</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-析构函数：对象销毁时的内存释放"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">C++析构函数：对象销毁时的内存释放</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-析构函数：对象的优雅告别"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">C++ 析构函数：对象的优雅告别</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-析构函数：对象销毁时的内存释放"><span class="toc-number">1.</span> <span class="toc-text">C++析构函数：对象销毁时的内存释放</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-析构函数：对象的优雅告别"><span class="toc-number">2.</span> <span class="toc-text">C++ 析构函数：对象的优雅告别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">2.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">2.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">279 - cpp析构函数：对象销毁时的内存释放</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/279%20-%20cpp%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/279%20-%20cpp%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="C-析构函数：对象销毁时的内存释放"><a href="#C-析构函数：对象销毁时的内存释放" class="headerlink" title="C++析构函数：对象销毁时的内存释放"></a>C++析构函数：对象销毁时的内存释放</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about the structures.The structures are spatial functions or methods in a class that are called by the compiler to destroyyour object.And these are going to be especially useful if you are, for example, allocating memory in your constructors.Let’s look at a simple example Here we have a class called Dog.It has two sections the public section and the private section.In the public section we have two constructors, a default constructor that doesn’t take any parameterand a constructor that takes two parameters and the parameters are going to be used to initialize ourmember variables and they are passed by value here for simplicity.And they are going to be used to initialize these member variables dog name, dog breed and dog age.The special thing about this class is that it has a destructor and you declare the destructor usingthis syntax here.It puts a tilde character in front.You say the name of the class and then you put an empty parameter list.It is also possible to declare a destructor and put in its entire body in the header.And this is the syntax to do this inside the body, you’re going to do whatever it is you need to destroyyour object.For example, if the class here is allocating some memory in the constructor, the destructor is thebest place to release that.And this is an example of how you can do that.Here is a more direct example of how we allocate for dynamic memory in the constructor and release thatmemory in the destructor.We have our three variables, but we have chosen to allocate our dog age variable on the heap usingdynamic memory allocation.And after we dynamically allocate a piece of memory to store our age variable, we’re going to set thatto zero because we are in a constructor.If we are using the three parameter constructor here, we might use the past parameter to initializeour age variable.But the important thing here is that it is being dynamically allocated memory on the heap here.And when our object dies, we need to remember to release that memory and the destructor is the bestplace to release that memory.As you see here, we say delete dog age when our object dies and the compiler is going to call thisfunction when it’s about to kill the object.So you might ask, when are Destructors really called?We are going to start by looking at obvious cases here.For example, when a local stack object goes out of scope, the destructor is going to be called becausethat object is going to be wiped out from memory.So this is an obvious case in which the compiler will need to call a destructor.Also, when a heap object is released from memory using delete, the destructor is also going to becalled.But there are some indirect ways in which the structures are also called.For example, when an object is passed by value to a function, this is going to call the destructorto kill the object when the object goes out of scope in the function.Because when an object is passed by value, we’re going to have a copy in the local scope of the function.And when the function exits, that local copy is going to be killed.And we’re going to see an example of that.Another case where you might have the structure called is when a local object is returned from a function,another copy is going to be created to be used outside the function and the copy inside the functionis going to be killed.But this is not guaranteed as some compiler may optimize your return value and use some kind of referenceso you’re not guaranteed to see this behavior, but it is possible to see it now that you have an ideaabout Destructors, it’s time we headed over to Visual Studio Code and play with us a little more.Okay, here we are in our working folder.The current project is Destructors.We’re going to grab our template files pretty quick and we’re going to put them in place.And after that we’re going to open our folder in Visual Studio code.By dragging and dropping here, this is going to open our folder and we will see our main CPP file here.We can open it and a clean up and remove what we don’t need.We have an unneeded breakpoint here.We can remove that and we’re going to clean up the main function.The first thing we want to do is to put in our dog class.I am going to just put this in here because I don’t want you to watch me type all this.That’s just going to waste your time.We have two sections in the dog class.We have a public section which is going to now contain our constructors and we have a private sectionwhich is going to contain three member variables.We have two strings, one for.The name and the other for the breed of dog.And we have another one which is an int pointer, which is going to store the age of the dog and yousee that this is initialized to null pointer.One thing you should notice is that for our parameter taking constructor, we are passing the stringinformation here using string views to avoid copies with the STD string view type.You already know this because we learnt about this, but for this to work we will need to include thestring view.So let’s do that.And now we have our class and we can use it however we want.So but before we do, we need to put in the implementations for this functions.One way we can do that is do that directly in the function here, but I want you to see that you canalso do that directly outside the class here.I don’t think I have shown you this, but it is possible to do that.So we’re going to grab the prototype for our constructor and say the scope resolution operator and we’regoing to just paste in what we have copied, which is the prototype here, and we’re going to go inside,put in our body and in the body we’re going to initialize these three guys.So the name is going to be initialized to name Param and the breed is going to be initialized to breedparam.We can do that and the age is going to be dynamically allocated from the heap.You see that it is a pointer.So we’re going to say p equals new and because we’re going to allocate dynamic space to store an INTand we’re going to put data in using our good old dereference operator, we’re going to say P equalswhatever page parameter that you passed.And I think we should say age here because it’s not a pointer.So we’re going to say age.I think this is going to do better.H Param This is probably going to be better and we’re going to say age param.Okay, so now we have our constructor and, and it’s going to allocate memory from the heap and we’regoing to put data in that new memory location that has just been allocated to our class here.So this is our class and we can go in the main function and really use it however we want.For example, we can set up a dog object, so we’re going to say my dog and we’re going to give it aname.The name is going to be fluffy and we’re going to put the breed in and it’s going to just be a shepherdand we’re going to put in the age, which is going to be, for example, a two let’s say our dog istwo years old.This is a valid C plus plus code.It’s going to be setting up an object of our class here and we can build to see that this program isgoing to build without a problem.So both is good.But if we run the program, we’re not going to see anything.But we don’t really need to see our constructor here called because we already know about constructors.What we want to learn about are Destructors, and these are special methods that are called by the compiler.When your object dies.Let’s set up a destructor and see it called When Our Dog Objects Die.The syntax to do that is to use the tilde character here.You’re going to say the name of the class.You’re going to put an empty parameter list.And if you want, you can put a body and do whatever you want to do in the body of your destructor here.But again, we’re going to move the entire definition of the destructor to the outside.So let’s go down and save that.We’re going to say the scope resolution operator.We’re going to say dog and we’re going to put in our body.And the first thing we want to do in our destructor is to release this memory that was dynamically allocatedfor us.If we don’t release it when this dog object dies, we’re going to leak memory.And that’s really bad.So let’s do that directly in the destructor.We can say delete and say page.This is going to release the memory that was allocated in the constructor here.And we have access to this page variable because of the destructor is part of our class.Any member function of your class is going to have access to any member variable, even if it happensto be private.Okay, so we forgot our tilde character.Let’s put that in here and this is going to be valid C plus plus code.But to really see things happening here, let’s put in an Stdcout statement.We’re going to say dog destructor called for and we’re going to say the name of the dog, let’s sayname, and we’re going to say the same thing in the constructor.We’re going to say Stdcout and say dog constructor called for and we’re going to say the dog name goingto use our member variable.And now we have our thing in place.We have the destructor declared in the class definition, and this is the syntax again, this is whatwe really want to learn about in this lecture.We have the tilde character, we have the class name and we put an empty parameter list.Let me tell you that it is not possible to pass parameters to your destructor.If you do that, you’re going to get a compiler error.Destructors were always have no parameters in C plus plus.Here we have the definition of our destructor and it is going to release whatever memory we have dynamicallyallocated from the constructor here.If we run this program, we’re going to see our constructor called as a result of this line here, becausewe are constructing a dog object and we’re going to see the destructor called when the main functionis about to end.Let’s put an stdcout statement to the main function here and say done.Just to prove that we have hit the end of our main function here.I think this is useful and we’re going to build.So let’s do that.We’re going to build with GCC.You’re going to see that the build is good so we can clear and run our program.Let’s hit enter here and clear and run, Rooster.You’re going to see that the constructor was called.We are going to say done when the main function is about to end.But before the main function ends, we’re going to destroy any stack data that we have in the main functionand our dog object is on the stack.So it’s going to be destroyed as part of that process.And the destructor for dog is going to be called and we’re going to release our memory and we’re goingto say that dog destructor was called for whatever name we have assigned to our dog here.So this is how Destructors are called when your objects are killed.And we didn’t put in the correct name, we said Fluffly, let’s say Fluffy, because that’s what I wanted.And now you see that our destructor is really being called and releasing memory however we want.But we can also go a little further and show you another example of a case where Destructors are calledand we’re going to look at a function that sets up a local object of a dog.We’re going to see the dog constructor and we’re going to see it destroyed when the function is aboutto end.Let’s do that.We’re going to say void Somefunc and it’s going to be just some function to play with us.We’re going to move our dog declaration and some func here and this is really it.We’re going to call this function and when we call it, we’re going to construct the object here.When the function is about to end, the compiler is going to call the destructor because it’s goingto destroy this object here.And we’re going to see the destructor called.By that point, the somefunc function is going to be popped off the top of the stack.We’re going to hit the main function here and we’re going to say done.And the program is going to end.Let’s call some function main here.So we’re going to say some func and we’re going to world to really see this happening.So we have built successfully, we can clear, clear properly and run Rooster we’re going to see constructorcalled for Fluffy destructor called for fluffy and you see done.We have hit the main function and we finished executing our program here.We can even see this through the debugger.We’re going to set up three break points.One in the main function here before we call the Somefunc function, we’re going to set up another onein our destructor before we print the message here.And we’re going to put another one in the constructor when we are about to print this message here online 20.After we set up these break points, we can kill the terminal here and minimize a little bit.Let’s kill these things here so that we have a clean we have a lot of windows here.Okay.We have our editor here.And now if we go to the tab here that says start or run, we’re going to be able to click the greenbutton here to start our debugging session.We are going to have our terminal here.So let’s bring that to the side so that we can see things printed out nicely.Let’s do like this.And now we have hit the breakpoint.In the main function we can step into the somefunc function and we’re going to do that using the stampingtwo button here.Let’s click that.We’re going to jump into some func.Now we have the option to step into, but this is going to jump us into the logic of transforming thestring literal here into a string view.Because if you see the constructor is going to take string view parameters, we can actually see this.Let’s try and hit the step into button.You see that we are in the string view class and we don’t really want this.So let’s step out and we’re going to step over this so that we can hit the next breakpoint.And you see, the next breakpoint is in our constructor.And this proves that the compiler is going to call our constructor here to build our object.If we step over this, we’re going to print the message from the constructor.And if we.We keep going, we’re going to get out of our constructor and you see where this is going to go.This is going to go in the destructor because before we leave the Somefunc function, our data objectis going to be destroyed.So we’re going to release our memory and we’re going to print the message from our constructor.And if we hit next and step out of this, I think we can do that because this is logic we don’t want.We’re going to try and step over this.And now if we hit next, we’re going to come back in some func and some func is already going to befinished.And if we hit next, we’re going to come back in main and we’re going to print done and the programis basically going to be done.Hopefully you can see that the compiler is going to call our destructor after it leaves some func herebecause it’s going to be destroying the local object that we have inside some func here.So this is one case where the destructor is going to be called by the compiler and it is if you havea local object that needs to be destroyed when function scope finishes.Another case where the destructor may be called is if you pass a class object parameter by value.So let’s change some func here and make it take something by value.So we’re going to pass a dog inside and we’re going to say dog param, this is going to do okay.Now that we have changed some func here, we can really do all kinds of crazy things with it.For example, we can set up our dog object inside our main function here.So let’s do that.We can say dog and dog.The variable name is going to be dog.We can give it a name which is going to be fluffy, it’s going to have a breed of shepherd and we cangive it the age of two like we have been doing all along.We can call our function with the dog object here, but be careful about what is going to happen herewhen we do something like this, we’re going to be passing by value and the compiler is going to seethat it needs to copy a dog object.Now, we haven’t really told our class here how to copy dog objects, and we do that through constructorswe call copy constructors we haven’t really learnt about yet.But what the compiler is going to do by default is copy these things, member by member.So it’s going to set up a dog copy object which is going to be initialized with empty strings and anull pointer here.And then it’s going to copy from our dog object that we have here.It’s going to take the name and copy that in the name member variable of our dog copy.It’s going to take the breed and copy that in in the second member variable here.And it’s going to take the age from our dog and copy that in.The problem is going to come to this pointer here.It’s going to copy the address and it’s not going to copy what is pointed to.And this is going to be a recipe for disaster.I don’t really want to go through this right now, but if we try to run this program, it’s not goingto work like we expect.For example, if we pass Fluffy here, we’re going to see things that we don’t expect.So let’s try to build.We’re going to build with GCC and the build is good.So what we expect is to have the constructor of Fluffy here called and we’re going to copy the dog objectfor use in Somefunc here.And to set up this copy, it’s not this constructor here that is going to be called, so it’s not ourconstructor here, which is going to be called.So we’re not going to see this called for the copy that we set up inside Somefunc.Another thing is because now these two dog objects are pointing to the same thing because what we justcopied is the address as we see in our member variable here, the two dog objects are going to be pointingto the same thing in memory.And when we hit the destructor, we’re going to call delete twice.And this is going to be a recipe for disaster.Our application could really crash.You already know that deleting a pointer twice is really bad.We shouldn’t do this and we are doing this here because we are copying.I realize this is a slightly confusing example, but what I want you to know is that if you pass a classobject by value like this, the copy you have inside is going to code for the destructor to be calledwhen the function exits because the copy is going to be scoped inside the function here.So let’s take out this example because it really is confusing, but I hope you note that and I am goingto show you that in other case, where you might see the destructor called is when you call the destructorexplicitly using the delete operator on your object so we can set up some func again, let’s do thatsome func and we’re going to repurpose it.And this side we’re going to set up a dog object.So let’s grab this and.And we use that in our function here and we’re going to say dog pointer.So let’s say dog pointer, we’re going to say P dog P underscore dog.It’s going to be equals to new dog and we’re going to pass in what we need to initialize our dog objectwith.This is going to create a dog object on the heap and it is going to be pointed to by p dog here.Now, I want you to see that if we don’t explicitly release the memory that we allocate through thenew operator, we’re going to leak memory.So we created an object on the heap here, but we’re not deleting that in some func.When some func exits, we’re going to lose this pointer, this variable because it is on the stack itselfand we won’t have any way to release this memory.Let’s call some func here and really show you this.So we’re going to call some func and we’re going to build.Let’s use GCC for that.The build is good.We can bring this up a little bit and clear and run Rooster.We’re going to see that the constructor for Fluffy was called because of this new operator, but wedidn’t see the destructor called and this is really bad.So for the destructor to be called, we need to explicitly release the memory in this function here.And we do that by using the delete keyword and saying the pointer that is pointing to the memory thatwe want to release.If we do this, this is going to cause for the destructor of dog to be called.And if we run, we’re going to see our destructor called.Let’s do that.We’re going to use GCC.The build is good.We can clear and run Rooster.Now you see that the constructor is called Full of Fluffy and we have the destructor called.This is really all I wanted to share with you in this lecture.I apologize if you found it confusing, but if you have any problem, I am always available.Please do ask and I will do the best I can to help you out.So the destructor is a special method which is going to be called when your object Dies.It is going to be called when an object is passed by value to a function.We have seen an example of that.It’s going to be called when a local object is returned from a function by value.But this is going to be compiler dependent because some compilers are going to optimize this out andmake it look like we returned by reference.So I don’t want to go into this because this is subject to compiler optimization, but other cases whereyou’re going to have your destructor called is when a local stack object goes out of scope and whena heap object is deleted through the delete keyword.This is really all I had to share in this lecture.I hope you found it interesting.We are going to stop here in this one and the next one we’re going to see the order in which constructorsand destructors are called and you really need to be aware of this.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，同学你好！非常开心能作为你的C++向导。今天我们要学习C++中一个非常重要的概念——析构函数。别担心，我会一步一步带你了解它。</p>
<h1 id="C-析构函数：对象的优雅告别"><a href="#C-析构函数：对象的优雅告别" class="headerlink" title="C++ 析构函数：对象的优雅告别"></a>C++ 析构函数：对象的优雅告别</h1><p><strong>简要总结：</strong><br>析构函数 (Destructor) 是类中的一种特殊成员函数。它的主要任务是在对象生命周期结束时，执行一些清理工作，比如释放对象在构造时动态分配的内存 (dynamic memory allocation)。编译器会自动调用析构函数。</p>
<hr>
<p><strong>详细解释：</strong></p>
<p>想象一下，你开了一家玩具店。</p>
<ul>
<li><strong>构造函数 (Constructor)</strong>：就像你进货并把玩具摆上货架的过程。当你创建一个对象时，构造函数负责初始化这个对象，比如给它的成员变量赋值，或者为它申请一些资源（比如内存）。</li>
<li><strong>析构函数 (Destructor)</strong>：就像你关店前，需要把没卖掉的、租来的展示架还回去，打扫卫生等。当一个对象的生命周期结束时（比如它离开了自己的作用域 (scope)，或者被显式删除），析构函数就会被自动调用，来执行一些“善后”工作。</li>
</ul>
<p><strong>1. 为什么需要析构函数？</strong></p>
<p>最常见的场景是管理动态分配的资源。如果在构造函数中使用了 <code>new</code>关键字在堆 (heap) 上为对象分配了内存，那么在对象销毁时，你就需要在析构函数中使用 <code>delete</code> 关键字来释放这块内存。如果不这么做，这块内存就会一直被占用，无法被其他程序使用，造成<strong>内存泄漏 (memory leak)</strong>——这就像你借了书不还，图书馆的书越来越少一样，最终会导致程序因内存耗尽而崩溃。</p>
<p><strong>2. 析构函数的语法</strong></p>
<p>析构函数的声明非常特殊：</p>
<ul>
<li>它没有返回类型（连 <code>void</code> 都不写）。</li>
<li>它的名字必须是类名的前面加上一个波浪号 <code>~</code>。</li>
<li>它不能有任何参数。</li>
</ul>
<p>例如，如果你的类名是 <code>Dog</code>，那么析构函数就是 <code>~Dog()</code>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Dog() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    Dog(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数声明</span></span><br><span class="line">    ~Dog(); <span class="comment">// 这就是析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> dogName;</span><br><span class="line">    <span class="keyword">int</span>* dogAge; <span class="comment">// 假设年龄用指针动态分配</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数定义（可以在类外）</span></span><br><span class="line">Dog::~Dog() &#123;</span><br><span class="line">    <span class="comment">// 清理工作的代码，比如释放内存</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog "</span> &lt;&lt; dogName &lt;&lt; <span class="string">" is being destroyed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> dogAge; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    dogAge = <span class="literal">nullptr</span>; <span class="comment">// 好习惯：指针置空，防止悬挂指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>3. 析构函数何时被调用？</strong></p>
<p>编译器会在以下几种主要情况下自动调用析构函数：</p>
<ul>
<li><p><strong>栈 (Stack) 对象的生命周期结束</strong>：当一个在函数内部定义的局部对象（栈对象）离开其作用域时（例如，函数执行完毕），它的析构函数会被调用。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">"Buddy"</span>, <span class="number">3</span>)</span></span>; <span class="comment">// myDog 是一个栈对象</span></span><br><span class="line">    <span class="comment">// ... myDog 在这里被使用 ...</span></span><br><span class="line">&#125; <span class="comment">// 当myFunction结束时，myDog的析构函数会被自动调用</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>堆 (Heap) 对象被 <code>delete</code> 操作符 (delete operator) 删除时</strong>：当你使用 <code>new</code> 创建一个堆对象，并使用 <code>delete</code> 删除它时，该对象的析构函数会在内存被释放前调用。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog* pDog = <span class="keyword">new</span> Dog(<span class="string">"Charlie"</span>, <span class="number">5</span>); <span class="comment">// pDog 指向一个堆对象</span></span><br><span class="line">    <span class="comment">// ... pDog 在这里被使用 ...</span></span><br><span class="line">    <span class="keyword">delete</span> pDog; <span class="comment">// 首先调用pDog指向对象的析构函数，然后释放内存</span></span><br><span class="line">    pDog = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>重要</strong>：如果你 <code>new</code> 了一个对象但忘记 <code>delete</code>，析构函数将不会被调用，资源（如内存）也不会被释放，从而导致资源泄漏。</p>
</li>
<li><p><strong>对象按值传递给函数时（副本的销毁）</strong>：<br>当一个对象按值传递给一个函数时，会创建该对象的一个副本。当函数结束时，这个副本的生命周期也就结束了，它的析构函数会被调用。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processDog</span><span class="params">(Dog d)</span> </span>&#123; <span class="comment">// d 是 aDog 的一个副本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Processing dog in function..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="comment">// 当 processDog 结束时，副本 d 的析构函数会被调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">aDog</span><span class="params">(<span class="string">"Rex"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    processDog(aDog); <span class="comment">// aDog 被按值传递，创建副本</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Back in main."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// aDog 的析构函数在这里被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><em>注意</em>：按值传递对象，尤其是包含动态分配内存且没有正确定义拷贝构造函数和拷贝赋值运算符的类对象，可能会导致问题（比如浅拷贝 (shallow copy) 导致的双重释放 (double free)），我们之后会学到如何正确处理这种情况（通常涉及“三/五法则”）。</p>
</li>
<li><p><strong>从函数按值返回局部对象时（临时副本的销毁，可能被优化）</strong>：<br>当函数返回一个局部对象时，可能会创建一个临时对象用于返回值。这个临时对象的析构函数在其不再需要时会被调用。但是，现代编译器通常会进行返回值优化 (Return Value Optimization, RVO) 或命名返回值优化 (Named Return Value Optimization, NRVO)，这可能会消除临时对象的创建和销毁，所以你可能不会总是观察到这种行为。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dog <span class="title">createDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">tempDog</span><span class="params">(<span class="string">"Lucy"</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tempDog; <span class="comment">// 返回一个局部对象</span></span><br><span class="line">&#125; <span class="comment">// tempDog 的析构函数通常在这里被调用，但RVO可能改变行为</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog mainDog = createDog();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<p><strong>4. 析构函数的实现细节</strong></p>
<ul>
<li><strong>定义位置</strong>：析构函数可以在类定义内部直接定义，也可以在类外定义（像上面的 <code>Dog::~Dog()</code> 例子）。</li>
<li><strong>无参数</strong>：析构函数绝对不能有参数。如果你尝试给它参数，编译器会报错。</li>
<li><strong>隐式析构函数</strong>：如果你没有为类显式定义析构函数，编译器会自动生成一个默认的析构函数。这个默认析构函数通常什么也不做，除非类成员本身是其他类的对象且那些类有自己的析构函数（这种情况下，默认析构函数会调用成员对象的析构函数）。对于动态分配的内存，默认析构函数不会做任何释放操作。</li>
</ul>
<hr>
<p><strong>代码示例：</strong></p>
<p>让我们看一个完整的例子，演示构造函数和析构函数如何配合工作来管理动态分配的内存。我们将使用课程中提到的 <code>Dog</code> 类。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt; // 为了高效传递字符串参数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> dog_name_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> dog_breed_;</span><br><span class="line">    <span class="keyword">int</span>* p_dog_age_; <span class="comment">// 指针 (pointer)，用于动态分配年龄</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数 (constructor) 1: 默认构造函数</span></span><br><span class="line">    Dog() : dog_name_(<span class="string">"Nameless"</span>), dog_breed_(<span class="string">"Unknown"</span>) &#123;</span><br><span class="line">        p_dog_age_ = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// 在堆上分配一个int大小的内存</span></span><br><span class="line">        *p_dog_age_ = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"默认构造函数被调用，为小狗 "</span> &lt;&lt; dog_name_ &lt;&lt; <span class="string">" 分配了年龄内存。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数 (constructor) 2: 带参数</span></span><br><span class="line">    <span class="comment">// 使用 std::string_view 避免不必要的 std::string 拷贝</span></span><br><span class="line">    Dog(<span class="built_in">std</span>::string_view name_param, <span class="built_in">std</span>::string_view breed_param, <span class="keyword">int</span> age_param)</span><br><span class="line">        : dog_name_(name_param), dog_breed_(breed_param) &#123;</span><br><span class="line">        p_dog_age_ = <span class="keyword">new</span> <span class="keyword">int</span>;       <span class="comment">// 在堆 (heap) 上为年龄动态分配内存</span></span><br><span class="line">        *p_dog_age_ = age_param;    <span class="comment">// 将传入的年龄值存入新分配的内存中</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"参数化构造函数被调用，为小狗 "</span> &lt;&lt; dog_name_ &lt;&lt; <span class="string">" (年龄: "</span> &lt;&lt; *p_dog_age_ &lt;&lt; <span class="string">") 分配了年龄内存。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数 (destructor)</span></span><br><span class="line">    ~Dog() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数被调用，准备为小狗 "</span> &lt;&lt; dog_name_ &lt;&lt; <span class="string">" 释放年龄内存。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> p_dog_age_;      <span class="comment">// 释放构造函数中动态分配的内存</span></span><br><span class="line">        p_dog_age_ = <span class="literal">nullptr</span>;   <span class="comment">// 良好习惯：将指针置为空，防止悬挂指针 (dangling pointer)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"小狗 "</span> &lt;&lt; dog_name_ &lt;&lt; <span class="string">" 的年龄内存已释放。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_dog_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"小狗信息 - 名字: "</span> &lt;&lt; dog_name_ &lt;&lt; <span class="string">", 品种: "</span> &lt;&lt; dog_breed_ &lt;&lt; <span class="string">", 年龄: "</span> &lt;&lt; (p_dog_age_ ? *p_dog_age_ : <span class="number">-1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个演示析构函数调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function_stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 进入 some_function_stack ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Dog <span class="title">local_dog</span><span class="params">(<span class="string">"旺财"</span>, <span class="string">"中华田园犬"</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 栈对象</span></span><br><span class="line">    local_dog.print_dog_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 离开 some_function_stack ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 当函数结束时，local_dog会离开作用域，其析构函数被调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function_heap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 进入 some_function_heap ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Dog* heap_dog = <span class="keyword">new</span> Dog(<span class="string">"啸天"</span>, <span class="string">"细犬"</span>, <span class="number">5</span>); <span class="comment">// 堆对象</span></span><br><span class="line">    heap_dog-&gt;print_dog_info();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"显式删除堆对象 heap_dog..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> heap_dog; <span class="comment">// 显式调用delete，会触发析构函数</span></span><br><span class="line">    heap_dog = <span class="literal">nullptr</span>; <span class="comment">// 好习惯</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不delete，当some_function_heap结束时，heap_dog指针本身会消失，</span></span><br><span class="line">    <span class="comment">// 但它指向的内存不会被释放，造成内存泄漏，析构函数也不会被调用。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 离开 some_function_heap ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 程序开始 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    some_function_stack();</span><br><span class="line"></span><br><span class="line">    some_function_heap();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 创建主函数中的栈对象 dog_main ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Dog <span class="title">dog_main</span><span class="params">(<span class="string">"小白"</span>, <span class="string">"萨摩耶"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    dog_main.print_dog_info();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 主函数即将结束 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 当main函数结束时，dog_main会离开作用域，其析构函数被调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>预期输出分析：</strong><br>你会看到构造函数和析构函数的 <code>std::cout</code> 语句交替出现。特别注意 <code>some_function_stack</code> 和 <code>some_function_heap</code> 中对象的创建和销毁顺序，以及 <code>main</code> 函数中对象的销毁时机。</p>
<hr>
<p><strong>QA闪卡 (QA Flash Cards):</strong></p>
<ol>
<li><p><strong>问：</strong>什么是析构函数 (Destructor)？<br><strong>答：</strong> 类中的一个特殊成员函数，在对象生命周期结束时自动调用，用于执行清理工作，如释放动态分配的资源。</p>
</li>
<li><p><strong>问：</strong>如何声明一个析构函数？<br><strong>答：</strong> 使用波浪号 <code>~</code> 加上类名，例如 <code>~MyClass()</code>。它没有返回类型，也没有参数。</p>
</li>
<li><p><strong>问：</strong>析构函数最常见的用途是什么？<br><strong>答：</strong> 释放在构造函数中或对象生命周期内动态分配的内存 (dynamic memory allocation) 或其他资源（如文件句柄、网络连接）。</p>
</li>
<li><p><strong>问：</strong>什么时候析构函数会被调用？（至少列举两种情况）<br><strong>答：</strong></p>
<ul>
<li>当栈 (stack) 上的局部对象离开其作用域 (scope) 时。</li>
<li>当堆 (heap) 上的对象被 <code>delete</code> 操作符 (delete operator) 删除时。</li>
<li>（可选）当按值传递给函数的对象副本在函数结束时。</li>
</ul>
</li>
<li><p><strong>问：</strong>如果我创建了一个对象 <code>MyClass* obj = new MyClass();</code> 但忘记 <code>delete obj;</code>，会发生什么？<br><strong>答：</strong> 该对象的析构函数不会被调用，它占用的堆内存也不会被释放，导致内存泄漏 (memory leak)。</p>
</li>
</ol>
<hr>
<p><strong>常见误解或新手易犯错误：</strong></p>
<ol>
<li><strong>忘记释放动态分配的内存</strong>：这是最常见的错误。如果在构造函数中用了 <code>new</code>，就必须在析构函数中用 <code>delete</code>（如果是数组用 <code>new[]</code>，则用 <code>delete[]</code>）。否则会导致内存泄漏。<ul>
<li>错误示例：析构函数为空，但构造函数中 <code>p_dog_age_ = new int;</code></li>
</ul>
</li>
<li><strong>对非动态分配的内存使用 <code>delete</code></strong>：<code>delete</code> 只能用于通过 <code>new</code> 分配的指针。对栈上对象的地址或已释放的指针使用 <code>delete</code> 会导致未定义行为（通常是程序崩溃）。<ul>
<li>错误示例：<code>int x; delete &amp;x;</code> (x是栈变量)</li>
</ul>
</li>
<li><strong>重复释放内存 (Double Free)</strong>：同一个指针被 <code>delete</code> 两次。这通常发生在多个指针指向同一块动态分配的内存，并且都尝试释放它时，或者不小心拷贝了原始指针并分别删除。这也会导致程序崩溃。<ul>
<li>这与课程中提到的“按值传递类对象”时的潜在问题有关。如果类有一个原始指针成员，并且你没有定义自己的拷贝构造函数，那么按值传递时，会创建一个“浅拷贝”，使得副本和原始对象的指针成员指向同一块内存。当副本销毁时，它会 <code>delete</code> 这块内存；当原始对象销毁时，它会再次 <code>delete</code> 已经被释放的内存，Boom！</li>
</ul>
</li>
<li><strong>认为指针变量离开作用域就会自动释放其指向的堆内存</strong>：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leaky_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* num_ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="comment">// num_ptr (栈上的指针变量) 消失了，但它指向的堆内存 (存储10的那块) 还在，并且无法访问了 -&gt; 内存泄漏</span></span><br></pre></td></tr></table></figure></div>
必须显式调用 <code>delete num_ptr;</code> 才能释放堆内存并调用析构函数（如果 <code>num_ptr</code> 指向的是类对象）。</li>
<li><strong>给析构函数添加参数或返回类型</strong>：析构函数有严格的语法规定：无参数，无返回类型。</li>
</ol>
<hr>
<p><strong>编码练习：</strong></p>
<p>下面是一个 <code>ResourceHolder</code> 类，它在构造时获取一些“资源”（这里用动态分配的 <code>int</code> 模拟）。请你为它补全析构函数，确保资源被正确释放。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceHolder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_resource; <span class="comment">// 指向我们“获取”的资源</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，获取资源</span></span><br><span class="line">    ResourceHolder(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">int</span> value) : m_name(name) &#123;</span><br><span class="line">        m_resource = <span class="keyword">new</span> <span class="keyword">int</span>(value); <span class="comment">// 动态分配一个整数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ResourceHolder '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' created, resource value: "</span> &lt;&lt; *m_resource &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 实现析构函数</span></span><br><span class="line">    <span class="comment">// 你需要在这里添加代码来释放 m_resource 指向的内存</span></span><br><span class="line">    <span class="comment">// 并打印一条消息，表明资源已被释放</span></span><br><span class="line">    <span class="comment">// ~ResourceHolder() &#123;</span></span><br><span class="line">    <span class="comment">//     // 在这里填入你的代码</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_resource) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ResourceHolder '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' has resource with value: "</span> &lt;&lt; *m_resource &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ResourceHolder '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' has no resource."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Program Start ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#123; <span class="comment">// 创建一个作用域块</span></span><br><span class="line">        <span class="function">ResourceHolder <span class="title">rh1</span><span class="params">(<span class="string">"DataBlock1"</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">        rh1.print_info();</span><br><span class="line"></span><br><span class="line">        ResourceHolder* rh2 = <span class="keyword">new</span> ResourceHolder(<span class="string">"DataBlock2_Heap"</span>, <span class="number">200</span>);</span><br><span class="line">        rh2-&gt;print_info();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加代码，显式删除 rh2 指向的对象</span></span><br><span class="line">        <span class="comment">// (思考：如果这里不delete，会发生什么？rh2的析构函数会被调用吗？)</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// rh1 会在这里离开作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Program End ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请你思考一下，<code>// TODO:</code> 部分应该填入什么代码，然后把你的实现方案告诉我。我会根据你的答案给出反馈。加油！</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceHolder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_resource; <span class="comment">// 指向我们“获取”的资源</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，获取资源</span></span><br><span class="line">    ResourceHolder(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">int</span> value) : m_name(name) &#123;</span><br><span class="line">        m_resource = <span class="keyword">new</span> <span class="keyword">int</span>(value); <span class="comment">// 动态分配一个整数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ResourceHolder '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' created, resource value: "</span> &lt;&lt; *m_resource &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 实现析构函数</span></span><br><span class="line">    <span class="comment">// 你需要在这里添加代码来释放 m_resource 指向的内存</span></span><br><span class="line">    <span class="comment">// 并打印一条消息，表明资源已被释放</span></span><br><span class="line">     ~ResourceHolder() &#123;</span><br><span class="line">        <span class="comment">// 在这里填入你的代码</span></span><br><span class="line">        <span class="keyword">delete</span> m_resource;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ResourceHolder memory has been released"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_resource) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ResourceHolder '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' has resource with value: "</span> &lt;&lt; *m_resource &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ResourceHolder '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' has no resource."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Program Start ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#123; <span class="comment">// 创建一个作用域块</span></span><br><span class="line">        <span class="function">ResourceHolder <span class="title">rh1</span><span class="params">(<span class="string">"DataBlock1"</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">        rh1.print_info();</span><br><span class="line"></span><br><span class="line">        ResourceHolder* rh2 = <span class="keyword">new</span> ResourceHolder(<span class="string">"DataBlock2_Heap"</span>, <span class="number">200</span>);</span><br><span class="line">        rh2-&gt;print_info();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 在这里添加代码，显式删除 rh2 指向的对象</span></span><br><span class="line">        <span class="comment">// (思考：如果这里不delete，会发生什么？rh2的析构函数会被调用吗？)</span></span><br><span class="line">        <span class="keyword">delete</span> rh2;</span><br><span class="line">        <span class="comment">// 不delete会内存泄漏， 并且不会调用析构函数</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// rh1 会在这里离开作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Program End ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>非常好！你已经成功地为 <code>ResourceHolder</code> 类实现了析构函数，并且正确地在 <code>main</code> 函数中处理了堆对象的删除。做得不错！</p>
<hr>
<p><strong>7. 用户解答评估、正确答案及解释</strong></p>
<p><strong>用户解答评估：</strong></p>
<ul>
<li><p><strong>析构函数实现：</strong></p>
<ul>
<li><code>delete m_resource;</code>: <strong>正确</strong>。你正确地使用了 <code>delete</code> 来释放 <code>m_resource</code> 指向的动态分配的内存。</li>
<li><code>std::cout &lt;&lt; &quot;ResourceHolder memory has been released&quot; &lt;&lt; std::endl;</code>: <strong>基本正确</strong>。打印了释放消息。为了更清晰，最好能指明是哪个对象的资源被释放了，比如包含 <code>m_name</code>。</li>
<li><strong>小建议</strong>：在 <code>delete m_resource;</code> 之后，通常的好习惯是加上 <code>m_resource = nullptr;</code>。虽然在这个特定的析构函数场景下，对象即将被销毁，<code>m_resource</code> 这个成员变量本身也将不复存在，所以悬挂指针的风险相对较小。但在其他可能多次操作指针的场景下（比如一个 <code>release()</code> 方法），这是一个非常重要的防止悬挂指针 (dangling pointer) 的措施。</li>
</ul>
</li>
<li><p><strong><code>main</code> 函数中的 <code>TODO</code>：</strong></p>
<ul>
<li><code>delete rh2;</code>: <strong>正确</strong>。你正确地删除了在堆上创建的 <code>rh2</code> 对象。</li>
<li>注释 <code>// 不delete会内存泄漏， 并且不会调用析构函数</code>: <strong>理解完全正确！</strong> 如果忘记 <code>delete rh2;</code>，<code>rh2</code> 指向的 <code>ResourceHolder</code> 对象的析构函数将不会被调用，其内部通过 <code>new int()</code> 分配的内存也不会被释放，从而导致内存泄漏。</li>
</ul>
</li>
</ul>
<p><strong>综合评价：优秀！核心功能都已正确实现。</strong></p>
<p><strong>正确答案与解释：</strong></p>
<p>这是修改后更完善的版本：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 确保包含了&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceHolder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_resource; <span class="comment">// 指向我们“获取”的资源</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，获取资源</span></span><br><span class="line">    ResourceHolder(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">int</span> value) : m_name(name) &#123;</span><br><span class="line">        m_resource = <span class="keyword">new</span> <span class="keyword">int</span>(value); <span class="comment">// 动态分配一个整数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ResourceHolder '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' created, resource value: "</span> &lt;&lt; *m_resource &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~ResourceHolder() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ResourceHolder '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' is being destroyed. Releasing resource..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> m_resource;      <span class="comment">// 1. 释放动态分配的内存</span></span><br><span class="line">        m_resource = <span class="literal">nullptr</span>;   <span class="comment">// 2. 将指针设置为空，防止悬挂指针 (好习惯)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ResourceHolder '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' resource released."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查 m_resource 是否为空指针是一个好习惯，尤其是在它可能被置为 nullptr 后</span></span><br><span class="line">        <span class="keyword">if</span> (m_resource) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Info: ResourceHolder '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' has resource with value: "</span> &lt;&lt; *m_resource &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Info: ResourceHolder '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' has no (or released) resource."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Program Start ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#123; <span class="comment">// 创建一个作用域块</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nCreating rh1 (stack object)..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="function">ResourceHolder <span class="title">rh1</span><span class="params">(<span class="string">"DataBlock1_Stack"</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">        rh1.print_info();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nCreating rh2 (heap object)..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        ResourceHolder* rh2 = <span class="keyword">new</span> ResourceHolder(<span class="string">"DataBlock2_Heap"</span>, <span class="number">200</span>);</span><br><span class="line">        rh2-&gt;print_info();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nExplicitly deleting rh2 (heap object)..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> rh2; <span class="comment">// 显式删除 rh2 指向的对象，会调用其析构函数</span></span><br><span class="line">        rh2 = <span class="literal">nullptr</span>; <span class="comment">// 也是好习惯，防止悬挂指针 rh2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果我们尝试使用已经被 delete 的 rh2 (且没有置空)</span></span><br><span class="line">        <span class="comment">// if (rh2) &#123; // 如果 rh2 没有置空，这里可能还会判断为真</span></span><br><span class="line">        <span class="comment">//    rh2-&gt;print_info(); // 这将是未定义行为，很可能崩溃！</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// rh1 会在这里离开作用域，其析构函数自动被调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- Program End ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释关键点：</strong></p>
<ol>
<li><p><strong>析构函数 <code>~ResourceHolder()</code></strong>:</p>
<ul>
<li><code>delete m_resource;</code>: 这是核心。它告诉C++运行时系统，<code>m_resource</code> 指针所指向的那块在堆上分配的内存现在可以被回收了。</li>
<li><code>m_resource = nullptr;</code>: 将 <code>m_resource</code> 设置为 <code>nullptr</code> 是一个防御性编程措施。如果在析构函数被调用后（尽管不太可能对已销毁对象做操作）或者在类的其他方法中有可能在资源释放后意外访问 <code>m_resource</code>，将其设为 <code>nullptr</code> 可以防止使用一个无效的（悬挂的）指针。对空指针进行 <code>delete</code> 是安全的（什么也不做），但对悬挂指针进行操作是未定义行为。</li>
<li>更详细的析构信息：<code>std::cout &lt;&lt; &quot;ResourceHolder &#39;&quot; &lt;&lt; m_name &lt;&lt; &quot;&#39; is being destroyed...&quot; &lt;&lt; std::endl;</code> 能够帮助我们清晰地追踪是哪个对象的析构函数被调用了。</li>
</ul>
</li>
<li><p><strong><code>main</code> 函数中的 <code>delete rh2;</code></strong>:</p>
<ul>
<li><code>rh2</code> 是一个指向在堆上创建的 <code>ResourceHolder</code> 对象的指针。</li>
<li><code>delete rh2;</code> 做了两件事：<ol>
<li>调用 <code>rh2</code>所指向的 <code>ResourceHolder</code> 对象的析构函数 (<code>~ResourceHolder()</code>)。</li>
<li>释放该对象本身占用的堆内存。</li>
</ol>
</li>
<li><code>rh2 = nullptr;</code>: 在 <code>delete rh2;</code> 之后，<code>rh2</code> 本身仍然存储着之前那个对象的内存地址（现在那个地址上的内容是无效的了）。将 <code>rh2</code> 设置为 <code>nullptr</code> 可以防止后续代码不小心通过 <code>rh2</code> 访问已经被释放的内存。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>8. 建议与扩展问题</strong></p>
<p><strong>进一步的建议：</strong></p>
<ol>
<li><strong>RAII (Resource Acquisition Is Initialization)</strong>：你刚才写的其实就是 RAII 思想的一个简单体现！RAII 是一种强大的C++编程范式，即在对象的构造函数中获取资源，在析构函数中释放资源。这样可以确保资源在对象生命周期内被妥善管理，即使发生异常也能正确释放。</li>
<li><strong>智能指针 (Smart Pointers)</strong>：对于动态内存管理，C++标准库提供了智能指针（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>），它们可以自动管理所指向对象的生命周期，大大减少忘记 <code>delete</code> 导致的内存泄漏。<ul>
<li>可以尝试将 <code>int* m_resource;</code> 修改为 <code>std::unique_ptr&lt;int&gt; m_resource;</code>，这样析构函数甚至不需要显式 <code>delete</code> 了！</li>
</ul>
</li>
</ol>
<p><strong>扩展问题供你思考：</strong></p>
<ol>
<li><strong>健壮性考虑</strong>：如果在 <code>ResourceHolder</code> 的构造函数中 <code>m_resource = new int(value);</code> 失败并抛出异常（例如，内存不足时 <code>new</code> 会抛出 <code>std::bad_alloc</code>），会发生什么？析构函数会被调用吗？（提示：如果构造函数中途失败，对象未完全构造，析构函数通常不会被调用。）</li>
<li><strong>拷贝问题</strong>：如果我们允许 <code>ResourceHolder</code> 对象被拷贝，例如：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResourceHolder <span class="title">rh_original</span><span class="params">(<span class="string">"Original"</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">ResourceHolder rh_copy = rh_original; <span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// ResourceHolder rh_another("Another", 60);</span></span><br><span class="line"><span class="comment">// rh_copy = rh_another; // 拷贝赋值</span></span><br></pre></td></tr></table></figure></div>
默认的拷贝行为（浅拷贝 (shallow copy)）会导致 <code>rh_original.m_resource</code> 和 <code>rh_copy.m_resource</code> 指向同一块内存。当其中一个对象析构并释放内存后，另一个对象的 <code>m_resource</code> 就成了悬挂指针，再次析构时会导致双重释放 (double free) 错误。如何解决这个问题？（提示：<strong>深拷贝 (deep copy)</strong>，或者禁用拷贝，或者使用智能指针处理所有权。这通常涉及到“Rule of Three/Five/Zero”，即如果你自定义了析构函数、拷贝构造函数或拷贝赋值运算符中的一个，你可能需要自定义其他的。）</li>
<li><strong>移动语义 (Move Semantics)</strong>：除了拷贝，C++11引入了移动语义。如果一个 <code>ResourceHolder</code> 对象的资源可以被“转移”给另一个对象，而不是拷贝，这会更高效。这涉及到移动构造函数和移动赋值运算符。</li>
<li><strong>数组资源</strong>：如果 <code>m_resource</code> 指向的不是单个 <code>int</code>，而是一个动态分配的 <code>int</code> 数组（例如 <code>m_resource = new int[10];</code>），那么在析构函数中应该如何释放它？（提示：使用 <code>delete[] m_resource;</code>）</li>
</ol>
<p>这些问题会引导你学习更多关于C++资源管理和对象生命周期的重要概念。继续探索，你会越来越熟练！如果你对这些扩展问题有任何想法或疑问，随时可以提出！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Tutorial/">Tutorial    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a><a class="post-meta__tags" href="/tags/Memory/">Memory    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/282%20-%20cpp%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>282 - cpp结构体与类的区别和用法</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/278%20-%20cpp%20%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%A4%BA%E4%BE%8B/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>278 - cpp 指针管理类对象示例</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/256 - cpp decltype(auto)/" title="256 - cpp decltype(auto)"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">256 - cpp decltype(auto)</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/257 - cpp Default template arguments/" title="257 - cpp Default template arguments"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">257 - cpp Default template arguments</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/262 - constexpr if/" title="262 - constexpr if"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">262 - constexpr if</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/282 - cpp结构体与类的区别和用法/" title="282 - cpp结构体与类的区别和用法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">282 - cpp结构体与类的区别和用法</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/313 - friend of class/" title="313 - friend of class"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">313 - friend of class</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/318 - inline static variable/" title="318 - inline static variable"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">318 - inline static variable</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>