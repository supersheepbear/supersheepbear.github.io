<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>340 - ODR Cpp | Bear's dream</title><meta name="description" content="340 - ODR Cpp"><meta name="keywords" content="Cpp,Coding,Development,Developer,Definition"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="340 - ODR Cpp"><meta name="twitter:description" content="340 - ODR Cpp"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="340 - ODR Cpp"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/340%20-%20ODR%20Cpp/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="340 - ODR Cpp"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/340%20-%20ODR%20Cpp/"><link rel="prev" title="Pandas_Basic_Command_Quick_Check_Table" href="https://yxiong.org/2025/06/08/30-resources/coding/python/Pandas_Basic_Command_Quick_Check_Table/"><link rel="next" title="Pandas_10_sets_of_exercises" href="https://yxiong.org/2025/06/08/30-resources/coding/python/Pandas_10_sets_of_exercises/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">178</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">160</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">23</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#340-ODR-Cpp"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">340 - ODR Cpp</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-核心概念：一次定义规则-One-Definition-Rule-ODR"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">C++核心概念：一次定义规则 (One Definition Rule - ODR)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#详细解释"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">详细解释</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-自由变量-Freestanding-Variables"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">1. 自由变量 (Freestanding Variables)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-函数-Functions"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">2. 函数 (Functions)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-类-Classes"><span class="toc_mobile_items-number">1.4.3.</span> <span class="toc_mobile_items-text">3. 类 (Classes)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-成员函数-Member-Functions-和-静态成员-Static-Members"><span class="toc_mobile_items-number">1.4.4.</span> <span class="toc_mobile_items-text">4. 成员函数 (Member Functions) 和 静态成员 (Static Members)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#QA-闪存卡-Flash-Cards"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">QA 闪存卡 (Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#常见误解或编码错误"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">常见误解或编码错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#编程练习"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">编程练习</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-2"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-2"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-什么是“类的定义”？"><span class="toc_mobile_items-number">1.12.</span> <span class="toc_mobile_items-text">1. 什么是“类的定义”？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-为什么“类的定义”要放在头文件（-h）里？"><span class="toc_mobile_items-number">1.13.</span> <span class="toc_mobile_items-text">2. 为什么“类的定义”要放在头文件（.h）里？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-那么，什么定义要放在-cpp-文件里呢？"><span class="toc_mobile_items-number">1.14.</span> <span class="toc_mobile_items-text">3. 那么，什么定义要放在 .cpp 文件里呢？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-总结：头文件-Vs-cpp-文件中的定义"><span class="toc_mobile_items-number">1.15.</span> <span class="toc_mobile_items-text">4. 总结：头文件 Vs. .cpp 文件中的定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-3"><span class="toc_mobile_items-number">1.16.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#ifndef-GEOM-CYLINDER-H"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">ifndef GEOM_CYLINDER_H</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#define-GEOM-CYLINDER-H"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">define GEOM_CYLINDER_H</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#endif"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">endif</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-3"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-4"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-4"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#官方叫法与概念辨析"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">官方叫法与概念辨析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么之前我的表述会引起您的困惑？"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">为什么之前我的表述会引起您的困惑？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#最终澄清与最佳实践"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">最终澄清与最佳实践</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-5"><span class="toc_mobile_items-number">4.7.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-5"><span class="toc_mobile_items-number">4.8.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么可以多次出现？"><span class="toc_mobile_items-number">4.9.</span> <span class="toc_mobile_items-text">为什么可以多次出现？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#例子"><span class="toc_mobile_items-number">4.10.</span> <span class="toc_mobile_items-text">例子</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">4.11.</span> <span class="toc_mobile_items-text">总结</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-6"><span class="toc_mobile_items-number">4.12.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-6"><span class="toc_mobile_items-number">4.13.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么变量和函数的声明可以多次出现？"><span class="toc_mobile_items-number">4.14.</span> <span class="toc_mobile_items-text">为什么变量和函数的声明可以多次出现？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#示例"><span class="toc_mobile_items-number">4.15.</span> <span class="toc_mobile_items-text">示例</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-变量的声明-Variable-Declaration"><span class="toc_mobile_items-number">4.15.1.</span> <span class="toc_mobile_items-text">1. 变量的声明 (Variable Declaration)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-函数的声明-Function-Declaration-Function-Prototype"><span class="toc_mobile_items-number">4.15.2.</span> <span class="toc_mobile_items-text">2. 函数的声明 (Function Declaration &#x2F; Function Prototype)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-1"><span class="toc_mobile_items-number">4.16.</span> <span class="toc_mobile_items-text">总结</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-7"><span class="toc_mobile_items-number">4.17.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-7"><span class="toc_mobile_items-number">4.18.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#举例说明-header-guard-的必要性"><span class="toc_mobile_items-number">4.19.</span> <span class="toc_mobile_items-text">举例说明 header guard 的必要性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#header-guard-的作用"><span class="toc_mobile_items-number">4.20.</span> <span class="toc_mobile_items-text">header guard 的作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结-2"><span class="toc_mobile_items-number">4.21.</span> <span class="toc_mobile_items-text">总结</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-8"><span class="toc_mobile_items-number">4.22.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-8"><span class="toc_mobile_items-number">4.23.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C语言中的例子"><span class="toc_mobile_items-number">4.24.</span> <span class="toc_mobile_items-text">C语言中的例子</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-变量的声明-Variable-Declaration-1"><span class="toc_mobile_items-number">4.24.1.</span> <span class="toc_mobile_items-text">1. 变量的声明 (Variable Declaration)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-函数的声明-Function-Declaration-Function-Prototype-1"><span class="toc_mobile_items-number">4.24.2.</span> <span class="toc_mobile_items-text">2. 函数的声明 (Function Declaration &#x2F; Function Prototype)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C语言与C-在这一点上的主要差异"><span class="toc_mobile_items-number">4.25.</span> <span class="toc_mobile_items-text">C语言与C++在这一点上的主要差异</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-9"><span class="toc_mobile_items-number">4.26.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-9"><span class="toc_mobile_items-number">4.27.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#官方叫法：精确区分“声明”与“定义”"><span class="toc_mobile_items-number">4.28.</span> <span class="toc_mobile_items-text">官方叫法：精确区分“声明”与“定义”</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么-class-MyClass-被称为“类的定义”？"><span class="toc_mobile_items-number">4.29.</span> <span class="toc_mobile_items-text">为什么 class MyClass { ... }; 被称为“类的定义”？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#您的困惑来源"><span class="toc_mobile_items-number">4.30.</span> <span class="toc_mobile_items-text">您的困惑来源</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-10"><span class="toc_mobile_items-number">4.31.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-10"><span class="toc_mobile_items-number">4.32.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-C-语言中的-struct"><span class="toc_mobile_items-number">4.33.</span> <span class="toc_mobile_items-text">1. C 语言中的 struct</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-C-中的-struct-和-class"><span class="toc_mobile_items-number">4.34.</span> <span class="toc_mobile_items-text">2. C++ 中的 struct (和 class)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结比较"><span class="toc_mobile_items-number">4.35.</span> <span class="toc_mobile_items-text">总结比较</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-11"><span class="toc_mobile_items-number">4.36.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-11"><span class="toc_mobile_items-number">4.37.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#详细解释-1"><span class="toc_mobile_items-number">4.38.</span> <span class="toc_mobile_items-text">详细解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#示例-1"><span class="toc_mobile_items-number">4.39.</span> <span class="toc_mobile_items-text">示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#解决“不同行为”的方法"><span class="toc_mobile_items-number">4.40.</span> <span class="toc_mobile_items-text">解决“不同行为”的方法</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-类与一次定义规则-ODR-深度解析"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">C++ 类与一次定义规则 (ODR) 深度解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-概念详述：C-中的声明、定义与-ODR"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">1. 概念详述：C++ 中的声明、定义与 ODR</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-声明-Declaration"><span class="toc_mobile_items-number">5.1.1.</span> <span class="toc_mobile_items-text">1.1 声明 (Declaration)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-定义-Definition"><span class="toc_mobile_items-number">5.1.2.</span> <span class="toc_mobile_items-text">1.2 定义 (Definition)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-翻译单元-Translation-Unit"><span class="toc_mobile_items-number">5.1.3.</span> <span class="toc_mobile_items-text">1.3 翻译单元 (Translation Unit)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-类、头文件与源文件的最佳实践"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">2. 类、头文件与源文件的最佳实践</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-详细代码示例：Geom-Cylinder"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">3. 详细代码示例：Geom::Cylinder</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-QA-闪卡-Flash-Cards"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">4. QA 闪卡 (Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-常见误解与错误"><span class="toc_mobile_items-number">5.5.</span> <span class="toc_mobile_items-text">5. 常见误解与错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-编码练习"><span class="toc_mobile_items-number">5.6.</span> <span class="toc_mobile_items-text">6. 编码练习</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#340-ODR-Cpp"><span class="toc-number">1.</span> <span class="toc-text">340 - ODR Cpp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-核心概念：一次定义规则-One-Definition-Rule-ODR"><span class="toc-number">1.3.</span> <span class="toc-text">C++核心概念：一次定义规则 (One Definition Rule - ODR)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#详细解释"><span class="toc-number">1.4.</span> <span class="toc-text">详细解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-自由变量-Freestanding-Variables"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 自由变量 (Freestanding Variables)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-函数-Functions"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 函数 (Functions)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-类-Classes"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 类 (Classes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-成员函数-Member-Functions-和-静态成员-Static-Members"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. 成员函数 (Member Functions) 和 静态成员 (Static Members)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QA-闪存卡-Flash-Cards"><span class="toc-number">1.5.</span> <span class="toc-text">QA 闪存卡 (Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见误解或编码错误"><span class="toc-number">1.6.</span> <span class="toc-text">常见误解或编码错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编程练习"><span class="toc-number">1.7.</span> <span class="toc-text">编程练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">1.8.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">1.9.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-2"><span class="toc-number">1.10.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-2"><span class="toc-number">1.11.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是“类的定义”？"><span class="toc-number">1.12.</span> <span class="toc-text">1. 什么是“类的定义”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-为什么“类的定义”要放在头文件（-h）里？"><span class="toc-number">1.13.</span> <span class="toc-text">2. 为什么“类的定义”要放在头文件（.h）里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-那么，什么定义要放在-cpp-文件里呢？"><span class="toc-number">1.14.</span> <span class="toc-text">3. 那么，什么定义要放在 .cpp 文件里呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-总结：头文件-Vs-cpp-文件中的定义"><span class="toc-number">1.15.</span> <span class="toc-text">4. 总结：头文件 Vs. .cpp 文件中的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-3"><span class="toc-number">1.16.</span> <span class="toc-text">🧑‍💻 User</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ifndef-GEOM-CYLINDER-H"><span class="toc-number">2.</span> <span class="toc-text">ifndef GEOM_CYLINDER_H</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define-GEOM-CYLINDER-H"><span class="toc-number">3.</span> <span class="toc-text">define GEOM_CYLINDER_H</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#endif"><span class="toc-number">4.</span> <span class="toc-text">endif</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-3"><span class="toc-number">4.1.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-4"><span class="toc-number">4.2.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-4"><span class="toc-number">4.3.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#官方叫法与概念辨析"><span class="toc-number">4.4.</span> <span class="toc-text">官方叫法与概念辨析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么之前我的表述会引起您的困惑？"><span class="toc-number">4.5.</span> <span class="toc-text">为什么之前我的表述会引起您的困惑？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最终澄清与最佳实践"><span class="toc-number">4.6.</span> <span class="toc-text">最终澄清与最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-5"><span class="toc-number">4.7.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-5"><span class="toc-number">4.8.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么可以多次出现？"><span class="toc-number">4.9.</span> <span class="toc-text">为什么可以多次出现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例子"><span class="toc-number">4.10.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.11.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-6"><span class="toc-number">4.12.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-6"><span class="toc-number">4.13.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么变量和函数的声明可以多次出现？"><span class="toc-number">4.14.</span> <span class="toc-text">为什么变量和函数的声明可以多次出现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例"><span class="toc-number">4.15.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-变量的声明-Variable-Declaration"><span class="toc-number">4.15.1.</span> <span class="toc-text">1. 变量的声明 (Variable Declaration)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-函数的声明-Function-Declaration-Function-Prototype"><span class="toc-number">4.15.2.</span> <span class="toc-text">2. 函数的声明 (Function Declaration &#x2F; Function Prototype)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-1"><span class="toc-number">4.16.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-7"><span class="toc-number">4.17.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-7"><span class="toc-number">4.18.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#举例说明-header-guard-的必要性"><span class="toc-number">4.19.</span> <span class="toc-text">举例说明 header guard 的必要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#header-guard-的作用"><span class="toc-number">4.20.</span> <span class="toc-text">header guard 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结-2"><span class="toc-number">4.21.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-8"><span class="toc-number">4.22.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-8"><span class="toc-number">4.23.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C语言中的例子"><span class="toc-number">4.24.</span> <span class="toc-text">C语言中的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-变量的声明-Variable-Declaration-1"><span class="toc-number">4.24.1.</span> <span class="toc-text">1. 变量的声明 (Variable Declaration)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-函数的声明-Function-Declaration-Function-Prototype-1"><span class="toc-number">4.24.2.</span> <span class="toc-text">2. 函数的声明 (Function Declaration &#x2F; Function Prototype)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C语言与C-在这一点上的主要差异"><span class="toc-number">4.25.</span> <span class="toc-text">C语言与C++在这一点上的主要差异</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-9"><span class="toc-number">4.26.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-9"><span class="toc-number">4.27.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#官方叫法：精确区分“声明”与“定义”"><span class="toc-number">4.28.</span> <span class="toc-text">官方叫法：精确区分“声明”与“定义”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么-class-MyClass-被称为“类的定义”？"><span class="toc-number">4.29.</span> <span class="toc-text">为什么 class MyClass { ... }; 被称为“类的定义”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#您的困惑来源"><span class="toc-number">4.30.</span> <span class="toc-text">您的困惑来源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-10"><span class="toc-number">4.31.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-10"><span class="toc-number">4.32.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-C-语言中的-struct"><span class="toc-number">4.33.</span> <span class="toc-text">1. C 语言中的 struct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-C-中的-struct-和-class"><span class="toc-number">4.34.</span> <span class="toc-text">2. C++ 中的 struct (和 class)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结比较"><span class="toc-number">4.35.</span> <span class="toc-text">总结比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-11"><span class="toc-number">4.36.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-11"><span class="toc-number">4.37.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#详细解释-1"><span class="toc-number">4.38.</span> <span class="toc-text">详细解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例-1"><span class="toc-number">4.39.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决“不同行为”的方法"><span class="toc-number">4.40.</span> <span class="toc-text">解决“不同行为”的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-类与一次定义规则-ODR-深度解析"><span class="toc-number">5.</span> <span class="toc-text">C++ 类与一次定义规则 (ODR) 深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-概念详述：C-中的声明、定义与-ODR"><span class="toc-number">5.1.</span> <span class="toc-text">1. 概念详述：C++ 中的声明、定义与 ODR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-声明-Declaration"><span class="toc-number">5.1.1.</span> <span class="toc-text">1.1 声明 (Declaration)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-定义-Definition"><span class="toc-number">5.1.2.</span> <span class="toc-text">1.2 定义 (Definition)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-翻译单元-Translation-Unit"><span class="toc-number">5.1.3.</span> <span class="toc-text">1.3 翻译单元 (Translation Unit)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-类、头文件与源文件的最佳实践"><span class="toc-number">5.2.</span> <span class="toc-text">2. 类、头文件与源文件的最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-详细代码示例：Geom-Cylinder"><span class="toc-number">5.3.</span> <span class="toc-text">3. 详细代码示例：Geom::Cylinder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-QA-闪卡-Flash-Cards"><span class="toc-number">5.4.</span> <span class="toc-text">4. QA 闪卡 (Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见误解与错误"><span class="toc-number">5.5.</span> <span class="toc-text">5. 常见误解与错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-编码练习"><span class="toc-number">5.6.</span> <span class="toc-text">6. 编码练习</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">340 - ODR Cpp</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/340%20-%20ODR%20Cpp/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/340%20-%20ODR%20Cpp/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="340-ODR-Cpp"><a href="#340-ODR-Cpp" class="headerlink" title="340 - ODR Cpp"></a>340 - ODR Cpp</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about the one definition rule.And this is a rule that says definitions can’t show up more than once in your entire C plus plus program,or in some cases, a definition can show up more than once in a translation unit.We are going to look at the one definition rule in the context of free standing variables, functions,classes, member functions, and static members in our classes.In most cases, a definition can’t really show up more than once in your entire C plus plus program.But we have exceptions to this rule and the exception is for classes.A definition for a class can show up in multiple translation units, and the reason is we need to createobjects of those classes.So each translation unit really needs to see the definition for the class and we are going to try andmake this super clear with examples once we hit Visual Studio code.Okay, so it is time to head over to Visual Studio code and shed some more light on the one definitionrule.Here we are in our working folder.The current project is one definition rule.We’re going to grab our template files like we always do.We’re going to put them in place and we’re going to open this little guy in Visual Studio code.Let’s do that.We’re going to drag and drop and we’re going to have our main CPP file here.We’re going to clean it up.That’s what we always do.And now we want to explore the one definition rule in the context of variables.So we have a free standing variable here, and that’s going to be the same variable we had in the lastlecture.We’re going to initialize this and this is really good.We can use it, we can go in main and use it however we want.We can print the weight and if we build and run this program, it is going to work.But the one definition rule says we can’t have more than one definition for anything.And for this variable here we have seen that this is both a declaration and a definition.So we can’t have more than one definition for the weight name here.For example, if we try and grab it and copy and paste it here.So we’re going to try and build this program.We’re going to use GCC, we’re going to see that we have a problem and the problem is going to say redefinitionof double weight and it is not going to help.Even if you take this and put that in another file.So let’s create another file to really show you this.We’re going to call it some other file dot CPP and we’re going to grab our definition and move thatthere.And you’re going to see that if we try and build this program, we’re going to get the same problem.We’re going to have redefinition.So we’re going to see what is the problem here.The compiler error is a little bit different, but it is going to say multiple definitions of weightand it’s going to say one is defined in the main CPP file.So this is a linker error.This was caught by the linker because the definition is showing up in multiple files.So the linker was linking this program and it needed to see a definition for weight and it had seenone definition in the main CPP file and it has seen another definition in some other file.And this is a problem.The linker doesn’t know which one to choose, so it’s going to throw an error and you can’t really havemultiple definitions for a variable in your C plus plus program.And this is the one definition rule and the context of freestanding variables like the weight here.But this is the same in the context of functions.If we go down and put up our Add function here, we’re going to say double A and double B here and we’regoing to put the definition below the main CPP file.Let’s grab this.You can copy this and put this in the code here.I’m going to remove this little thing.We don’t want it.We’re going to put in our body and we’re going to return A plus B here.Okay.So this is our function.It is working.We can take out what we had here because it had served its purpose.We can say double result and we’re going to add up ten and 20 like we did in the last lecture, no problem.And we can try and print out our result here.If we build and run this program, it is going to work without a problem because we only have one definitionfor the Add function.What is the problem here?We have weight defined multiple times.We’re going to comment out one the definition for weight and we’re going to build again.Now the world is good and we can run this program.We can kill our terminal here and bring up another one and run rooster.You’re going to see that the result is 30 and the program is working just fine.But if we set up another definition for Add even.If we put this in the same file, we’re going to get a problem because we are violating the one definitionrule.Let’s run again.You’re going to see the problem here.We’re going to see the definition redefinition of the Add function.This is not allowed.Your program is not going to compile.We see the compiler error here.Even if you put the definition in another file, that’s not going to help.We’re going to take this and put this in our some other file and try to compile the program.We’re going to get a linker error and it is going to say multiple definition of the Add function.And this is not allowed.This is a linker error in this time.If we comment out one definition, let’s do that.We’re going to comment out the one in the main function.This is going to work and we want to be violating the one definition rule.So this is good.The world is good.We can clear and run Rooster.We’re going to see our result here.So the one definition rule says you can’t have multiple definitions for freestanding variables or evenfunctions.And we said that if you do that, you’re going to get a compiler error.Let’s look at this in the context of classes.We’re going to do a class, we’re going to say struct and we’re going to call this point like we alwaysdo.Mostly we’re going to call this point and we’re going to put in a few member variables.One is going to be M X, the other is going to be M y, and this is going to be our definition here.But what you’re going to see is that it is possible to have multiple definitions for classes.For example, if we take this and have a copy of this in another file, we’re going to do that.We’re going to declare this structure here and we’re going to try and build this program.You’re going to see that it is working.We have multiple definitions of this, guys.We can go in Maine, for example, and say point P one and we can build and see that the program isgoing to work.Okay?So if you go in here, for example, and try to print Stdcout P one and print X, we’re going to dothat.We’re going to say P1MX, we’re going to be able to use this because this is a struct.The member variables are public by default.We can do this and we can say P1Y is P1YMY.Let’s do that and we can say Stdendl What is the problem here?We need to put our output stream.Operator I think now the compiler is going to be happy and if we build, we’re going to use GCC.You like to say that if we run the program, we’re going to see our things here and we have some junkvalues inside because these things are not initialized.But if we initialize them to zero using braced initialization here, we’re going to build again.And we should see zero inside.So let’s clear and run, Rooster.Now we have zero in X and Y for our object here.This is working fine and we have multiple definitions for our class, but the definitions can’t showup in a single translation unit.For example, if we took this definition here and brought that back in main and put that just belowour structure here, if we try to build, the compiler is going to complain because now we have multipledefinitions for the same class in the same translation unit for classes, we can have multiple definitions,but the definitions have to show up in different translation units.And that’s what I want you to see here.So we have a redefinition of our point struct and it is not good.It is going to violate the one definition rule.Okay.Now that you have seen this, we also want to see this in the context of a class that also has somestatic member variables.We’re going to take this out because we have already seen this and we’re going to bring in our personclass like we used in the last lecture.We’re going to add in a new header file.It’s going to be called person dot H, and we’re going to jump into what did we do?Is this a folder?Let’s remove this.We didn’t want a folder.We’re going to delete this folder.We don’t want it.And we’re going to just add a file called Person Dot H.That’s our file here and we’re going to put in the content.The content is going to be our person class.Let’s close this so that you can see more of this class here.Okay, so we have our person class here.We have our include card, we have our person class definition, we have a constructor and we have aprinter form function.We have our member variables.And down below here you see that we have a static variable, which is person count.We need to put in the definition for this guys.So let’s go down and do that.We’re going to put in the definition for the person constructor.We’re going to go on top here and include our person header file and we’re going to put in place ourconstructor.We can go down and do that.We can say person and say person.That’s going to be our constructor.We’re going to go back to the class and grab the parameters because I don’t want to type all this things,so let’s do that.We’re going to put them in.We are going to put in our initializer list.I think we should also delete the parentheses here.We’re going to go down and put in our initializer list.We’re going to say full name.We’re going to initialize this with name param and we’re going to also put in our age and we’re goingto initialize this with age param, the parameter we have from the function.And this is going to be all inside the body, we’re going to increment the static variable, we’re goingto say increment person count.You can select that here and this is going to be good.We also need to initialize our static variable.So we’re going to say person, person count, let’s do person count and we’re going to initialize thisto maybe eight like we did in the last lecture.And this should be all we need here.So if we build and run this program, I think it’s going to run.Let’s select the main function here.And what problem do we have here?Let’s build and see.We’re going to let the compiler figure this out.We’re going to see that the world is good and we can create person objects and really use them in ourprograms.So let’s come down here and delete whatever we had.We’re going to include person and we’re going to go down here and create a person object.We’re going to say person P one and we’re going to specify the name to be Jon Snow.Why not?And we’re going to say that they are 35.Why not?And we can print information about this person.We can say person Printinfo And if we try to build this program, let’s use GCC to do that.The world is going to be good.As you see down here, we can clear and run roster.We’re going to see Jon Snow.He is 35 years old.So this is working just fine.But we can’t have multiple definitions for the same class in the same translation unit here.For example, if we come in the main function, notice we are including person.So this is bringing in the definition for person we have in our person dot here.If we also try to declare another class called person, if and if we don’t put anything in, the compileris going to complain because we have two definitions for the same name, which is person here.If we try to build, I think we are going to get a compiler error saying that we have a definition,say we have a definition of person.So this is not allowed.We can’t really do this.But notice that this person class is included both in some other file, which is a separate translationunit and main.We have it included here.So it is really in a separate translation unit.We have the definition for the class and separate translation units and that’s not a problem.But if you try and put the same definition multiple times in a single translation unit, you’re goingto get a problem and you need to be aware of that.What I want you to see right here is that you can also have multiple definitions for your static variablesand the member functions of your class.For example, if we grab what we have here and also put that in our main function, we can do that.Why not?We’re going to come in our main function here and we’re going to put the same definitions here.Now we’re going to have a problem because the linker is going to see two definitions for the staticvariable and the constructor for person here.And this is going to be a problem.You can’t really do that.If we built, we’re going to see a problem.We’re going to see that.The problem is we have multiple definitions for the constructor and we have multiple definitions forperson account.And this is not allowed.You can’t really do that.You can either remove the one from some other file dot cpp.For example.If we comment this out, let’s do that.We can.And come on up here and comment this out and try to build the program.Now, the program is going to work because we have one definition for these guys.You see, the world is good.We can even run the program to show you that it works or we can remove the one in the main CPP fileand we can leave this alive.So let’s go back in the CPP file, the main CPP file I should say, and remove this.And if we build, we’re going to see that this is going to work and we are compliant with what the Cplus plus standard expects us to do in our C plus plus programs.If we rerun, we’re going to see that this is going to work.And this is really cool.This is really all I wanted you to see in this lecture.The one definition rule, which says that you can’t have multiple definitions for the same name in yourentire C plus plus program.But for classes, we can violate this rule a little bit and make it the same definition.Show up in multiple translation units.We are going to stop here in this lecture.In the next one, we’re going to learn about linkage.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，非常高兴能为您开启C++学习之旅！作为您的C++导师，我将尽力用最清晰、最易懂的方式来讲解C++中的核心概念。</p>
<hr>
<h2 id="C-核心概念：一次定义规则-One-Definition-Rule-ODR"><a href="#C-核心概念：一次定义规则-One-Definition-Rule-ODR" class="headerlink" title="C++核心概念：一次定义规则 (One Definition Rule - ODR)"></a><strong>C++核心概念：一次定义规则 (One Definition Rule - ODR)</strong></h2><p><strong>简要总结:</strong><br>一次定义规则（ODR）是C++编程中一个基本原则，它规定了程序中各种实体（如变量、函数、类）的定义（definition）在整个程序或特定范围内只能出现一次。了解并遵守ODR对于避免编译错误和链接错误至关重要。</p>
<hr>
<h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a><strong>详细解释</strong></h2><p>在C++中，每个变量、函数、类或任何其他实体都必须有且仅有一个定义。这就是我们所说的一次定义规则（One Definition Rule，简称 ODR）。它对于C++程序的正确编译和链接是至关重要的。</p>
<p>在深入了解ODR的具体应用之前，我们首先需要理解几个核心概念：</p>
<ol>
<li><p><strong>声明 (Declaration) 与 定义 (Definition)</strong></p>
<ul>
<li><strong>声明</strong>：声明引入了一个名称及其类型，告诉编译器这个实体存在。它让编译器知道该如何使用这个名称，但不会为其分配内存。可以有多次声明。<ul>
<li>例如：<code>extern int count;</code> 声明了一个名为 <code>count</code> 的整型变量，但没有给它分配存储空间。</li>
<li>例如：<code>void func();</code> 声明了一个名为 <code>func</code> 的函数，但没有提供它的实现。</li>
</ul>
</li>
<li><strong>定义</strong>：定义除了声明实体之外，还为它分配了内存或提供了完整的实现。一个实体只能有一个定义。<ul>
<li>例如：<code>int count = 0;</code> 定义并初始化了一个名为 <code>count</code> 的整型变量。</li>
<li>例如：<code>void func() { /* ... */ }</code> 定义了 <code>func</code> 函数的实现。</li>
<li><strong>注意</strong>：类的声明（<code>class MyClass { /* ... */ };</code>）本身就是一种定义，它定义了 <code>MyClass</code> 这个类型。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>翻译单元 (Translation Unit)</strong></p>
<ul>
<li>一个<strong>翻译单元</strong>是指一个 <code>.cpp</code> 源文件及其所有被 <code>#include</code> 预处理指令包含的头文件（经过宏展开等预处理后）共同形成的一个单一的、用于编译的文本文件。</li>
<li>每个 <code>.cpp</code> 文件都会被独立编译成一个<strong>目标文件</strong>（object file，通常是 <code>.o</code> 或 <code>.obj</code> 后缀）。</li>
<li>最终，链接器（linker）会将所有这些目标文件以及任何所需的库文件组合起来，生成最终的可执行程序。</li>
</ul>
</li>
</ol>
<p>理解了声明、定义和翻译单元后，我们来看ODR在不同C++实体上的具体应用：</p>
<h3 id="1-自由变量-Freestanding-Variables"><a href="#1-自由变量-Freestanding-Variables" class="headerlink" title="1. 自由变量 (Freestanding Variables)"></a><strong>1. 自由变量 (Freestanding Variables)</strong></h3><p><strong>规则:</strong> 一个自由变量（即非类的成员，也不在任何函数内部的变量，通常指全局变量）在整个C++程序中只能有一个定义。</p>
<p><strong>解释:</strong><br>如果你在多个翻译单元（即多个 <code>.cpp</code> 文件）中定义了同名的全局变量，链接器在尝试合并这些目标文件时会发现多个同名变量的定义，它不知道该选择哪一个，因此会报错。即使在同一个翻译单元中多次定义同一个变量，编译器也会报错。</p>
<p><strong>代码示例:</strong></p>
<ul>
<li><p><strong><code>main.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1: 在同一个翻译单元内多次定义变量 (编译错误)</span></span><br><span class="line"><span class="comment">// int weight = 10.0; // 第一次定义</span></span><br><span class="line"><span class="comment">// int weight = 20.0; // 再次定义 - 违反ODR</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个合法的全局变量</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">double</span> globalWeight; <span class="comment">// 声明：告诉编译器 globalWeight 存在于别处</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"当前重量: "</span> &lt;&lt; globalWeight &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>some_other_file.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例2: 在不同翻译单元内多次定义变量 (链接错误)</span></span><br><span class="line"><span class="comment">// double globalWeight = 10.0; // 定义 globalWeight</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是正确的做法：一个翻译单元定义，其他翻译单元声明</span></span><br><span class="line"><span class="keyword">double</span> globalWeight = <span class="number">10.0</span>; <span class="comment">// globalWeight 的唯一定义</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译和运行:</strong></p>
<ol>
<li>如果 <code>main.cpp</code> 和 <code>some_other_file.cpp</code> 都包含 <code>int weight = 10.0;</code> 这样的定义，当你尝试编译 <code>main.cpp</code> 时，如果 <code>weight</code> 在 <code>main.cpp</code> 中定义了两次，你会立即得到一个<strong>编译错误</strong>（<code>redefinition of &#39;weight&#39;</code>）。</li>
<li>如果 <code>main.cpp</code> 和 <code>some_other_file.cpp</code> 各自包含 <code>double globalWeight = 10.0;</code> 的定义，那么这两个文件会分别编译成功，生成 <code>main.o</code> 和 <code>some_other_file.o</code>。然而，当链接器尝试将 <code>main.o</code> 和 <code>some_other_file.o</code> 合并时，它会发现 <code>globalWeight</code> 有两个定义，此时会报<strong>链接错误</strong>（<code>multiple definition of &#39;globalWeight&#39;</code>）。</li>
</ol>
</li>
</ul>
<h3 id="2-函数-Functions"><a href="#2-函数-Functions" class="headerlink" title="2. 函数 (Functions)"></a><strong>2. 函数 (Functions)</strong></h3><p><strong>规则:</strong> 函数在整个C++程序中只能有一个定义。</p>
<p><strong>解释:</strong><br>与自由变量类似，如果你在同一个翻译单元或多个翻译单元中提供了同一个函数的多个定义，编译器或链接器会报错。一个函数可以被多次声明（比如在头文件中声明），但只能被定义一次（通常在对应的 <code>.cpp</code> 文件中）。</p>
<p><strong>代码示例:</strong></p>
<ul>
<li><p><strong><code>main.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1: 在同一个翻译单元内多次定义函数 (编译错误)</span></span><br><span class="line"><span class="comment">// double Add(double a, double b) &#123; return a + b; &#125;</span></span><br><span class="line"><span class="comment">// double Add(double a, double b) &#123; return a - b; &#125; // 再次定义 - 违反ODR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = Add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"结果: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>some_other_file.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例2: 在不同翻译单元内多次定义函数 (链接错误)</span></span><br><span class="line"><span class="comment">// double Add(double a, double b) &#123; return a + b; &#125; // 定义 Add 函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是正确的做法：函数的唯一定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译和运行:</strong></p>
<ol>
<li>如果在 <code>main.cpp</code> 中定义了两次 <code>Add</code> 函数，会得到<strong>编译错误</strong>（<code>redefinition of &#39;Add(double, double)&#39;</code>）。</li>
<li>如果 <code>main.cpp</code> 和 <code>some_other_file.cpp</code> 各自包含了 <code>Add</code> 函数的定义，则会发生<strong>链接错误</strong>（<code>multiple definition of &#39;Add(double, double)&#39;</code>）。</li>
</ol>
</li>
</ul>
<h3 id="3-类-Classes"><a href="#3-类-Classes" class="headerlink" title="3. 类 (Classes)"></a><strong>3. 类 (Classes)</strong></h3><p><strong>规则:</strong> 类是一个特例。一个类的定义可以（也通常会）在多个翻译单元中出现，但前提是这些定义必须是<strong>完全相同的</strong>。在同一个翻译单元中，一个类只能有一个定义。</p>
<p><strong>解释:</strong><br>为了在不同的 <code>.cpp</code> 文件中使用同一个类的对象或访问其成员，这些 <code>.cpp</code> 文件都需要“看到”这个类的完整定义。这通常通过将类的定义放在头文件（<code>.h</code> 或 <code>.hpp</code>）中，然后在使用到该类的所有 <code>.cpp</code> 文件中 <code>#include</code> 这个头文件来实现。尽管这导致类的定义在多个翻译单元中重复出现，但C++标准允许这种情况，只要它们完全一致，链接器就不会报错。如果同一个翻译单元中出现了同一个类的多个定义，编译器则会报错。</p>
<p><strong>代码示例:</strong></p>
<ul>
<li><p><strong><code>point.h</code></strong> (头文件，包含类的定义)</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> POINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="comment">// Point 类的定义</span></span><br><span class="line">    <span class="keyword">int</span> m_x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m_y = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>main.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span> <span class="comment">// 包含 Point 类的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p1; <span class="comment">// 创建 Point 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"P1.x: "</span> &lt;&lt; p1.m_x &lt;&lt; <span class="string">", P1.y: "</span> &lt;&lt; p1.m_y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：在同一个翻译单元内多次定义类 (编译错误)</span></span><br><span class="line">    <span class="comment">// struct Point &#123; int a, b; &#125;; // 再次定义 Point - 违反ODR</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>some_other_file.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span> <span class="comment">// 包含 Point 类的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createAndUsePoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p2; <span class="comment">// 在另一个翻译单元中创建 Point 对象</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译和运行:</strong></p>
<ul>
<li>在 <code>main.cpp</code> 和 <code>some_other_file.cpp</code> 中都包含了 <code>point.h</code>，因此 <code>Point</code> 类的定义在两个翻译单元中都出现了。这是<strong>允许的</strong>，程序会正常编译和链接。</li>
<li>如果在 <code>main.cpp</code> 中手动写了两次 <code>struct Point { ... };</code> 并且它们定义的内容不同，或者直接在 <code>main.cpp</code> 中包含了 <code>point.h</code> 又自己定义了一个同名的 <code>Point</code> 结构体，那么会得到<strong>编译错误</strong>（<code>redefinition of &#39;Point&#39;</code>）。</li>
</ul>
</li>
</ul>
<h3 id="4-成员函数-Member-Functions-和-静态成员-Static-Members"><a href="#4-成员函数-Member-Functions-和-静态成员-Static-Members" class="headerlink" title="4. 成员函数 (Member Functions) 和 静态成员 (Static Members)"></a><strong>4. 成员函数 (Member Functions) 和 静态成员 (Static Members)</strong></h3><p><strong>规则:</strong></p>
<ul>
<li>类的<strong>成员函数</strong>（包括构造函数、析构函数）的定义，在整个程序中只能有一个。</li>
<li>类的<strong>静态数据成员</strong>（<code>static</code> 成员变量）的定义，在整个程序中也只能有一个。</li>
</ul>
<p><strong>解释:</strong><br>虽然类的定义可以出现在多个翻译单元，但其成员函数和静态数据成员的<strong>实现/定义</strong>仍然遵循全局的ODR。通常，它们的声明放在头文件中（随类定义一起），而它们的定义则放在一个（且仅一个）<code>.cpp</code> 文件中。</p>
<p><strong>代码示例:</strong></p>
<ul>
<li><p><strong><code>person.h</code></strong> (头文件)</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PERSON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_fullName;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员声明 (不是定义)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_personCount; <span class="comment">// 声明静态成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数声明</span></span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name_param, <span class="keyword">int</span> age_param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>person.cpp</code></strong> (实现文件，包含成员函数和静态成员的定义)</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态数据成员的定义 (必须在类外定义，且只能定义一次)</span></span><br><span class="line"><span class="keyword">int</span> Person::s_personCount = <span class="number">0</span>; <span class="comment">// Person::s_personCount 的唯一定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的定义</span></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name_param, <span class="keyword">int</span> age_param)</span><br><span class="line">    : m_fullName(name_param), m_age(age_param) &#123;</span><br><span class="line">    s_personCount++; <span class="comment">// 每次创建对象时递增计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::PrintInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名: "</span> &lt;&lt; m_fullName &lt;&lt; <span class="string">", 年龄: "</span> &lt;&lt; m_age</span><br><span class="line">              &lt;&lt; <span class="string">", 当前人数: "</span> &lt;&lt; s_personCount &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>main.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.h"</span> <span class="comment">// 包含 Person 类的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"张三"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    p1.PrintInfo();</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"李四"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    p2.PrintInfo();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：在 main.cpp 中再次定义 Person::s_personCount 或 Person::Person (链接错误)</span></span><br><span class="line">    <span class="comment">// int Person::s_personCount = 100; // 再次定义 - 违反ODR</span></span><br><span class="line">    <span class="comment">// Person::Person(const std::string&amp; name_param, int age_param) &#123;&#125; // 再次定义 - 违反ODR</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编译和运行:</strong></p>
<ul>
<li><code>person.cpp</code> 包含了 <code>Person</code> 类成员函数和静态成员的定义。</li>
<li><code>main.cpp</code> 包含了 <code>Person</code> 类的声明，并使用了 <code>Person</code> 对象。</li>
<li>程序会正常编译和链接。</li>
<li>如果你在 <code>main.cpp</code> 或 <code>some_other_file.cpp</code> 中再次定义 <code>Person::s_personCount</code> 或 <code>Person::Person</code> 构造函数，那么就会出现<strong>链接错误</strong>（<code>multiple definition of &#39;Person::s_personCount&#39;</code> 或 <code>multiple definition of &#39;Person::Person(std::string, int)&#39;</code>）。</li>
</ul>
</li>
</ul>
<p><strong>总结:</strong><br>ODR的核心思想是：<strong>“一个实体，一个定义”</strong>。这个规则确保了程序中每个命名实体都有一个明确的、唯一的含义，避免了歧义。类的定义本身是特例，可以跨翻译单元重复出现，但其内部的成员函数和静态数据成员的实现仍需遵循严格的单一定义原则。</p>
<hr>
<h2 id="QA-闪存卡-Flash-Cards"><a href="#QA-闪存卡-Flash-Cards" class="headerlink" title="QA 闪存卡 (Flash Cards)"></a><strong>QA 闪存卡 (Flash Cards)</strong></h2><p><strong>Q1:</strong> 什么是C++中的一次定义规则（ODR）？<br><strong>A1:</strong> 一次定义规则（ODR）规定了C++程序中每个实体（如变量、函数、类）的定义在整个程序中只能出现一次。</p>
<p><strong>Q2:</strong> 声明 (declaration) 和 定义 (definition) 有什么区别？<br><strong>A2:</strong> <strong>声明</strong>告诉编译器一个实体存在及其类型，但不分配内存或提供实现。<strong>定义</strong>除了声明外，还会分配内存或提供完整实现。一个实体可以有多个声明，但只能有一个定义。</p>
<p><strong>Q3:</strong> 为什么类的定义可以在多个翻译单元中出现，而不会违反ODR？<br><strong>A3:</strong> 类的定义是一个特例。虽然它在多个翻译单元中“出现”，但这些出现被认为是同一个类的定义（它们必须完全相同）。这是为了让链接器在合并不同目标文件时，知道如何创建和使用该类的对象。如果它们不完全相同，则会引发未定义行为。</p>
<p><strong>Q4:</strong> 如果我在两个不同的 <code>.cpp</code> 文件中定义了同一个全局变量，会发生什么错误？<br><strong>A4:</strong> 会发生<strong>链接错误</strong>。因为每个 <code>.cpp</code> 文件会被独立编译，链接器在合并目标文件时会发现同一个变量被定义了两次，导致无法决定使用哪一个定义。</p>
<p><strong>Q5:</strong> 类中的成员函数定义和静态数据成员定义，是否也遵循ODR？<br><strong>A5:</strong> 是的。尽管类的定义可以跨翻译单元，但其成员函数和静态数据成员的定义（即实现或初始化）在整个程序中仍然必须是唯一的，通常放在一个单独的 <code>.cpp</code> 文件中。</p>
<hr>
<h2 id="常见误解或编码错误"><a href="#常见误解或编码错误" class="headerlink" title="常见误解或编码错误"></a><strong>常见误解或编码错误</strong></h2><ol>
<li><p><strong>在头文件中定义非内联函数或全局变量：</strong></p>
<ul>
<li><strong>误解/错误:</strong> 许多初学者喜欢直接在头文件中定义函数或全局变量（例如 <code>int myGlobal = 0;</code> 或 <code>void myFunction() { /* ... */ }</code>）。</li>
<li><strong>后果:</strong> 如果这个头文件被多个 <code>.cpp</code> 文件包含，那么每个 <code>.cpp</code> 文件都会包含这个函数或变量的定义。当这些 <code>.cpp</code> 文件被编译成目标文件后，链接器会发现同一个函数或变量被定义了多次，从而导致<strong>链接错误</strong>（<code>multiple definition</code>）。</li>
<li><strong>正确做法:</strong> 在头文件中只放置函数<strong>声明</strong>和全局变量<strong>声明</strong>（使用 <code>extern</code> 关键字），而它们的<strong>定义</strong>则放在一个（且仅一个）对应的 <code>.cpp</code> 文件中。对于函数，如果它们是内联函数（<code>inline</code>）或者类模板/函数模板，则允许在头文件中定义，因为它们是ODR的特殊例外。</li>
</ul>
</li>
<li><p><strong>忘记或错误地定义静态数据成员：</strong></p>
<ul>
<li><strong>误解/错误:</strong> 在类定义中声明了 <code>static int count;</code>，但忘记在任何 <code>.cpp</code> 文件中提供其定义（<code>int MyClass::count = 0;</code>），或者在多个 <code>.cpp</code> 文件中重复定义了它。</li>
<li><strong>后果:</strong> 忘记定义会导致<strong>链接错误</strong>（<code>undefined reference</code>），因为链接器找不到该静态成员的实际存储位置。重复定义则会导致<strong>链接错误</strong>（<code>multiple definition</code>）。</li>
<li><strong>正确做法:</strong> 静态数据成员的声明在类内部（头文件），但它的<strong>定义</strong>（初始化）必须在类外部，且只能在一个 <code>.cpp</code> 文件中。</li>
</ul>
</li>
<li><p><strong>对头文件中的类定义进行修改，但没有重建所有依赖的 <code>.cpp</code> 文件：</strong></p>
<ul>
<li><strong>误解/错误:</strong> 修改了 <code>MyClass.h</code> 中的类定义（例如添加或删除成员），但只重新编译了 <code>main.cpp</code> 而不是所有包含 <code>MyClass.h</code> 的 <code>.cpp</code> 文件。</li>
<li><strong>后果:</strong> 这可能导致链接器错误，或者更糟的是，导致运行时未定义行为，因为不同翻译单元中对 <code>MyClass</code> 的理解不一致（“不一致的定义”）。</li>
<li><strong>正确做法:</strong> 只要头文件被修改，所有包含该头文件的 <code>.cpp</code> 文件都应该重新编译，以确保所有翻译单元中的定义都是最新且一致的。</li>
</ul>
</li>
<li><p><strong>混淆 <code>const</code> 全局变量的定义：</strong></p>
<ul>
<li><strong>误解/错误:</strong> 认为 <code>const int MAX_VALUE = 100;</code> 这样的全局常量在多个 <code>.cpp</code> 文件中可以重复定义。</li>
<li><strong>解释:</strong> C++标准规定，<code>const</code> 修饰的全局变量默认具有内部链接（<code>internal linkage</code>），这意味着它们只在定义它们的翻译单元内可见。因此，即使你在多个 <code>.cpp</code> 文件中定义了同名的 <code>const int MAX_VALUE = 100;</code>，这也不会导致链接错误，因为每个都是其所在翻译单元的局部副本。但是，这是一种特殊情况，并非所有类型都如此，并且可能导致对“同一”常量的不同副本。</li>
<li><strong>正确做法:</strong> 如果你希望一个 <code>const</code> 全局变量在整个程序中都是唯一的且共享同一个地址，你需要显式地给它 <code>extern</code> 关键字进行声明（<code>extern const int MAX_VALUE;</code>），并在一个 <code>.cpp</code> 文件中给出其定义（<code>const int MAX_VALUE = 100;</code>）。或者，对于常量，更好的做法通常是使用 <code>enum class</code> 或 <code>constexpr</code> 变量。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a><strong>编程练习</strong></h2><p>现在，请您尝试修改以下代码，使其遵守一次定义规则，并能成功编译运行。您的任务是修复 <code>main.cpp</code> 和 <code>utils.cpp</code> 中的 ODR 违规。</p>
<p><strong>文件结构：</strong></p>
<ul>
<li><code>common.h</code></li>
<li><code>main.cpp</code></li>
<li><code>utils.cpp</code></li>
</ul>
<hr>
<p><strong><code>common.h</code></strong> (请勿修改此文件，它包含了我们将要使用的声明)<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMMON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_sharedCounter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> instanceCount; <span class="comment">// 声明一个静态成员变量</span></span><br><span class="line"></span><br><span class="line">    MyData(<span class="keyword">int</span> val); <span class="comment">// 构造函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 成员函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// COMMON_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>main.cpp</code></strong> (请在此文件中填写 <code>TODO</code> 部分的代码，使其遵守 ODR)<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 1: 这是一个全局变量的定义，请确保它遵守 ODR。</span></span><br><span class="line"><span class="comment">// 思考：它应该放在哪里？如果放在这里，会和另一个文件中的定义冲突吗？</span></span><br><span class="line"><span class="comment">// int g_sharedCounter = 0; // 这行代码目前是 ODR 违规的潜在来源，请思考如何处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 2: 这是一个函数的定义。请确保它遵守 ODR。</span></span><br><span class="line"><span class="comment">// 思考：它应该放在哪里？</span></span><br><span class="line"><span class="comment">// void printMessage(const std::string&amp; msg) &#123; // 这行代码目前是 ODR 违规的潜在来源</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; "消息: " &lt;&lt; msg &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用全局变量</span></span><br><span class="line">    g_sharedCounter = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main.cpp 中的 g_sharedCounter: "</span> &lt;&lt; g_sharedCounter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数</span></span><br><span class="line">    printMessage(<span class="string">"Hello from main.cpp!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 MyData 类</span></span><br><span class="line">    <span class="function">MyData <span class="title">d1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    d1.showValue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>utils.cpp</code></strong> (请在此文件中填写 <code>TODO</code> 部分的代码，使其遵守 ODR)<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 3: 在这里提供 g_sharedCounter 的唯一定义。</span></span><br><span class="line"><span class="comment">// int g_sharedCounter = 0; // 这行代码是 ODR 违规的潜在来源，请思考如何处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 4: 在这里提供 printMessage 函数的唯一定义。</span></span><br><span class="line"><span class="comment">// void printMessage(const std::string&amp; msg) &#123; // 这行代码是 ODR 违规的潜在来源</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; "Another message: " &lt;&lt; msg &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 5: 在这里提供 MyData 类的静态成员变量 instanceCount 的唯一定义。</span></span><br><span class="line"><span class="comment">// 思考：它应该如何定义？</span></span><br><span class="line"><span class="comment">// int MyData::instanceCount = 0; // 这行代码是 ODR 违规的潜在来源，请思考如何处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 6: 在这里提供 MyData 构造函数的唯一定义。</span></span><br><span class="line"><span class="comment">// 思考：它应该如何定义？</span></span><br><span class="line"><span class="comment">// MyData::MyData(int val) &#123; // 这行代码是 ODR 违规的潜在来源</span></span><br><span class="line"><span class="comment">//     value = val;</span></span><br><span class="line"><span class="comment">//     // 静态成员在这里递增</span></span><br><span class="line"><span class="comment">//     instanceCount++;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 7: 在这里提供 MyData::showValue 成员函数的唯一定义。</span></span><br><span class="line"><span class="comment">// 思考：它应该如何定义？</span></span><br><span class="line"><span class="comment">// void MyData::showValue() const &#123; // 这行代码是 ODR 违规的潜在来源</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; "MyData value: " &lt;&lt; value &lt;&lt; ", Instances: " &lt;&lt; instanceCount &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useUtilsFunctionality</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保 g_sharedCounter 在这里可见并可用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"utils.cpp 中的 g_sharedCounter (before update): "</span> &lt;&lt; g_sharedCounter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    g_sharedCounter++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"utils.cpp 中的 g_sharedCounter (after update): "</span> &lt;&lt; g_sharedCounter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    printMessage(<span class="string">"Greetings from utils.cpp!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">MyData <span class="title">d2</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    d2.showValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>请您在 <code>main.cpp</code> 和 <code>utils.cpp</code> 中修改或补充代码，使得它们在被编译和链接时，不会出现 ODR 相关的编译错误或链接错误。然后，当您准备好时，请提交您的解决方案。</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>规则: 类是一个特例。一个类的定义可以（也通常会）在多个翻译单元中出现，但前提是这些定义必须是完全相同的。在同一个翻译单元中，一个类只能有一个定义。</p>
<p>good practice是只定义一次么？</p>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常好的问题，它触及了C++一次定义规则中关于类的一个核心且经常引起混淆的方面！</p>
<p>您的理解非常敏锐。当我说“一个类的定义可以（也通常会）在多个翻译单元中出现，但前提是这些定义必须是<strong>完全相同的</strong>”时，重点在于“<strong>完全相同</strong>”。</p>
<p>那么，“good practice”是否意味着只定义一次呢？答案是：<strong>是的，从代码编写的角度来看，好的实践是只“物理地”定义类一次。</strong></p>
<p>让我来详细解释一下：</p>
<ol>
<li><p><strong>“物理定义”与“逻辑定义”的区别：</strong></p>
<ul>
<li><strong>物理定义 (Physical Definition):</strong> 指的是您在源代码文件中实际写下 <code>class MyClass { /* ... */ };</code> 这个类结构的地方。在实际编码中，我们总是会把一个类的完整结构定义<strong>只写在一个头文件</strong>（例如 <code>MyClass.h</code>）中。这是“物理上”只定义一次。</li>
<li><strong>逻辑定义 (Logical Definition) / 翻译单元中的定义：</strong> 当一个 <code>.cpp</code> 文件通过 <code>#include &quot;MyClass.h&quot;</code> 包含这个头文件时，预处理器会把 <code>MyClass.h</code> 中的所有内容（包括类的定义）复制粘贴到这个 <code>.cpp</code> 文件中。因此，从编译器的角度来看，<code>MyClass</code> 的定义就存在于这个 <code>.cpp</code> 文件的<strong>翻译单元</strong>中。如果 <code>MyClass.h</code> 被 <code>main.cpp</code> 和 <code>utils.cpp</code> 都包含，那么 <code>MyClass</code> 的定义就会“逻辑地”出现在 <code>main.cpp</code> 的翻译单元和 <code>utils.cpp</code> 的翻译单元中。</li>
</ul>
</li>
<li><p><strong>为什么允许“逻辑定义”多次出现？</strong></p>
<ul>
<li>C++标准允许类定义在多个翻译单元中逻辑地重复出现，前提是这些重复的定义<strong>必须是逐字（token by token）相同的</strong>。这是因为编译器在编译每个 <code>.cpp</code> 文件时，需要知道类的完整布局（包括成员变量、成员函数签名等），以便正确地为该类的对象分配内存、调用其方法。链接器在最后阶段合并所有目标文件时，如果发现同一个类的不同定义，它可能会陷入困惑，或者导致未定义行为。</li>
<li>通过将类定义放在头文件中，并使用<strong>头文件保护</strong>（<code>#ifndef ... #define ... #endif</code> 或 <code>#pragma once</code>）来防止在同一个翻译单元内重复包含，我们确保了：<ul>
<li>在一个单独的翻译单元内，类定义不会重复（避免编译错误）。</li>
<li>在不同翻译单元之间，类定义虽然逻辑上重复，但由于它们都来自同一个头文件，所以它们是<strong>完全相同</strong>的（避免链接错误和未定义行为）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>总结“good practice”：</strong></p>
<ul>
<li><strong>将类的完整定义（结构、成员变量、成员函数声明）放在一个独立的头文件 (<code>.h</code> 或 <code>.hpp</code>) 中。</strong> 这是“物理定义”只发生一次的地方。</li>
<li><strong>在所有需要使用该类的 <code>.cpp</code> 文件中，<code>#include</code> 这个头文件。</strong> 这会导致类定义在多个翻译单元中“逻辑地”出现，这是允许的，也是必须的。</li>
<li><strong>确保头文件中有头文件保护（Include Guards）。</strong> 这能防止同一个头文件在同一个翻译单元中被多次包含，从而避免编译错误（<code>redefinition</code>）。</li>
</ul>
</li>
</ol>
<p>所以，您的理解“只定义一次”是正确的，但这里的“一次”是指<strong>物理上您编写代码时只写一次</strong>，而不是指最终编译过程中它只出现在一个翻译单元里。它会在多个翻译单元中“出现”，但这些出现都是同一份“蓝图”的复制。</p>
<p>希望这个解释能让您更清晰地理解 ODR 在类上的应用！</p>
<hr>
<h2 id="🧑‍💻-User-2"><a href="#🧑‍💻-User-2" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>等下， 类的定义是放在header好还是cpp好？ 之前的课里， header里面都只有declaration, 定义都是放在cpp的</p>
<hr>
<h2 id="🤖-Assistant-2"><a href="#🤖-Assistant-2" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常好的问题！它触及了C++中声明与定义、头文件与源文件的核心用法，也是初学者经常感到困惑的地方。</p>
<p>您的记忆是正确的：<strong>在C++中，好的实践是头文件里通常只放声明（declaration），而定义（definition）放在对应的 <code>.cpp</code> 文件里。</strong></p>
<p>但是，对于<strong>类（Class）的定义</strong>，情况有些特殊，它是一个重要的例外！</p>
<p>让我们来梳理一下：</p>
<h2 id="1-什么是“类的定义”？"><a href="#1-什么是“类的定义”？" class="headerlink" title="1. 什么是“类的定义”？"></a>1. <strong>什么是“类的定义”？</strong></h2><p>“类的定义”是指 <code>class MyClass { /* ... */ };</code> 这样的整个代码块，它包含了类的结构、成员变量和成员函数的声明（甚至可以是 inline 函数的定义）。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个类的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data; <span class="comment">// 成员变量声明</span></span><br><span class="line">    MyClass(<span class="keyword">int</span> d); <span class="comment">// 构造函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>; <span class="comment">// 成员函数声明</span></span><br><span class="line">    <span class="comment">// inline void print() &#123; std::cout &lt;&lt; m_data &lt;&lt; std::endl; &#125; // 也可以在这里定义 inline 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-为什么“类的定义”要放在头文件（-h）里？"><a href="#2-为什么“类的定义”要放在头文件（-h）里？" class="headerlink" title="2. 为什么“类的定义”要放在头文件（.h）里？"></a>2. <strong>为什么“类的定义”要放在头文件（.h）里？</strong></h2><p>这是因为 C++ 编译器在编译一个 <code>.cpp</code> 文件时，需要知道它所使用的<strong>所有类型（包括类）的完整信息</strong>。这些信息包括：</p>
<ul>
<li>这个类有多少个成员变量？每个成员变量的类型是什么？</li>
<li>这个类的大小是多少？（编译器需要知道如何为它分配内存）</li>
<li>这个类有哪些构造函数、析构函数、成员函数？它们的参数和返回类型是什么？（编译器需要知道如何调用这些函数）</li>
</ul>
<p>如果 <code>MyClass</code> 的定义只放在一个 <code>.cpp</code> 文件里，比如 <code>myclass.cpp</code>：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myclass.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">/* ... */</span> &#125;; <span class="comment">// 定义</span></span><br><span class="line"><span class="comment">// ... 成员函数实现 ...</span></span><br></pre></td></tr></table></figure></div><br>那么当你在 <code>main.cpp</code> 中想创建一个 <code>MyClass</code> 的对象时：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="comment">// 哪里知道 MyClass 长什么样呢？</span></span><br><span class="line">MyClass obj; <span class="comment">// 编译错误：'MyClass' was not declared in this scope</span></span><br></pre></td></tr></table></figure></div><br>编译器在编译 <code>main.cpp</code> 时根本不知道 <code>MyClass</code> 是什么。</p>
<p>所以，<strong>类的完整定义必须放在头文件里</strong>，然后所有需要使用这个类的 <code>.cpp</code> 文件都 <code>#include</code> 这个头文件。这样，每个 <code>.cpp</code> 文件在编译时都能“看到”这个类的完整定义，知道它的结构和接口，从而正确地使用它。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYCLASS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYCLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的定义 (蓝图)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data;</span><br><span class="line">    MyClass(<span class="keyword">int</span> d);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyClass.h"</span> <span class="comment">// 编译器现在知道 MyClass 是什么了</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// OK</span></span><br><span class="line">    obj.doSomething(); <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="3-那么，什么定义要放在-cpp-文件里呢？"><a href="#3-那么，什么定义要放在-cpp-文件里呢？" class="headerlink" title="3. 那么，什么定义要放在 .cpp 文件里呢？"></a>3. <strong>那么，什么定义要放在 <code>.cpp</code> 文件里呢？</strong></h2><p>放在 <code>.cpp</code> 文件里的是：</p>
<ul>
<li><strong>类的非 <code>inline</code> 成员函数的定义（实现）。</strong></li>
<li><strong>类的静态数据成员的定义（初始化）。</strong></li>
<li><strong>全局函数的定义（实现）。</strong></li>
<li><strong>全局变量的定义（初始化）。</strong></li>
</ul>
<p>这些“定义”是实际的代码执行逻辑或存储空间的分配，它们只需要在整个程序中存在一份拷贝。如果它们被放在头文件里，并且这个头文件被多个 <code>.cpp</code> 文件包含，就会导致这些定义在多个翻译单元中重复，从而违反 ODR，引发<strong>链接错误</strong>（<code>multiple definition</code>）。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.cpp (成员函数和静态成员的定义)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyClass.h"</span> <span class="comment">// 包含类的声明，以便定义其成员</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的静态数据成员定义 (如果 MyClass 有静态成员的话)</span></span><br><span class="line"><span class="comment">// int MyClass::staticMember = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的定义</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> d) : m_data(d) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyClass::doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="4-总结：头文件-Vs-cpp-文件中的定义"><a href="#4-总结：头文件-Vs-cpp-文件中的定义" class="headerlink" title="4. 总结：头文件 Vs. .cpp 文件中的定义"></a>4. <strong>总结：头文件 Vs. .cpp 文件中的定义</strong></h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">实体类型</th>
<th style="text-align:left">放在头文件 (.h) 里？</th>
<th style="text-align:left">放在源文件 (.cpp) 里？</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>类的定义</strong> (<code>class MyClass { ... };</code>)</td>
<td style="text-align:left"><strong>是</strong> (必须)</td>
<td style="text-align:left">否 (会导致同一个翻译单元内重定义，或链接错误)</td>
<td style="text-align:left">这是个特例！因为每个 <code>.cpp</code> 文件都需要看到类的完整结构。它遵循 ODR 的特殊允许：相同定义在多翻译单元中出现。</td>
</tr>
<tr>
<td style="text-align:left"><strong>类的成员函数定义</strong></td>
<td style="text-align:left">否 (会导致链接错误)</td>
<td style="text-align:left"><strong>是</strong> (必须且只一次)</td>
<td style="text-align:left"><code>inline</code> 函数是例外，它们可以且通常直接在类定义内或头文件中定义。</td>
</tr>
<tr>
<td style="text-align:left"><strong>类的静态数据成员定义</strong></td>
<td style="text-align:left">否 (只是声明)</td>
<td style="text-align:left"><strong>是</strong> (必须且只一次)</td>
<td style="text-align:left">必须在类外部定义并初始化。</td>
</tr>
<tr>
<td style="text-align:left"><strong>全局函数定义</strong></td>
<td style="text-align:left">否 (只是声明)</td>
<td style="text-align:left"><strong>是</strong> (必须且只一次)</td>
<td style="text-align:left">遵循标准 ODR。</td>
</tr>
<tr>
<td style="text-align:left"><strong>全局变量定义</strong></td>
<td style="text-align:left">否 (只是声明，用 <code>extern</code>)</td>
<td style="text-align:left"><strong>是</strong> (必须且只一次)</td>
<td style="text-align:left">遵循标准 ODR。<code>const</code> 变量是个例外，默认内部链接，但在多个 <code>.cpp</code> 定义不会导致链接错误，但通常也只定义一次或通过 <code>extern</code> 共享。</td>
</tr>
</tbody>
</table>
</div>
<p>所以，您之前的学习并没有错，对于<strong>绝大多数</strong>的定义（特别是函数的实现和变量的存储分配），它们确实应该只出现在一个 <code>.cpp</code> 文件中。但是，<strong>类的定义本身</strong>是一个重要的例外，它必须放在头文件中，以供所有使用它的翻译单元包含。</p>
<p>希望这个详细的解释能彻底消除您的困惑！</p>
<hr>
<h2 id="🧑‍💻-User-3"><a href="#🧑‍💻-User-3" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>你确定？</p>
<p>我记得不对。。。<br>header里可以放类声明啊比如</p>
<h1 id="ifndef-GEOM-CYLINDER-H"><a href="#ifndef-GEOM-CYLINDER-H" class="headerlink" title="ifndef GEOM_CYLINDER_H"></a>ifndef GEOM_CYLINDER_H</h1><h1 id="define-GEOM-CYLINDER-H"><a href="#define-GEOM-CYLINDER-H" class="headerlink" title="define GEOM_CYLINDER_H"></a>define GEOM_CYLINDER_H</h1><p>namespace Geom {<br>    class Cylinder {<br>    private:<br>        double m_base_radius;<br>        double m_height;<br>    public:<br>        Cylinder(double radius = 1.0, double height = 1.0);<br>        double volume() const;<br>    };<br>}</p>
<h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><p>然后cpp再实现啊</p>
<hr>
<h2 id="🤖-Assistant-3"><a href="#🤖-Assistant-3" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>您说得非常对！感谢您指出这个关键的细微之处，这是很多C++初学者容易混淆的地方，也是理解ODR和头文件/源文件组织的关键。</p>
<p>我非常确定，您所理解的<strong>“头文件放声明，.cpp文件放定义”</strong>的规则是正确的，而且是C++的最佳实践！</p>
<p>我的措辞确实不够严谨，导致了误解。请允许我重新澄清和精确我的说法：</p>
<ol>
<li><p><strong>“类的定义”</strong> (Class Definition):</p>
<ul>
<li>我之前说“类的定义放在头文件里”，这里我指的是<strong>类本身的结构定义</strong>，也就是您在 <code>common.h</code> 中写的那部分：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common.h</span></span><br><span class="line"><span class="keyword">namespace</span> Geom &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> &#123;</span> <span class="comment">// &lt;-- 整个这个代码块，就是 "Cylinder 类的定义"</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> m_base_radius;</span><br><span class="line">        <span class="keyword">double</span> m_height;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Cylinder(<span class="keyword">double</span> radius = <span class="number">1.0</span>, <span class="keyword">double</span> height = <span class="number">1.0</span>); <span class="comment">// 成员函数声明</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">volume</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 成员函数声明</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>这个<strong>类结构（或称类的蓝图、类的声明）</strong>必须放在头文件里。因为任何想要使用 <code>Cylinder</code> 类型（例如声明 <code>Cylinder</code> 类型的变量、创建 <code>Cylinder</code> 对象）的 <code>.cpp</code> 文件，在编译时都必须知道 <code>Cylinder</code> 长什么样（它有多少成员变量，函数签名是什么）。如果这个类结构不在头文件里，其他 <code>.cpp</code> 文件就无法看到它的定义，从而无法使用它。</li>
</ul>
</li>
<li><p><strong>“成员函数的定义”</strong> (Member Function Definition / Implementation):</p>
<ul>
<li>而您提到的<code>volume()</code> 和 <code>Cylinder()</code> <strong>成员函数的具体实现（定义）</strong>，确实是放在 <code>.cpp</code> 文件里的。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span> <span class="comment">// 包含 Cylinder 类的声明，才能定义其成员函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的定义</span></span><br><span class="line">Geom::Cylinder::Cylinder(<span class="keyword">double</span> radius, <span class="keyword">double</span> height)</span><br><span class="line">    : m_base_radius(radius), m_height(height) &#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// volume 成员函数的定义</span></span><br><span class="line"><span class="keyword">double</span> Geom::Cylinder::volume() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14159</span> * m_base_radius * m_base_radius * m_height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>这部分代码是真正的函数逻辑实现，它为函数分配了存储空间。根据一次定义规则 (ODR)，这种<strong>函数的定义（实现）</strong>在整个程序中只能有一份。如果把它也放在头文件里，并且这个头文件被多个 <code>.cpp</code> 文件包含，那么每个 <code>.cpp</code> 文件都会生成一份 <code>volume()</code> 函数的定义。在链接阶段，链接器会发现多个同名函数的定义，从而引发 <strong>“多重定义错误” (multiple definition error)</strong>。</li>
</ul>
</li>
</ol>
<p><strong>总结一下，我的前次表述中不够精确的地方在于对“类的定义”这个词的范围界定。</strong></p>
<ul>
<li><strong>精确的说法是：</strong><ul>
<li><strong>类的声明（即类的结构/蓝图，包括成员变量和成员函数原型）</strong> 放在头文件 (<code>.h</code>) 中。</li>
<li><strong>类的非 <code>inline</code> 成员函数的定义（实现）和静态数据成员的定义</strong> 放在源文件 (<code>.cpp</code>) 中。</li>
</ul>
</li>
</ul>
<p>您对 <code>Cylinder</code> 类的组织方式是完全符合 C++ 最佳实践的！这正是我们如何将声明和定义分离，以遵守 ODR 并确保代码可维护性的标准方式。</p>
<p>感谢您的细致和质疑精神，这正是学习 C++ 所需的！它帮助我更精确地表达了关键概念。</p>
<hr>
<h2 id="🧑‍💻-User-4"><a href="#🧑‍💻-User-4" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>你说的类的定义是不是就是我说的声明？ 官方叫法是什么</p>
<hr>
<h2 id="🤖-Assistant-4"><a href="#🤖-Assistant-4" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>您问得非常好，也指出了我之前表达中的关键不严谨之处！这正是C++学习中，概念容易混淆、需要反复辨析的重点。</p>
<p>确实，在C++标准中，对于“<strong>类（Class）</strong>”这个整体而言，官方的叫法有一些细微但重要的区别：</p>
<h2 id="官方叫法与概念辨析"><a href="#官方叫法与概念辨析" class="headerlink" title="官方叫法与概念辨析"></a>官方叫法与概念辨析</h2><ol>
<li><p><strong>类的定义 (Class Definition)</strong></p>
<ul>
<li><strong>官方含义：</strong> 在C++标准中，“<strong>类的定义</strong>”指的是您写下的整个 <code>class MyClass { /* ... */ };</code> 这个完整的代码块。它不仅仅是声明了一个类存在，更重要的是它<strong>定义了</strong>这个类<strong>类型</strong>的完整结构和接口（成员变量、成员函数的签名、访问权限等）。</li>
<li><strong>您的理解：</strong> 您之前说的 <code>class Cylinder { ... };</code> 放在头文件里，这正是“<strong>类的定义</strong>”。</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个 Cylinder 类的【定义】 (Class Definition)</span></span><br><span class="line"><span class="comment">// 它定义了 Cylinder 这个类型长什么样子，有哪些成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_base_radius;</span><br><span class="line">    <span class="keyword">double</span> m_height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cylinder(<span class="keyword">double</span> radius = <span class="number">1.0</span>, <span class="keyword">double</span> height = <span class="number">1.0</span>); <span class="comment">// 成员函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">volume</span><span class="params">()</span> <span class="keyword">const</span></span>;                               <span class="comment">// 成员函数声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>类的声明 (Class Declaration) 或 前向声明 (Forward Declaration)</strong></p>
<ul>
<li><strong>官方含义：</strong> “<strong>类的声明</strong>”通常指的是<strong>前向声明</strong> (Forward Declaration)，它仅仅是告诉编译器某个类类型存在，但没有提供其完整结构。这种声明通常用在当一个类只需要引用另一个类，而不需要知道其内部细节时（例如，声明一个指针或引用）。</li>
<li><strong>您的理解：</strong> 您可能没直接用过这个概念，但它确实存在。</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个 MyClass 的【声明】 (Class Declaration 或 Forward Declaration)</span></span><br><span class="line"><span class="comment">// 它只告诉编译器 MyClass 是一个类，但不知道它内部有什么</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>何时使用：</strong> 当你在头文件A中声明一个类A，类A的某个成员是一个指向类B的指针或引用，但你又不想在头文件A中包含类B的整个定义时，你就可以在前向声明类B：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header_A.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span> <span class="comment">// ClassB 的前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line">    ClassB* b_ptr; <span class="comment">// 只需要知道 ClassB 是一个类型，不需要知道它的完整定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li><p><strong>成员函数的声明 (Member Function Declaration)</strong></p>
<ul>
<li><strong>官方含义：</strong> 这是指在类的<strong>定义</strong>内部，您为成员函数写的原型，例如 <code>double volume() const;</code>。它告诉编译器这个函数叫什么、参数是什么、返回类型是什么，但没有提供实现。</li>
<li><strong>您的理解：</strong> 您在 <code>class Cylinder { ... };</code> 内部写下的 <code>Cylinder(double radius = 1.0, double height = 1.0);</code> 和 <code>double volume() const;</code> 正是<strong>成员函数的声明</strong>。</li>
</ul>
</li>
<li><p><strong>成员函数的定义 (Member Function Definition) 或 实现 (Implementation)</strong></p>
<ul>
<li><strong>官方含义：</strong> 这是指成员函数的具体代码实现，例如 <code>double Geom::Cylinder::volume() const { /* ... */ }</code>。它提供了函数的功能逻辑。</li>
<li><strong>您的理解：</strong> 您在 <code>.cpp</code> 文件中写下的 <code>Geom::Cylinder::volume() const { ... }</code> 正是<strong>成员函数的定义</strong>。</li>
</ul>
</li>
</ol>
<h2 id="为什么之前我的表述会引起您的困惑？"><a href="#为什么之前我的表述会引起您的困惑？" class="headerlink" title="为什么之前我的表述会引起您的困惑？"></a>为什么之前我的表述会引起您的困惑？</h2><p>我之前说“<strong>类的定义</strong>（<code>class MyClass { ... };</code> 整个代码块）放在头文件里”，我的本意是强调<strong>类类型本身的结构蓝图</strong>必须放在头文件里。</p>
<p>而您强调的“<code>header</code>里都只有<code>declaration</code>，定义都是放在<code>cpp</code>的”，这是针对<strong>函数</strong>和<strong>变量</strong>的<strong>定义（实现）</strong>而言的。</p>
<p><strong>所以，我们都对，只是对“定义”这个词的侧重点不同导致了误解。</strong></p>
<h2 id="最终澄清与最佳实践"><a href="#最终澄清与最佳实践" class="headerlink" title="最终澄清与最佳实践"></a>最终澄清与最佳实践</h2><ul>
<li><p><strong>头文件 (.h):</strong></p>
<ul>
<li>放置 <strong>类的定义</strong> (Class Definition，即 <code>class MyClass { ... };</code> 整个结构，包括成员变量声明和成员函数声明)。</li>
<li>放置 <strong>前向声明</strong> (Forward Declaration，如 <code>class MyOtherClass;</code>)。</li>
<li>放置 <strong>全局函数声明</strong> (<code>void myFunction();</code>)。</li>
<li>放置 <strong><code>extern</code> 关键字修饰的全局变量声明</strong> (<code>extern int g_myVar;</code>)。</li>
<li>放置 <strong>模板的定义</strong> (Templates，因为它们是特例，通常需要在被使用的地方看到完整定义)。</li>
<li>放置 <strong><code>inline</code> 成员函数的定义</strong> (通常直接在类定义内部或类定义后紧随其后)。</li>
</ul>
</li>
<li><p><strong>源文件 (.cpp):</strong></p>
<ul>
<li>放置 <strong>类的非 <code>inline</code> 成员函数的定义</strong> (Member Function Definition/Implementation)。</li>
<li>放置 <strong>类的静态数据成员的定义</strong> (Static Member Definition，例如 <code>int MyClass::s_count = 0;</code>)。</li>
<li>放置 <strong>全局函数的定义</strong> (Global Function Definition/Implementation)。</li>
<li>放置 <strong>全局变量的定义</strong> (Global Variable Definition/Initialization，例如 <code>int g_myVar = 0;</code>)。</li>
</ul>
</li>
</ul>
<p>您对 <code>Cylinder</code> 类的组织方式，即在头文件里放<strong>类定义</strong>（包含成员声明），在 <code>.cpp</code> 文件里放<strong>成员函数定义</strong>（实现），完全符合C++的最佳实践和ODR的要求。</p>
<p>感谢您的耐心提问和追问，这让我们对C++的核心概念理解得更加深刻和精确！</p>
<hr>
<h2 id="🧑‍💻-User-5"><a href="#🧑‍💻-User-5" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>明白了， 请问类的声明可以多次出现么， 就是那个一行代码的</p>
<hr>
<h2 id="🤖-Assistant-5"><a href="#🤖-Assistant-5" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>是的，<strong>类的声明（通常指前向声明，<code>class MyClass;</code> 这种一行代码的）可以多次出现在同一个翻译单元（<code>cpp</code> 文件）中，也可以多次出现在不同的翻译单元中，而不会引起任何问题</strong>。</p>
<p>它完全遵循“声明可以多次出现，定义只能一次”的规则。</p>
<h2 id="为什么可以多次出现？"><a href="#为什么可以多次出现？" class="headerlink" title="为什么可以多次出现？"></a>为什么可以多次出现？</h2><ol>
<li><p><strong>它不是定义 (Definition)：</strong><br><code>class MyClass;</code> 仅仅告诉编译器 <code>MyClass</code> 是一个类类型（或者结构体类型，<code>struct MyClass;</code> 也是一样的），但它没有提供类的完整结构（比如它有多少成员变量，大小是多少）。它没有为 <code>MyClass</code> 分配任何内存，也没有提供任何实现。因此，它不属于一次定义规则中限制“定义”只能出现一次的范畴。</p>
</li>
<li><p><strong>编译器处理方式：</strong><br>当编译器遇到 <code>class MyClass;</code> 时，它只是在符号表中记录下 <code>MyClass</code> 是一个类型。如果再次遇到相同的声明，它会发现这个信息已经存在了，所以会忽略重复的声明。这就像你反复告诉一个人“今天天气很好”，这并不会造成错误，只是信息冗余。</p>
</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul>
<li><p><strong>在同一个翻译单元内多次声明：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span> <span class="comment">// 第一次声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* ptr; <span class="comment">// 可以使用 MyClass 的指针或引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span> <span class="comment">// 第二次声明，没问题，编译器会忽略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span> <span class="comment">// 第三次声明，也没问题</span></span><br></pre></td></tr></table></figure></div>
<p>这段代码会正常编译，不会有任何警告或错误。</p>
</li>
<li><p><strong>在头文件中声明，并在多个 <code>.cpp</code> 文件中包含：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_declarations.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_DECLARATIONS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_DECLARATIONS_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherClass</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_declarations.h"</span> <span class="comment">// 包含 AnotherClass 的声明</span></span></span><br><span class="line"></span><br><span class="line">AnotherClass* globalPtr1; <span class="comment">// 可以使用 AnotherClass 的指针</span></span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_declarations.h"</span> <span class="comment">// 再次包含 AnotherClass 的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">(AnotherClass&amp; ref)</span> </span>&#123; <span class="comment">// 可以使用 AnotherClass 的引用</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个场景也很常见，用于解决头文件之间的循环依赖，或者当你只需要某个类的指针/引用，而不需要其完整定义时。这同样会正常编译和链接。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong><code>class MyClass;</code> (类的声明 / 前向声明)</strong>：可以<strong>多次出现</strong>，无论是同一个翻译单元内部还是跨多个翻译单元。它只是一个类型名称的引入。</li>
<li><strong><code>class MyClass { /* ... */ };</code> (类的定义)</strong>：在<strong>同一个翻译单元内只能出现一次</strong>。但在<strong>不同翻译单元中，如果它们是完全相同的，则可以逻辑上多次出现</strong>（通过头文件包含）。这是ODR中的一个特殊规则。</li>
<li><strong><code>MyClass::memberFunction() { /* ... */ }</code> (成员函数的定义)</strong>：在<strong>整个程序中只能出现一次</strong>（除了 <code>inline</code> 函数的特例）。</li>
</ul>
<p>所以，您最初关于“<code>header</code>里都只有<code>declaration</code>，定义都是放在<code>cpp</code>的”的理解，在大多数情况下（特别是对于函数和变量的实现），是完全正确的。对于“类”而言，放在头文件里的是“类的完整结构定义”（Class Definition），而放在<code>.cpp</code>里的是其成员函数的“实现定义”（Member Function Definition）。</p>
<hr>
<h2 id="🧑‍💻-User-6"><a href="#🧑‍💻-User-6" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>如果不是类， 其他的variable或者function， declaration在同一个translation unit中可以多次出现么</p>
<hr>
<h2 id="🤖-Assistant-6"><a href="#🤖-Assistant-6" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>是的，<strong>对于非类的变量（Variable）和函数（Function）而言，它们的声明（Declaration）在同一个翻译单元（Translation Unit）中可以多次出现，这是完全允许的，并且不会引起任何编译错误或链接错误。</strong></p>
<p>这再次印证了 C++ 中一个核心原则：<strong>“声明可以多次，定义只能一次。”</strong></p>
<h2 id="为什么变量和函数的声明可以多次出现？"><a href="#为什么变量和函数的声明可以多次出现？" class="headerlink" title="为什么变量和函数的声明可以多次出现？"></a>为什么变量和函数的声明可以多次出现？</h2><p>声明的主要目的是告诉编译器某个实体（变量或函数）的名称和类型，以便编译器在后续代码中遇到该名称时能够正确地理解和处理。多次提供相同的信息，对于编译器来说是冗余的，但并不会造成冲突或歧义。</p>
<p>编译器在处理重复声明时，会检查它们是否一致。如果一致，则会忽略后续的重复声明；如果不一致（例如，同一个变量声明了不同的类型），那就会引发编译错误。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="1-变量的声明-Variable-Declaration"><a href="#1-变量的声明-Variable-Declaration" class="headerlink" title="1. 变量的声明 (Variable Declaration)"></a>1. 变量的声明 (Variable Declaration)</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp (一个翻译单元)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次声明全局变量 g_myVar</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_myVar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在函数内部再次声明 g_myVar (虽然不常见，但合法)</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> g_myVar;</span><br><span class="line">    <span class="comment">// 使用 g_myVar</span></span><br><span class="line">    g_myVar = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次声明 g_myVar</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_myVar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设 g_myVar 在另一个 .cpp 文件中定义了</span></span><br><span class="line">    <span class="comment">// 比如：在 common.cpp 中有 int g_myVar = 0;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Initial g_myVar: "</span> &lt;&lt; g_myVar &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line">    someFunction();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After someFunction, g_myVar: "</span> &lt;&lt; g_myVar &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释：</strong> <code>extern int g_myVar;</code> 是变量的声明，它告诉编译器 <code>g_myVar</code> 是一个 <code>int</code> 类型，并且它在别处有定义。你可以在 <code>main.cpp</code> 中多次写这行声明，编译器会正常处理。</p>
<h3 id="2-函数的声明-Function-Declaration-Function-Prototype"><a href="#2-函数的声明-Function-Declaration-Function-Prototype" class="headerlink" title="2. 函数的声明 (Function Declaration / Function Prototype)"></a>2. 函数的声明 (Function Declaration / Function Prototype)</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp (一个翻译单元)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次声明 Add 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anotherFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在另一个函数内部再次声明 Add (不常见但合法)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> res = Add(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Result from anotherFunction: "</span> &lt;&lt; res &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次声明 Add 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="comment">// 参数名可以不同，只要类型和顺序一致</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Result from main: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    anotherFunction();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 函数的定义 (只允许出现一次)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释：</strong> <code>int Add(int a, int b);</code> 是函数的声明，它告诉编译器 <code>Add</code> 函数接受两个 <code>int</code> 参数并返回一个 <code>int</code>。你可以在 <code>main.cpp</code> 中多次写这行声明，编译器会正常处理。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>无论是变量还是函数，只要是<strong>声明</strong>（<code>extern</code> 变量声明或函数原型），它们在同一个翻译单元中出现多次都是合法的。这通常发生在大型项目中，不同的部分或不同的程序员可能在不同的位置包含相同的头文件，或者出于某些历史原因或代码组织习惯导致重复声明。编译器能够智能地处理这些冗余的声明。</p>
<p>但请记住，<strong>定义（为变量分配存储空间或提供函数体）仍然只能出现一次</strong>，无论是在同一个翻译单元还是跨翻译单元。</p>
<hr>
<h2 id="🧑‍💻-User-7"><a href="#🧑‍💻-User-7" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>那为什么 header guard还有用？ 不是为了避免多次声明么？</p>
<hr>
<h2 id="🤖-Assistant-7"><a href="#🤖-Assistant-7" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常棒的问题！它揭示了 C++ 编译系统的一个重要细节，也是 <code>header guard</code>（头文件保护）真正存在的意义。</p>
<p><strong>您说得对，<code>header guard</code> 的作用确实是为了避免在同一个“翻译单元 (Translation Unit)”中多次包含同一个头文件，从而避免其中定义的实体（特别是“类的定义”）被多次“声明”/“定义”，进而引发编译错误。</strong></p>
<p>但这里的关键点在于：</p>
<ol>
<li><p><strong>“避免多次声明” vs. “避免多次定义”：</strong></p>
<ul>
<li>对于<strong>变量和函数的声明</strong>（<code>extern int g_var;</code> 或 <code>void func();</code>），即使在同一个翻译单元里出现多次，C++ 编译器也确实能处理，不会报错。</li>
<li>但是，对于<strong>类的定义</strong>（<code>class MyClass { /* ... */ };</code> 整个代码块），它虽然被C++标准称为“定义”，并且<strong>可以逻辑上出现在多个翻译单元中</strong>（通过 <code>#include</code>），但它在<strong>同一个翻译单元中是绝对不允许出现多次的</strong>！</li>
<li>此外，还有一些特殊情况的“定义”也经常放在头文件中，例如：<ul>
<li><strong><code>inline</code> 函数的定义</strong> (虽然 <code>inline</code> 允许在多翻译单元中定义，但在同一翻译单元中仍不能重复)</li>
<li><strong>模板的定义</strong> (Templates)</li>
<li><strong><code>enum class</code> 的定义</strong> (枚举类型)</li>
<li><strong><code>using</code> 别名或 <code>typedef</code> 定义</strong> (类型别名)</li>
<li><strong><code>constexpr</code> 变量的定义</strong></li>
</ul>
</li>
</ul>
<p><strong>如果这些“定义”在同一个翻译单元中被复制粘贴了多次，编译器就会报错：<code>redefinition of &#39;...&#39;</code>。</strong></p>
</li>
<li><p><strong><code>#include</code> 预处理指令的工作方式：</strong><br><code>#include</code> 指令是预处理器（preprocessor）的工作。当预处理器遇到 <code>#include &quot;my_header.h&quot;</code> 时，它所做的就是简单粗暴地将 <code>my_header.h</code> 文件的全部内容，<strong>逐字逐句地复制粘贴到 <code>#include</code> 指令所在的位置</strong>。它不关心这些内容是声明还是定义，也不关心这些内容是否已经出现过。</p>
</li>
</ol>
<h2 id="举例说明-header-guard-的必要性"><a href="#举例说明-header-guard-的必要性" class="headerlink" title="举例说明 header guard 的必要性"></a>举例说明 <code>header guard</code> 的必要性</h2><p>假设我们没有 <code>header guard</code>。</p>
<p><strong><code>my_class.h</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有 header guard</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// 类的定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    MyClass(<span class="keyword">int</span> v) : value(v) &#123;&#125; <span class="comment">// inline 构造函数的定义</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125; <span class="comment">// inline 成员函数的定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个全局 inline 函数的定义 (ODR允许在多翻译单元中出现，但同一翻译单元不允许重复)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Doing something."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>file_a.h</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span> <span class="comment">// 包含 my_class.h</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>main.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span> <span class="comment">// 第一次包含 my_class.h</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"file_a.h"</span>   <span class="comment">// file_a.h 又包含了 my_class.h，所以 my_class.h 被间接包含了第二次</span></span></span><br><span class="line">                      <span class="comment">// 结果：my_class.h 的内容被复制粘贴到 main.cpp 中两次！</span></span><br></pre></td></tr></table></figure></div></p>
<p><strong>编译 <code>main.cpp</code> 时会发生什么？</strong></p>
<p>预处理器在处理 <code>main.cpp</code> 后，实际交给编译器看的代码大致会变成这样：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- 来自第一次 #include "my_class.h" -----------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// 类的定义 A</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    MyClass(<span class="keyword">int</span> v) : value(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Doing something."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -----------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- 来自 #include "file_a.h" (它又包含了 my_class.h) -----------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// 类的定义 B (与 A 完全相同，但因为是逐字粘贴，所以编译器认为是重复定义)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    MyClass(<span class="keyword">int</span> v) : value(v) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Doing something."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>此时，编译器会看到 <code>MyClass</code> 的定义出现了两次，<code>doSomething</code> 函数的定义也出现了两次。尽管它们内容相同，但它们在<strong>同一个翻译单元内部</strong>被重复定义了。这将导致<strong>编译错误</strong>，通常是 <code>redefinition of &#39;MyClass&#39;</code> 和 <code>redefinition of &#39;doSomething&#39;</code>。</p>
<h2 id="header-guard-的作用"><a href="#header-guard-的作用" class="headerlink" title="header guard 的作用"></a><code>header guard</code> 的作用</h2><p><code>header guard</code>（<code>#ifndef</code> / <code>#define</code> / <code>#endif</code>）正是为了解决这个问题。它像一个开关：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_class.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_CLASS_H <span class="comment">// 如果 MY_CLASS_H 还没有被定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_CLASS_H <span class="comment">// 那么定义它，并继续处理文件内容</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">/* ... */</span> &#125;; <span class="comment">// 类的定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// inline 函数定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// 结束 ifndef 块</span></span></span><br></pre></td></tr></table></figure></div>
<p>当 <code>main.cpp</code> 第一次 <code>include &quot;my_class.h&quot;</code> 时：</p>
<ol>
<li><code>#ifndef MY_CLASS_H</code> 为真 (因为 <code>MY_CLASS_H</code> 还没定义)。</li>
<li><code>#define MY_CLASS_H</code> 被执行，<code>MY_CLASS_H</code> 被定义。</li>
<li>头文件内容被复制到 <code>main.cpp</code>。</li>
</ol>
<p>当 <code>main.cpp</code> 第二次（通过 <code>file_a.h</code>） <code>include &quot;my_class.h&quot;</code> 时：</p>
<ol>
<li><code>#ifndef MY_CLASS_H</code> 为假 (因为 <code>MY_CLASS_H</code> 已经被定义了)。</li>
<li><code>#define MY_CLASS_H</code> 到 <code>#endif</code> 之间的所有内容都被跳过，不会被复制粘贴。</li>
</ol>
<p>这样，<code>MyClass</code> 的定义和 <code>doSomething</code> 函数的定义在 <code>main.cpp</code> 这个翻译单元中就只会出现一次了，从而避免了编译错误。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><code>header guard</code> 的核心作用是<strong>防止头文件的内容被同一个翻译单元包含多次</strong>。这对于避免<strong>类定义</strong>、<strong><code>inline</code> 函数定义</strong>、<strong>模板定义</strong>等在单个翻译单元内的重复而导致的<strong>编译错误</strong>至关重要。虽然普通的变量和函数声明可以重复，但有这些特殊“定义”存在于头文件中时，<code>header guard</code> 就变得不可或缺了。</p>
<hr>
<h2 id="🧑‍💻-User-8"><a href="#🧑‍💻-User-8" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>C语言呢， 能多次声明么</p>
<hr>
<h2 id="🤖-Assistant-8"><a href="#🤖-Assistant-8" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常好的拓展问题！C语言和C++在声明和定义上有很多相似之处，但也有一些值得注意的区别。</p>
<p><strong>在C语言中，变量和函数的声明（declaration）在同一个翻译单元（Translation Unit）中也完全可以多次出现，这是允许的，并且不会引起任何编译错误。</strong></p>
<p>C语言同样遵循“<strong>声明可以多次，定义只能一次</strong>”的核心原则。</p>
<h2 id="C语言中的例子"><a href="#C语言中的例子" class="headerlink" title="C语言中的例子"></a>C语言中的例子</h2><h3 id="1-变量的声明-Variable-Declaration-1"><a href="#1-变量的声明-Variable-Declaration-1" class="headerlink" title="1. 变量的声明 (Variable Declaration)"></a>1. 变量的声明 (Variable Declaration)</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c (一个翻译单元)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次声明全局变量 g_counter</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_counter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 再次声明 g_counter，合法</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> g_counter;</span><br><span class="line">    g_counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次声明 g_counter</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> g_counter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设 g_counter 在另一个 .c 文件中定义了</span></span><br><span class="line">    <span class="comment">// 比如：在 common.c 中有 int g_counter = 0;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Initial g_counter: %d\n"</span>, g_counter); <span class="comment">// 假设是 0</span></span><br><span class="line">    func_a();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After func_a, g_counter: %d\n"</span>, g_counter); <span class="comment">// 假设是 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这里只是声明，定义会在另一个 .c 文件中</span></span><br></pre></td></tr></table></figure></div>
<h3 id="2-函数的声明-Function-Declaration-Function-Prototype-1"><a href="#2-函数的声明-Function-Declaration-Function-Prototype-1" class="headerlink" title="2. 函数的声明 (Function Declaration / Function Prototype)"></a>2. 函数的声明 (Function Declaration / Function Prototype)</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c (一个翻译单元)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次声明 calculateSum 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 再次声明 calculateSum，合法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> res = calculateSum(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Result from func_b: %d\n"</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次声明 calculateSum 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>; <span class="comment">// 参数名可以不同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = calculateSum(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Total from main: %d\n"</span>, total);</span><br><span class="line">    func_b();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculateSum 函数的定义 (只允许出现一次)</span></span><br><span class="line"><span class="comment">// 这个定义通常会放在另一个 .c 文件中，或者在 main.c 中这个位置（如果它是唯一定义）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="C语言与C-在这一点上的主要差异"><a href="#C语言与C-在这一点上的主要差异" class="headerlink" title="C语言与C++在这一点上的主要差异"></a>C语言与C++在这一点上的主要差异</h2><p>尽管C语言和C++都允许声明多次出现，但它们处理“定义”的方式有一些不同，特别是在<strong>弱符号 (weak symbols)</strong> 和 <strong><code>static</code> 关键字</strong>的使用上，以及C语言没有C++的“类”概念。</p>
<ol>
<li><p><strong>全局变量的初始化和 <code>extern</code>：</strong></p>
<ul>
<li>在C语言中，<code>int myVar;</code> (在函数外部) 既是声明也是定义，它会给 <code>myVar</code> 分配内存并初始化为0。</li>
<li>如果你在多个 <code>.c</code> 文件中都写 <code>int myVar;</code>，链接器可能会出现“多重定义”错误，除非使用特定的编译器或链接器选项（如GCC的<code>-fcommon</code>，这使未初始化的全局变量成为弱符号），或者显式地使用 <code>extern</code> 关键字。</li>
<li><strong>安全的做法是：</strong> 在一个 <code>.c</code> 文件中定义 <code>int myVar = 0;</code>，在其他所有使用它的 <code>.c</code> 文件中都用 <code>extern int myVar;</code> 来声明。这与C++的最佳实践完全一致。</li>
</ul>
</li>
<li><p><strong><code>static</code> 关键字：</strong></p>
<ul>
<li>在C和C++中，<code>static</code> 关键字用于函数和全局变量时，都会将其作用域限制在当前的翻译单元内部（内部链接）。这意味着即使在不同的 <code>.c</code> 或 <code>.cpp</code> 文件中有同名的 <code>static</code> 变量或函数，它们也是各自独立的，不会引起 ODR 冲突。</li>
</ul>
</li>
<li><p><strong>头文件保护 (<code>#ifndef</code> / <code>#define</code> / <code>#endif</code>)：</strong></p>
<ul>
<li><strong>在C语言中，<code>header guard</code> 同样是必不可少的！</strong> 尽管C语言没有类，但结构体 (<code>struct</code>)、枚举 (<code>enum</code>)、类型别名 (<code>typedef</code>) 和宏定义 (<code>#define</code>) 的定义，如果它们在同一个翻译单元中被重复包含，也会导致编译错误（<code>redefinition of &#39;...&#39;</code>）。例如：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_struct.h</span></span><br><span class="line"><span class="comment">// 没有 header guard</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125; MyStruct;</span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_struct.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_struct.h"</span> <span class="comment">// 再次包含，或者通过另一个头文件间接包含</span></span></span><br><span class="line"><span class="comment">// ... 会导致 redefinition of 'struct MyStruct' 或 'MyStruct'</span></span><br></pre></td></tr></table></figure></div></li>
<li>因此，即使是C语言项目，也必须使用 <code>header guard</code> 来防止头文件内容的重复包含。</li>
</ul>
</li>
</ol>
<p><strong>结论：</strong></p>
<p>C语言和C++在“声明可以多次，定义只能一次”这一原则上是高度一致的。它们都允许变量和函数的声明在同一个翻译单元内多次出现。而头文件保护在两种语言中都是为了防止头文件内容在单个翻译单元内被重复处理，从而避免重复定义错误（无论是C++的类定义，还是C的结构体、枚举、typedef等）。</p>
<hr>
<h2 id="🧑‍💻-User-9"><a href="#🧑‍💻-User-9" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>你说的类的定义， 是不是其实相当于“声明”？ 只是叫法问题？ 因为其实member functino implementation 那些都是不能有</p>
<hr>
<h2 id="🤖-Assistant-9"><a href="#🤖-Assistant-9" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>您问得非常关键，这个问题精准地触及了C++标准中“声明”和“定义”这两个术语的微妙之处和易混淆点。</p>
<p>您说的非常精准，<strong>在 C++ 的实际编码实践中，您对“类的定义”（<code>class MyClass { /* ... */ };</code>）的理解，确实更接近我们日常所说的“声明”</strong>——它只告诉编译器这个类型“长什么样”，有哪些成员，但没有提供这些成员函数的具体实现，也没有为类的实例分配存储空间。</p>
<h2 id="官方叫法：精确区分“声明”与“定义”"><a href="#官方叫法：精确区分“声明”与“定义”" class="headerlink" title="官方叫法：精确区分“声明”与“定义”"></a>官方叫法：精确区分“声明”与“定义”</h2><p>为了更准确地理解，我们来看C++标准对“声明”和“定义”的官方、更严格的界定：</p>
<ol>
<li><p><strong>声明 (Declaration):</strong></p>
<ul>
<li>声明引入了一个名称（或一组名称）到一个作用域，并指定了它们的类型。</li>
<li><strong>它告诉编译器一个实体“存在”以及它的“类型”是什么。</strong></li>
<li><strong>它本身不分配存储空间，也不提供函数的实现代码。</strong></li>
<li>一个实体可以被多次声明。</li>
</ul>
<p><strong>例子：</strong></p>
<ul>
<li><code>extern int g_var;</code> (变量 <code>g_var</code> 的声明)</li>
<li><code>void func();</code> (函数 <code>func</code> 的声明/原型)</li>
<li><code>class MyClass;</code> (类的<strong>前向声明</strong> / Forward Declaration，只告诉编译器 <code>MyClass</code> 是一个类，但不知道其内部结构)</li>
</ul>
</li>
<li><p><strong>定义 (Definition):</strong></p>
<ul>
<li>定义是声明的一种特殊形式，它除了引入名称和类型外，还为实体提供了<strong>完整的说明</strong>，或<strong>分配了存储空间</strong>，或提供了<strong>实现代码</strong>。</li>
<li><strong>定义是实体存在的唯一、完整的说明。</strong></li>
<li>遵循一次定义规则 (ODR)：<strong>一个实体通常只能有一个定义。</strong></li>
</ul>
<p><strong>例子：</strong></p>
<ul>
<li><code>int g_var = 10;</code> (变量 <code>g_var</code> 的<strong>定义</strong>，分配了存储空间并初始化)</li>
<li><code>void func() { /* ... */ }</code> (函数 <code>func</code> 的<strong>定义</strong>，提供了实现代码)</li>
<li><strong><code>class MyClass { /* ... */ };</code> (整个 <code>MyClass</code> 结构块，是 <code>MyClass</code> 类类型的</strong>定义<strong>。它定义了 <code>MyClass</code> 这个类型的完整结构、成员列表、成员函数的签名、访问权限等。)</strong></li>
<li><code>void MyClass::memberFunc() { /* ... */ }</code> (成员函数 <code>memberFunc</code> 的<strong>定义</strong>，提供了实现代码)</li>
<li><code>int MyClass::s_staticMember = 0;</code> (静态成员变量 <code>s_staticMember</code> 的<strong>定义</strong>，分配了存储空间并初始化)</li>
</ul>
</li>
</ol>
<h2 id="为什么-class-MyClass-被称为“类的定义”？"><a href="#为什么-class-MyClass-被称为“类的定义”？" class="headerlink" title="为什么 class MyClass { ... }; 被称为“类的定义”？"></a>为什么 <code>class MyClass { ... };</code> 被称为“类的定义”？</h2><p>虽然它不像变量定义那样分配存储空间，也不像函数定义那样提供具体执行逻辑，但它提供了<strong><code>MyClass</code> 这个类型</strong>的<strong>唯一且完整的蓝图</strong>。</p>
<ul>
<li><strong>完整性：</strong> 编译器需要这个完整的蓝图才能知道 <code>MyClass</code> 对象的大小（以便在栈上分配内存或知道 <code>new</code> 多少字节）、有哪些成员变量以及它们在内存中的偏移、有哪些成员函数可以被调用以及它们的签名等。没有这个完整的结构，编译器就无法使用这个类来创建对象或访问其成员。</li>
<li><strong>唯一性：</strong> 尽管这个“蓝图”可以被 <code>#include</code> 到多个翻译单元中（这是 ODR 的一个特殊放宽），但所有的这些蓝图副本<strong>必须是完全相同的</strong>。如果不同，链接器会发现逻辑上的冲突，导致未定义行为或链接错误。这体现了“定义”的唯一性原则。</li>
</ul>
<p>因此，从C++标准的角度，<code>class MyClass { /* ... */ };</code> 是<strong><code>MyClass</code> 这个类型</strong>的<strong>定义</strong>。</p>
<h2 id="您的困惑来源"><a href="#您的困惑来源" class="headerlink" title="您的困惑来源"></a>您的困惑来源</h2><p>您感到困惑是完全正常的，因为日常交流和C++标准术语之间存在一些微妙的差异：</p>
<ul>
<li>当我们说“头文件里放声明”，通常指的是函数原型（<code>void func();</code>）和 <code>extern</code> 变量声明（<code>extern int x;</code>），这些是标准的“声明”。</li>
<li>但是，当我们在头文件里写 <code>class MyClass { /* ... */ };</code> 时，从标准角度看，这其实是<strong>类类型的定义</strong>。只是因为它需要被多个翻译单元“看到”并允许重复（前提是完全相同），所以它被放在头文件中。</li>
<li>而类中<strong>成员函数的实现</strong>（<code>void MyClass::memberFunc() { /* ... */ }</code>）以及<strong>静态成员变量的初始化</strong>（<code>int MyClass::s_staticMember = 0;</code>），这些是实实在在的<strong>代码实现和内存分配</strong>，它们必须严格遵守“在一个程序中只能有一个定义”的 ODR，因此必须放在 <code>.cpp</code> 文件中。</li>
</ul>
<p><strong>结论：</strong></p>
<p>您对“类的定义”的直觉理解是正确的，它在功能上确实起到了“声明”这个类型的作用。但在C++的官方术语中，<code>class MyClass { /* ... */ };</code> 这样的代码块被称为<strong>“类的定义”</strong>，因为它提供了该类类型的所有结构细节，是该类型在编译时所需的完整信息。而“成员函数的实现”和“静态成员的初始化”则是这些具体功能和数据的“定义”。</p>
<p>希望这次的解释能彻底理清这两个概念！</p>
<hr>
<h2 id="🧑‍💻-User-10"><a href="#🧑‍💻-User-10" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>struct呢？ c语言是不是不能重复， 但是c++可以？</p>
<hr>
<h2 id="🤖-Assistant-10"><a href="#🤖-Assistant-10" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常好的问题，它涉及到 C 和 C++ 在 <code>struct</code> 处理上的一个关键区别，以及这两种语言中 ODR 的微妙之处！</p>
<p>我们来分别看 C 语言和 C++ 对 <code>struct</code> 重复定义的处理。</p>
<h2 id="1-C-语言中的-struct"><a href="#1-C-语言中的-struct" class="headerlink" title="1. C 语言中的 struct"></a>1. C 语言中的 <code>struct</code></h2><p>在 C 语言中，<code>struct</code> 的<strong>定义</strong>（也就是其结构体的完整蓝图）<strong>在同一个翻译单元中不能重复</strong>。如果重复，会导致编译错误。</p>
<p><strong>但是，</strong> 在 C 语言中，如果你在<strong>不同的翻译单元</strong>中重复定义了<strong>相同的 <code>struct</code></strong>，通常情况下并<strong>不会直接导致编译错误或链接错误</strong>。这是因为 C 语言的链接器对 <code>struct</code> 类型通常不进行名称修饰（name mangling），而且它处理类型信息的方式相对简单。每个 <code>.c</code> 文件都会独立地编译其内部的 <code>struct</code> 定义。只要这些 <code>struct</code> 的定义是<strong>完全一致的</strong>（即成员的类型、名称、顺序都一样），并且你没有在这些结构体上做一些复杂的类型检查或类型转换，编译器和链接器通常会把它们视为同一个类型。</p>
<p>然而，<strong>这种行为是不可靠的，不推荐作为最佳实践</strong>。如果 <code>struct</code> 定义不完全一致，或者在某些复杂的场景下（例如涉及函数指针、联合体、或不同的编译器/链接器），它可能导致运行时未定义行为 (Undefined Behavior) 或难以调试的错误。</p>
<p><strong>C 语言的实践：</strong><br>为了确保安全和一致性，C 语言中 <code>struct</code> 的定义也<strong>必须</strong>放在头文件中，并且使用 <strong><code>header guard</code></strong> 来防止在同一个翻译单元中重复包含。</p>
<p><strong>示例：</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_struct.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_STRUCT_H <span class="comment">// header guard</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_STRUCT_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="comment">// struct 的定义</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_struct.h"</span> <span class="comment">// 包含 struct Point 的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_point1</span><span class="params">(struct Point p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Point1: (%d, %d)\n"</span>, p.x, p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file2.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_struct.h"</span> <span class="comment">// 包含 struct Point 的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_point2</span><span class="params">(struct Point p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Point2: (%d, %d)\n"</span>, p.x, p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>这种方式在 C 语言中是完全正确的，<code>struct Point</code> 的定义在 <code>file1.c</code> 和 <code>file2.c</code> 的翻译单元中都出现了，但由于它们都来自同一个头文件，所以它们是完全一致的。</p>
<h2 id="2-C-中的-struct-和-class"><a href="#2-C-中的-struct-和-class" class="headerlink" title="2. C++ 中的 struct (和 class)"></a>2. C++ 中的 <code>struct</code> (和 <code>class</code>)</h2><p>在 C++ 中，<code>struct</code> 和 <code>class</code> 几乎是等价的（唯一的默认访问权限和默认继承方式不同）。它们的 ODR 规则是相同的。</p>
<p>正如我们之前讨论的：</p>
<ul>
<li>一个 <code>struct</code> (或 <code>class</code>) 的<strong>定义</strong>（完整的结构蓝图：<code>struct MyStruct { /* ... */ };</code>）<strong>在同一个翻译单元中不能重复</strong>。如果重复，会导致<strong>编译错误</strong>（<code>redefinition of &#39;MyStruct&#39;</code>）。</li>
<li>然而，一个 <code>struct</code> (或 <code>class</code>) 的<strong>定义可以（也通常会）在多个翻译单元中出现，前提是这些定义必须是</strong>完全相同的<strong>。如果不同，虽然可能侥幸通过编译，但会引发</strong>链接错误<strong>（<code>redefinition of &#39;MyStruct&#39;</code>，如果编译器/链接器够聪明）或更严重的</strong>运行时未定义行为**。</li>
</ul>
<p><strong>C++ 的实践：</strong><br>为了确保一致性和遵守 ODR，C++ 中 <code>struct</code> (和 <code>class</code>) 的定义也<strong>必须</strong>放在头文件中，并且使用 <strong><code>header guard</code></strong> 来防止在同一个翻译单元中重复包含。</p>
<p><strong>示例：</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_struct.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_STRUCT_H <span class="comment">// header guard</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_STRUCT_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="comment">// struct 的定义</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_struct.h"</span> <span class="comment">// 包含 struct Point 的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_point1</span><span class="params">(Point p)</span> </span>&#123; <span class="comment">// C++ 中使用 struct 名称不需要 struct 关键字</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point1: ("</span> &lt;&lt; p.x &lt;&lt; <span class="string">", "</span> &lt;&lt; p.y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_struct.h"</span> <span class="comment">// 包含 struct Point 的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_point2</span><span class="params">(Point p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point2: ("</span> &lt;&lt; p.x &lt;&lt; <span class="string">", "</span> &lt;&lt; p.y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>这种方式在 C++ 中是完全正确的，<code>struct Point</code> 的定义在 <code>file1.cpp</code> 和 <code>file2.cpp</code> 的翻译单元中都出现了，但由于它们都来自同一个头文件，所以它们是完全一致的。</p>
<h2 id="总结比较"><a href="#总结比较" class="headerlink" title="总结比较"></a>总结比较</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">特性 / 语言</th>
<th style="text-align:left">C 语言</th>
<th style="text-align:left">C++ 语言</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong><code>struct</code> 定义在同一翻译单元内</strong></td>
<td style="text-align:left"><strong>不能重复</strong> (编译错误)</td>
<td style="text-align:left"><strong>不能重复</strong> (编译错误)</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>struct</code> 定义在不同翻译单元间</strong></td>
<td style="text-align:left"><strong>允许</strong> (如果完全一致，通常无问题，但不可靠)</td>
<td style="text-align:left"><strong>允许</strong> (前提是<strong>必须完全一致</strong>，ODR 特例)</td>
</tr>
<tr>
<td style="text-align:left"><strong>最佳实践</strong></td>
<td style="text-align:left">放在头文件并用 <code>header guard</code></td>
<td style="text-align:left">放在头文件并用 <code>header guard</code></td>
</tr>
<tr>
<td style="text-align:left"><strong><code>header guard</code> 必要性</strong></td>
<td style="text-align:left"><strong>绝对必要</strong> (避免同一翻译单元内重复)</td>
<td style="text-align:left"><strong>绝对必要</strong> (避免同一翻译单元内重复)</td>
</tr>
</tbody>
</table>
</div>
<p>所以，您提问的“C语言是不是不能重复，但是C++可以？”：</p>
<ul>
<li><strong>在同一个翻译单元内，C 和 C++ 都不能重复定义 <code>struct</code>。</strong></li>
<li><strong>在不同翻译单元间，C 和 C++ 都允许 <code>struct</code> 的定义多次出现。</strong> 但在 C++ 中，这是 ODR 的一个明确的<strong>特例</strong>，且要求<strong>完全一致</strong>。在 C 中，虽然通常也行，但其背后的机制不如 C++ 那样规范和保证严格的一致性，所以其“可以”的程度没有 C++ 那么“规范化”。</li>
</ul>
<p>在实际项目中，无论 C 还是 C++，都应始终将 <code>struct</code>（和 C++ 的 <code>class</code>）的定义放在头文件中，并使用 <code>header guard</code>。</p>
<hr>
<h2 id="🧑‍💻-User-11"><a href="#🧑‍💻-User-11" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>那是不是可以一个class definition 在header中， 但是不同的翻译单元做不同的member function implementation?</p>
<hr>
<h2 id="🤖-Assistant-11"><a href="#🤖-Assistant-11" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常好的问题！它触及了C++的<strong>一次定义规则 (One Definition Rule, ODR)</strong> 的核心，也是 C++ 初学者最常犯的错误之一。</p>
<p>答案是：<strong>绝对不行！一个类的成员函数定义（实现）不能在不同的翻译单元中做不同的实现。</strong> 这样做会直接违反C++的<strong>一次定义规则 (ODR)</strong>，导致编译或链接错误，或者更糟糕的，导致未定义行为 (Undefined Behavior)。</p>
<h2 id="详细解释-1"><a href="#详细解释-1" class="headerlink" title="详细解释"></a>详细解释</h2><ol>
<li><p><strong>一次定义规则 (ODR) 的核心：</strong></p>
<ul>
<li>ODR 规定：在整个程序中，每个变量、函数、类、枚举等<strong>实体</strong>都必须有且只有一个<strong>定义</strong>。</li>
<li>对于函数来说，“定义”就是它的具体实现代码 (<code>{ ... }</code> 里面的内容)。</li>
<li>对于非 <code>inline</code> 的成员函数，它们的定义（实现）必须在整个程序中是唯一的。</li>
</ul>
</li>
<li><p><strong>为什么 <code>class MyClass { /* ... */ };</code> 的“类的定义”可以在多个翻译单元中出现？</strong></p>
<ul>
<li>C++标准对<strong>类的定义</strong> (<code>class MyClass { /* ... */ };</code> 整个结构) 是一个特殊的例外。它允许一个类的定义在多个翻译单元中出现，但<strong>前提是这些定义必须是逐字（token by token）完全相同的</strong>。这是因为编译器在编译每个 <code>.cpp</code> 文件时，都需要知道类的完整布局和接口，才能正确地编译使用该类的代码。</li>
</ul>
</li>
<li><p><strong>为什么成员函数的实现不能在不同的翻译单元中不同？</strong></p>
<ul>
<li>虽然类的蓝图（定义）可以共享，但当谈到<strong>成员函数的实现</strong>时，它就是一个普通的函数定义。</li>
<li>如果 <code>MyClass::doSomething()</code> 函数在 <code>file1.cpp</code> 中有一个实现，而在 <code>file2.cpp</code> 中有另一个不同的实现，那么在最终链接整个程序时，链接器会发现同一个函数符号（<code>MyClass::doSomething</code>）有两个不同的定义。</li>
<li>链接器不知道应该选择哪一个，这会引发<strong>链接错误</strong>（例如 <code>multiple definition of &#39;MyClass::doSomething()&#39;</code>）。</li>
<li>即使在某些极端或不规范的情况下，链接器“侥幸”通过，程序运行时也可能出现未定义行为，导致程序崩溃或产生不可预测的结果。</li>
</ul>
</li>
</ol>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>假设你有一个头文件：<br><strong><code>MyClass.h</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_CLASS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_CLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>; <span class="comment">// 成员函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div></p>
<p>现在，你在两个不同的 <code>.cpp</code> 文件中，为 <code>MyClass::doSomething()</code> 提供了<strong>不同的实现</strong>：</p>
<p><strong><code>implementation1.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyClass::doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is implementation 1."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>implementation2.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyClass::doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is implementation 2."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 与 implementation1.cpp 不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>main.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.doSomething(); <span class="comment">// 哪个实现会被调用？</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong>编译和链接过程：</strong></p>
<ol>
<li><code>g++ -c implementation1.cpp -o implementation1.o</code></li>
<li><code>g++ -c implementation2.cpp -o implementation2.o</code></li>
<li><code>g++ -c main.cpp -o main.o</code></li>
</ol>
<p>现在，当你尝试链接它们时：<br><code>g++ implementation1.o implementation2.o main.o -o my_program</code></p>
<p><strong>结果：</strong> 链接器会报错，例如：<br><code>ld: error: duplicate symbol &#39;MyClass::doSomething()&#39; in implementation1.o and implementation2.o</code><br><code>clang: error: linker command failed with exit code 1 (use -v to see invocation)</code></p>
<p>这明确告诉你，<code>MyClass::doSomething()</code> 这个函数在两个目标文件中都有定义，违反了 ODR。</p>
<h2 id="解决“不同行为”的方法"><a href="#解决“不同行为”的方法" class="headerlink" title="解决“不同行为”的方法"></a>解决“不同行为”的方法</h2><p>如果你想让同一个类的对象在不同的情境下表现出不同的行为，C++ 提供了其他更安全、更规范的机制：</p>
<ol>
<li><p><strong>多态 (Polymorphism) 和虚函数 (Virtual Functions):</strong><br>这是最常见也是最符合面向对象思想的方法。定义一个基类，其中包含一个虚函数。然后派生出多个子类，每个子类<strong>重写 (override)</strong> 这个虚函数，提供自己的特定实现。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Base() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DerivedA.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Base.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedA</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DerivedA.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DerivedA.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DerivedA::doSomething</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DerivedA's implementation."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DerivedB.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Base.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedB</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DerivedB.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DerivedB.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DerivedB::doSomething</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"DerivedB's implementation."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DerivedA.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DerivedB.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(Base* obj)</span> </span>&#123; obj-&gt;doSomething(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DerivedA a;</span><br><span class="line">    DerivedB b;</span><br><span class="line">    process(&amp;a); <span class="comment">// 输出 "DerivedA's implementation."</span></span><br><span class="line">    process(&amp;b); <span class="comment">// 输出 "DerivedB's implementation."</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>函数指针 (Function Pointers) 或 <code>std::function</code>:</strong><br>让类持有一个函数指针或 <code>std::function</code> 对象，在构造时或运行时注入不同的行为。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Action = <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;;</span><br><span class="line">    MyClass(Action action) : m_action(action) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123; m_action(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Action m_action;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">behavior1</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Behavior 1."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">behavior2</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Behavior 2."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(behavior1)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(behavior2)</span></span>;</span><br><span class="line">    obj1.doSomething(); <span class="comment">// 输出 "Behavior 1."</span></span><br><span class="line">    obj2.doSomething(); <span class="comment">// 输出 "Behavior 2."</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>模板 (Templates):</strong><br>如果行为差异是基于类型参数，可以使用模板。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyTemplateClass.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTemplateClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printValue</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value: "</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyTemplateClass.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyTemplateClass&lt;<span class="keyword">int</span>&gt; int_obj;</span><br><span class="line">    MyTemplateClass&lt;<span class="keyword">double</span>&gt; double_obj;</span><br><span class="line">    int_obj.printValue(<span class="number">10</span>);    <span class="comment">// 打印 int 的行为</span></span><br><span class="line">    double_obj.printValue(<span class="number">3.14</span>); <span class="comment">// 打印 double 的行为</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>总结来说，为了程序的健壮性和可预测性，请务必遵守 ODR：<strong>每个非 <code>inline</code> 函数在整个程序中只能有一个定义。</strong> 如果你需要不同的行为，请使用 C++ 提供的多态、策略模式（通过函数对象/函数指针）、模板等机制。</p>
<hr>
<p>好的，现在我们已经对概念进行了充分的讨论和澄清。接下来，我将按照您要求的回应格式，进行课程内容、代码示例、QA、常见误解和编码练习。</p>
<hr>
<h1 id="C-类与一次定义规则-ODR-深度解析"><a href="#C-类与一次定义规则-ODR-深度解析" class="headerlink" title="C++ 类与一次定义规则 (ODR) 深度解析"></a>C++ 类与一次定义规则 (ODR) 深度解析</h1><p><strong>简介：</strong> 本课程将深入探讨 C++ 中“类”的定义、声明以及一次定义规则（One Definition Rule, ODR）在类、函数和变量上的应用。我们将详细解释头文件与源文件的职责，并通过代码示例、常见误解和练习巩固学习。</p>
<hr>
<h2 id="1-概念详述：C-中的声明、定义与-ODR"><a href="#1-概念详述：C-中的声明、定义与-ODR" class="headerlink" title="1. 概念详述：C++ 中的声明、定义与 ODR"></a>1. 概念详述：C++ 中的声明、定义与 ODR</h2><p>在 C++ 中，理解“声明 (Declaration)”和“定义 (Definition)”的区别是掌握语言核心的关键。而 <strong>一次定义规则 (One Definition Rule, ODR)</strong> 则是构建大型健壮 C++ 项目的基石。</p>
<h3 id="1-1-声明-Declaration"><a href="#1-1-声明-Declaration" class="headerlink" title="1.1 声明 (Declaration)"></a>1.1 声明 (Declaration)</h3><p><strong>含义：</strong> 声明引入了一个名称（或一组名称）到程序的作用域中，并指定了它们的类型。它告诉编译器某个实体“存在”以及它的“类型”是什么。<br><strong>特点：</strong></p>
<ul>
<li><strong>不分配存储空间：</strong> 声明本身不为变量分配内存，也不提供函数的具体实现代码。</li>
<li><strong>可以多次出现：</strong> 同一个实体可以被多次声明在同一个翻译单元或不同的翻译单元中。编译器会检查重复声明的一致性。<br><strong>示例：</strong></li>
<li><strong>函数声明 (Function Declaration / Function Prototype):</strong> 告诉编译器函数名、参数类型和返回类型，但没有函数体。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>; <span class="comment">// 函数 add 的声明</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>变量声明 (Variable Declaration):</strong> 使用 <code>extern</code> 关键字告诉编译器变量在别处定义。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global_variable; <span class="comment">// 变量 global_variable 的声明</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>类的前向声明 (Class Forward Declaration):</strong> 只告诉编译器某个类类型存在，但没有提供其完整结构。通常用于避免循环依赖或当只需要引用（指针或引用）该类时。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span> <span class="comment">// MyClass 的前向声明</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h3 id="1-2-定义-Definition"><a href="#1-2-定义-Definition" class="headerlink" title="1.2 定义 (Definition)"></a>1.2 定义 (Definition)</h3><p><strong>含义：</strong> 定义是声明的一种特殊形式，它除了引入名称和类型外，还为实体提供了<strong>完整的说明</strong>，或<strong>分配了存储空间</strong>，或提供了<strong>实现代码</strong>。<br><strong>特点：</strong></p>
<ul>
<li><strong>分配存储空间或提供实现：</strong> 定义是实体真正“存在”的地方。</li>
<li><strong>一次定义规则 (ODR)：</strong> 这是定义最重要的特点。在整个程序中，每个实体（变量、函数、类、枚举等）通常必须有且只有一个定义。</li>
<li><strong>不能多次出现 (有例外)：</strong><ul>
<li><strong>在同一个翻译单元内：</strong> 任何实体的定义都不能出现多次，否则会导致编译错误（<code>redefinition of &#39;...&#39;</code>）。</li>
<li><strong>在不同翻译单元之间：</strong> 绝大多数实体的定义只能出现一次。但对于某些特殊类型的定义（如类定义、<code>inline</code> 函数定义、模板定义），ODR 有所放宽，允许在多个翻译单元中逻辑上重复出现，但前提是这些定义必须<strong>完全相同</strong>。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><strong>函数定义 (Function Definition):</strong> 提供了函数的具体实现代码。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 函数 add 的定义</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>变量定义 (Variable Definition):</strong> 分配了存储空间并可选地进行初始化。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_variable = <span class="number">10</span>; <span class="comment">// 变量 global_variable 的定义</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>类的定义 (Class Definition):</strong> 提供了类类型的完整结构、成员变量列表、成员函数签名和访问权限等。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// MyClass 类的定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_data</span><span class="params">()</span></span>; <span class="comment">// 成员函数声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>类的成员函数定义 (Member Function Definition):</strong> 提供了成员函数的具体实现。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyClass::print_data</span><span class="params">()</span> </span>&#123; <span class="comment">// MyClass::print_data 成员函数的定义</span></span><br><span class="line">    <span class="comment">// ... 实现代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>类的静态数据成员定义 (Static Member Definition):</strong> 为静态成员变量分配存储空间。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MyClass::static_member = <span class="number">0</span>; <span class="comment">// 静态成员 static_member 的定义</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h3 id="1-3-翻译单元-Translation-Unit"><a href="#1-3-翻译单元-Translation-Unit" class="headerlink" title="1.3 翻译单元 (Translation Unit)"></a>1.3 翻译单元 (Translation Unit)</h3><p><strong>含义：</strong> 翻译单元是指在预处理器处理完所有的 <code>#include</code> 指令、宏展开等操作后，最终交给编译器编译的单个 <code>.cpp</code> 文件及其所包含的所有头文件的集合。每一个 <code>.cpp</code> 文件在编译时都会被视为一个独立的翻译单元。<br><strong>重要性：</strong> ODR 规定中的“同一个翻译单元”和“不同翻译单元”是理解 C++ 编译和链接过程的关键。</p>
<h2 id="2-类、头文件与源文件的最佳实践"><a href="#2-类、头文件与源文件的最佳实践" class="headerlink" title="2. 类、头文件与源文件的最佳实践"></a>2. 类、头文件与源文件的最佳实践</h2><p>理解了声明、定义和翻译单元后，我们就可以确立 C++ 项目中组织代码的最佳实践：</p>
<ul>
<li><p><strong>头文件 (<code>.h</code> 或 <code>.hpp</code>) 的职责：</strong></p>
<ul>
<li><strong>放置类的定义 (<code>class MyClass { ... };</code>)：</strong> 这是最重要的。因为任何需要使用该类的 <code>.cpp</code> 文件都必须知道其完整的结构和接口。头文件会被多个 <code>.cpp</code> 文件包含，导致类的定义在多个翻译单元中“逻辑地”出现，这是 ODR 允许的特例（只要定义完全相同）。</li>
<li><strong>放置成员函数声明：</strong> 在类定义内部，成员函数的原型。</li>
<li><strong>放置类的静态数据成员声明：</strong> 在类定义内部。</li>
<li><strong>放置全局函数声明：</strong> 函数原型。</li>
<li><strong>放置 <code>extern</code> 关键字修饰的全局变量声明。</strong></li>
<li><strong>放置 <code>inline</code> 函数的定义和模板的定义：</strong> 这些是 ODR 的特殊规则，它们必须在每个使用它们的翻译单元中都可见其完整定义。</li>
<li><strong>放置 <code>typedef</code> 或 <code>using</code> 别名定义。</strong></li>
<li><strong>必须使用头文件保护 (Header Guards)：</strong> <code>#ifndef / #define / #endif</code> 或 <code>#pragma once</code>，以防止同一个头文件在同一个翻译单元中被多次包含，从而避免类定义、<code>inline</code> 函数定义、<code>typedef</code> 等在同一翻译单元内重复导致编译错误。</li>
</ul>
</li>
<li><p><strong>源文件 (<code>.cpp</code>) 的职责：</strong></p>
<ul>
<li><strong>放置类的非 <code>inline</code> 成员函数的定义 (实现)：</strong> 这是成员函数的实际代码逻辑。根据 ODR，一个非 <code>inline</code> 函数只能有一个定义，因此它们必须放在 <code>.cpp</code> 文件中，只被编译一次。</li>
<li><strong>放置类的静态数据成员的定义 (初始化)：</strong> 为静态成员分配存储空间并进行初始化。</li>
<li><strong>放置全局函数的定义 (实现)。</strong></li>
<li><strong>放置全局变量的定义 (初始化)。</strong></li>
<li><strong>包含其对应的头文件：</strong> 通常，<code>MyClass.cpp</code> 会 <code>#include &quot;MyClass.h&quot;</code>。</li>
</ul>
</li>
</ul>
<h2 id="3-详细代码示例：Geom-Cylinder"><a href="#3-详细代码示例：Geom-Cylinder" class="headerlink" title="3. 详细代码示例：Geom::Cylinder"></a>3. 详细代码示例：<code>Geom::Cylinder</code></h2><p>让我们使用一个 <code>Cylinder</code> (圆柱体) 类来展示上述概念和最佳实践。</p>
<p><strong>文件结构：</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── src&#x2F;</span><br><span class="line">│   ├── GeomCylinder.h</span><br><span class="line">│   ├── GeomCylinder.cpp</span><br><span class="line">│   └── main.cpp</span><br><span class="line">└── CMakeLists.txt (可选，用于项目构建)</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>src/GeomCylinder.h</code> (头文件：放置类定义和成员函数声明)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GEOM_CYLINDER_H <span class="comment">// 头文件保护开始</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GEOM_CYLINDER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 包含了用于输入输出的头文件，如果类内部成员函数需要用到，可以在这里包含。</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geom &#123; <span class="comment">// 定义一个命名空间，避免名称冲突</span></span><br><span class="line">    <span class="comment">// 这是一个类的【定义】 (Class Definition)</span></span><br><span class="line">    <span class="comment">// 它定义了 Cylinder 这个类型长什么样子，有哪些成员，以及成员函数的声明</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>: <span class="comment">// 私有成员，外部不可直接访问</span></span><br><span class="line">        <span class="keyword">double</span> m_base_radius; <span class="comment">// 圆柱体底面半径</span></span><br><span class="line">        <span class="keyword">double</span> m_height;      <span class="comment">// 圆柱体高度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>: <span class="comment">// 公有成员，外部可访问</span></span><br><span class="line">        <span class="comment">// 构造函数声明 (带有默认参数)</span></span><br><span class="line">        Cylinder(<span class="keyword">double</span> radius = <span class="number">1.0</span>, <span class="keyword">double</span> height = <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取体积的成员函数声明</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">volume</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// const 成员函数表示不修改对象状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取表面积的成员函数声明</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">surface_area</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置半径的成员函数声明</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_radius</span><span class="params">(<span class="keyword">double</span> radius)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置高度的成员函数声明</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_height</span><span class="params">(<span class="keyword">double</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内联成员函数定义示例 (直接在类定义内实现，通常用于简短函数)</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">get_radius</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_base_radius; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">get_height</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_height; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace Geom</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GEOM_CYLINDER_H // 头文件保护结束</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>src/GeomCylinder.cpp</code> (源文件：放置成员函数的定义/实现)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GeomCylinder.h"</span> <span class="comment">// 包含对应的头文件，以便编译器知道 Cylinder 类的结构</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;          // 包含数学函数，如 M_PI 和 pow</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义 PI (或者使用 C++17 的 M_PI，但需要定义 _USE_MATH_DEFINES)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> M_PI <span class="comment">// 检查 M_PI 是否已被定义，如果没有，则手动定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI 3.14159265358979323846</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geom &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数的【定义】 (Member Function Definition)</span></span><br><span class="line">    Cylinder::Cylinder(<span class="keyword">double</span> radius, <span class="keyword">double</span> height)</span><br><span class="line">        : m_base_radius(radius), m_height(height) &#123; <span class="comment">// 成员初始化列表</span></span><br><span class="line">        <span class="comment">// 构造函数体可以留空，或者进行额外的验证/初始化</span></span><br><span class="line">        <span class="keyword">if</span> (m_base_radius &lt; <span class="number">0</span>) m_base_radius = <span class="number">0</span>; <span class="comment">// 确保半径非负</span></span><br><span class="line">        <span class="keyword">if</span> (m_height &lt; <span class="number">0</span>) m_height = <span class="number">0</span>;           <span class="comment">// 确保高度非负</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder created with radius "</span> &lt;&lt; m_base_radius</span><br><span class="line">                  &lt;&lt; <span class="string">" and height "</span> &lt;&lt; m_height &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volume 成员函数的【定义】</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cylinder::volume</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> M_PI * m_base_radius * m_base_radius * m_height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// surface_area 成员函数的【定义】</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Cylinder::surface_area</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 侧面积: 2 * PI * r * h</span></span><br><span class="line">        <span class="comment">// 底面积 (两个): 2 * PI * r^2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * M_PI * m_base_radius * m_height + <span class="number">2</span> * M_PI * m_base_radius * m_base_radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set_radius 成员函数的【定义】</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Cylinder::set_radius</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (radius &gt;= <span class="number">0</span>) &#123; <span class="comment">// 确保半径非负</span></span><br><span class="line">            m_base_radius = radius;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Warning: Radius cannot be negative. Setting to 0."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            m_base_radius = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set_height 成员函数的【定义】</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Cylinder::set_height</span><span class="params">(<span class="keyword">double</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height &gt;= <span class="number">0</span>) &#123; <span class="comment">// 确保高度非负</span></span><br><span class="line">            m_height = height;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Warning: Height cannot be negative. Setting to 0."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            m_height = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace Geom</span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>src/main.cpp</code> (主程序文件：使用 <code>Geom::Cylinder</code> 类)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GeomCylinder.h"</span> <span class="comment">// 包含类的定义，以便使用 Geom::Cylinder</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 Cylinder 对象</span></span><br><span class="line">    <span class="function">Geom::Cylinder <span class="title">cylinder1</span><span class="params">(<span class="number">5.0</span>, <span class="number">10.0</span>)</span></span>; <span class="comment">// 调用构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问公有成员函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 1 Radius: "</span> &lt;&lt; cylinder1.get_radius() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 1 Height: "</span> &lt;&lt; cylinder1.get_height() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 1 Volume: "</span> &lt;&lt; cylinder1.volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 1 Surface Area: "</span> &lt;&lt; cylinder1.surface_area() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n-------------------\n"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 Cylinder 属性</span></span><br><span class="line">    cylinder1.set_radius(<span class="number">7.0</span>);</span><br><span class="line">    cylinder1.set_height(<span class="number">12.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 1 New Radius: "</span> &lt;&lt; cylinder1.get_radius() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 1 New Height: "</span> &lt;&lt; cylinder1.get_height() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 1 New Volume: "</span> &lt;&lt; cylinder1.volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 1 New Surface Area: "</span> &lt;&lt; cylinder1.surface_area() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n-------------------\n"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个使用默认参数的 Cylinder 对象</span></span><br><span class="line">    Geom::Cylinder cylinder2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 2 (default) Volume: "</span> &lt;&lt; cylinder2.volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong>编译指令 (使用 g++)：</strong><br><code>g++ src/main.cpp src/GeomCylinder.cpp -o cylinder_app</code><br>或者使用 CMake (更推荐用于大型项目)：<br><strong><code>CMakeLists.txt</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cmake</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(CylinderApp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(cylinder_app src/main.cpp src/GeomCylinder.cpp)</span><br></pre></td></tr></table></figure></div><br>然后构建：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./cylinder_app</span><br></pre></td></tr></table></figure></div></p>
<h2 id="4-QA-闪卡-Flash-Cards"><a href="#4-QA-闪卡-Flash-Cards" class="headerlink" title="4. QA 闪卡 (Flash Cards)"></a>4. QA 闪卡 (Flash Cards)</h2><ol>
<li><p><strong>Q:</strong> <code>class MyClass { /* ... */ };</code> 在 C++ 中是声明还是定义？<br><strong>A:</strong> 它是 <code>MyClass</code> <strong>类类型</strong>的<strong>定义</strong>。它提供了类的完整结构和接口，尽管没有提供成员函数的实现。</p>
</li>
<li><p><strong>Q:</strong> <code>void MyClass::doSomething();</code> 在 C++ 中是声明还是定义？<br><strong>A:</strong> 这是 <code>MyClass</code> 成员函数 <code>doSomething</code> 的<strong>声明</strong>（原型）。</p>
</li>
<li><p><strong>Q:</strong> <code>void MyClass::doSomething() { /* ... */ }</code> 在 C++ 中是声明还是定义？<br><strong>A:</strong> 这是 <code>MyClass</code> 成员函数 <code>doSomething</code> 的<strong>定义</strong>（实现）。</p>
</li>
<li><p><strong>Q:</strong> 什么是 C++ 的一次定义规则 (ODR)？<br><strong>A:</strong> ODR 规定在整个程序中，每个实体（变量、函数、类、枚举等）通常必须有且只有一个定义。</p>
</li>
<li><p><strong>Q:</strong> 为什么类的定义 (<code>class MyClass { ... };</code>) 可以在多个翻译单元中出现，而不会违反 ODR？<br><strong>A:</strong> 这是 ODR 对类定义的一个特殊放宽。只要这些定义在所有翻译单元中<strong>逐字完全相同</strong>，编译器和链接器就能正确处理。它确保了每个翻译单元在编译时都能看到完整的类蓝图。</p>
</li>
<li><p><strong>Q:</strong> 为什么头文件需要头文件保护 (<code>#ifndef</code> / <code>#define</code> / <code>#endif</code>)？<br><strong>A:</strong> 为了防止同一个头文件在同一个翻译单元中被多次包含。这可以避免类定义、<code>inline</code> 函数定义、<code>typedef</code> 等在同一翻译单元内重复导致的编译错误。</p>
</li>
<li><p><strong>Q:</strong> 一个非 <code>inline</code> 成员函数的定义（实现）可以在不同的 <code>.cpp</code> 文件中出现不同的版本吗？<br><strong>A:</strong> <strong>绝对不行！</strong> 这会直接违反 ODR，导致链接器报错（<code>multiple definition</code>）或未定义行为。</p>
</li>
</ol>
<h2 id="5-常见误解与错误"><a href="#5-常见误解与错误" class="headerlink" title="5. 常见误解与错误"></a>5. 常见误解与错误</h2><ol>
<li><p><strong>误解：把“类定义”与“成员函数定义”混为一谈。</strong></p>
<ul>
<li><strong>错误：</strong> 认为 <code>class MyClass { /* ... */ };</code> 是声明，而把所有定义都放在 <code>.cpp</code>。</li>
<li><strong>正确：</strong> <code>class MyClass { /* ... */ };</code> 是<strong>类类型本身的定义</strong>，它必须放在头文件中。而其<strong>成员函数的具体实现（定义）</strong>则通常放在 <code>.cpp</code> 文件中（除了 <code>inline</code> 函数）。</li>
</ul>
</li>
<li><p><strong>误解：认为 <code>header guard</code> 只是为了美观，或只对宏有效。</strong></p>
<ul>
<li><strong>错误：</strong> 不加 <code>header guard</code>。</li>
<li><strong>正确：</strong> <code>header guard</code> 对于防止类定义、<code>inline</code> 函数定义、<code>typedef</code>、<code>enum class</code> 定义等在同一翻译单元中重复包含至关重要，否则会导致编译错误。</li>
</ul>
</li>
<li><p><strong>误解：尝试在多个 <code>.cpp</code> 文件中定义同一个非 <code>inline</code> 函数。</strong></p>
<ul>
<li><strong>错误：</strong> 在 <code>file1.cpp</code> 和 <code>file2.cpp</code> 中都写 <code>void MyClass::doSomething() { /* ... */ }</code>。</li>
<li><strong>正确：</strong> 这是严重的 ODR 违规。一个非 <code>inline</code> 函数的定义在整个程序中只能出现一次。如果需要不同的行为，请使用多态、策略模式等 C++ 特性，而不是重复定义。</li>
</ul>
</li>
<li><p><strong>误解：在头文件中定义非 <code>inline</code> 的全局变量或普通函数。</strong></p>
<ul>
<li><strong>错误：</strong> 在 <code>MyHeader.h</code> 中写 <code>int global_counter = 0;</code> 或 <code>void utility_func() { /* ... */ }</code>。</li>
<li><strong>正确：</strong> 如果这个头文件被多个 <code>.cpp</code> 文件包含，每个 <code>.cpp</code> 文件都会生成一份 <code>global_counter</code> 和 <code>utility_func</code> 的定义，导致链接错误（<code>multiple definition</code>）。<ul>
<li>全局变量应在头文件中用 <code>extern</code> 声明，在且仅在一个 <code>.cpp</code> 文件中定义。</li>
<li>普通函数应在头文件中声明，在且仅在一个 <code>.cpp</code> 文件中定义。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="6-编码练习"><a href="#6-编码练习" class="headerlink" title="6. 编码练习"></a>6. 编码练习</h2><p>现在，轮到您了！请完成以下编码练习。您的任务是修复一个存在 ODR 违规的代码库。</p>
<p><strong>场景：</strong> 你接手了一个小项目，其中包含一个用于表示 2D 点的 <code>Point</code> 类。但是，代码组织存在问题，导致无法编译。</p>
<p><strong>您的任务：</strong></p>
<ol>
<li><strong>分析错误：</strong> 找出当前代码存在的问题。</li>
<li><strong>重构代码：</strong> 遵循我们今天学习的 C++ 最佳实践：<ul>
<li>将<strong>类的定义</strong>（<code>class Point { ... };</code> 结构）放在头文件中。</li>
<li>将<strong>类的非 <code>inline</code> 成员函数的定义（实现）</strong>放在源文件中。</li>
<li>确保头文件有<strong>头文件保护</strong>。</li>
<li><code>main</code> 函数所在的 <code>.cpp</code> 文件和实现文件都正确地包含必要的头文件。</li>
</ul>
</li>
<li><strong>填写代码：</strong> 在下面的 <code>point.h</code> 和 <code>point.cpp</code> 中填写缺失的代码，使 <code>main.cpp</code> 能够成功编译并运行。</li>
</ol>
<hr>
<p><strong>当前文件结构 (存在问题):</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── src&#x2F;</span><br><span class="line">│   ├── point.h</span><br><span class="line">│   ├── point.cpp</span><br><span class="line">│   └── main.cpp</span><br></pre></td></tr></table></figure></div>
<p><strong><code>src/point.h</code></strong> (请补充完整)<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 添加头文件保护</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在这里定义 Point 类。</span></span><br><span class="line"><span class="comment">// 它应该有私有的 x 和 y (int 类型) 成员变量。</span></span><br><span class="line"><span class="comment">// 它应该有一个构造函数 Point(int x_val, int y_val)。</span></span><br><span class="line"><span class="comment">// 它应该有一个公有的成员函数 void print() const;</span></span><br><span class="line"><span class="comment">// 它应该有一个公有的成员函数 int get_x() const;</span></span><br><span class="line"><span class="comment">// 它应该有一个公有的成员函数 int get_y() const;</span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>src/point.cpp</code></strong> (请补充完整)<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 包含必要的头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在这里实现 Point 类的构造函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在这里实现 Point 类的 print() 成员函数。</span></span><br><span class="line"><span class="comment">// print() 函数应该打印点的坐标，例如 "Point: (x, y)"。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在这里实现 Point 类的 get_x() 成员函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在这里实现 Point 类的 get_y() 成员函数。</span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>src/main.cpp</code></strong> (无需修改)<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span> <span class="comment">// 包含 Point 类的定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>; <span class="comment">// 创建一个 Point 对象</span></span><br><span class="line">    p1.print();       <span class="comment">// 打印点的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.x: "</span> &lt;&lt; p1.get_x() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.y: "</span> &lt;&lt; p1.get_y() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">5</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">    p2.print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>请在您的回复中提供您填充后的 <code>point.h</code> 和 <code>point.cpp</code> 代码。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a><a class="post-meta__tags" href="/tags/Developer/">Developer    </a><a class="post-meta__tags" href="/tags/Definition/">Definition    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/30-resources/coding/python/Pandas_Basic_Command_Quick_Check_Table/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202104250.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Pandas_Basic_Command_Quick_Check_Table</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/30-resources/coding/python/Pandas_10_sets_of_exercises/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202104250.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Pandas_10_sets_of_exercises</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/256 - cpp decltype(auto)/" title="256 - cpp decltype(auto)"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">256 - cpp decltype(auto)</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/277 - IDE 创建 cpp 类方法/" title="277 - IDE 创建 cpp 类方法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">277 - IDE 创建 cpp 类方法</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/276 - Class across multiple files/" title="276 - Class across multiple files"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">276 - Class across multiple files</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/322 - Different Type Members/" title="322 - Different Type Members"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">322 - Different Type Members</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/328 - cpp命名空间/" title="328 - cpp命名空间"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">328 - cpp命名空间</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/330 - cpp 默认全局命名空间与作用域运算符/" title="330 - cpp 默认全局命名空间与作用域运算符"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">330 - cpp 默认全局命名空间与作用域运算符</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>