<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>343 - cpp链接属性翻转 | Bear's dream</title><meta name="description" content="343 - cpp链接属性翻转"><meta name="keywords" content="Cpp,Coding,Tutorial,Development"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="343 - cpp链接属性翻转"><meta name="twitter:description" content="343 - cpp链接属性翻转"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="343 - cpp链接属性翻转"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/343%20-%20cpp%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7%E7%BF%BB%E8%BD%AC/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="343 - cpp链接属性翻转"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/343%20-%20cpp%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7%E7%BF%BB%E8%BD%AC/"><link rel="prev" title="Jupyter correct workflow" href="https://yxiong.org/2025/06/08/30-resources/coding/python/Jupyter%20correct%20workflow/"><link rel="next" title="numpy_advanced_command_quick_lookup_table" href="https://yxiong.org/2025/06/08/30-resources/coding/python/numpy_advanced_command_quick_lookup_table/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">152</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#342-C-链接属性翻转"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">342 - C++链接属性翻转</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-标题与概要"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">1. 标题与概要</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-详细解释"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">2. 详细解释</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-将内部链接翻转为外部链接"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">(1) 将内部链接翻转为外部链接</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-将外部链接翻转为内部链接"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">(2) 将外部链接翻转为内部链接</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-常见误解或易犯错误"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">5. 常见误解或易犯错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-编码练习"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">6. 编码练习</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#342-C-链接属性翻转"><span class="toc-number">1.</span> <span class="toc-text">342 - C++链接属性翻转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-标题与概要"><span class="toc-number">1.3.</span> <span class="toc-text">1. 标题与概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-详细解释"><span class="toc-number">1.4.</span> <span class="toc-text">2. 详细解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-将内部链接翻转为外部链接"><span class="toc-number">1.4.1.</span> <span class="toc-text">(1) 将内部链接翻转为外部链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-将外部链接翻转为内部链接"><span class="toc-number">1.4.2.</span> <span class="toc-text">(2) 将外部链接翻转为内部链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-代码示例"><span class="toc-number">1.5.</span> <span class="toc-text">3. 代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc-number">1.6.</span> <span class="toc-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见误解或易犯错误"><span class="toc-number">1.7.</span> <span class="toc-text">5. 常见误解或易犯错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-编码练习"><span class="toc-number">1.8.</span> <span class="toc-text">6. 编码练习</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">343 - cpp链接属性翻转</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/343%20-%20cpp%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7%E7%BF%BB%E8%BD%AC/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/343%20-%20cpp%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7%E7%BF%BB%E8%BD%AC/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="342-C-链接属性翻转"><a href="#342-C-链接属性翻转" class="headerlink" title="342 - C++链接属性翻转"></a>342 - C++链接属性翻转</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to see how we can flip linkage properties associated with names in ourC plus plus program.For example, if something had internal linkage, we can change it to have external linkage or the reverse.Here we have a simple program.We have our distance variable.It is a constant variable.So by default it’s going to have internal linkage, but we can change it to have external linkage byputting the external keyword in front.And when we want to use it in a separate translation unit, we are also going to prefix it with theexternal keyword.I realize this is a little bit confusing, but it is possible to do this.When we set up our constant variable like this, what we have here is going to be a declaration forthe variable we had in the main CPP file.And if we try to print it out, for example, here we are printing the distance.This is going to be accessing the variable.We have in the main function.It’s not going to be a separate variable.So this is how you can do this.This is an example of how you can take something that had internal linkage and change it to have externallinkage and you can do this.Another thing we’re going to see is how we can take something that had external linkage like a functionhere.For example, the print distance function here has external linkage by default or the other.Some function here we want to change one of these guys to have internal linkage.And the way to do that you prefix that thing with the static keyword.Okay, so we can do something like this.For example, for the function, some function here, we can prefix it with the static keyword and thisis going to mark it as an internal function to this translation unit here.If you try to call it from another translation unit, you’re going to get a compiler error because nowit will be limited to this translation unit where it is defined.Another way to do this is to wrap the function or the name that you want to have internal linkage inan anonymous namespace like we do here.If we do this, this function here will only be accessible from the translation unit where it was declared.So we have two techniques here.We can take something that had internal linkage and mark it to have external linkage.And to do that we just prefix that with the external keyword as we have seen before.Or we can take something that has external linkage and change it to have internal linkage by prefacingthat with the static keyword or wrapping that in an anonymous namespace like we see here.Now that you know this, we’re going to head over to Visual Studio code and play with this a littlemore.Okay.Here we are in our working folder.The current project is flipping linkage.We’re going to grab the template files like we always do.We’re going to put them in place and we are going to open this in Visual Studio code by dragging anddropping here.This is going to give us our main CPP file and we can start setting up things.The first thing we want to do is to turn something from internal linkage to external linkage as we seehere.And a good example of this is a const variable.We’re going to do const and that’s going to be a double variable.The name is going to be distance and we’re going to put in a distance here.You can put in whatever you want, but the main message here is that this is a constant global variable.So it’s going to have internal linkage by default.But we want this guy to be used in other translation units.For example, if we set up another file, we’re going to do that.We’re going to call this some other file dot CPP.We’re going to go in and we want to have access to this constant here and use it in our program.The way to do this is really simple.You prefix whatever you want to have external linkage with the external keyword here.And once you want to use it, you go in whatever translation unit where you want to use it and you markit as external.You say external, you say the type of the variable.So it is conceivable and we’re going to say the name of the variable.It happens to be distance.And this is going to be a declaration for the variable we had in main.What we have here is both a declaration and a definition, but what we have in some other file is goingto be a declaration.It’s not a definition.The definition for this variable is in the main function.And notice that we were able to change the default behavior for linkage for global constant variables.Okay, now that we have this, we’re going to set up a function which is going to access this guy andwe’re going to let the function have external linkage because we want to call this from our main CPPfile.We are going to include Iostream here because we want to print some things.That’s why we.Have the squiggly lines here.You’re going to see they’re going to go away and we’re going to hop over in the main function and setup a declaration for the print distance function here so we can grab its signature here or its header,put that in the main function, and then we’re going to do whatever we did before to print what we havein the main function here and what we have in some other file dot cpp here I am going to hop over inthe main function and put in the code to do that because I don’t want to type all this.We’re going to print the distance in main, we’re going to see its distance and we’re going to printthe same thing from our other translation unit and we’re going to see that they actually are the samethings, because now our constant here has external linkage.And what we have in some other file is the same thing we had in our main CPP file here.And we are effectively changing from internal linkage to external linkage for this variable here.And this is really cool.So let’s build the program and show you that this is actually what we expect.Let’s see if the world is good, the world is good here.We can clear, but let’s bring up a terminal.First.We’re going to clear and run Rooster.You’re going to see that what we have in Main is 45.7.The address is what we see here.It ends in zero 50.And what we have in some other file is exactly the same thing, because now this constant has externallinkage and this is how you can change the linkage for your constant global variables to be externallinkage.If this happens to be making sense for your project.The other thing we’re going to see is how we can change from external linkage to internal linkage.And we know that functions have external linkage by default.So for example, if we have a function in our other translation unit, we’re going to make it not returnanything and it’s going to be called some other function.We can do this and it’s just going to say, Hello there, let’s do that.Okay, so this function has external linkage by default because that’s how C plus plus compilers wehave, we have external linkage here, but we wanted to change this to go from external linkage to internallinkage.So we want this function only usable inside this translation unit here.But before we do that, let’s make sure that this function is usable from the other translation unitHere.For example, we can put in its declaration.We’re going to say, what is it called?The name is some other function.So we’re going to grab the signature for this little guy here.We’re going to hop over in Main and we’re going to put in the declaration for this.This is a declaration, let’s say that to be super clear and we can call it in main, for example,we can go down and put a separator.This is going to do and we’re going to say some other function.That’s what it’s called.I think we have its name in our clipboard so we can take out the return type here and turn this intoa function call.This is going to work just fine.If we build and run the program, we’re going to see that the world is going to be good because thisguy has external linkage.We want to change the linkage of this guy.One way to do this is to prefix it with a static keyword, and at the moment you do this, the C plusplus compiler is going to look at this and note that this function can only be used or called from thistranslation unit here.Now, if we try to build our program, we’re going to see that we’re going to get a compiler error andthe compiler error is going to say undefined reference to some other function.We have this function and this translation unit here, but when the linker is going to look for it becauseof this call here, the compiler is going to say this function is only for use in this translation unit.You can’t call it from the main CPP file here, which is another translation unit.And we have effectively changed the linkage of this function from external to internal using this statickeyword here.This is what I want you to know, but this is not the only way to do this.Another way to do this is to wrap this function in an anonymous namespace.So if we go down here and say namespace and not give this namespace a name and we’re going to grab ourfunction here and move that inside our namespace here, we’re going to take out the static keyword.We’re going to see that we have the same effect here we’re going to build.And we are going to get an undefined reference to our function here because it is internal to this function.We have effectively changed from external linkage to internal linkage here.So we have seen two ways we can change the linkage.We can change from internal linkage to external linkage using the technique here, prefixing thingswith the external keyword and declaring them using the external keyword.This is going to tell the compiler that what we have in some other translation unit is just a declaration.We can also change from external linkage to internal linkage by prefixing what we want to set up withthe static keyword.Or we can wrap our name in an anonymous namespace and this is going to give it internal linkage andyou want to be able to use that thing from other translation units.For example, if we go into the main function and call some other function, this is not going to workand we have effectively changed the default behavior for linkage.This is really all I wanted you to see in this lecture, that you can change the linkage if you want,but don’t really overdo this because it’s going to make your code not easy to read and understand forother developers.Another thing is that the static keyword is really not welcome in modern C plus plus.If you happen to want to change from external linkage to internal linkage, wrapping your things insideunnamed or anonymous namespaces is the way to go in modern C plus plus.We are going to stop here in this lecture.In the next one, we’re going to learn about inline variables and functions.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，同学你好！很高兴能成为你的C++启蒙老师。别担心，C++虽然知识点多，但只要我们一步一个脚印，用正确的方法学习，你会发现它的魅力所在。</p>
<p>今天我们要学习的是C++中一个非常重要但有时又有点微妙的概念——<strong>链接属性 (linkage)</strong>，以及如何“翻转”它。</p>
<hr>
<h2 id="1-标题与概要"><a href="#1-标题与概要" class="headerlink" title="1. 标题与概要"></a>1. 标题与概要</h2><p><strong>标题：</strong> C++ 链接属性揭秘：轻松翻转内部与外部链接</p>
<p><strong>概要：</strong> 本节课我们将学习什么是C++中的链接属性，特别是内部链接 (internal linkage) 和外部链接 (external linkage)。我们将重点探讨如何使用 <code>extern</code> 关键字将默认具有内部链接的 <code>const</code> (常量) 全局变量改为外部链接，以及如何使用 <code>static</code> (静态) 关键字或匿名命名空间 (anonymous namespace) 将默认具有外部链接的函数改为内部链接。这将帮助我们更好地组织代码和控制符号 (symbol) 在不同编译单元 (translation unit) 间的可见性。</p>
<hr>
<h2 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h2><p>在我们开始之前，首先要理解几个核心概念：</p>
<ul>
<li><strong>符号 (Symbol)：</strong> 在编程中，符号通常指变量名、函数名等标识符。</li>
<li><strong>编译单元 (Translation Unit)：</strong> 简单来说，一个 <code>.cpp</code> 文件（以及它包含的所有头文件，经过预处理器处理后）通常被视为一个编译单元。编译器会分别编译每个编译单元，生成目标文件 (object file)。</li>
<li><strong>链接 (Linkage)：</strong> 链接是编译器和链接器用来确定一个标识符（如变量或函数名）在不同编译单元中是否指向同一个实体的规则。它决定了一个名称的“可见范围”。</li>
</ul>
<p>C++ 主要有两种链接属性：</p>
<ol>
<li><p><strong>内部链接 (Internal Linkage)：</strong></p>
<ul>
<li>具有内部链接的符号只在它自己所在的编译单元内可见。即使其他编译单元声明了同名的符号，它们也互不相关，是各自独立的存在。</li>
<li><strong>默认情况：</strong> <code>const</code> (常量) 和 <code>constexpr</code> (常量表达式) 全局变量，以及 <code>static</code> (静态) 全局变量和 <code>static</code> 函数（非类成员）默认具有内部链接。匿名命名空间中的所有符号也具有内部链接。</li>
</ul>
</li>
<li><p><strong>外部链接 (External Linkage)：</strong></p>
<ul>
<li>具有外部链接的符号可以在多个编译单元之间共享。也就是说，在一个编译单元中定义的外部链接符号，可以在其他编译单元中声明并使用，它们都指向同一个实体（同一块内存地址或同一个函数实现）。</li>
<li><strong>默认情况：</strong> 普通的全局变量（非<code>const</code>、非<code>static</code>）和普通函数（非<code>static</code>、非匿名命名空间内）默认具有外部链接。</li>
</ul>
</li>
</ol>
<p>现在，我们来看看如何“翻转”这些默认的链接属性。</p>
<h3 id="1-将内部链接翻转为外部链接"><a href="#1-将内部链接翻转为外部链接" class="headerlink" title="(1) 将内部链接翻转为外部链接"></a>(1) 将内部链接翻转为外部链接</h3><p>正如我们所说，<code>const</code> 全局变量默认具有内部链接。这意味着如果你在一个 <code>main.cpp</code> 文件中定义了一个 <code>const</code> 全局变量，例如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>; <span class="comment">// 默认内部链接</span></span><br></pre></td></tr></table></figure></div>
<p>那么在另一个 <code>other.cpp</code> 文件中，你无法直接访问到 <code>main.cpp</code> 中的这个 <code>PI</code>。如果你在 <code>other.cpp</code> 中也写 <code>const double PI = 3.14159;</code>，那么 <code>other.cpp</code> 会拥有一个自己的、独立的 <code>PI</code> 变量，它和 <code>main.cpp</code> 中的 <code>PI</code> 不是同一个。</p>
<p><strong>如何改变？使用 <code>extern</code> (外部) 关键字。</strong></p>
<p><code>extern</code> 关键字可以用来告诉编译器，某个变量或函数的定义在别处（可能在当前编译单元，也可能在其他编译单元）。</p>
<ul>
<li><p><strong>步骤一：在定义处使用 <code>extern</code></strong><br>当你想让一个 <code>const</code> 全局变量具有外部链接时，你需要在它的<strong>定义</strong>处使用 <code>extern</code> 关键字。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 const 全局变量，并使用 extern 显式声明其为外部链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> DISTANCE = <span class="number">45.7</span>; <span class="comment">// DISTANCE 现在具有外部链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个在 other.cpp 中定义的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_distance_from_other</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"In main.cpp: distance is "</span> &lt;&lt; DISTANCE</span><br><span class="line">              &lt;&lt; <span class="string">", address is "</span> &lt;&lt; &amp;DISTANCE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    print_distance_from_other();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里的 <code>extern const double DISTANCE = 45.7;</code> 是一个<strong>定义 (definition)</strong>，因为它分配了存储空间并提供了初始值。通过 <code>extern</code>，我们覆盖了 <code>const</code> 变量默认的内部链接行为，使其变为外部链接。</p>
</li>
<li><p><strong>步骤二：在其他编译单元使用 <code>extern</code> 进行声明</strong><br>在其他需要使用这个 <code>DISTANCE</code> 变量的编译单元中，你需要使用 <code>extern</code> 来<strong>声明 (declaration)</strong> 它。声明告诉编译器这个变量存在，并且具有外部链接，但定义在别处。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// other.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 main.cpp 中定义的 DISTANCE 变量</span></span><br><span class="line"><span class="comment">// 这个声明告诉编译器 DISTANCE 是一个在别处定义的 const double 类型变量</span></span><br><span class="line"><span class="comment">// 并且它具有外部链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> DISTANCE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_distance_from_other</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"In other.cpp: distance is "</span> &lt;&lt; DISTANCE</span><br><span class="line">              &lt;&lt; <span class="string">", address is "</span> &lt;&lt; &amp;DISTANCE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里的 <code>extern const double DISTANCE;</code> 是一个<strong>声明</strong>，它不分配内存，只是告诉编译器 <code>DISTANCE</code> 的类型和名称，并指明它是在其他地方定义的。</p>
</li>
</ul>
<p><strong>关键点：</strong><br>通过这种方式，<code>main.cpp</code> 和 <code>other.cpp</code> 中的 <code>DISTANCE</code> 指的是同一个变量。如果你打印它们的地址，会发现地址是相同的。这就实现了从内部链接到外部链接的翻转。</p>
<h3 id="2-将外部链接翻转为内部链接"><a href="#2-将外部链接翻转为内部链接" class="headerlink" title="(2) 将外部链接翻转为内部链接"></a>(2) 将外部链接翻转为内部链接</h3><p>默认情况下，普通函数（非成员函数）具有外部链接。这意味着如果你在一个 <code>helper.cpp</code> 中定义了一个函数，你可以在 <code>main.cpp</code> 中声明并调用它。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_external_function</span><span class="params">()</span> </span>&#123; <span class="comment">// 默认外部链接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello from some_external_function in helper.cpp!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明在 helper.cpp 中定义的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_external_function</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    some_external_function(); <span class="comment">// 可以正常调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>有时候，我们可能希望一个函数只在它自己定义的那个 <code>.cpp</code> 文件内部使用，不希望被其他编译单元意外地调用，或者为了避免与其他编译单元中可能存在的同名函数发生命名冲突。这时，我们就需要将它的外部链接改为内部链接。</p>
<p>有两种主要方法：</p>
<ul>
<li><p><strong>方法一：使用 <code>static</code> (静态) 关键字</strong><br>在函数定义前加上 <code>static</code> 关键字，可以将其链接属性改为内部链接。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">this_is_an_internal_function</span><span class="params">()</span> </span>&#123; <span class="comment">// 使用 static，变为内部链接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This function can only be called within helper.cpp"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_internal_from_helper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    this_is_an_internal_function(); <span class="comment">// 在 helper.cpp 内部可以调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>现在，如果你尝试在 <code>main.cpp</code> 中声明并调用 <code>this_is_an_internal_function()</code>：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="comment">// void this_is_an_internal_function(); // 尝试声明</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// this_is_an_internal_function(); // 尝试调用</span></span><br></pre></td></tr></table></figure></div>
<p>链接器在链接阶段会报错，因为它在 <code>main.cpp</code> 的编译单元找不到 <code>this_is_an_internal_function</code> 的定义（因为它在 <code>helper.cpp</code> 中是内部链接的，对外部不可见）。</p>
</li>
<li><p><strong>方法二：使用匿名命名空间 (Anonymous Namespace)</strong><br>匿名命名空间（也叫未命名命名空间）是一种更现代、更推荐的做法，用来限制符号的链接为内部链接。所有在匿名命名空间中声明的符号（变量、函数、类等）都自动具有内部链接。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// 这是一个匿名命名空间</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">another_internal_function</span><span class="params">()</span> </span>&#123; <span class="comment">// 自动具有内部链接</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This function (in anonymous namespace) is also internal to helper.cpp"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 匿名命名空间结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_another_internal_from_helper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    another_internal_function(); <span class="comment">// 在 helper.cpp 内部可以调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>效果与使用 <code>static</code> 关键字类似。<code>another_internal_function</code> 也无法从 <code>main.cpp</code> 或其他编译单元中直接访问。</p>
</li>
</ul>
<p><strong>为什么匿名命名空间更好？</strong><br><code>static</code> 关键字在C++中有多种含义（例如，静态局部变量、静态成员变量、静态成员函数），这有时会引起混淆。匿名命名空间的目的非常明确：提供内部链接。因此，在现代C++中，当需要将非成员函数或全局变量限制在当前编译单元时，推荐使用匿名命名空间。</p>
<p><strong>注意：</strong></p>
<ul>
<li>不要过度使用链接翻转技术。默认的链接行为通常是合理的。仅在确实需要控制符号可见性或解决命名冲突时才使用。</li>
<li><code>static</code> 关键字对于类成员（变量或函数）有不同的含义，与链接属性无关，而是与类的实例或类型本身相关联。我们这里讨论的是全局作用域或命名空间作用域下的 <code>static</code>。</li>
</ul>
<hr>
<h2 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h2><p>我们将整合上面的例子，创建两个文件：<code>main.cpp</code> 和 <code>utils.cpp</code>。</p>
<p><strong><code>utils.cpp</code> 文件:</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. const 全局变量，默认内部链接，我们用 extern 把它变成外部链接</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> SHARED_CONSTANT_VALUE = <span class="number">9.81</span>; <span class="comment">// 定义，并赋予外部链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 一个普通函数，默认外部链接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">externally_linked_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"utils.cpp: Called externally_linked_function."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"utils.cpp: Accessing SHARED_CONSTANT_VALUE: "</span> &lt;&lt; SHARED_CONSTANT_VALUE</span><br><span class="line">              &lt;&lt; <span class="string">" (Address: "</span> &lt;&lt; &amp;SHARED_CONSTANT_VALUE &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用 static 将函数改为内部链接</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internal_via_static</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"utils.cpp: Called internal_via_static. This shouldn't be callable from main.cpp directly."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 使用匿名命名空间将函数改为内部链接</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internal_via_anonymous_namespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"utils.cpp: Called internal_via_anonymous_namespace. Also not directly callable from main.cpp."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 一个外部链接的函数，它会调用内部链接的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_internal_functions_from_utils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"utils.cpp: Going to call my internal functions."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    internal_via_static();</span><br><span class="line">    internal_via_anonymous_namespace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>main.cpp</code> 文件:</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 声明在 utils.cpp 中定义的具有外部链接的 const 变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> SHARED_CONSTANT_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 声明在 utils.cpp 中定义的具有外部链接的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">externally_linked_function</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 声明在 utils.cpp 中定义的用于调用其内部函数的外部链接函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_internal_functions_from_utils</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这两行是尝试声明内部链接的函数，会导致链接错误</span></span><br><span class="line"><span class="comment">// static void internal_via_static(); // 错误: 'internal_via_static' has internal linkage and is not defined</span></span><br><span class="line"><span class="comment">// namespace &#123; void internal_via_anonymous_namespace(); &#125; // 更复杂的错误，本质也是找不到</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main.cpp: Accessing SHARED_CONSTANT_VALUE: "</span> &lt;&lt; SHARED_CONSTANT_VALUE</span><br><span class="line">              &lt;&lt; <span class="string">" (Address: "</span> &lt;&lt; &amp;SHARED_CONSTANT_VALUE &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    externally_linked_function();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    call_internal_functions_from_utils();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试调用内部链接的函数 (如果取消注释下面的声明和调用，会导致链接错误)</span></span><br><span class="line">    <span class="comment">// internal_via_static();</span></span><br><span class="line">    <span class="comment">// internal_via_anonymous_namespace();</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "If you see this, the direct calls to internal functions somehow worked (they shouldn't)." &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main.cpp: Program finished."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong>如何编译和运行 (以 g++ 为例):</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp utils.cpp -o program</span><br><span class="line">./program</span><br></pre></td></tr></table></figure></div></p>
<p><strong>预期输出:</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main.cpp: Accessing SHARED_CONSTANT_VALUE: 9.81 (Address: 0x........)</span><br><span class="line"></span><br><span class="line">utils.cpp: Called externally_linked_function.</span><br><span class="line">utils.cpp: Accessing SHARED_CONSTANT_VALUE: 9.81 (Address: 0x........) &#x2F;&#x2F; 注意地址和 main.cpp 中的相同</span><br><span class="line"></span><br><span class="line">utils.cpp: Going to call my internal functions.</span><br><span class="line">utils.cpp: Called internal_via_static. This shouldn&#39;t be callable from main.cpp directly.</span><br><span class="line">utils.cpp: Called internal_via_anonymous_namespace. Also not directly callable from main.cpp.</span><br><span class="line"></span><br><span class="line">main.cpp: Program finished.</span><br></pre></td></tr></table></figure></div><br>你会注意到 <code>SHARED_CONSTANT_VALUE</code> 在 <code>main.cpp</code> 和 <code>utils.cpp</code> 中的地址是相同的，证明它们是同一个变量。而 <code>internal_via_static</code> 和 <code>internal_via_anonymous_namespace</code> 无法在 <code>main.cpp</code> 中直接调用。</p>
<hr>
<h2 id="4-QA-闪卡-QA-Flash-Cards"><a href="#4-QA-闪卡-QA-Flash-Cards" class="headerlink" title="4. QA 闪卡 (QA Flash Cards)"></a>4. QA 闪卡 (QA Flash Cards)</h2><ol>
<li><p><strong>问：</strong> <code>const</code> 全局变量默认具有什么链接类型？<br><strong>答：</strong> 内部链接 (Internal linkage)。</p>
</li>
<li><p><strong>问：</strong> 如何将一个 <code>const</code> 全局变量的链接类型从内部改为外部？<br><strong>答：</strong> 在其定义处使用 <code>extern</code> 关键字 (e.g., <code>extern const int VAL = 10;</code>)，并在其他需要使用它的编译单元中也使用 <code>extern</code> 进行声明 (e.g., <code>extern const int VAL;</code>)。</p>
</li>
<li><p><strong>问：</strong> 普通的非成员函数默认具有什么链接类型？<br><strong>答：</strong> 外部链接 (External linkage)。</p>
</li>
<li><p><strong>问：</strong> 有哪两种主要方法可以将一个默认具有外部链接的函数改为内部链接？<br><strong>答：</strong> 1. 在函数定义前加上 <code>static</code> 关键字。 2. 将函数定义在一个匿名命名空间中。</p>
</li>
<li><p><strong>问：</strong> 在现代C++中，如果想将一个函数改为内部链接，更推荐使用 <code>static</code> 还是匿名命名空间？为什么？<br><strong>答：</strong> 推荐使用匿名命名空间。因为 <code>static</code> 关键字在C++中有多种含义，可能引起混淆，而匿名命名空间的意图更清晰，就是为了提供内部链接。</p>
</li>
<li><p><strong>问：</strong> 什么是编译单元 (Translation Unit)？<br><strong>答：</strong> 通常指一个 <code>.cpp</code> 源文件及其包含的所有头文件，在经过预处理器处理后形成的一个单元，编译器会独立编译它。</p>
</li>
</ol>
<hr>
<h2 id="5-常见误解或易犯错误"><a href="#5-常见误解或易犯错误" class="headerlink" title="5. 常见误解或易犯错误"></a>5. 常见误解或易犯错误</h2><ol>
<li><p><strong><code>extern</code> 的滥用与误解：</strong></p>
<ul>
<li><strong>错误：</strong> 在多个 <code>.cpp</code> 文件中都写 <code>extern const int MY_CONST = 100;</code>。这会导致多重定义 (multiple definition) 链接错误。<code>extern</code> 变量的<strong>定义</strong>（带初始化的）只能在一个编译单元中出现。其他编译单元应该只用 <code>extern const int MY_CONST;</code> 进行声明。</li>
<li><strong>混淆声明与定义：</strong> <code>extern int x;</code> 是声明。<code>int x;</code> 在全局作用域是定义（如果之前没有声明过，则为暂定性定义，若链接时无其他定义，则为0初始化）。<code>extern int x = 10;</code> 是定义。</li>
</ul>
</li>
<li><p><strong><code>static</code> 关键字的多义性：</strong></p>
<ul>
<li><strong>误解：</strong> 认为函数内的 <code>static</code> 局部变量也与链接属性有关。函数内的 <code>static</code> 变量表示它具有静态存储期（生命周期贯穿整个程序），并且只初始化一次，它的作用域仍然是局部的，与链接属性无关。我们这里讨论的是全局或命名空间作用域的 <code>static</code> 对链接属性的影响。</li>
</ul>
</li>
<li><p><strong>忘记在其他文件中使用 <code>extern</code> 声明：</strong></p>
<ul>
<li>如果在 <code>file1.cpp</code> 中定义了 <code>extern const int VAL = 5;</code>，但在 <code>file2.cpp</code> 中直接写 <code>const int VAL = 10;</code>（没有 <code>extern</code>），那么 <code>file2.cpp</code> 会认为这是一个新的、独立的、具有内部链接的 <code>VAL</code>，而不是引用 <code>file1.cpp</code> 中的那一个。如果 <code>file2.cpp</code> 中尝试使用 <code>VAL</code> 但没有自己的定义也没有 <code>extern</code> 声明，则会报未定义符号错误。</li>
</ul>
</li>
<li><p><strong>无法区分编译器错误和链接器错误：</strong></p>
<ul>
<li>链接属性问题通常导致<strong>链接器错误</strong> (linker error)，例如 “undefined reference to <code>symbol_name</code>“ 或 “multiple definition of <code>symbol_name</code>“。而语法错误、类型不匹配等通常是<strong>编译器错误</strong> (compiler error)。</li>
</ul>
</li>
<li><p><strong>不必要的链接翻转：</strong></p>
<ul>
<li>新手可能因为刚学了就想用，但实际上很多时候默认的链接属性就是最合适的。过度翻转链接属性会使代码可读性变差，更难维护。</li>
</ul>
</li>
<li><p><strong>对匿名命名空间的误解：</strong></p>
<ul>
<li>认为匿名命名空间只是“隐藏”了名字。实际上，它确实为其中的符号提供了内部链接，使得这些符号在不同编译单元中即使同名也是独立的。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-编码练习"><a href="#6-编码练习" class="headerlink" title="6. 编码练习"></a>6. 编码练习</h2><p>现在，请你来动手实践一下。这里有两个文件，<code>exercise_main.cpp</code> 和 <code>exercise_helper.cpp</code>。你的任务是补全代码，使得程序能够按预期工作。</p>
<p><strong><code>exercise_helper.cpp</code>:</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 1: 定义一个名为 'MAX_USERS' 的 const int 类型的全局常量，</span></span><br><span class="line"><span class="comment">//         其值为 100。请确保它具有 EXTERNAL 链接，以便 main.cpp 可以访问。</span></span><br><span class="line"><span class="comment">// _______ const int MAX_USERS = 100;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 2: 定义一个名为 'print_helper_message' 的函数。</span></span><br><span class="line"><span class="comment">//         这个函数不需要参数，返回 void。</span></span><br><span class="line"><span class="comment">//         它应该打印 "Message from exercise_helper.cpp!" 到控制台。</span></span><br><span class="line"><span class="comment">//         这个函数应该具有 EXTERNAL 链接 (默认即可)。</span></span><br><span class="line"><span class="comment">// void print_helper_message() &#123;</span></span><br><span class="line"><span class="comment">//     // ... 实现打印 ...</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 3: 定义一个名为 'internal_calculation' 的函数。</span></span><br><span class="line"><span class="comment">//         这个函数接受两个 int 参数，返回它们的和 (int)。</span></span><br><span class="line"><span class="comment">//         请确保这个函数具有 INTERNAL 链接。你可以选择使用 static 或匿名命名空间。</span></span><br><span class="line"><span class="comment">// _______ int internal_calculation(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">//     // ... 返回 a + b ...</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个已提供的外部链接函数，它会调用上面的内部链接函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perform_calculation_and_print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"exercise_helper.cpp: Performing internal calculation..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">// 替换为对 internal_calculation 的调用</span></span><br><span class="line">    <span class="comment">// TODO 4: 在这里调用你定义的 internal_calculation 函数，并将结果赋值给 result 变量。</span></span><br><span class="line">    <span class="comment">// result = internal_calculation(x, y);</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"exercise_helper.cpp: Calculation result: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>exercise_main.cpp</code>:</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 1: 声明在 exercise_helper.cpp 中定义的 'MAX_USERS' 常量。</span></span><br><span class="line"><span class="comment">// _______ const int MAX_USERS;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 2: 声明在 exercise_helper.cpp 中定义的 'print_helper_message' 函数。</span></span><br><span class="line"><span class="comment">// _______ void print_helper_message();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明在 exercise_helper.cpp 中定义的 'perform_calculation_and_print' 函数。</span></span><br><span class="line"><span class="comment">// (这个声明已经为你提供)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perform_calculation_and_print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 3: (思考题) 你能否在这里声明并成功调用 'internal_calculation' 函数？为什么？</span></span><br><span class="line"><span class="comment">// (不需要写代码，在心里回答或写注释回答即可)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"exercise_main.cpp: Program started."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 TODO 1 和 TODO 2 中声明的内容</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "exercise_main.cpp: MAX_USERS = " &lt;&lt; MAX_USERS &lt;&lt; std::endl; // 取消此行注释</span></span><br><span class="line">    <span class="comment">// print_helper_message(); // 取消此行注释</span></span><br><span class="line"></span><br><span class="line">    perform_calculation_and_print(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试调用 internal_calculation (如果直接调用会怎样？)</span></span><br><span class="line">    <span class="comment">// int r = internal_calculation(5,5); // 这行代码如果取消注释，应该会导致链接错误</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"exercise_main.cpp: Program finished."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>你需要将 <code>_______</code> 替换为正确的关键字，并补全函数体和调用。完成后，尝试编译这两个文件并运行程序。</p>
<p>等你完成后，把你的 <code>exercise_helper.cpp</code> 和 <code>exercise_main.cpp</code> 的代码发给我，我会帮你批改并给出解答和进一步的建议。加油！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Tutorial/">Tutorial    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/30-resources/coding/python/Jupyter%20correct%20workflow/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Jupyter correct workflow</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/30-resources/coding/python/numpy_advanced_command_quick_lookup_table/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202104250.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>numpy_advanced_command_quick_lookup_table</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/diff between constexpr and define/" title="diff between constexpr and define"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">diff between constexpr and define</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/257 - cpp Default template arguments/" title="257 - cpp Default template arguments"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">257 - cpp Default template arguments</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/262 - constexpr if/" title="262 - constexpr if"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">262 - constexpr if</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/279 - cpp析构函数：对象销毁时的内存释放/" title="279 - cpp析构函数：对象销毁时的内存释放"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">279 - cpp析构函数：对象销毁时的内存释放</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/256 - cpp decltype(auto)/" title="256 - cpp decltype(auto)"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">256 - cpp decltype(auto)</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/282 - cpp结构体与类的区别和用法/" title="282 - cpp结构体与类的区别和用法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">282 - cpp结构体与类的区别和用法</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>