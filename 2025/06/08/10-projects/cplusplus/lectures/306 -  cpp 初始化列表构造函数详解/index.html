<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>306 -  cpp 初始化列表构造函数详解 | Bear's dream</title><meta name="description" content="306 -  cpp 初始化列表构造函数详解"><meta name="keywords" content="Cpp,Coding,Tutorial,Class,Constructor"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="306 -  cpp 初始化列表构造函数详解"><meta name="twitter:description" content="306 -  cpp 初始化列表构造函数详解"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="306 -  cpp 初始化列表构造函数详解"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/306%20-%20%20cpp%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="306 -  cpp 初始化列表构造函数详解"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/306%20-%20%20cpp%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><link rel="prev" title="312 - cpp 友元函数详解" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/312%20-%20cpp%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><link rel="next" title="319 - Class Const" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/319%20-%20Class%20Const/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">178</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">160</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">23</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-初始化列表构造函数详解"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">## C++ 初始化列表构造函数详解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-聚合体的大括号初始化与自定义初始化列表构造函数（Initializer-List-Constructors-for-Aggregates）"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">C++ 聚合体的大括号初始化与自定义初始化列表构造函数（Initializer List Constructors for Aggregates）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-什么是聚合体（Aggregates）？以及为什么需要初始化列表构造函数？"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">1. 什么是聚合体（Aggregates）？以及为什么需要初始化列表构造函数？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-自定义初始化列表构造函数：std-initializer-list"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">2. 自定义初始化列表构造函数：std::initializer_list</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-如何访问-std-initializer-list-中的元素？"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">3. 如何访问 std::initializer_list 中的元素？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-QA-闪存卡（QA-Flash-Cards）"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">4. QA 闪存卡（QA Flash Cards）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-常见误解与错误（Common-Misunderstandings-or-Mistakes）"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">5. 常见误解与错误（Common Misunderstandings or Mistakes）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-编程练习（Coding-Exercise）"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">6. 编程练习（Coding Exercise）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-评估用户解决方案并给出实际答案和解释"><span class="toc_mobile_items-number">2.9.</span> <span class="toc_mobile_items-text">7. 评估用户解决方案并给出实际答案和解释</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解决方案评分"><span class="toc_mobile_items-number">2.9.1.</span> <span class="toc_mobile_items-text">解决方案评分</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实际答案和解释"><span class="toc_mobile_items-number">2.9.2.</span> <span class="toc_mobile_items-text">实际答案和解释</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-扩展问题和建议（Extended-Questions-and-Suggestions）"><span class="toc_mobile_items-number">2.10.</span> <span class="toc_mobile_items-text">8. 扩展问题和建议（Extended Questions and Suggestions）</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-初始化列表构造函数详解"><span class="toc-number">1.</span> <span class="toc-text">## C++ 初始化列表构造函数详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-聚合体的大括号初始化与自定义初始化列表构造函数（Initializer-List-Constructors-for-Aggregates）"><span class="toc-number">2.</span> <span class="toc-text">C++ 聚合体的大括号初始化与自定义初始化列表构造函数（Initializer List Constructors for Aggregates）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是聚合体（Aggregates）？以及为什么需要初始化列表构造函数？"><span class="toc-number">2.1.</span> <span class="toc-text">1. 什么是聚合体（Aggregates）？以及为什么需要初始化列表构造函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-自定义初始化列表构造函数：std-initializer-list"><span class="toc-number">2.2.</span> <span class="toc-text">2. 自定义初始化列表构造函数：std::initializer_list</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-如何访问-std-initializer-list-中的元素？"><span class="toc-number">2.3.</span> <span class="toc-text">3. 如何访问 std::initializer_list 中的元素？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-QA-闪存卡（QA-Flash-Cards）"><span class="toc-number">2.4.</span> <span class="toc-text">4. QA 闪存卡（QA Flash Cards）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见误解与错误（Common-Misunderstandings-or-Mistakes）"><span class="toc-number">2.5.</span> <span class="toc-text">5. 常见误解与错误（Common Misunderstandings or Mistakes）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-编程练习（Coding-Exercise）"><span class="toc-number">2.6.</span> <span class="toc-text">6. 编程练习（Coding Exercise）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">2.7.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">2.8.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-评估用户解决方案并给出实际答案和解释"><span class="toc-number">2.9.</span> <span class="toc-text">7. 评估用户解决方案并给出实际答案和解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方案评分"><span class="toc-number">2.9.1.</span> <span class="toc-text">解决方案评分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实际答案和解释"><span class="toc-number">2.9.2.</span> <span class="toc-text">实际答案和解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-扩展问题和建议（Extended-Questions-and-Suggestions）"><span class="toc-number">2.10.</span> <span class="toc-text">8. 扩展问题和建议（Extended Questions and Suggestions）</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">306 -  cpp 初始化列表构造函数详解</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/306%20-%20%20cpp%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/306%20-%20%20cpp%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="C-初始化列表构造函数详解"><a href="#C-初始化列表构造函数详解" class="headerlink" title="## C++ 初始化列表构造函数详解"></a>## C++ 初始化列表构造函数详解</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about initializer list constructors, and these are constructorsthat are used to initialize what we call aggregates in C plus plus and aggregates are really some kindsof containers and they are special containers in C plus plus and this special kind of containers thatcan contain stuff.For example, you see that we have an outer container which contains some little boxes in here and itis a representation of an aggregate in C plus plus.It is basically something that is going to aggregate a lot of little things together, but it’s notevery container in C plus plus there is a nuanced definition of aggregates, but for now you can thinkof an aggregate as just a container of things.And from the containers we have seen so far, an array is an aggregate and a struct which only has publicmember variables is also an aggregate.So all these aggregates can use a unified syntax to initialize them.For example, we can use the curly braces syntax here to initialize and put data in our container here.And when the compiler sees your initializer here, it knows how to generate the tools it will use toput this data in your container here.So, for example, it might choose to put one in this little box.It might choose to put two in this little box.It might choose to put three in this little box.It might choose to put four in this little box.And whatever we have after this is going to be put in sequential boxes that we have in our box containerhere.This is what a list initializer constructor is going to do.It’s going to be used by the compiler to take the data from our initializer here and put that in ouraggregate compound type.And at this point in the course we really know about to aggregate compound types, we have seen thatstruct is one type of aggregate and an array is also another type of aggregate.So we’re going to see how we can use an initializer list constructor with a struct because an arrayis really a built in type.We can’t mess with that and set up another way to initialize it.So we’re going to do this only for the struct in this course to let you learn about initializer listconstructors.Okay.So here is a simple struct we’re going to use.It’s going to be a point struct.It is going to be modeling a point.Inside we have two member variables.We have double X and double y and they are going to be public because we are using a structure.Members of a struct are public by default here.So we can set up a syntax like this to try and initialize this little guy and we’re going to see thatthis syntax is going to work even if we didn’t do anything to make this work.And what the compiler is going to do behind the scenes, it’s going to generate an initializer listconstructor and it’s going to use it to take the data from our curly braces here and store that in ourpoint object.So it is basically to take the first parameter here and store that in X and it is going to take thesecond parameter and store that in Y here.But sometimes you need to change the behavior of this initializer list constructors and we’re goingto see how we can set up our own and let to do exactly what we want.And here is a simple example of how you can do that in initializer List constructor is going to takethis form here.It’s going to have the name of the constructor, which is the name of the class.But our parameter list is going to take an STD initializer list, which is going to be an instance ofa template class.We haven’t really learned about class templates, but please think about STD initializer list here asan instance of a class template and you see that we initialize this for double because we know thatour class is going to contain double member variables.So these two things have to match the type of your member variables, has to match the type that youpass in your STD initializer list.Instance.Once you have this initializer list parameter, the compiler is going to take what you call in yourmain function and use that to create an STD initializer list object.So what is going to basically happen is if we issue a call like this, the compiler is going to noticethat we are using an initializer list here and it is going to grab whatever we have here and it is goingto call our initializer List constructor.So it is going to create a parameter that it is going to pass to that constructor.And the parameter happens to be an STD initializer list, which is going to be an instance for doubletype.So this is what we’re going to have here.So the compiler is so the compiler is going to take the first parameter and put that in the first spotfor our initializer list here.And it’s going to take the second parameter.And put that in the second spot in our STD initializer list.Instance object here.Okay, so now that we have the data, we need to grab the data and use that in our object and we’regoing to use a concept we haven’t really learnt about to do this.We’re going to use what we call iterators, but we haven’t learnt about them because we don’t have enoughtools to understand them fully yet.But I am going to try and help you understand this.Think of the begin function We call on our initializer list here as a function that is going to giveyou the starting pointer in our collection.So Begin is basically going to be a pointer to the first element in our initializer list here, andend is going to be a pointer past the last element in our initializer list here.So let’s say that Begin is going to be a pointer to the start of our list.It’s going to be a pointer to the first element in the list and end is going to be a pointer past thelast element in our initializer list here.So it’s not going to point to 45.3 here.It’s going to point past the last element.So it’s going to point to the spot past the last element in our initializer list here.So hopefully you have an understanding of what begin and end here are.So we’re going to use this information to our advantage in this loop here.So we’re going to use this to our advantage in this for loop, we’re going to say for auto I, the beginningis going to be the beginning pointer and we’re going to keep looping as long as our pointer is not theend pointer and as long as we have a valid pointer, we’re going to keep incrementing.And if we increment for the first iteration, we’re going to grab the first element in our initializerlist.And for the second iteration we’re going to grab the second element.And once we hit the third iteration, we’re going to be basically at the end of our list and we willstop printing stuff here so we can use this syntax and print information that we have in our initializerlist.And notice that what we use inside our body is the dereferencing operator to dereference this pointerand get to what is pointed to by this iterator pointer here.Okay.So now that we have this, we can even use pointer arithmetic notation to grab data from our iterator.So for example, we can grab what is pointed to by the begin pointer using the syntax here and we cangrab the second element using the syntax here, using pointer arithmetic on our begin pointer here andwe can do this and we’re going to be using this to our advantage to grab data that we store in our membervariables here.So please take a look at our Initializer List constructor here and see what we are doing.We are grabbing data from our initializer list parameter and then the first thing is going to be usedto initialize the x member variable.And the second thing is going to be used to initialize our y member variable.And with this we have successfully grabbed the data from our initializer list and used that to initializeour member variables.This is how you can set this up and realize the begin thing can throw you off a little bit.But please think of this as a pointer to the beginning element in your initializer list collection.Once you understand this like this, you will be able to use your initializer list constructors withouta problem.Okay, Now that you know this, we’re going to head over to Visual Studio code and try this out.Okay.Here we are in our working folder.The current project is Initializer List Constructors.We’re going to grab our template files and we’re going to put them in place and we are going to openthis in Visual Studio code by dragging and dropping here, This is going to open our folder and we’regoing to close the sidebar here and clean up a little bit.We’re going to set up a struct which is going to be our sandbox.So let’s say that it is going to be a point struct and inside we’re going to have two member variables.We’re going to have a double variable for x, the x coordinate of our point and we’re going to havea double variable for our Y coordinate here and we’re going to set up a function which is going to printour point easily.So let’s put a semicolon after here and we’re going to say void print point and we’re going to takethe point by const reference and we’re going to print it out with Stdcout.We’re going to say Stdcout, we’re going to say point and we’re going to grab its X, coordinate andprint that out.We’re going to say p x here and we’re going to grab the Y coordinate and print that out as well.We’re going to say p y.Think we can save that and then we’re going to.Close this off with a square bracket and then we’re going to put our new line character.This is going to do.Now that we have this, we can set up a point in the main function and we’re going to do that like this.We’re going to say point P one and we are going to use a curly brace, aggregate initializer.So we’re going to use this syntax here and we’re going to put data in our point.We’re going to put in a few arguments, let’s say 22.4 and 65.4.We can really put in anything.We just want to see that the data we specify here is going to end up in the object.And after we set up the object, we’re going to print the information in here.So we’re going to say print point and we’re going to pass our P one point and see what happens here.Let’s bolt.We’re going to use JK to do this.You’re going to see the world is going to be good and we’re going to clear and run.Rooster You’re going to see that we have our point here.And notice that this syntax is working.Even if we didn’t really set up any constructor to make this work.So how is this working?Well, the compiler is generating an initializer list constructor behind your back, and that initializerlist constructor is taking the data here and using some magic to take the data and put that in thismember variables.And when you get to use your object, for example, by printing it out here, you’re going to see thatthe data here has ended up in this p one object.What the initializer list is going to do by default is to take the first thing here and use that toinitialize X like this.And then it’s going to take the second thing you specify here and use that to initialize y like this.Or I should say this is what the initializer list constructor that is generated by the compiler is goingto do by default.If we want to see this happening, for example, through a debugger or we want to change this defaultbehavior, for example, we want to use the first thing to initialize y and the second thing to initializeX.Suppose you want that for your application.You will need to set up your own initializer list constructor and we’re going to do that in our structhere.So the way we’re going to do that, we’re going to modify our structure a little bit and we’re goingto put in our member variables.For example, we can make this two guys private and let’s bring this to the left a little bit, andwe’re going to put in a public section.And please note that this is just a preference.If you want, you can leave them as public.But I like to keep my member variables private unless I have a compelling reason not to do so.So we’re going to put in our initializer list constructor.It’s going to be called Point like any other constructor, and then it’s going to take an initializerlist parameter.And this is going to be a template instance for double for the initializer list class template we havein the C plus plus standard library.So this is something that is built in and we just want to use this here.So we’re going to call this list and then we’re going to put a body which is going to be used to passthis list and grab the data and put that in our member variables here, let’s say list properly.Okay.So in this list, we’re going to do things step by step.What we want to do is to put a message out that this constructor was actually called.So we’re going to say initializer list called or constructor called and we’re going to put this out.Okay.So let’s see that this is actually the case.And now you see that because we have made our member variables private, we no longer have access tothem, but we can take this function and make it part of our class here because we can do that.So let’s grab this and we’re going to make it a public function in our point class.We’re going to modify it a little bit.We’re going to take out the parameters here because we don’t need this and we’re going to make it acast member function because it’s not going to be modifying our class here and we’re going to printX and Y directly, and this is going to do what we want.We’re going to get rid of this squiggly lines and what we need to do to print our object.We don’t need to call this guy directly like this.We can say p one and print info or print point and it is going to print our point here.But it doesn’t make to call this function yet because we haven’t really put in any data.So let’s just make it a member for now and we’re going to use it later.Let’s take this call out and we want to see if our Initializer List constructor was called.That’s what we want to see here.So let’s build our program.But before we do that, we’re going to clean up a little bit because now it’s ugly.Let’s build.With Jake.We’re going to see that the world is going to be good.So our constructor here must be valid and good.We can clear and run, Rooster.We’re going to see that the Initializer List constructor is called.So this is a step forward.Now that this guy is being called, we need to grab the data from the inside.Let’s see some initial things we can do on this list here.So the first thing we can do is print its size.We can print that out and say list size, and we can say list size.We can call the size method on this.And it is going to give us however many elements we have in our list here that was passed to us as aresult of the call here.Let’s build and run and see the size it should be.Two because we have two elements in our initializer here.So let’s clear and run Rooster.You’re going to see that the list size is two.And if you pass in more than two elements, the initializer list is going to take that.So let’s put in a 5.9, a 6.7 or 8 and a 4.3 here.This is going to do and you’re going to see that this is going to take it even if we have only two membervariables and the compiler trusts that we know what to do with the data that we are taking here becausewe built our own initializer list constructor.So if we print the size, we should see however many elements we have in here and I think it is fiveelements one, two, three, four, five.We should see a five printed out.So let’s build this and we’re going to clear and run Rooster.And you see that we have five elements.We are able to grab our data in our initializer and use that in our constructor here.This is pretty powerful.Okay, So now that we have this, we want to grab the first and second element because that’s what wewant to use to initialize our member variables here.To do this, we will have to use the begin pointer.That’s the list type here has.And to play with this, let’s do this.We’re going to print the first element.We’re going to save this and then we’re going to dereference the begin pointer.So we’re going to dereference and say list and call the begin method and this is going to dereferencethe pointer to the first element in the list here and it’s going to give us the value in there.So what we will get here in this case is 22.4 here, print it out.Let’s put in a new line character and we’re going to print this.Let’s build with GCC and we’re going to see our first element printed out.The build is good so we can run this.Let’s clear and run Rooster.We’re going to see that the first element is this guy here.We can even grab the second element.This is cool, right?So we can do stdcout and we’re going to say second element and we’re going to grab that.So we’re going to dereference the second element and we’re going to use Pointer arithmetic on this pointerhere.So we can say list begin and add one to that pointer.This is going to move us to the next spot.If we do this and print this out, we’re going to grab the second element and that’s going to be 65.4here.Let’s build and see that this is actually the case.So the world is good.We can clear and run.Rooster You see that 65.4 is our second element.We can even go on and keep printing stuff we have in our initializer.So for example, we can use the for loop.Let’s use that so we can do something like for size T and say I and initialize this to zero and we’regoing to keep looping as long as I is less than the size of our list.So we’re going to say I less than list size and then we’re going to increment, we’re going to put inour incrementing part, then we’re going to hit the body and then we’re going to print the element ata given index in this initializer list here.So we’re going to say stdcout and say element at index.We’re going to say the index.Let’s put I here and then we’re going to put a square bracket and we’re going to say which element itis and we’re going to use the pointer arithmetic notation.We’re going to Dereference and say list begin and we’re going to add the current iteration we are at.So we’re going to add I here and I think this is going to work.This is really cool, right?So we’re going to print all the elements that we have in our initializer, but notice that we’re goingto do that using a loop in the body of our Initializer List constructor.This is really cool.You can’t tell how excited I was when I learned about this.Let’s go out and see this working.We’re going to build with GCC.The build is good.We can clear.And run Rooster.We’re going to see that we have our elements in our initializer list here.We have from 22.4 that we have here, all the way to 4.3, which is the last element.And this is completely dynamic.If we change and put in more elements, let’s put in a 5.6 and do a 9.3 and do a 4.3.Let’s build and run and we’re going to see that the list here is going to grow dynamically.Notice that we didn’t need to change a thing and the body of our constructor here, we are able to grabour initializers and use them to do stuff.So let’s build and really show you this.We’re going to use GCC to do this, so let’s clear and run Rooster.We’re going to see that we are grabbing everything here.Eight elements from 0 to 7 and the last one is 4.3 here.This is really cool.So now that we know how to do this, we can use this to our advantage and grab the first element anduse that to initialize our member variable X and use the second element to initialize the second element,which is Y.Here, let’s do that.We’re going to comment all this out because I don’t want to take this out.I think it is really cool.So let’s keep this down in here in case you need to use this as a reference.And we’re just going to grab the first element and store that in our X member variable.So we’re going to dereference the begin pointer.We’re going to say list begin and that’s going to be our first element and we’re going to store thatin X, We’re going to grab the second element and store that in our Y member variable.Let’s do this and we’re going to use pointer arithmetic because I think it is good we’re going to addone because that’s going to be the second element.The element at index one is going to be what we want, which is going to be 65.4 here and we’re goingto use that to initialize our Y member variable.So by this point, if we go down and print information about P one, we’re going to say print point.We should see all the member variables printed out.We’re going to print what we have in X and we’re going to print what we have in Y, and you’re goingto see that it is the two pieces of data we have in the first spot and the second spot in our initializerhere.Let’s build and run.And you’re going to see this.We’re going to use GCC, as always.You see, the build is good.We’re going to clear and run Rooster.You see that?Our point is really working and it is exactly what we saw with the default initializer list that wasgenerated by the compiler for us.But now we have our own initializer list constructor and we can really make it do whatever we want.For example, we can flip all these two things and make X take the second element and we can do this.So if this makes sense for whatever application you are designing, please use this to your advantage.You already know how to do this.So if you look at this, you’re going to see that what we pass in here 22 is going to be used to initializeour Y member variable.So you can really customize how your initializer list constructors work.Let’s take this back to X and Y because I think what we just did is confusing, but hopefully this provesthat you can do all kinds of crazy things in your initializer list.Constructors.Okay.Before I let you go, let’s add some safety mechanism on our point class here and throw a compiler error.If people really pass more than two elements in our initializer list here because we don’t really wantmore.This is a point.And the point is going to have two member variables, and that’s what we want to take from this here.No more, no less.We just want two elements in our initializer here.We can enforce this by using a staticassert.We already know that.So what we can do, I think some of you are going to believe this can work is use a staticassert.But I hate to break to you.This is not going to work as you see here, because the size of our list is the runtime thing.It is something that is known at runtime when somebody initializes your object.So we can’t use this at compile time.It is not a constant expression.What we really need to use is something that works at runtime.So we’re going to use an assert.I don’t think we have seen what an assert is, but it is a mechanism.We have to check for things at runtime and if our check fails, we’re going to throw a compiler error.Let’s do that.We’re going to include a utility which is going to allow us to do that.So we’re going to include C assert and it is a library that is going to give us access to what we areabout to use and what we’re going to do is.A version of the Staticassert here, but it is going to be a runtime thing which is going to be evaluatedwhen your application is running.So we’re going to say assert.We can save that and inside we’re going to put in our assert expression here.So we’re going to basically be checking if the size of the list is two.If it’s not two, we’re going to throw a compiler error and we’re going to try and build our programhere.We’re going to see our compiler error.We’re not going to get a compiler error, but we’re going to get a runtime error when our code startsto run.So I have to correct this.Sorry, I was wrong about this.So we’re going to clear and run Rooster, and if we try to run it, you’re going to see that our programcrashed and it is telling us what is wrong here.It is saying list size equal to.So this has failed and it is going to tell us where this actually failed in our program.So, for example, we can go in our code and see the main CPP file and it’s going to give us the linenumber.And this is really cool.So we can go back there and look in the main CPP file, look at line eight and see what failed and wewill know that we have passed more than what is needed in this initializer here.If we change this to two elements, our code is going to build and do what we want.But note that this assert is going to check for things at runtime.When your application is running, let’s build and run.You’re going to see that this is going to work.If we pass less than two elements, we’re going to fail at runtime.So let’s build again.You’re going to see that the build is good.We can clear and run.Rooster and assertion is going to fail.The list size should be two and we only have one element in and our program is going to basically crashhere at line eight.We should fix this problem in our class.We’re going to look at this assert and we’re going to say if the size of the list is not two, we’renot throwing a compiler error.We are going to terminate the program with an error.Let’s say that I think this is more descriptive for this.So we’re going to see the problem here and we’re going to fix it and put in two elements.Let’s put in 34.9.Why not?And we’re going to build and this is going to work.Now, this is pretty cool.Let’s clear and run, Rooster.We’re going to see that we have our data in here.This is really all we set out to do in this lecture.Hopefully, you know that you can use initializer list constructors to your advantage.We are going to stop here in this lecture.In the next one, we’re going to learn about aggregate initialization.Go ahead and finish up here and and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><h1 id="C-聚合体的大括号初始化与自定义初始化列表构造函数（Initializer-List-Constructors-for-Aggregates）"><a href="#C-聚合体的大括号初始化与自定义初始化列表构造函数（Initializer-List-Constructors-for-Aggregates）" class="headerlink" title="C++ 聚合体的大括号初始化与自定义初始化列表构造函数（Initializer List Constructors for Aggregates）"></a>C++ 聚合体的大括号初始化与自定义初始化列表构造函数（Initializer List Constructors for Aggregates）</h1><p><strong>简介：</strong> 本节课我们将深入学习C++中用于初始化<a href="aggregate">聚合体</a>的特殊构造函数——<a href="initializer list constructors">初始化列表构造函数</a>。我们将探讨聚合体的概念，编译器如何默认支持这种初始化，以及如何编写自己的初始化列表构造函数来定制行为并进行运行时检查。</p>
<hr>
<h2 id="1-什么是聚合体（Aggregates）？以及为什么需要初始化列表构造函数？"><a href="#1-什么是聚合体（Aggregates）？以及为什么需要初始化列表构造函数？" class="headerlink" title="1. 什么是聚合体（Aggregates）？以及为什么需要初始化列表构造函数？"></a>1. 什么是聚合体（Aggregates）？以及为什么需要初始化列表构造函数？</h2><p>在C++中，<a href="aggregate">聚合体</a>是一种特殊的<a href="container">容器</a>类型，它们能够“聚合”或包含许多小的数据项。你可以把它想象成一个大盒子，里面放着许多小盒子。</p>
<p><strong>聚合体的特性和例子：</strong></p>
<ul>
<li><strong>本质</strong>：聚合体是一种将多个独立的数据项聚集在一起的复合类型。</li>
<li><strong>具体定义</strong>：C++对聚合体有严格的定义，但对于初学者，你可以暂时将其理解为一种可以容纳其他数据的容器。</li>
<li><strong>常见例子</strong>：<ul>
<li><strong><a href="array">数组</a></strong>：例如 <code>int arr[] = {1, 2, 3};</code> 数组就是最典型的聚合体。</li>
<li><strong><a href="struct">结构体</a></strong>：如果一个<code>struct</code>只包含公共的（或者说默认是公共的）非静态数据成员，没有用户定义的构造函数、析构函数、赋值运算符，也没有基类或虚函数等，那么它就是一个聚合体。</li>
</ul>
</li>
<li><strong>统一的初始化语法</strong>：对于这些聚合体，C++提供了一种统一且非常简洁的初始化语法，即使用<a href="curly braces initialization">大括号 <code>{}</code></a>。<ul>
<li>例如：<code>Point p = {10.0, 20.0};</code> 或者 <code>int arr[] = {1, 2, 3};</code>。</li>
</ul>
</li>
<li><strong>编译器的工作</strong>：当你使用这种大括号初始化语法时，编译器会“知道”如何生成必要的工具来将这些数据放入你的容器中。它会根据数据在括号中的顺序，将它们依次存入聚合体的成员中。</li>
</ul>
<p><strong>为什么是初始化列表构造函数？</strong></p>
<p>当编译器看到你使用大括号 <code>{}</code> 来初始化一个对象时，它实际上会在幕后（<a href="幕后">behind the scenes</a>）调用或生成一个特殊的构造函数来处理这些数据。这个构造函数就是<a href="initializer list constructor">初始化列表构造函数</a>。</p>
<p>对于像<code>struct Point { double x; double y; };</code> 这样的聚合体，即使你没有显式定义任何构造函数，编译器也会为你生成一个默认的初始化列表构造函数。这个默认行为通常是：按成员声明的顺序，将大括号中的数据依次赋给对应的成员。例如，<code>Point p = {10.0, 20.0};</code> 会将 <code>10.0</code> 赋给 <code>x</code>，<code>20.0</code> 赋给 <code>y</code>。</p>
<h2 id="2-自定义初始化列表构造函数：std-initializer-list"><a href="#2-自定义初始化列表构造函数：std-initializer-list" class="headerlink" title="2. 自定义初始化列表构造函数：std::initializer_list"></a>2. 自定义初始化列表构造函数：<code>std::initializer_list</code></h2><p>虽然编译器可以为我们生成默认的初始化列表构造函数，但有时我们需要改变这种默认行为，例如：</p>
<ul>
<li><strong>改变初始化顺序</strong>：你可能想让第一个传入的值初始化 <code>y</code>，第二个值初始化 <code>x</code>。</li>
<li><strong>添加校验逻辑</strong>：你可能希望确保用户传入的数据项数量符合预期。</li>
<li><strong>执行自定义操作</strong>：你可能需要根据传入的列表执行一些额外的逻辑。</li>
</ul>
<p>为了实现这些自定义，我们可以显式地定义自己的初始化列表构造函数。</p>
<p><strong>语法结构：</strong></p>
<p>一个自定义的初始化列表构造函数通常长这样：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt; // 必须包含这个头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他成员 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化列表构造函数</span></span><br><span class="line">    <span class="comment">// 构造函数名与类名相同</span></span><br><span class="line">    <span class="comment">// 参数类型为 std::initializer_list&lt;T&gt;，其中 T 是列表元素的类型</span></span><br><span class="line">    MyClass(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; list_param) &#123;</span><br><span class="line">        <span class="comment">// 在这里处理 list_param 中的数据</span></span><br><span class="line">        <span class="comment">// 例如：</span></span><br><span class="line">        <span class="comment">// if (list_param.size() &gt;= 1) &#123;</span></span><br><span class="line">        <span class="comment">//     member1 = *(list_param.begin());</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if (list_param.size() &gt;= 2) &#123;</span></span><br><span class="line">        <span class="comment">//     member2 = *(list_param.begin() + 1);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他成员 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>std::initializer_list&lt;T&gt;</code> 的作用：</strong></p>
<ul>
<li><strong><a href="template class">模板类</a></strong>：<code>std::initializer_list</code> 是C++标准库中的一个<a href="template class">模板类</a>。它用来表示一个不可变（immutable）的同类型元素的序列。</li>
<li><strong>类型匹配</strong>：<code>std::initializer_list&lt;double&gt;</code> 中的 <code>double</code> 类型应该与你希望它接收的列表元素类型相匹配。如果你的类成员是 <code>double</code>，那么这里通常也用 <code>double</code>。</li>
<li><strong>编译器转换</strong>：当你使用大括号 <code>{}</code> 初始化你的类对象时（例如 <code>MyClass obj = {v1, v2, v3};</code>），编译器会捕获 <code>{v1, v2, v3}</code> 中的所有数据，并用它们来构造一个临时的 <code>std::initializer_list&lt;T&gt;</code> 对象。然后，这个 <code>std::initializer_list</code> 对象会被作为参数传递给你定义的初始化列表构造函数。</li>
</ul>
<h2 id="3-如何访问-std-initializer-list-中的元素？"><a href="#3-如何访问-std-initializer-list-中的元素？" class="headerlink" title="3. 如何访问 std::initializer_list 中的元素？"></a>3. 如何访问 <code>std::initializer_list</code> 中的元素？</h2><p><code>std::initializer_list</code> 提供了几种方法来访问它所包含的元素：</p>
<ul>
<li><strong><code>size()</code> 方法</strong>：返回列表中元素的数量。<ul>
<li>例如：<code>list_param.size()</code>。</li>
</ul>
</li>
<li><strong><a href="iterator">迭代器</a> (<code>begin()</code>, <code>end()</code>)</strong>：<ul>
<li><code>list_param.begin()</code>：返回一个指向列表中第一个元素的<a href="iterator">迭代器</a>（你可以简单地把它想象成一个<a href="pointer">指针</a>）。</li>
<li><code>list_param.end()</code>：返回一个指向列表中“最后一个元素之后”位置的<a href="iterator">迭代器</a>。这个迭代器不指向任何实际元素，它通常用于循环的终止条件。</li>
</ul>
</li>
<li><strong><a href="dereferencing operator">解引用运算符</a> <code>*</code></strong>：如果你有一个迭代器（或指针），可以使用 <code>*</code> 来获取它所指向的实际值。<ul>
<li>例如：<code>*list_param.begin()</code> 将获取列表中的第一个元素的值。</li>
</ul>
</li>
<li><strong><a href="pointer arithmetic">指针算术</a></strong>：虽然 <code>begin()</code> 返回的是迭代器，但对于 <code>std::initializer_list</code> 的迭代器，你通常可以像对待指针一样对它们执行加减运算，以访问后续元素。<ul>
<li>例如：<code>*(list_param.begin() + 1)</code> 将获取列表中的第二个元素的值（索引为1）。</li>
</ul>
</li>
</ul>
<p><strong>示例代码（如何在构造函数中使用）：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt; // 必须包含</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;        // 用于 assert</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义一个 Point 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 通常我们将成员变量设为私有</span></span><br><span class="line">    <span class="keyword">double</span> m_x;</span><br><span class="line">    <span class="keyword">double</span> m_y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    Point() : m_x(<span class="number">0.0</span>), m_y(<span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"默认构造函数 called."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义初始化列表构造函数</span></span><br><span class="line">    Point(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Initializer List 构造函数 called."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行时断言：确保传入的元素数量是 2</span></span><br><span class="line">        <span class="comment">// assert 是一个运行时检查，如果条件为假，程序会终止并报错</span></span><br><span class="line">        <span class="comment">// 记得包含 &lt;cassert&gt; 头文件</span></span><br><span class="line">        assert(<span class="built_in">list</span>.size() == <span class="number">2</span> &amp;&amp; <span class="string">"Point requires exactly 2 values (x, y) for initialization."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用迭代器和指针算术访问元素并初始化成员变量</span></span><br><span class="line">        <span class="comment">// 注意：这里我们假设列表至少有两个元素（通过上面的 assert 保证）</span></span><br><span class="line">        m_x = *(<span class="built_in">list</span>.begin());        <span class="comment">// 第一个元素初始化 x</span></span><br><span class="line">        m_y = *(<span class="built_in">list</span>.begin() + <span class="number">1</span>);    <span class="comment">// 第二个元素初始化 y</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果你希望颠倒顺序，可以这样：</span></span><br><span class="line">        <span class="comment">// m_y = *(list.begin());</span></span><br><span class="line">        <span class="comment">// m_x = *(list.begin() + 1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 Point 信息的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// const 成员函数表示不修改对象状态</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point: [x="</span> &lt;&lt; m_x &lt;&lt; <span class="string">", y="</span> &lt;&lt; m_y &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 编译器生成的默认聚合初始化 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 对于满足聚合体定义的结构体，即使没有自定义构造函数，也可以这样初始化</span></span><br><span class="line">    <span class="comment">// 注意：如果 Point 内部有自定义构造函数，它就不再是严格意义上的聚合体，</span></span><br><span class="line">    <span class="comment">// 但是大括号初始化仍然有效，会调用对应的构造函数。</span></span><br><span class="line">    <span class="comment">// 在我们这里，Point 有了自定义初始化列表构造函数，所以它会调用它。</span></span><br><span class="line">    Point p1 = &#123;<span class="number">10.5</span>, <span class="number">20.5</span>&#125;; <span class="comment">// 调用我们自定义的 Initializer List 构造函数</span></span><br><span class="line">    p1.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 使用 Initializer List 构造函数初始化 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(&#123;<span class="number">-5.0</span>, <span class="number">15.0</span>&#125;)</span></span>; <span class="comment">// 显式使用大括号初始化，也会调用 Initializer List 构造函数</span></span><br><span class="line">    p2.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 尝试传入过多元素 (会触发 assert 终止程序) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// Point p3 = &#123;1.0, 2.0, 3.0&#125;; // 这行代码如果执行，会因为 assert 失败而终止程序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 尝试传入过少元素 (会触发 assert 终止程序) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// Point p4 = &#123;100.0&#125;; // 这行代码如果执行，会因为 assert 失败而终止程序</span></span><br><span class="line"></span><br><span class="line">    Point p5; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    p5.print_info();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>遍历 <code>std::initializer_list</code> 中的所有元素：</strong></p>
<p>虽然对于 <code>Point</code> 这样固定数量成员的类，我们通常只取前几个元素，但 <code>std::initializer_list</code> 支持遍历所有元素。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomContainer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 假设我们有一个动态数组来存储元素</span></span><br><span class="line">    <span class="keyword">double</span>* m_data;</span><br><span class="line">    <span class="keyword">size_t</span> m_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyCustomContainer(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span>) : m_size(<span class="built_in">list</span>.size()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"MyCustomContainer Initializer List 构造函数 called. List size: "</span> &lt;&lt; <span class="built_in">list</span>.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">double</span>[m_size]; <span class="comment">// 分配内存</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 方法1: 使用基于范围的 for 循环 (Range-based for loop)</span></span><br><span class="line">        <span class="comment">// 这种方式最简洁、推荐使用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> val : <span class="built_in">list</span>) &#123;</span><br><span class="line">            m_data[i++] = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法2: 使用传统 for 循环和迭代器/指针算术</span></span><br><span class="line">        <span class="comment">// size_t i = 0;</span></span><br><span class="line">        <span class="comment">// for (auto it = list.begin(); it != list.end(); ++it) &#123;</span></span><br><span class="line">        <span class="comment">//     m_data[i++] = *it;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法3: 使用传统 for 循环和索引 (通过指针算术)</span></span><br><span class="line">        <span class="comment">// for (size_t j = 0; j &lt; list.size(); ++j) &#123;</span></span><br><span class="line">        <span class="comment">//     m_data[j] = *(list.begin() + j);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数，释放内存</span></span><br><span class="line">    ~MyCustomContainer() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_elements</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Elements: ["</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_size; ++i) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_data[i] &lt;&lt; (i == m_size - <span class="number">1</span> ? <span class="string">""</span> : <span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyCustomContainer c1 = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line">    c1.print_elements();</span><br><span class="line"></span><br><span class="line">    MyCustomContainer c2 = &#123;<span class="number">100.0</span>&#125;;</span><br><span class="line">    c2.print_elements();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="4-QA-闪存卡（QA-Flash-Cards）"><a href="#4-QA-闪存卡（QA-Flash-Cards）" class="headerlink" title="4. QA 闪存卡（QA Flash Cards）"></a>4. QA 闪存卡（QA Flash Cards）</h2><p><strong>Q1：C++ 中的<a href="aggregate">聚合体</a>是什么？</strong><br>A1：聚合体是指符合特定条件的类类型，通常是不包含用户声明的构造函数、析构函数、虚函数、私有/保护非静态数据成员、基类等的<a href="struct">结构体</a>或<a href="class">类</a>，以及<a href="array">数组</a>类型。它们可以使用<a href="curly braces initialization">大括号初始化</a>语法进行初始化。</p>
<p><strong>Q2：<a href="initializer list constructor">初始化列表构造函数</a>的目的是什么？</strong><br>A2：它的目的是允许你使用统一的<a href="curly braces initialization">大括号初始化</a>语法 <code>{}</code> 来构造和初始化对象，并为这种初始化提供自定义逻辑，而不仅仅依赖于编译器生成的默认行为。</p>
<p><strong>Q3：如何自定义一个<a href="initializer list constructor">初始化列表构造函数</a>？</strong><br>A3：通过定义一个接受 <code>std::initializer_list&lt;T&gt;</code> 类型参数的构造函数，其中 <code>T</code> 是你希望列表元素具有的类型。例如：<code>MyClass(std::initializer_list&lt;int&gt; list_param);</code>。</p>
<p><strong>Q4：如何在 <code>std::initializer_list</code> 中访问元素？</strong><br>A4：可以使用 <code>list.size()</code> 获取元素数量；使用 <code>*(list.begin())</code> 获取第一个元素；使用 <code>*(list.begin() + N)</code> 获取第 <code>N+1</code> 个元素（<a href="pointer arithmetic">指针算术</a>）；或者使用基于范围的 <code>for</code> 循环遍历所有元素。</p>
<p><strong>Q5：<code>static_assert</code> 和 <code>assert</code> 有什么区别？</strong><br>A5：</p>
<ul>
<li><code>static_assert</code> 用于<strong><a href="compile-time">编译期</a></strong>检查，它要求其条件是一个常量表达式。如果条件为假，则会导致编译错误。</li>
<li><code>assert</code> 用于<strong><a href="run-time">运行期</a></strong>检查，它在其条件为假时会终止程序的执行（通常是抛出<a href="exception">异常</a>或调用 <code>abort()</code>）。它通常用于调试目的，在发布版本中可以被禁用。</li>
</ul>
<h2 id="5-常见误解与错误（Common-Misunderstandings-or-Mistakes）"><a href="#5-常见误解与错误（Common-Misunderstandings-or-Mistakes）" class="headerlink" title="5. 常见误解与错误（Common Misunderstandings or Mistakes）"></a>5. 常见误解与错误（Common Misunderstandings or Mistakes）</h2><ol>
<li><strong>混淆 <code>std::initializer_list</code> 与普通多参数构造函数</strong>：<ul>
<li><strong>错误</strong>：认为 <code>Point(double x_val, double y_val)</code> 也是一个初始化列表构造函数。</li>
<li><strong>澄清</strong>：虽然看起来相似，但只有参数类型是 <code>std::initializer_list&lt;T&gt;</code> 的构造函数才是初始化列表构造函数。它允许你使用统一的 <code>{}</code> 语法，并且可以接受任意数量的元素（只要类型匹配）。</li>
</ul>
</li>
<li><strong>试图对 <code>std::initializer_list::size()</code> 使用 <code>static_assert</code></strong>：<ul>
<li><strong>错误</strong>：在初始化列表构造函数中写 <code>static_assert(list.size() == 2, &quot;Error message&quot;);</code></li>
<li><strong>澄清</strong>：<code>list.size()</code> 的值是在<a href="run-time">运行时</a>才知道的，因为它取决于用户实际传入了多少个元素。<code>static_assert</code> 只能用于<a href="compile-time">编译期</a>已知的值。对于运行时检查，应该使用 <code>assert</code>。</li>
</ul>
</li>
<li><strong>忘记包含必要的头文件</strong>：<ul>
<li><strong>错误</strong>：使用 <code>std::initializer_list</code> 但没有包含 <code>&lt;initializer_list&gt;</code>。使用 <code>assert</code> 但没有包含 <code>&lt;cassert&gt;</code>。</li>
<li><strong>澄清</strong>：这些都是标准库组件，必须显式包含对应的头文件。</li>
</ul>
</li>
<li><strong>未处理 <code>std::initializer_list</code> 中元素数量不匹配的情况</strong>：<ul>
<li><strong>错误</strong>：直接使用 <code>*(list.begin() + 1)</code> 访问第二个元素，但用户只传入了一个元素，导致<a href="undefined behavior">未定义行为</a>。</li>
<li><strong>澄清</strong>：在使用 <code>begin()</code> 和<a href="pointer arithmetic">指针算术</a>访问元素之前，务必检查 <code>list.size()</code> 来确保有足够的元素，或者使用 <code>assert</code> 进行断言检查。对于可变数量的元素，应该遍历列表而不是固定索引访问。</li>
</ul>
</li>
<li><strong>认为 <code>std::initializer_list</code> 只能用于<a href="aggregate">聚合体</a></strong>：<ul>
<li><strong>错误</strong>：只有<a href="array">数组</a>和<a href="struct">结构体</a>才能使用 <code>std::initializer_list</code> 构造函数。</li>
<li><strong>澄清</strong>：任何<a href="class">类</a>（<code>class</code> 或 <code>struct</code>）都可以定义一个接受 <code>std::initializer_list</code> 的构造函数，从而允许使用<a href="curly braces initialization">大括号初始化</a>语法来构造该类的对象，这大大增加了类的灵活性和可用性。</li>
</ul>
</li>
<li><strong>在构造函数体内进行成员初始化</strong>：<ul>
<li><strong>错误</strong>：在构造函数体内使用 <code>x = *(list.begin());</code></li>
<li><strong>澄清</strong>：虽然可以，但更推荐使用<a href="member initializer list">成员初始化列表</a>来初始化成员变量。例如：<code>Point(std::initializer_list&lt;double&gt; list) : m_x(*(list.begin())), m_y(*(list.begin() + 1)) { ... }</code> 这样可以避免先默认构造再赋值的开销，尤其对于复杂对象。然而，对于 <code>std::initializer_list</code> 本身，通常需要在构造函数体内进行处理，因为它是参数。这里特指我们自己的成员变量 <code>m_x</code>, <code>m_y</code>。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-编程练习（Coding-Exercise）"><a href="#6-编程练习（Coding-Exercise）" class="headerlink" title="6. 编程练习（Coding Exercise）"></a>6. 编程练习（Coding Exercise）</h2><p>现在，请你来完成一个简单的练习。</p>
<p><strong>任务</strong>：创建一个名为 <code>Rectangle</code> 的结构体，它代表一个二维矩形。</p>
<ul>
<li><code>Rectangle</code> 应该有两个 <code>double</code> 类型的私有成员变量：<code>m_width</code> (宽度) 和 <code>m_height</code> (高度)。</li>
<li>它应该有一个<a href="custom initializer list constructor">自定义初始化列表构造函数</a>，接受一个 <code>std::initializer_list&lt;double&gt;</code> 参数。</li>
<li>这个构造函数应该：<ol>
<li>打印一条消息，表明它被调用了。</li>
<li>使用 <code>assert</code> 确保传入的<a href="initializer list">初始化列表</a>恰好包含<strong>两个</strong> <code>double</code> 值（分别用于宽度和高度）。如果不是，则程序终止。</li>
<li>使用<a href="pointer arithmetic">指针算术</a>和<a href="dereferencing">解引用</a>从列表中获取第一个值并初始化 <code>m_width</code>，获取第二个值并初始化 <code>m_height</code>。</li>
</ol>
</li>
<li>添加一个公共的 <code>print_dimensions()</code> 方法来打印矩形的宽度和高度。</li>
<li>在 <code>main</code> 函数中，创建 <code>Rectangle</code> 对象：<ol>
<li>成功初始化一个 <code>Rectangle</code> 对象。</li>
<li>（可选）尝试用不正确的元素数量初始化一个 <code>Rectangle</code> 对象，观察 <code>assert</code> 的行为（记得注释掉这行代码，否则程序会终止）。</li>
</ol>
</li>
</ul>
<p>请在下面的代码块中填写你的解决方案：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; // Don't forget this for assert!</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Define the Rectangle struct here</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_width;</span><br><span class="line">    <span class="keyword">double</span> m_height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 2. Add your custom initializer list constructor here</span></span><br><span class="line">    <span class="comment">// Remember to check list size and initialize m_width and m_height</span></span><br><span class="line">    <span class="comment">// 提示：可以使用成员初始化列表来初始化成员变量</span></span><br><span class="line">    <span class="comment">// Rectangle(std::initializer_list&lt;double&gt; list) : ________, ________ &#123;</span></span><br><span class="line">    <span class="comment">//     // ... your assert and print message here ...</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Add the print_dimensions() method here</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_dimensions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle: [Width="</span> &lt;&lt; m_width &lt;&lt; <span class="string">", Height="</span> &lt;&lt; m_height &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Test case 1: Correct initialization</span></span><br><span class="line">    Rectangle rect1 = &#123;<span class="number">10.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line">    rect1.print_dimensions();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test case 2 (Optional): Incorrect number of elements - Uncomment to see assert in action</span></span><br><span class="line">    <span class="comment">// Rectangle rect2 = &#123;20.0&#125;; // Should trigger assert</span></span><br><span class="line">    <span class="comment">// rect2.print_dimensions();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test case 3 (Optional): Incorrect number of elements - Uncomment to see assert in action</span></span><br><span class="line">    <span class="comment">// Rectangle rect3 = &#123;30.0, 15.0, 2.0&#125;; // Should trigger assert</span></span><br><span class="line">    <span class="comment">// rect3.print_dimensions();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; // Don't forget this for assert!</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Define the Rectangle struct here</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_width;</span><br><span class="line">    <span class="keyword">double</span> m_height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 2. Add your custom initializer list constructor here</span></span><br><span class="line">    <span class="comment">// Remember to check list size and initialize m_width and m_height</span></span><br><span class="line">    <span class="comment">// 提示：可以使用成员初始化列表来初始化成员变量</span></span><br><span class="line">    <span class="comment">// Rectangle(std::initializer_list&lt;double&gt; list) : ________, ________ &#123;</span></span><br><span class="line">    <span class="comment">//     // ... your assert and print message here ...</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    Rectangle(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Initializer List called."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        assert(<span class="built_in">list</span>.size() == <span class="number">2</span> &amp;&amp; <span class="string">"list size shall be two to include width and length"</span>);</span><br><span class="line">        m_width = *(<span class="built_in">list</span>.begin());</span><br><span class="line">        m_height = *(<span class="built_in">list</span>.begin() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Add the print_dimensions() method here</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_dimensions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle: [Width="</span> &lt;&lt; m_width &lt;&lt; <span class="string">", Height="</span> &lt;&lt; m_height &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Test case 1: Correct initialization</span></span><br><span class="line">    Rectangle rect1 = &#123;<span class="number">10.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line">    rect1.print_dimensions();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test case 2 (Optional): Incorrect number of elements - Uncomment to see assert in action</span></span><br><span class="line">    <span class="comment">// Rectangle rect2 = &#123;20.0&#125;; // Should trigger assert</span></span><br><span class="line">    <span class="comment">// rect2.print_dimensions();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test case 3 (Optional): Incorrect number of elements - Uncomment to see assert in action</span></span><br><span class="line">    <span class="comment">// Rectangle rect3 = &#123;30.0, 15.0, 2.0&#125;; // Should trigger assert</span></span><br><span class="line">    <span class="comment">// rect3.print_dimensions();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，你的解决方案已收到！作为你的C++专业导师，我将仔细审查你的代码，提供详细的反馈，并给出一些扩展的思考。</p>
<h2 id="7-评估用户解决方案并给出实际答案和解释"><a href="#7-评估用户解决方案并给出实际答案和解释" class="headerlink" title="7. 评估用户解决方案并给出实际答案和解释"></a>7. 评估用户解决方案并给出实际答案和解释</h2><h3 id="解决方案评分"><a href="#解决方案评分" class="headerlink" title="解决方案评分"></a>解决方案评分</h3><p><strong>总分：5/5</strong></p>
<p><strong>评价：</strong> 你的解决方案非常出色！你成功地实现了所有要求，包括定义结构体、实现初始化列表构造函数、使用 <code>assert</code> 进行运行时校验，并通过指针算术正确地初始化了成员变量。代码逻辑清晰，功能实现完整。</p>
<p><strong>具体得分点：</strong></p>
<ul>
<li><strong><code>Rectangle</code> 结构体定义与成员变量私有化 (1/1)</strong>：你正确地将 <code>m_width</code> 和 <code>m_height</code> 声明为私有成员，这是一个良好的封装实践。</li>
<li><strong>自定义初始化列表构造函数 (1/1)</strong>：你成功地定义了接受 <code>std::initializer_list&lt;double&gt;</code> 参数的构造函数，这是本节课的核心内容。</li>
<li><strong>打印调用信息 (1/1)</strong>：构造函数中包含了 <code>std::cout &lt;&lt; &quot;Initializer List called.&quot; &lt;&lt; std::endl;</code>，符合要求。</li>
<li><strong>使用 <code>assert</code> 进行运行时校验 (1/1)</strong>：你正确地使用了 <code>assert(list.size() == 2 &amp;&amp; &quot;list size shall be two to include width and length&quot;);</code> 来检查列表大小，并给出了有用的错误信息。</li>
<li><strong>正确初始化成员变量 (1/1)</strong>：你使用 <code>m_width = *(list.begin());</code> 和 <code>m_height = *(list.begin() + 1);</code> 来初始化成员，精确地利用了指针算术和解引用。</li>
<li><strong><code>print_dimensions()</code> 方法 (1/1)</strong>：你实现了正确的打印方法，并且是 <code>const</code> 成员函数，表示它不会修改对象状态，这也是一个好习惯。</li>
<li><strong><code>main</code> 函数测试 (1/1)</strong>：<code>main</code> 函数中的测试用例也演示了正确的初始化。</li>
</ul>
<p>你唯一没有完全按照提示（“可以使用成员初始化列表来初始化成员变量”）做的地方是：你在构造函数体内对 <code>m_width</code> 和 <code>m_height</code> 进行了赋值，而不是在<a href="member initializer list">成员初始化列表</a>中。这并非错误，但涉及到C++的一个重要最佳实践，我们会在下面的“实际答案和解释”中详细说明。</p>
<h3 id="实际答案和解释"><a href="#实际答案和解释" class="headerlink" title="实际答案和解释"></a>实际答案和解释</h3><p>你的代码是完全正确的，并且能够正常工作。这里我提供一个稍作优化的版本，主要是在构造函数中使用了<strong>成员初始化列表</strong>。</p>
<p><strong>优化的代码：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt; // Don't forget this for assert!</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Define the Rectangle struct here</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_width;</span><br><span class="line">    <span class="keyword">double</span> m_height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 2. Add your custom initializer list constructor here</span></span><br><span class="line">    <span class="comment">// 使用成员初始化列表初始化 m_width 和 m_height 是更推荐的做法</span></span><br><span class="line">    Rectangle(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span>) </span><br><span class="line">        : m_width(*(<span class="built_in">list</span>.begin())), <span class="comment">// 在这里初始化 m_width</span></span><br><span class="line">          m_height(*(<span class="built_in">list</span>.begin() + <span class="number">1</span>)) <span class="comment">// 在这里初始化 m_height</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Initializer List Constructor called."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 稍微修改了打印信息</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运行时断言：确保传入的元素数量是 2</span></span><br><span class="line">        assert(<span class="built_in">list</span>.size() == <span class="number">2</span> &amp;&amp; <span class="string">"Rectangle requires exactly 2 values (width, height) for initialization."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意：由于成员变量已在成员初始化列表中初始化，这里不再需要赋值操作</span></span><br><span class="line">        <span class="comment">// m_width = *(list.begin());</span></span><br><span class="line">        <span class="comment">// m_height = *(list.begin() + 1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Add the print_dimensions() method here</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_dimensions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle: [Width="</span> &lt;&lt; m_width &lt;&lt; <span class="string">", Height="</span> &lt;&lt; m_height &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Test case 1: Correct initialization</span></span><br><span class="line">    Rectangle rect1 = &#123;<span class="number">10.0</span>, <span class="number">5.0</span>&#125;; <span class="comment">// 使用大括号初始化语法</span></span><br><span class="line">    rect1.print_dimensions();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test case 2 (Optional): Incorrect number of elements - Uncomment to see assert in action</span></span><br><span class="line">    <span class="comment">// Rectangle rect2 = &#123;20.0&#125;; // Should trigger assert and terminate the program</span></span><br><span class="line">    <span class="comment">// rect2.print_dimensions();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test case 3 (Optional): Incorrect number of elements - Uncomment to see assert in action</span></span><br><span class="line">    <span class="comment">// Rectangle rect3 = &#123;30.0, 15.0, 2.0&#125;; // Should trigger assert and terminate the program</span></span><br><span class="line">    <span class="comment">// rect3.print_dimensions();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>为什么推荐使用<a href="member initializer list">成员初始化列表</a>？</strong></p>
<p>在C++中，构造函数有两种方式来为成员变量赋值：</p>
<ol>
<li><p><strong>在构造函数体内赋值 (你目前的做法)</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rectangle(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m_width = *(<span class="built_in">list</span>.begin());</span><br><span class="line">    m_height = *(<span class="built_in">list</span>.begin() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这种方式的问题在于，对于非基本类型（如自定义类对象），在进入构造函数体之前，它们的<a href="default constructor">默认构造函数</a>会先被隐式调用（如果存在）。然后，在构造函数体内，你再对它们进行一次<a href="assignment operation">赋值操作</a>。这意味着可能会有一次不必要的<a href="default construction">默认构造</a>和随后的<a href="assignment">赋值</a>开销。</p>
</li>
<li><p><strong>使用<a href="member initializer list">成员初始化列表</a> (推荐做法)</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rectangle(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">double</span>&gt; <span class="built_in">list</span>) </span><br><span class="line">    : m_width(*(<span class="built_in">list</span>.begin())), </span><br><span class="line">      m_height(*(<span class="built_in">list</span>.begin() + <span class="number">1</span>)) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... 构造函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这种方式直接在成员变量被创建时就使用指定的值进行<strong>初始化</strong>。这通常效率更高，因为它避免了先进行默认构造再进行赋值的步骤。对于某些没有<a href="default constructor">默认构造函数</a>的类类型成员，或者 <code>const</code> 成员、<a href="reference">引用</a>成员，你<strong>必须</strong>使用<a href="member initializer list">成员初始化列表</a>来初始化它们。</p>
</li>
</ol>
<p>虽然对于像 <code>double</code> 这样的基本类型，这种差异通常可以忽略不计，但养成使用<a href="member initializer list">成员初始化列表</a>的好习惯对编写高效和正确的C++代码非常重要。你的代码的执行顺序是：</p>
<ol>
<li><code>list.begin()</code> 和 <code>list.begin() + 1</code> 被求值。</li>
<li><code>m_width</code> 被初始化为第一个值。</li>
<li><code>m_height</code> 被初始化为第二个值。</li>
<li>构造函数体内的 <code>std::cout</code> 语句执行。</li>
<li><code>assert</code> 语句执行。</li>
</ol>
<p>这确保了成员变量在构造函数体开始执行之前就已经被初始化了。</p>
<h2 id="8-扩展问题和建议（Extended-Questions-and-Suggestions）"><a href="#8-扩展问题和建议（Extended-Questions-and-Suggestions）" class="headerlink" title="8. 扩展问题和建议（Extended Questions and Suggestions）"></a>8. 扩展问题和建议（Extended Questions and Suggestions）</h2><p>你已经很好地掌握了<a href="initializer list constructor">初始化列表构造函数</a>的基本概念和用法。接下来，你可以探索以下几个方面，加深对相关知识的理解：</p>
<ol>
<li><p><strong><a href="member initializer list">成员初始化列表</a>的深入理解</strong>：</p>
<ul>
<li>尝试修改你的 <code>Rectangle</code> 结构体，让 <code>m_width</code> 或 <code>m_height</code> 成为 <code>const double</code> 类型，看看没有<a href="member initializer list">成员初始化列表</a>会发生什么（会编译错误）。</li>
<li>研究<a href="member initializer list">成员初始化列表</a>中成员的初始化顺序（总是按照在类中声明的顺序，而不是列表中的顺序），并思考这可能带来的潜在问题。</li>
<li>了解如何利用<a href="delegating constructor">委托构造函数</a>来重用<a href="initializer list constructor">初始化列表构造函数</a>中的逻辑。</li>
</ul>
</li>
<li><p><strong><code>std::initializer_list</code> 的其他应用</strong>：</p>
<ul>
<li><strong>容器的初始化</strong>：许多标准库容器，如 <code>std::vector</code>, <code>std::map</code>, <code>std::set</code> 等，都提供了接受 <code>std::initializer_list</code> 的构造函数。你可以尝试用这种方式初始化一个 <code>std::vector&lt;double&gt;</code>。</li>
<li><strong>可变参数函数</strong>：思考如何设计一个函数，它能接受任意数量的相同类型参数，而不仅仅是固定两个。<code>std::initializer_list</code> 是实现这种“可变参数”的一种安全且类型安全的方式。</li>
<li><strong>设计通用容器</strong>：如果让你设计一个简单的动态数组类（类似 <code>std::vector</code>），如何利用 <code>std::initializer_list</code> 来实现它的便捷初始化？这需要你处理列表中元素的复制和存储，并考虑内存管理。</li>
</ul>
</li>
<li><p><strong>运行时检查与<a href="exception handling">异常处理</a></strong>：</p>
<ul>
<li>目前你使用了 <code>assert</code>，它在<a href="debug mode">调试模式</a>下很有用，但在<a href="release mode">发布模式</a>下通常会被禁用，导致错误可能不被发现或者程序崩溃。</li>
<li>学习C++的<a href="exception handling">异常处理</a>机制（<code>try</code>, <code>catch</code>, <code>throw</code>）。尝试将 <code>assert</code> 替换为抛出 <code>std::invalid_argument</code> <a href="exception">异常</a>，并学习如何在 <code>main</code> 函数中捕获并处理这个<a href="exception">异常</a>，而不是让程序终止。这在实际软件开发中是更健壮的做法。</li>
</ul>
</li>
<li><p><strong><a href="aggregate">聚合体</a>的详细定义</strong>：</p>
<ul>
<li>如果你有兴趣，可以深入了解C++标准中对<a href="aggregate">聚合体</a>的精确定义。这有助于你理解为什么某些<a href="class">类</a>可以进行<a href="curly braces initialization">大括号初始化</a>而另一些则不行。</li>
</ul>
</li>
</ol>
<p>继续保持这种学习热情，你会在C++的学习道路上取得更大进步！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Tutorial/">Tutorial    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Constructor/">Constructor    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/312%20-%20cpp%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>312 - cpp 友元函数详解</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/319%20-%20Class%20Const/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>319 - Class Const</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/274 - default constructor/" title="274 - default constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">274 - default constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/296 - 构造函数默认参数/" title="296 - 构造函数默认参数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">296 - 构造函数默认参数</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/273 - constructor/" title="273 - constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">273 - constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/280 - 构造与析构顺序 倒序析构/" title="280 - 构造与析构顺序 倒序析构"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">280 - 构造与析构顺序 倒序析构</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/282 - cpp结构体与类的区别和用法/" title="282 - cpp结构体与类的区别和用法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">282 - cpp结构体与类的区别和用法</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/297 - 构造函数初始化列表/" title="297 - 构造函数初始化列表"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">297 - 构造函数初始化列表</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>