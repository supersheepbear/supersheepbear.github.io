<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>339 - cpp 声明与定义 | Bear's dream</title><meta name="description" content="339 - cpp 声明与定义"><meta name="keywords" content="Coding,Cpp,Developer,Programming,Definition"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="339 - cpp 声明与定义"><meta name="twitter:description" content="339 - cpp 声明与定义"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="339 - cpp 声明与定义"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/339%20-%20cpp%20%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="339 - cpp 声明与定义"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/339%20-%20cpp%20%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89/"><link rel="prev" title="343 - cpp链接属性翻转" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/343%20-%20cpp%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7%E7%BF%BB%E8%BD%AC/"><link rel="next" title="cpp 全局变量和常量" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/notes/cpp%20%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-声明与定义"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">C++ 声明与定义</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-声明与定义：程序构建的基石"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">C++ 声明与定义：程序构建的基石</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-声明与定义：核心概念深度解析"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">1. 声明与定义：核心概念深度解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-声明与定义的关系和编译-链接阶段"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">1.1 声明与定义的关系和编译&#x2F;链接阶段</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-为什么区分声明和定义？"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">1.2 为什么区分声明和定义？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-不同场景下的声明与定义"><span class="toc_mobile_items-number">1.4.3.</span> <span class="toc_mobile_items-text">1.3 不同场景下的声明与定义</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-3-1-变量-Variables"><span class="toc_mobile_items-number">1.4.3.1.</span> <span class="toc_mobile_items-text">1.3.1 变量 (Variables)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-3-2-函数-Functions"><span class="toc_mobile_items-number">1.4.3.2.</span> <span class="toc_mobile_items-text">1.3.2 函数 (Functions)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-3-3-类-Classes-和结构体-Structs"><span class="toc_mobile_items-number">1.4.3.3.</span> <span class="toc_mobile_items-text">1.3.3 类 (Classes) 和结构体 (Structs)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-4-总结声明与定义的关键规则"><span class="toc_mobile_items-number">1.4.4.</span> <span class="toc_mobile_items-text">1.4 总结声明与定义的关键规则</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-代码示例"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">2. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-QA-闪卡-Flash-Cards"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">3. QA 闪卡 (Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-常见误解和错误"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">4. 常见误解和错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-编程练习"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">5. 编程练习</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么这种特性对于头文件很重要？"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">为什么这种特性对于头文件很重要？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结："><span class="toc_mobile_items-number">1.12.</span> <span class="toc_mobile_items-text">总结：</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-声明与定义"><span class="toc-number">1.</span> <span class="toc-text">C++ 声明与定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-声明与定义：程序构建的基石"><span class="toc-number">1.3.</span> <span class="toc-text">C++ 声明与定义：程序构建的基石</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-声明与定义：核心概念深度解析"><span class="toc-number">1.4.</span> <span class="toc-text">1. 声明与定义：核心概念深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-声明与定义的关系和编译-链接阶段"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.1 声明与定义的关系和编译&#x2F;链接阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-为什么区分声明和定义？"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.2 为什么区分声明和定义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-不同场景下的声明与定义"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.3 不同场景下的声明与定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-变量-Variables"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">1.3.1 变量 (Variables)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-函数-Functions"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">1.3.2 函数 (Functions)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-类-Classes-和结构体-Structs"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">1.3.3 类 (Classes) 和结构体 (Structs)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-总结声明与定义的关键规则"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.4 总结声明与定义的关键规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-代码示例"><span class="toc-number">1.5.</span> <span class="toc-text">2. 代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-QA-闪卡-Flash-Cards"><span class="toc-number">1.6.</span> <span class="toc-text">3. QA 闪卡 (Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-常见误解和错误"><span class="toc-number">1.7.</span> <span class="toc-text">4. 常见误解和错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-编程练习"><span class="toc-number">1.8.</span> <span class="toc-text">5. 编程练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">1.9.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">1.10.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么这种特性对于头文件很重要？"><span class="toc-number">1.11.</span> <span class="toc-text">为什么这种特性对于头文件很重要？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结："><span class="toc-number">1.12.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">339 - cpp 声明与定义</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/339%20-%20cpp%20%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/339%20-%20cpp%20%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="C-声明与定义"><a href="#C-声明与定义" class="headerlink" title="C++ 声明与定义"></a>C++ 声明与定义</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture.We’re going to zoom in on the declarations and the definitions in your C plus plus code.And we’re going to think about the meaning of these words in your C plus plus program.A declaration is something or a statement that is going to introduce a name in your C plus plus program.A definition says what that name is or what that name does.And now that sounds a bit confusing right now.So let’s look at an example here.We have a piece of code in which we have a function declaration and we have a function definition below.The function declaration is giving up some information about this function.For example, we know that this function is not going to return anything.We know the name of the function, but we don’t really know what this function is going to do.And this is really what the splitting between declaration and definition is all about.Somebody might not be interested in the full details of your function and they are just going to usethe function declaration.This is going to introduce the name some function in our code.So if we refer to it, the compiler is not going to complain.So we have successfully introduced a name in our program using this declaration.Here again, a declaration is some kind of statement in your C plus plus code that is going to introducea new code if you want the full details about that name.For example, knowing what that name does or how it does what it does, then you will need a definitionfor your thank.If you look down below here we have a definition.This is the code that is going to give up more information about this function here.For example, if we have something in the body of this function, we will be able to see it and we willexactly know how this function does its job.And this is a function definition.Again, the definition is going to give up more information about what the name does.In this case, the name is some function here and how the name does what it does.This is what we really mean when we say we have a declaration of something or we have a definition ofsomething.Let’s look at some things you need to be careful about in terms of definitions and declarations.If a name is never used, for example, a function is called or a variable is used in any way in yourC plus plus program, its definition won’t never be needed because we won’t need those details becausethe name is not really used in your code.So the code will just compile and work fine, even if the definition for that name is not in place.If we look at the second point here, we’re going to say if you compile without a declaration and thename is used, you get a compiler error and we’re going to get some kind of name is not defined in thisscope or something like that.So for your name to be used in any way, you need a declaration in place.And we’re going to see an example of this in a minute when we hit Visual Studio code.But you need to keep this in mind.If we look down here, we’re going to see that if you compile with a declaration without a definitionand the name is not used, the code is going to compile.So you have a declaration, you don’t have a definition, but the name is never used.So the code is going to compile.If we look at this line here, we’re going to say if you compile with a declaration without a definitionand the name is used, you’re going to get a linker error because the definitions are already resolvedat the linker stage.So you’re going to get a linker error.And we saw an example of this in a previous lecture when we split our computation in two steps compilationand linking.Okay, so now that you have these ideas in mind, we’re going to look at declarations and definitions.Strategically, we are going to look at these concepts in the context of freestanding variables.We’re going to look at them in the context of functions and we’re going to look at them in the contextof classes.Let’s start with variables here we have a single variable.It is really simple.Its type is double.The name is weight and it is initialized to zero using braced initialization.Here, the statement here is going to double as both a declaration and a definition because it is introducingthe way to name in our C plus plus program.For example, if we’re trying to print the weight, we’re going to get it printed out.We’re not going to get a compiler error saying we don’t know what weight is because we have introducedthis name using this declaration here.But this is also a definition because it is really saying what this weight is.It is a variable of double type and its value is zero because we initialize this using brace initialization.So this is a definition.And the declaration.At the same time, I have to say that it isn’t really common to separate declarations and definitionsfor variables, and I don’t really know how you would even do that.So we usually do this this way by combining declaration and definitions for variables, but for somevariables, for example, static variables that are inside the classes, it is possible to separatedeclaration and definition.And I am going to show you that in a minute when we hit Visual Studio code.But note that in most cases for freestanding variables, the declaration and definition are combinedin one statement.As you see here, for functions, it is possible to separate the declaration and definition.For example, what we have here is a function declaration.It is introducing this name in our code, but we don’t really see how this function does its job.And if we want to see that, we will need to look at the definition for this function here down here,you see, we have the definition for this function.This is a definition and we have the body of the function.And in the body we can really see what this function is doing.So this is a function definition here for classes.For example, using the example here, this is also going to double as a declaration and a definition.It is a declaration because it is introducing the point name in our code.For example, we can create a point object and that’s going to work.The compiler is not going to be confused.It is a definition because we already have all the information to know what this type does.If you create it, you’re going to have the value stored in your member variables.And we have all the information about a point type in our code.So this is also a definition.Here is another example for classes, but we are using the class keyword here.We are not using struct like we did in the previous slide.This is also going to double as both a definition and a declaration.It is a declaration because it is introducing the person name in our code.We know what it is.So it is a class, but it is also a definition because we already have all the information here.We know its member variables, we know its constructor.So this is a declaration and the definition at the same time.But you know that it is possible to separate the members of a class into declaration and definitionand the definitions might show up at the outside of the class.And we’re going to see how you can do that in a minute.Okay.So this is really all I wanted you to know.The concepts of declarations and the definitions in the context of variables, functions and classes.Now that you have an idea about this, we’re going to head over to Visual Studio code and play withthis a little more.Okay.So here we are in our working folder.The current project is declarations and definitions.We’re going to grab our template files and put them in place.Let’s do that.And we are going to open this in Visual Studio code pretty quick.This is going to give us our main CPP file and we can clean up a little bit.So this is what we have.The first thing we’re going to do is play with free standing variables.We’re going to go on top here and declare a weight variable like we had in the slides and we’re goingto initialize this guy to zero.And one thing you should know is that this is going to double both as a declaration and a definition.It is a declaration because it is introducing the way to name in our program.So, for example, if we go down and try to print out the weight, this is going to be valid C plusplus program.The compiler is not going to wonder about this name here.It was introduced in our C plus plus program.It is also a definition because we already know what is inside this weight variable.We know that it has a value of zero.So this is both a declaration and a definition.If we build and run this program, it is going to work because it is really a valid C plus plus program.We can bring up a terminal and run it.No, we don’t want that.We want a terminal.So let’s run Rooster and we’re going to see that this program is going to print zero because that’swhat we have in here.If we happen to put in an eight, for example, 8.7, why not?We’re going to build again and we’re going to have our value in.If we run Rooster, we’re going to have our value in here and it is going to be printed out.So this is a declaration and a definition.Please note that in most cases variables are going to be set up like this, combining declaration anddefinitions.But it is possible, especially for static variables in classes, to be split into declaration and definition.If you ask me to break this into declaration and definition, I wouldn’t really know how to do that.If you happen to know that, please share.I am interested, but in most cases we’re going to declare and initialize the variables in one go likethis and this.Is going to double as a declaration and a definition.Somebody is going to say, Aha, what if I do something like this and maybe assign a value to the weighthere?Let’s do this to really remove this confusion.For example, you do something like this, they’re going to say maybe this is a declaration and thisis a definition.I hate to break it to you, but this is also a definition like we had before because this is going toinitialize weight anyway.So this is going to initialize weight to a junk value, but it is going to be initialized.So this is going to still be a declaration and the definition and here what you will be doing is justassigning to a variable that’s been already set up, declared and defined.So this is just an assignment here.You should know that.Okay.So if we comment this out, you’re going to see that the compiler is going to accept this.The code is going to compile.Let’s do that.You’re going to see what is good.And if we print whatever is in weight by running our program, as you see here, we’re going to geta junk value.And this happens to be zero in this case.So this is a declaration and the definition for free standing variables.Now, let’s talk about functions.If you set up a function like this, for example, we’re going to say add.We’re going to say double and we’re going to add up two parameters.We’re going to say A and B, and you do something like this and you return, for example, A plus B,this is going to double both as a declaration and a definition because we have the body of this functionhere.We know what this name is.We know it was introduced in our program.So it is a declaration.But we also know what this function does.It is going to add up two parameters and we know how it is going to add up those parameters becausewe can see the statement that is doing exactly that.So this is also a definition, but note that it is possible to break functions into declarations anddefinitions.Let’s comment this out and show you that option here.And I’m going to leave this in as a reference.We’re going to grab the signature of this little guy and we’re going to make it a declaration.Let’s do this.We’re going to put this in.And this is going to be our declaration.You already knew this, but I really wanted this to be super clear.We can now take this declaration here and go down and use it a little bit and set up a definition.We can do that.What we have below here is going to be our definition and we can go inside and do whatever we want todo in this function.And in this case, what we want to do is to add up A and B and return the result.So this is going to be our function here.And if we call it, it is going to work.If we go down here and say double result and say add 10 to 20, we have done this a thousand times,but we’re going to use this example again, we’re going to print the result and we’re going to printthis out.If we build and run this program, it is going to work because we have a declaration that is introducingthis Add name in our program, but we also have a definition that is saying how this function is doingits job.We can see that right here.So if we build this program, we’re going to use GCC like we always do.We’re going to clear the build is good.If we run Rooster, we’re going to see result to be 30.And if we change this, for example, to be 20.5 and above again, just to make sure that this programis working and I am not making this up, we’re going to see 30.5.So this is adding up what we have here.One thing you should know is that if you don’t have a definition in place for functions, you’re goingto get a linker error.Let’s do that.We’re going to comment out this definition and we’re going to try and build again.And you’re going to see that we’re going to get a problem.We’re going to see world finished with errors.And what we have here is an undefined reference to add.So this is a linker error.It is a linker error because we can see they returned one exit status here.But in a previous lecture we also saw that we could split computation in two steps compilation and linkingand we saw that you could see these linker errors if you don’t have definitions in place.So this is one way you can split your functions into declarations and definitions.It is also possible for the definition to live in some other file.So let’s bring up our sidebar here and create another file.We’re going to call it some other file.Why not?And it’s going to be a CPP file.What we’re going to do is move our definition there, so we’re going to copy it.Let’s copy what is inside the comment.So we’re going to copy this and we’re going to put this in some other file here.And the linker is going to be smart enough to search this entire directory looking for the definitionof this function.Now, if we compile, you’re going to see that the definition in main is gone, but we have a definitionin some other file.Now, if we try to compile the program again, it is going to work because we have a definition andyou’re going to see that the world is good because we have this definition here and now if we run theprogram, let’s clear and run Rooster.We’re going to see that it is going to work because we have a definition in place.Another thing we’re going to look at is declarations and the definitions in the context of classes.So let’s create a structure.We’re going to do a struct and we’re going to call it point like we have been doing all along.Inside, we’re going to have two member variables.We’re going to have M, X and m Y to represent the coordinates of our point type here.And I hate to break it to you, but this is also going to double as a declaration and a definition.And in most cases you’re going to see things like this called definitions.They’re going to say it’s a class definition and it’s going to do this and that.So this is going to be mostly called the definition, but note that it’s doubling as a declaration andthe definition it is a declaration because it is introducing the point name in our C plus plus program.It is a definition because we really have all the information we need to know about this point object.It is going to store its member variables in X and Y, so we already know all we need to know aboutthis little guy here.If you also set up a class, it is going to double as a declaration and the definition I am going tograb a class I have lying around on my system and I am going to put it in here because I don’t wantto type all this.We have a class called Person.It has a constructor here and we don’t have a body of this constructor.And so we can put it in.We’re going to say full name and we’re going to pass in names.Param, we’re going to use brace initialization and we’re going to do this on a separate line.I think that’s going to be much cleaner and we’re going to do H and we’re going to put in H parameterhere and we’re going to put in a body for this function here.I think this is all we need for this to be valid C plus plus code.So this is our constructor.We have a function to print information about a person object and we have our member variables here.Notice that we also have a static variable and this function here, so it will need to be initializedin some other CPP file and we can do that using a statement like this, we can say person and we’regoing to say person count because it is a static variable.We are going to specify its type and then we can initialize it to a value.For example.Eight We can do something like this from this.You should note that for this static variables, what we have inside the class here is a declaration.So you should note that.But the entire class here is also a declaration and a definition in one go.So in most cases, things like this are going to be called class definitions.But note that they also double as declarations.But it is possible to take member functions of classes and split them into declarations and definitions.Declarations are going to live inside the classes, but definitions can be put to the outside of theclass.And we’re going to show you an example of that using the constructor here.So we’re going to take out the initialization we have here and we’re going to leave in a declaration.So we’re going to do that.This is going to become a declaration for the constructor and we’re going to put the definition at theoutside so we can go down here, for example.A person.Person.And we’re going to put the body of our constructor down below here.Now, this code is going to work, and if we create a person object, we can go down here.I think we can comment out all we had before because it had served its purpose.It is now confusing us.So let’s do that.We’re going to comment all this out.We’re going to go down and create a person object.We can say person P one and we can give our person a name and an age.I think we can do that.Let’s see.Yes, we can do that.We can pass a first parameter as a name.We’re going to say Jon Snow, and we can give them an age, let’s say 27.Why not?And we can print information about this person.We can say P one Printinfo And if we build and run this program, I think it is going to work.Let’s bring this up a little bit.You see, the build is good.We can clear and run Rooster and we’re going to get name age, age.And if we want, we can also print the static variable here, but we don’t really want to do that.Okay, so now you know that a class itself is going to be a declaration and a definition, but for themember variables of the class, it is possible to split them into declarations and definitions.One thing I want you to see is that we can also move these things out.For example, the class here, it is cluttering our main CPP file.So what we can do is come back to the left here, bring up the sidebar, we can create a header filefor it.We’re going to say person dot age, and then we are going to put in our include guards.We are going to put them in here and we’re going to go down and say end.If I can’t really remember these things and we’re going to say that this is for person age and thenwe’re going to grab the class, we can copy it, let’s do that and we can grab the class here and we’regoing to put that in its separate file.We’re going to do that and we can come back in our main CPP file and now include the person We’re goingto do that.We’re going to say include person dot H, And I think we should also move the definitions for the staticvariable and the person constructor in a separate file.Let’s go back to person and see what problem we have here.What did we have in Main?We had i o stream.So it is complaining that it doesn’t know stdcout and the string.Let’s go on top here and include i o stream.Let’s do that.It should stop complaining here.Let’s wait a minute.So this is all good.If we go in main we see that we have no problem.If we compile our program, it is going to work.We’re going to see that the world is good even if we have our class definition in a separate file andsome definitions in the CPP file, you see that we have the definition for our static variable.In main, we have the definition for the constructor in main, but it is really not cool to have thisdefinitions in main so we can also take them and put them in a separate file.For example, we can move them in our some other file here.We’re going to put them in here.Okay.You see that the moment we do this, we’re going to get these errors because this file doesn’t knowwhat person is.So we’re going to go on top and include the person.And now we shouldn’t have a problem with this.Now the IDE or the editor is happy.We can build and run this and you’re going to see that it is going to work.And this is really all I wanted you to see in this lecture, that you can split things into declarationand definitions.And we really tried our best to explain the difference between declaration and definition and the contextof freestanding variables like we have here, the weight variable functions like the add function hereand the classes using point and person here as an example.And we saw that we could really split things between files.Once you understand the difference between a declaration and a definition, definitions can really livein any files.You have seen that the definition for the constructor here and the definition for the static file couldreally live anywhere.We were able to compile our code with these definitions.In Main, we are able to compile our code with this definitions in this file here.And this is really cool.Okay, before I wrap up this lecture, one thing I want you to see is that if any of these definitionsis not in place, you’re going to get a linker error.And it really proves this.We’re going to comment out the definition for the constructor of our class here, and we’re going totry and build our program.We’re going to build this with GCC.Let’s do that.And you’re going to.See that we get an error and the error is saying undefined reference to person person.So we don’t have a constructor here.Even if we have a declaration and our class here, you can see that it is not enough.The linker is going to complain because it needs to know how to construct person objects so we can comeback and bring this back in.And if we build, this is going to work.So we’re going to run with GCC and the build is going to be good.If we also don’t have this definition for person account, if we build the program, it is going towork and run fine because we already not using this static variable in our program.And let’s build to show you this and we’re going to see that the build is good and the program can run.We can clear and run Rooster.This is going to do whatever it is we want to do.But if this static variable is used anywhere in this class, for example, when we create a person object,we increment the person, count this is a logical thing to do because this is keeping track of how manyperson objects we have.If we’re trying to build this program now, we are going to get an error and that’s going to be a linkererror saying undefined reference to person count.But we have a person count declared in our class here.So some of you might be thinking, what the hell is going on here?But this is a declaration.It is not a definition and the linker really needs a definition to know what this variable is.So we need to go back in whatever CPP file where we have our declaration and we need to bring this backin.And if we build now, we’re going to see that the build is good and everything is working as expected.So I really want you to know that the definitions are important for your program to run.And this is really all I had to share in this lecture, shedding some light on declarations and thedefinitions in the context of free standing variables like the weight variable here functions like theadd functions and classes like point and person.As we have seen in this lecture, we are going to stop here in this one.In the next lecture, we’re going to learn about the one definition rule.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，欢迎来到 C++ 的奇妙世界！我将以C++资深开发者的经验和最佳教学方法，带你深入理解C++中两个核心概念：<strong>声明 (Declaration)</strong> 和 <strong>定义 (Definition)</strong>。</p>
<hr>
<h2 id="C-声明与定义：程序构建的基石"><a href="#C-声明与定义：程序构建的基石" class="headerlink" title="C++ 声明与定义：程序构建的基石"></a><strong>C++ 声明与定义：程序构建的基石</strong></h2><p><strong>摘要:</strong> 本讲将详细阐述C++程序中“声明”和“定义”这两个核心概念的含义、区别及其在变量、函数、类等不同语境下的应用。理解它们对于编写清晰、高效且可编译的C++代码至关重要，特别是在多文件项目中。</p>
<hr>
<h2 id="1-声明与定义：核心概念深度解析"><a href="#1-声明与定义：核心概念深度解析" class="headerlink" title="1. 声明与定义：核心概念深度解析"></a><strong>1. 声明与定义：核心概念深度解析</strong></h2><p>在C++编程中，<strong>声明 (Declaration)</strong> 和 <strong>定义 (Definition)</strong> 是理解程序如何构建的两个基本但又常常令人困惑的术语。</p>
<ul>
<li><p><strong>声明 (Declaration)</strong>: 声明是向 <strong>编译器 (Compiler)</strong> 介绍一个名字（例如变量名、函数名、类名）。它告诉编译器这个名字的存在，以及这个名字的一些基本信息，比如它的类型、参数列表等。声明的目的主要是为了让编译器知道这个名字是合法的，并且可以在当前 <strong>作用域 (Scope)</strong> 内被引用。它就像是告诉大家“有这么一个东西存在，它叫XXX，长这样”。</p>
<ul>
<li><strong>关键点</strong>: 声明仅仅是“告知”而非“实现”。一个名字可以被声明多次。</li>
</ul>
</li>
<li><p><strong>定义 (Definition)</strong>: 定义则是在声明的基础上，为这个名字提供完整的实现或具体内容。它告诉编译器和 <strong>链接器 (Linker)</strong> 这个名字“是什么”或“做什么”。对于变量，定义是分配内存并可能初始化其值；对于函数，定义是提供函数体内的实际执行代码；对于类，定义是提供类的完整结构（成员变量、成员函数等）。定义是实际的“实体”，它分配资源（内存）并提供行为。</p>
<ul>
<li><strong>关键点</strong>: 一个名字只能被定义一次 (One Definition Rule - ODR)，否则会导致链接错误。</li>
</ul>
</li>
</ul>
<p>现在，我们来更详细地看看在不同编程元素中声明和定义的具体表现。</p>
<h3 id="1-1-声明与定义的关系和编译-链接阶段"><a href="#1-1-声明与定义的关系和编译-链接阶段" class="headerlink" title="1.1 声明与定义的关系和编译/链接阶段"></a><strong>1.1 声明与定义的关系和编译/链接阶段</strong></h3><p>理解声明和定义之间的关系，以及它们在C++程序构建过程中的作用，是至关重要的。C++程序的构建通常分为两个主要阶段：</p>
<ol>
<li><p><strong>编译阶段 (Compilation Stage)</strong>:</p>
<ul>
<li><strong>任务</strong>: 编译器将你的源代码文件（<code>.cpp</code>文件）翻译成机器可以理解的 <strong>目标文件 (Object File)</strong>（例如Windows上的<code>.obj</code>，Linux上的<code>.o</code>）。</li>
<li><strong>声明的作用</strong>: 在这个阶段，编译器主要依赖声明来检查语法和类型。如果你尝试使用一个未声明的名字，编译器会立即报错（“undeclared identifier”）。编译器知道 <code>std::cout</code> 是一个合法的名字，因为它在 <code>iostream</code> 头文件中被声明了。</li>
</ul>
</li>
<li><p><strong>链接阶段 (Linking Stage)</strong>:</p>
<ul>
<li><strong>任务</strong>: 链接器将一个或多个目标文件以及任何所需的库文件（例如C++标准库）组合起来，生成最终的可执行程序。</li>
<li><strong>定义的作用</strong>: 链接器的工作是解析所有对外部符号（变量、函数等）的引用，并将它们与它们的实际定义连接起来。如果一个名字被声明了但在程序的任何地方都没有被定义（但被使用了），链接器就会报错（“undefined reference”）。它会找不到那个声明过的“东西”的实际实现。</li>
</ul>
</li>
</ol>
<h3 id="1-2-为什么区分声明和定义？"><a href="#1-2-为什么区分声明和定义？" class="headerlink" title="1.2 为什么区分声明和定义？"></a><strong>1.2 为什么区分声明和定义？</strong></h3><p>区分声明和定义的主要原因是为了：</p>
<ul>
<li><strong>模块化 (Modularity)</strong> 和 <strong>信息隐藏 (Information Hiding)</strong>: 允许在头文件 (<code>.h</code> 或 <code>.hpp</code>) 中放置声明，以便其他文件可以包含并使用这些实体，而无需知道其内部实现的细节。实际的定义则放在对应的 <code>.cpp</code> 文件中。这样可以提高代码的可维护性、可重用性，并减少编译时间（因为如果只修改实现，不需要重新编译所有使用它的文件）。</li>
<li><strong>分离编译 (Separate Compilation)</strong>: C++程序通常由多个 <code>.cpp</code> 文件组成。每个 <code>.cpp</code> 文件独立编译。声明允许一个文件引用在另一个文件中定义的实体。</li>
</ul>
<h3 id="1-3-不同场景下的声明与定义"><a href="#1-3-不同场景下的声明与定义" class="headerlink" title="1.3 不同场景下的声明与定义"></a><strong>1.3 不同场景下的声明与定义</strong></h3><p>让我们通过具体的例子来理解声明和定义在不同C++元素中的表现。</p>
<h4 id="1-3-1-变量-Variables"><a href="#1-3-1-变量-Variables" class="headerlink" title="1.3.1 变量 (Variables)"></a><strong>1.3.1 变量 (Variables)</strong></h4><p>对于<strong>自由变量 (Freestanding Variables)</strong>（即不在任何类或函数内部定义的全局变量），声明和定义通常是合二为一的。</p>
<ul>
<li><p><strong>声明与定义结合</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个变量的声明和定义，同时进行了初始化</span></span><br><span class="line"><span class="keyword">double</span> weight = <span class="number">0.0</span>;</span><br><span class="line"><span class="comment">// 声明：引入了名为 'weight' 的双精度浮点型变量</span></span><br><span class="line"><span class="comment">// 定义：分配了内存空间，并将其值初始化为 0.0</span></span><br></pre></td></tr></table></figure></div>
<p>当你写 <code>double weight = 0.0;</code> 时，编译器知道 <code>weight</code> 是一个 <code>double</code> 类型，并且它会为 <code>weight</code> 分配一块内存空间，并将 <code>0.0</code> 存储到这块内存中。<br>所以，对于局部变量，通常在声明的同时就完成了定义和初始化。</p>
</li>
<li><p><strong>仅声明（外部变量）</strong>:<br>虽然不常见，但全局变量可以被<strong>仅声明</strong>而<strong>不定义</strong>。这通过 <code>extern</code> 关键字实现。<code>extern</code> 关键字告诉编译器：“这个变量在别的地方定义了，你先别给它分配内存，我只是在这里声明它。”</p>
<ul>
<li><strong>文件 <code>file1.cpp</code></strong>:<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="keyword">double</span> global_variable = <span class="number">100.0</span>; <span class="comment">// 定义 (并初始化)</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>文件 <code>main.cpp</code></strong>:<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> global_variable; <span class="comment">// 声明：告诉编译器存在一个名为 global_variable 的双精度变量，</span></span><br><span class="line">                              <span class="comment">// 但其定义在其他地方</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Global variable: "</span> &lt;&lt; global_variable &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
在这里，<code>extern double global_variable;</code> 是一个纯粹的声明。它告诉 <code>main.cpp</code> 编译器 <code>global_variable</code> 存在，但它不会在 <code>main.cpp</code> 中分配内存。实际的内存分配发生在 <code>file1.cpp</code> 中。链接器最终会将 <code>main.cpp</code> 中对 <code>global_variable</code> 的引用解析到 <code>file1.cpp</code> 中的定义。</li>
</ul>
</li>
<li><p><strong>常见误解：<code>double weight;</code> 是声明还是定义？</strong><br>对于<strong>局部变量</strong>：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> weight; <span class="comment">// 这也是一个定义！它分配了内存，只是没有显式初始化，</span></span><br><span class="line">                   <span class="comment">// 其值是一个不确定的“垃圾值” (junk value)。</span></span><br><span class="line">    <span class="comment">// 这是一个赋值操作，不是定义</span></span><br><span class="line">    weight = <span class="number">8.7</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; weight &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当你写 <code>double weight;</code> 在函数内部时，编译器会为 <code>weight</code> 分配栈上的内存空间。即使没有显式初始化，这个内存空间也被“定义”为属于 <code>weight</code> 变量。后续的 <code>weight = 8.7;</code> 是一个<strong>赋值</strong>操作，而不是定义。如果这个变量是全局的或静态的，它会被自动零初始化。</p>
</li>
</ul>
<h4 id="1-3-2-函数-Functions"><a href="#1-3-2-函数-Functions" class="headerlink" title="1.3.2 函数 (Functions)"></a><strong>1.3.2 函数 (Functions)</strong></h4><p>函数是声明和定义分离最常见的例子，尤其是在大型项目中。</p>
<ul>
<li><p><strong>声明与定义结合</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个函数的声明和定义结合的形式</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123; <span class="comment">// 声明：函数签名 (signature) 引入 'add' 名称</span></span><br><span class="line">                                 <span class="comment">// 定义：包含函数体的实际代码</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当函数体紧跟着函数签名时，它既是声明（介绍了函数名、返回类型和参数），也是定义（提供了函数的具体实现）。</p>
</li>
<li><p><strong>分离声明 (Function Prototype) 与定义</strong>:<br>这是推荐的做法，尤其是在多文件项目中。函数声明通常被称为 <strong>函数原型 (Function Prototype)</strong>。</p>
<ul>
<li><p><strong>函数声明 (在头文件中或使用前)</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常在头文件 (e.g., my_math.h) 中</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>; <span class="comment">// 声明：告诉编译器存在一个名为 'add' 的函数，</span></span><br><span class="line">                               <span class="comment">// 接受两个 double 参数，返回一个 double 值。</span></span><br><span class="line">                               <span class="comment">// 但不包含函数体。</span></span><br></pre></td></tr></table></figure></div>
<p>这个声明告诉编译器 <code>add</code> 函数的存在和使用方式。编译器在遇到对 <code>add</code> 的调用时，会根据这个声明检查参数类型和数量是否匹配。</p>
</li>
<li><p><strong>函数定义 (在 <code>.cpp</code> 文件中)</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常在对应的源文件 (e.g., my_math.cpp) 中</span></span><br><span class="line"><span class="comment">// 注意：这里需要再次提供完整的函数签名，但关键是它提供了函数体</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123; <span class="comment">// 定义：提供了 'add' 函数的实际实现代码</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个定义包含了 <code>add</code> 函数的实际逻辑。链接器在程序中找到对 <code>add</code> 的所有调用，然后将它们连接到这个定义。</p>
</li>
</ul>
</li>
<li><p><strong>缺失定义时的链接器错误</strong>:<br>如果一个函数被声明并被调用，但其定义缺失，则会产生链接错误。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>; <span class="comment">// 声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = calculate(<span class="number">10.0</span>, <span class="number">5.0</span>); <span class="comment">// 调用了 calculate 函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Result: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// calculate 函数的定义在这里缺失！</span></span><br><span class="line"><span class="comment">// 如果没有另一个 .cpp 文件提供 calculate 的定义，链接器会报错</span></span><br></pre></td></tr></table></figure></div>
<p>编译 <code>main.cpp</code> 会成功，因为 <code>calculate</code> 被声明了。但在链接时，链接器会发现 <code>calculate</code> 函数被调用了，但它在任何目标文件中都找不到 <code>calculate</code> 的实际代码，于是会报“undefined reference to <code>calculate</code>”的链接错误。</p>
</li>
</ul>
<h4 id="1-3-3-类-Classes-和结构体-Structs"><a href="#1-3-3-类-Classes-和结构体-Structs" class="headerlink" title="1.3.3 类 (Classes) 和结构体 (Structs)"></a><strong>1.3.3 类 (Classes) 和结构体 (Structs)</strong></h4><p>类和结构体在 C++ 中是用户定义类型。它们的完整定义通常同时作为声明和定义。</p>
<ul>
<li><p><strong>声明与定义结合 (类/结构体本身)</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个 struct 的声明和定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="comment">// 声明：引入了 'Point' 这个名字</span></span><br><span class="line">               <span class="comment">// 定义：提供了 Point 类型的完整结构（成员变量 m_x, m_y）</span></span><br><span class="line">    <span class="keyword">double</span> m_x;</span><br><span class="line">    <span class="keyword">double</span> m_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>当你定义一个类或结构体时，你不仅引入了它的名字（例如 <code>Point</code>），还提供了关于它如何布局内存、包含哪些成员变量、成员函数等所有信息。因此，这个完整的结构体或类定义同时也是它的声明。</p>
</li>
<li><p><strong>分离成员函数 (Member Functions) 的声明与定义</strong>:<br>虽然类的定义本身通常是完整的，但类中的<strong>成员函数 (Member Functions)</strong> 可以像普通函数一样，将声明放在类内部，而将定义放在类外部，通常在 <code>.cpp</code> 文件中。</p>
<ul>
<li><p><strong>类声明 (通常在头文件 <code>person.h</code> 中)</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PERSON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 需要 string 类型的声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 需要 cout 等的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 成员变量声明</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_full_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员变量声明 (注意：这里只是声明，没有分配内存)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_person_count; <span class="comment">// s_person_count 是 static 成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数声明 (在类内部)</span></span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; full_name_param, <span class="keyword">int</span> age_param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数声明 (在类内部)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_person_count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PERSON_H</span></span></span><br></pre></td></tr></table></figure></div>
<p>在 <code>person.h</code> 中，<code>Person</code> 类被声明，它的成员变量和成员函数（包括构造函数和静态成员）也都在这里被声明了。编译器知道了 <code>Person</code> 类有哪些成员。</p>
</li>
<li><p><strong>成员函数定义 (通常在 <code>person.cpp</code> 中)</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.h"</span> <span class="comment">// 包含类的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量的定义 (必须在类外部，且通常在 .cpp 文件中进行，分配内存)</span></span><br><span class="line"><span class="comment">// 注意：这里不需要 'static' 关键字，因为 Person::s_person_count 已经通过其声明是静态的了。</span></span><br><span class="line"><span class="keyword">int</span> Person::s_person_count = <span class="number">0</span>; <span class="comment">// 定义并初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的定义 (使用作用域解析运算符 ::)</span></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; full_name_param, <span class="keyword">int</span> age_param)</span><br><span class="line">    : m_full_name(full_name_param), m_age(age_param) &#123;</span><br><span class="line">    s_person_count++; <span class="comment">// 每次创建 Person 对象时递增计数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; m_full_name &lt;&lt; <span class="string">", Age: "</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::get_person_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s_person_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 <code>person.cpp</code> 中，我们提供了 <code>Person</code> 类成员函数和静态成员变量的实际定义。这里的 <code>Person::</code> 是 <strong>作用域解析运算符 (Scope Resolution Operator)</strong>，它指明了这些定义属于 <code>Person</code> 类。</p>
</li>
</ul>
</li>
<li><p><strong>静态成员变量的特殊性</strong>:<br>静态成员变量 <code>s_person_count</code> 在类内部只是一个<strong>声明</strong>。它不占用类的实例的内存，而是所有对象共享的一份内存。因此，它必须在类外部的某个 <code>.cpp</code> 文件中进行<strong>定义</strong>并分配内存。如果没有这个定义，并且程序中使用了 <code>s_person_count</code>，就会导致链接错误。</p>
</li>
</ul>
<h3 id="1-4-总结声明与定义的关键规则"><a href="#1-4-总结声明与定义的关键规则" class="headerlink" title="1.4 总结声明与定义的关键规则"></a><strong>1.4 总结声明与定义的关键规则</strong></h3><ul>
<li><strong>声明</strong>可以多次，<strong>定义</strong>只能一次。</li>
<li><strong>声明</strong>告诉编译器一个名字存在。</li>
<li><strong>定义</strong>为这个名字分配内存并提供实际内容/实现。</li>
<li>如果一个名字被<strong>使用</strong>：<ul>
<li><strong>无声明</strong>: <strong>编译器错误</strong> (undeclared identifier)。</li>
<li><strong>有声明无定义</strong>: <strong>链接器错误</strong> (undefined reference)。</li>
</ul>
</li>
<li>如果一个名字<strong>从未使用</strong>：<ul>
<li><strong>有声明无定义</strong>: <strong>编译通过</strong> (因为没有被使用，链接器不需要寻找其定义)。</li>
</ul>
</li>
</ul>
<p>理解这些规则是编写复杂C++程序，尤其是涉及多个源文件和头文件的项目的基础。</p>
<hr>
<h2 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a><strong>2. 代码示例</strong></h2><p>让我们通过一个完整的项目结构来演示声明和定义的用法。</p>
<p><strong>项目结构:</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project_root&#x2F;</span><br><span class="line">├── main.cpp</span><br><span class="line">├── person.h</span><br><span class="line">├── person.cpp</span><br><span class="line">└── some_math.h</span><br><span class="line">└── some_math.cpp</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>some_math.h</code> (函数声明)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some_math.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SOME_MATH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOME_MATH_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 add 的声明 (Function Prototype)</span></span><br><span class="line"><span class="comment">// 告诉编译器存在一个名为 add 的函数，它的签名是 double add(double, double);</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SOME_MATH_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>some_math.cpp</code> (函数定义)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some_math.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"some_math.h"</span> <span class="comment">// 包含函数的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 add 的定义</span></span><br><span class="line"><span class="comment">// 提供函数 add 的实际实现代码</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>person.h</code> (类声明)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PERSON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 包含 C++ 标准库中的 string 类的声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 包含 C++ 标准库中的 iostream 声明 (用于 cout, endl)</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 成员变量声明</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_full_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员变量声明 (类内部的声明，不分配内存)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_person_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数声明</span></span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; full_name_param, <span class="keyword">int</span> age_param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_person_count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PERSON_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>person.cpp</code> (类成员定义)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.h"</span> <span class="comment">// 包含 Person 类的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量 s_person_count 的定义和初始化</span></span><br><span class="line"><span class="comment">// 这在程序启动时为其分配内存并赋初始值 0</span></span><br><span class="line"><span class="keyword">int</span> Person::s_person_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数 Person 的定义</span></span><br><span class="line"><span class="comment">// 使用作用域解析运算符 (::) 指明这是 Person 类的构造函数</span></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; full_name_param, <span class="keyword">int</span> age_param)</span><br><span class="line">    : m_full_name(full_name_param), m_age(age_param) &#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">    s_person_count++; <span class="comment">// 每创建一个 Person 对象，计数器加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数 print_info 的定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; m_full_name &lt;&lt; <span class="string">", Age: "</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员函数 get_person_count 的定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::get_person_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s_person_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>main.cpp</code> (主程序)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 包含 C++ 标准库中的 iostream 声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"some_math.h"</span> <span class="comment">// 包含 some_math.h 中的函数声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.h"</span>    <span class="comment">// 包含 person.h 中的类声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量的声明和定义</span></span><br><span class="line"><span class="keyword">double</span> global_weight = <span class="number">8.7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// --- 变量的声明与定义 ---</span></span><br><span class="line">    <span class="keyword">double</span> local_value = <span class="number">10.5</span>; <span class="comment">// 局部变量的声明和定义 (并初始化)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Global Weight: "</span> &lt;&lt; global_weight &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Local Value: "</span> &lt;&lt; local_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 函数的声明与定义 ---</span></span><br><span class="line">    <span class="comment">// 调用在 some_math.h 中声明、在 some_math.cpp 中定义的 add 函数</span></span><br><span class="line">    <span class="keyword">double</span> sum_result = add(global_weight, local_value);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum Result: "</span> &lt;&lt; sum_result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 类的声明与定义 ---</span></span><br><span class="line">    <span class="comment">// 创建 Person 对象 (使用 Person.h 中声明、Person.cpp 中定义的构造函数)</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Alice Smith"</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    p1.print_info(); <span class="comment">// 调用 Person.h 中声明、Person.cpp 中定义的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"Bob Johnson"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    p2.print_info();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问静态成员函数 (使用 Person.h 中声明、Person.cpp 中定义的静态成员函数)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Total Persons: "</span> &lt;&lt; Person::get_person_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong>如何编译这个项目 (以 GCC 为例):</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp some_math.cpp person.cpp -o my_program</span><br></pre></td></tr></table></figure></div><br>这个命令会将 <code>main.cpp</code>、<code>some_math.cpp</code> 和 <code>person.cpp</code> 分别编译成目标文件，然后将它们链接起来生成 <code>my_program</code> 可执行文件。如果缺少任何一个 <code>.cpp</code> 文件（例如 <code>person.cpp</code>），那么当 <code>main.cpp</code> 中使用了 <code>Person</code> 类的定义时，就会出现链接错误。</p>
<hr>
<h2 id="3-QA-闪卡-Flash-Cards"><a href="#3-QA-闪卡-Flash-Cards" class="headerlink" title="3. QA 闪卡 (Flash Cards)"></a><strong>3. QA 闪卡 (Flash Cards)</strong></h2><p><strong>Q1:</strong> 什么是声明 (Declaration)？<br><strong>A1:</strong> 声明是向编译器介绍一个名字（如变量名、函数名、类名），并提供其基本信息（如类型、参数列表），告知其存在且可在当前作用域内使用。</p>
<p><strong>Q2:</strong> 什么是定义 (Definition)？<br><strong>A2:</strong> 定义是为声明过的名字提供完整的实现或具体内容，如为变量分配内存、为函数提供实际代码、为类提供完整结构。</p>
<p><strong>Q3:</strong> 一个名字可以被声明多次吗？可以被定义多次吗？<br><strong>A3:</strong> 一个名字可以被声明多次，但只能被定义一次（C++ 的 <strong>One Definition Rule</strong>）。</p>
<p><strong>Q4:</strong> 如果一个函数被声明但没有定义，并且在程序中被调用了，会发生什么错误？<br><strong>A4:</strong> 会发生 <strong>链接器错误 (Linker Error)</strong>，通常是“undefined reference”（未定义引用）。编译器在编译时会通过，但链接器找不到实际的代码实现。</p>
<p><strong>Q5:</strong> <code>double value;</code> 在 <code>main</code> 函数内部时，它是声明还是定义？<br><strong>A5:</strong> 它是<strong>定义</strong>。它为 <code>value</code> 分配了内存空间，即使没有显式初始化，内存也已经被“定义”为属于这个变量。</p>
<hr>
<h2 id="4-常见误解和错误"><a href="#4-常见误解和错误" class="headerlink" title="4. 常见误解和错误"></a><strong>4. 常见误解和错误</strong></h2><ol>
<li><p><strong>“声明就是头文件，定义就是源文件”的过度简化</strong>:</p>
<ul>
<li><strong>误解</strong>: 有些初学者会简单地认为头文件里都是声明，源文件里都是定义。</li>
<li><strong>纠正</strong>: 虽然这是常见且推荐的做法，但并非绝对。例如，模板函数的定义通常也放在头文件中；内联函数 (inline function) 的定义也经常放在头文件中。类的完整定义（包含成员变量和在类内定义的成员函数）本身就是声明和定义的结合，通常也放在头文件中。关键在于理解声明和定义的本质，而不是简单地看文件类型。</li>
</ul>
</li>
<li><p><strong>混淆局部变量的“声明”和“赋值”</strong>:</p>
<ul>
<li><strong>误解</strong>: 认为 <code>int x;</code> 是声明，<code>x = 5;</code> 才是定义或初始化。</li>
<li><strong>纠正</strong>: <code>int x;</code>（在函数内部）已经是一个定义了，它为 <code>x</code> 分配了内存（尽管值不确定）。<code>x = 5;</code> 是一个赋值操作，不是定义。对于全局变量或静态变量，<code>int x;</code> 也是定义，并且会被自动零初始化。</li>
</ul>
</li>
<li><p><strong>忘记定义静态成员变量</strong>:</p>
<ul>
<li><strong>误解</strong>: 认为在类内部声明 <code>static int count;</code> 就足够了。</li>
<li><strong>纠正</strong>: <code>static int count;</code> 只是声明，它不为 <code>count</code> 分配内存。你必须在类外部的某个 <code>.cpp</code> 文件中提供其定义（例如 <code>int MyClass::count = 0;</code>）。如果使用了 <code>count</code> 而没有这个定义，就会导致链接错误。</li>
</ul>
</li>
<li><p><strong>在头文件中定义非内联函数或非模板函数</strong>:</p>
<ul>
<li><strong>误解</strong>: 为了方便，直接把函数定义（带函数体）写在头文件中。</li>
<li><strong>纠正</strong>: 除了内联函数和模板函数外，不应该在头文件中定义普通函数。如果这样做，并且这个头文件被多个 <code>.cpp</code> 文件包含，那么每个 <code>.cpp</code> 文件都会生成该函数的一个定义，最终在链接时违反 <strong>One Definition Rule (ODR)</strong>，导致“multiple definition”（重复定义）的链接错误。</li>
</ul>
</li>
<li><p><strong>认为没有 <code>extern</code> 关键字的全局变量就是声明</strong>:</p>
<ul>
<li><strong>误解</strong>: <code>int globalVar;</code> 放在 <code>.cpp</code> 文件顶部就是声明。</li>
<li><strong>纠正</strong>: 在全局作用域下，<code>int globalVar;</code> 默认就是<strong>定义</strong>（并零初始化）。如果你想在另一个 <code>.cpp</code> 文件中引用它，才需要使用 <code>extern int globalVar;</code> 进行声明。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-编程练习"><a href="#5-编程练习" class="headerlink" title="5. 编程练习"></a><strong>5. 编程练习</strong></h2><p>现在，是时候动手实践了！请完成以下代码，使其能够成功编译并运行。你的任务是补全缺失的声明和定义，使其符合C++的声明与定义规则。</p>
<p><strong>项目结构:</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exercise_root&#x2F;</span><br><span class="line">├── main.cpp</span><br><span class="line">├── math_operations.h</span><br><span class="line">├── math_operations.cpp</span><br><span class="line">└── rectangle.h</span><br><span class="line">└── rectangle.cpp</span><br></pre></td></tr></table></figure></div></p>
<hr>
<p><strong><code>math_operations.h</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math_operations.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MATH_OPERATIONS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATH_OPERATIONS_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数，名为 subtract，它接受两个 int 参数并返回一个 int</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在这里添加 subtract 函数的声明</span></span><br><span class="line"><span class="comment">// HINT: 记住函数声明的格式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MATH_OPERATIONS_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>math_operations.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math_operations.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math_operations.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在这里添加 subtract 函数的定义</span></span><br><span class="line"><span class="comment">// 该函数应返回两个参数的差 (第一个参数 - 第二个参数)</span></span><br></pre></td></tr></table></figure></div></p>
<hr>
<p><strong><code>rectangle.h</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rectangle.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RECTANGLE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECTANGLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">double</span> m_width;</span><br><span class="line">    <span class="keyword">double</span> m_height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数声明 (在类内部)</span></span><br><span class="line">    Rectangle(<span class="keyword">double</span> width_param, <span class="keyword">double</span> height_param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数声明 (在类内部)</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 声明一个名为 get_area 的成员函数，它不接受参数，返回 double 类型，且不修改对象状态</span></span><br><span class="line">    <span class="comment">// HINT: 记住 const 关键字</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// RECTANGLE_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>rectangle.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rectangle.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rectangle.h"</span> <span class="comment">// 包含 Rectangle 类的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数 Rectangle 的定义</span></span><br><span class="line">Rectangle::Rectangle(<span class="keyword">double</span> width_param, <span class="keyword">double</span> height_param)</span><br><span class="line">    : m_width(width_param), m_height(height_param) &#123;</span><br><span class="line">    <span class="comment">// 构造函数体为空，因为成员初始化列表已完成工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在这里添加 get_area 成员函数的定义</span></span><br><span class="line"><span class="comment">// 该函数应返回矩形的面积 (m_width * m_height)</span></span><br></pre></td></tr></table></figure></div></p>
<hr>
<p><strong><code>main.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math_operations.h"</span> <span class="comment">// 包含 math_operations 中的声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rectangle.h"</span>       <span class="comment">// 包含 rectangle 中的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 声明一个全局变量，名为 g_app_version，类型为 const std::string，并初始化为 "1.0.0"</span></span><br><span class="line"><span class="comment">// HINT: 全局变量的声明和定义通常合二为一，如果它是常量，可以直接定义。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Application Version: "</span> &lt;&lt; g_app_version &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 math_operations 中的 subtract 函数</span></span><br><span class="line">    <span class="keyword">int</span> result_subtract = subtract(<span class="number">100</span>, <span class="number">42</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"100 - 42 = "</span> &lt;&lt; result_subtract &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Rectangle 类</span></span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">5.0</span>, <span class="number">10.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> area = rect.get_area(); <span class="comment">// 调用 get_area 函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle Area: "</span> &lt;&lt; area &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>请你填写 <code>TODO</code> 部分的代码，然后告诉我你的解决方案。期待你的答案！</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>为什么Inline function可以在header中定义？</p>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常棒的问题！你观察得很仔细，而且思考得很深入，这正是一个优秀C++程序员应该具备的素质。</p>
<p>我们前面讲到，一个名字（比如函数）只能被 <strong>定义 (Definition)</strong> 一次，这就是 C++ 的 <strong>单一定义规则 (One Definition Rule - ODR)</strong>。如果违反了这条规则，在链接阶段就会出现“重复定义”(multiple definition) 的错误。所以，将普通函数的定义放在头文件中，然后这个头文件被多个 <code>.cpp</code> 文件包含时，每个 <code>.cpp</code> 文件都会生成一份该函数的定义，最终导致链接错误。</p>
<p>那么，为什么 <code>inline</code> (内联) 函数可以在头文件中定义呢？这正是 <code>inline</code> 关键字的一个关键作用！</p>
<p><code>inline</code> 关键字有两层含义：</p>
<ol>
<li><p><strong>首要含义（优化提示）</strong>: <code>inline</code> 关键字是对 <strong>编译器 (Compiler)</strong> 的一个 <strong>提示 (Hint)</strong>，建议编译器在编译时将函数的调用点直接替换为函数的实际代码，而不是生成一个函数调用指令。这就像把函数体“粘贴”到调用它的地方。这样可以消除函数调用的开销（如参数传递、栈帧管理），从而提高程序执行效率。但请注意，这只是一个<strong>提示</strong>，编译器有权决定是否真正进行内联。现代编译器非常智能，即使没有 <code>inline</code> 关键字，它们也可能对小型函数进行内联优化；反之，对于大型或复杂的 <code>inline</code> 函数，编译器也可能选择不内联。</p>
</li>
<li><p><strong>次要但更重要的含义（ODR 豁免）</strong>: 这是为什么 <code>inline</code> 函数可以在头文件中定义的核心原因。当一个函数被声明为 <code>inline</code> 时，C++ 标准放宽了对它的 <strong>单一定义规则 (ODR)</strong> 限制。它允许一个 <code>inline</code> 函数在程序的多个 <strong>翻译单元 (Translation Unit)</strong>（即 <code>.cpp</code> 文件经过预处理后的结果）中存在<strong>多个定义</strong>，但前提是所有这些定义都必须是<strong>完全相同</strong>的。</p>
<ul>
<li><strong>链接器如何处理？</strong> 当链接器遇到一个 <code>inline</code> 函数的多个相同定义时，它知道这是一个合法的 <code>inline</code> 函数，并且能够智能地选择其中一个定义或者以某种方式合并它们，以避免产生“重复定义”的链接错误。它不会像处理普通函数那样，看到多个定义就报错。</li>
</ul>
</li>
</ol>
<h2 id="为什么这种特性对于头文件很重要？"><a href="#为什么这种特性对于头文件很重要？" class="headerlink" title="为什么这种特性对于头文件很重要？"></a><strong>为什么这种特性对于头文件很重要？</strong></h2><p>将 <code>inline</code> 函数的定义放在头文件中，有以下几个主要优点：</p>
<ol>
<li><p><strong>实现真正的内联优化</strong>: 如果 <code>inline</code> 函数的定义不在头文件中，而是在一个 <code>.cpp</code> 文件中，那么当其他 <code>.cpp</code> 文件调用它时，编译器在编译调用点时看不到函数的实际代码。在这种情况下，编译器就无法执行内联优化。只有当函数的定义对编译器可见时，它才能进行内联。将定义放在头文件中，可以确保每个包含该头文件的 <code>.cpp</code> 文件在编译时都能看到函数体，从而使编译器有机会进行内联替换。</p>
</li>
<li><p><strong>简化使用</strong>: 将定义放在头文件中，用户只需包含头文件即可使用该 <code>inline</code> 函数，无需在额外的 <code>.cpp</code> 文件中定义。</p>
</li>
<li><p><strong>与模板函数类似</strong>: 实际上，C++ 中的 <strong>模板函数 (Template Functions)</strong> 也有类似的特性，它们的定义通常也必须放在头文件中。原因也是为了让编译器在实例化模板时能够看到其完整的定义。<code>inline</code> 关键字和模板的工作机制在打破 ODR 方面有异曲同工之妙。</p>
</li>
</ol>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><p><code>inline</code> 关键字的本质是告诉编译器：“这个函数可能很小，请考虑将其代码直接插入到调用点，并且如果这个函数的定义出现在多个地方，请链接器不要抱怨，只要它们完全相同就行。”</p>
<p>所以，当你在头文件中定义一个 <code>inline</code> 函数时，你实际上是告诉编译器和链接器：</p>
<ol>
<li>这个函数可能会被内联。</li>
<li>这个函数的定义可以在多个 <code>.cpp</code> 文件中重复出现，只要内容一致，就不要报错。</li>
</ol>
<p>理解这一点，对于你在 C++ 中正确组织代码，特别是处理头文件和源文件之间的关系，以及理解模板的工作方式，都至关重要。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Developer/">Developer    </a><a class="post-meta__tags" href="/tags/Programming/">Programming    </a><a class="post-meta__tags" href="/tags/Definition/">Definition    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/343%20-%20cpp%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7%E7%BF%BB%E8%BD%AC/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>343 - cpp链接属性翻转</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/notes/cpp%20%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>cpp 全局变量和常量</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/321 - 类内变量自引用/" title="321 - 类内变量自引用"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">321 - 类内变量自引用</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/340 - ODR Cpp/" title="340 - ODR Cpp"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">340 - ODR Cpp</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/256 - cpp decltype(auto)/" title="256 - cpp decltype(auto)"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">256 - cpp decltype(auto)</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/266 - building concept/" title="266 - building concept"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">266 - building concept</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/277 - IDE 创建 cpp 类方法/" title="277 - IDE 创建 cpp 类方法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">277 - IDE 创建 cpp 类方法</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/276 - Class across multiple files/" title="276 - Class across multiple files"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">276 - Class across multiple files</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>