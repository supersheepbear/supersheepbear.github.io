<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>266 - building concept | Bear's dream</title><meta name="description" content="266 - building concept"><meta name="keywords" content="Coding,Cpp,Learning,Development,Programming"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="266 - building concept"><meta name="twitter:description" content="266 - building concept"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="266 - building concept"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/266%20-%20building%20concept/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="266 - building concept"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/266%20-%20building%20concept/"><link rel="prev" title="273 - constructor" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/273%20-%20constructor/"><link rel="next" title="276 - Class across multiple files" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/276%20-%20Class%20across%20multiple%20files/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#266-Building-Concept"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">266 - Building Concept</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-标题和摘要"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">1. 标题和摘要</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-详细内容解释"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">2. 详细内容解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#include"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">include </span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#include-1"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">include </span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#include-需要包含"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">include  &#x2F;&#x2F; 需要包含</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-解决方案评价、标准答案及解释"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">7. 解决方案评价、标准答案及解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-建议与扩展问题-Suggestions-amp-Extended-Questions"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">8. 建议与扩展问题 (Suggestions &amp; Extended Questions)</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#266-Building-Concept"><span class="toc-number">1.</span> <span class="toc-text">266 - Building Concept</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-标题和摘要"><span class="toc-number">1.1.</span> <span class="toc-text">1. 标题和摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-详细内容解释"><span class="toc-number">1.2.</span> <span class="toc-text">2. 详细内容解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-代码示例"><span class="toc-number">1.3.</span> <span class="toc-text">3. 代码示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include"><span class="toc-number">2.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-1"><span class="toc-number">3.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-需要包含"><span class="toc-number">4.</span> <span class="toc-text">include  &#x2F;&#x2F; 需要包含</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-解决方案评价、标准答案及解释"><span class="toc-number">4.1.</span> <span class="toc-text">7. 解决方案评价、标准答案及解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-建议与扩展问题-Suggestions-amp-Extended-Questions"><span class="toc-number">4.2.</span> <span class="toc-text">8. 建议与扩展问题 (Suggestions &amp; Extended Questions)</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">266 - building concept</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/266%20-%20building%20concept/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/266%20-%20building%20concept/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="266-Building-Concept"><a href="#266-Building-Concept" class="headerlink" title="266 - Building Concept"></a>266 - Building Concept</h1><p><a href="https://gemini.google.com/u/2/app/2b1cb1ab39ffda6d" target="_blank" rel="external nofollow noopener noreferrer">https://gemini.google.com/u/2/app/2b1cb1ab39ffda6d</a></p>
<p>好的，同学！欢迎来到 C++ 的世界！我是你的专属 C++ 老师，拥有丰富的开发经验和教学技巧。别担心，就算你是 C++ 新手，我也会用最清晰、最易懂的方式，一步步带你掌握 C++ 的强大功能。</p>
<p>今天我们要学习的是 C++20 引入的一个非常酷的特性：<strong>如何创建你自己的概念 (Concepts)</strong>。这会让你编写的模板代码更安全、更清晰、也更容易理解。</p>
<hr>
<h2 id="1-标题和摘要"><a href="#1-标题和摘要" class="headerlink" title="1. 标题和摘要"></a><strong>1. 标题和摘要</strong></h2><p><strong>标题：</strong> C++ 概念：动手创建你自己的类型约束</p>
<p><strong>摘要：</strong> 本节课我们将学习如何在 C++20 中定义自己的概念 (Concept)。继上一课使用标准库 (Standard Library) 提供的概念后，本课将重点讲解两种创建自定义概念的语法：一种基于类型萃取 (Type Trait)，另一种使用 <code>requires</code> 子句 (requires clause) 来指定更复杂的语法 (syntax) 要求。我们还将学习如何将自定义概念应用到函数模板上。</p>
<hr>
<h2 id="2-详细内容解释"><a href="#2-详细内容解释" class="headerlink" title="2. 详细内容解释"></a><strong>2. 详细内容解释</strong></h2><p>我们上一课学习了如何使用 C++ 标准库里已经为我们准备好的概念。它们很好用，但有时我们需要更特定的约束，这时候就需要创建自己的概念了。别担心，这比听起来要简单！</p>
<p><strong>为什么要创建自己的概念？</strong></p>
<p>想象一下，你在写一个函数模板 (template)，比如一个加法函数 <code>add(T a, T b)</code>。你希望这个函数能用于整数、浮点数，但不能用于字符串或者其他不能相加的类型。在 C++20 之前，如果你传入了错误的类型，编译器 (compiler) 可能会报出一大堆难以理解的错误信息。而概念就像是给模板参数 T 定下的一系列“规矩”或“要求”，只有满足这些要求的类型才能被接受。如果传入的类型不满足要求，编译器会给出清晰的错误提示，告诉你“这个类型不满足某某概念的要求”。自定义概念让我们可以精确地定义这些“规矩”。</p>
<p><strong>创建自定义概念的两种主要语法：</strong></p>
<p><strong>语法一：基于类型萃取 (Type Trait)</strong></p>
<p>这是最简单的一种方式，适用于你的要求可以通过一个类型萃取来判断的情况。</p>
<ul>
<li><p><strong>语法结构：</strong></p>
<p>  C++</p>
  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; &#x2F;&#x2F; 首先，声明一个模板参数，比如 T</span><br><span class="line">concept 概念名称 &#x3D; std::某个类型萃取&lt;T&gt;::value; &#x2F;&#x2F; 或者使用 C++17 的 _v 简化版</span><br><span class="line">&#x2F;&#x2F; concept 关键字表明你正在定义一个概念</span><br><span class="line">&#x2F;&#x2F; 概念名称 是你给这个概念起的名字（通常用大驼峰命名法）</span><br><span class="line">&#x2F;&#x2F; &#x3D; 号后面是你定义的要求</span><br><span class="line">&#x2F;&#x2F; std::某个类型萃取&lt;T&gt;::value 是一个在编译时求值的布尔表达式。</span><br><span class="line">&#x2F;&#x2F; 如果这个表达式为 true，则类型 T 满足该概念；否则不满足。</span><br><span class="line">&#x2F;&#x2F; 别忘了最后的 ; 分号！</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>示例：定义一个 MyIntegral 概念</p>
<p>  假设我们想定义一个概念，要求类型必须是整型 (integral) 的（比如 int, char, long 等，但不包括 float, double）。我们可以使用标准库中的 std::is_integral 类型萃取：</p>
<p>  C++</p>
  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt; &#x2F;&#x2F; 需要包含 &lt;type_traits&gt; 头文件</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">concept MyIntegral &#x3D; std::is_integral_v&lt;T&gt;; &#x2F;&#x2F; 使用 _v 版本更简洁，它等价于 std::is_integral&lt;T&gt;::value</span><br></pre></td></tr></table></figure></div>
<p>  这段代码定义了一个名为 <code>MyIntegral</code> 的概念。任何类型 <code>T</code>，只要 <code>std::is_integral_v&lt;T&gt;</code> 在编译时计算结果为 <code>true</code>，那么它就满足 <code>MyIntegral</code> 这个概念。</p>
</li>
</ul>
<p><strong>语法二：使用 <code>requires</code> 子句 (requires clause)</strong></p>
<p>当你需要的约束比较复杂，不能简单地用一个类型萃取来表示时，或者你需要检查某些表达式的语法是否有效时，就需要用到 <code>requires</code> 子句。</p>
<ul>
<li><p><strong>语法结构：</strong></p>
<p>  C++</p>
  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, ...&gt; &#x2F;&#x2F; 可以有一个或多个模板参数</span><br><span class="line">concept 概念名称 &#x3D; requires(参数列表) &#123; &#x2F;&#x2F; 使用 requires 关键字</span><br><span class="line">    &#x2F;&#x2F; 在这里列出对类型的语法要求</span><br><span class="line">    表达式1;</span><br><span class="line">    表达式2;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;&#x2F; 每个要求都是一个表达式语句，必须以分号结尾</span><br><span class="line">    &#x2F;&#x2F; 这些表达式本身并不需要计算出有意义的值，编译器只检查它们的语法是否对给定类型有效</span><br><span class="line">&#125;; &#x2F;&#x2F; 别忘了最后的分号！</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>requires</code> 关键字后面可以跟一个可选的参数列表 <code>(参数列表)</code>，这里的参数就像是临时创建的、用于检查语法的变量。你可以给它们命名，比如 <code>(T a, T b)</code>。</li>
<li>花括号 <code>{}</code> 内部包含了一系列的要求（通常是表达式语句）。编译器会检查对于满足该概念的类型，这些语句在语法上是否都有效。</li>
</ul>
</li>
<li><p>示例 1：定义一个 Multipliable 概念</p>
<p>  我们想定义一个概念，要求两个该类型的对象能够使用 * 运算符相乘。</p>
<p>  C++</p>
  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">concept Multipliable &#x3D; requires(T a, T b) &#123; &#x2F;&#x2F; a 和 b 是用于语法检查的临时变量名</span><br><span class="line">    a * b; &#x2F;&#x2F; 检查 a * b 这个表达式的语法是否有效</span><br><span class="line">           &#x2F;&#x2F; 注意：这里只检查语法，不关心 a * b 的结果是什么，也不关心这个操作是否有意义</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>  如果类型 <code>T</code>（比如 <code>int</code> 或 <code>double</code>）的对象支持 <code>*</code> 运算，那么它就满足 <code>Multipliable</code> 概念。但如果 <code>T</code> 是 <code>std::string</code>，因为字符串不能直接相乘，所以它不满足这个概念。</p>
</li>
<li><p>示例 2：定义一个 Incrementable 概念</p>
<p>  我们想定义一个概念，要求某个类型的对象支持自增操作（前缀 ++、后缀 ++）和加法赋值 +=。</p>
<p>  C++</p>
  <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">concept Incrementable &#x3D; requires(T a) &#123;</span><br><span class="line">    a +&#x3D; 1;    &#x2F;&#x2F; 检查 a +&#x3D; 1 是否是有效语法</span><br><span class="line">    ++a;       &#x2F;&#x2F; 检查 ++a 是否是有效语法</span><br><span class="line">    a++;       &#x2F;&#x2F; 检查 a++ 是否是有效语法</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>  任何支持这三种操作的类型（比如 <code>int</code>, <code>double</code>, 甚至某些自定义的类）都满足 <code>Incrementable</code> 概念。</p>
</li>
</ul>
<p><strong>重要提醒：概念检查的是语法，不是语义或值！</strong></p>
<p>这一点非常重要！当你在 <code>requires</code> 子句中写 <code>a * b;</code> 时，编译器只检查对于类型 <code>T</code>，写 <code>a * b</code> 这行代码会不会导致编译错误。它并不检查 <code>a * b</code> 的结果是不是你期望的，也不检查这个乘法操作在逻辑上是否有意义。同样，<code>Incrementable</code> 概念只检查 <code>++a;</code> 等语句能否编译通过，不检查 <code>a</code> 的值到底增加了多少。</p>
<p><strong>如何使用自定义概念？</strong></p>
<p>一旦你定义了自己的概念，就可以像使用标准库概念一样，用它来约束你的模板了。主要有四种语法形式（和我们上一课学的一样）：</p>
<p>假设我们有之前定义的 <code>MyIntegral</code> 概念和一个 <code>add</code> 函数模板：</p>
<ol>
<li><p><strong><code>requires</code> 子句放在模板声明之后，函数声明之前：</strong></p>
<p> C++</p>
 <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires MyIntegral&lt;T&gt; &#x2F;&#x2F; 要求 T 必须满足 MyIntegral 概念</span><br><span class="line">T add(T a, T b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>直接在模板参数列表中使用概念名：</strong></p>
<p> C++</p>
 <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;MyIntegral T&gt; &#x2F;&#x2F; 直接声明 T 是一个满足 MyIntegral 的类型</span><br><span class="line">T add(T a, T b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>拖尾 <code>requires</code> 子句 (Trailing requires clause)：</strong></p>
<p> C++</p>
 <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T add(T a, T b) requires MyIntegral&lt;T&gt; &#123; &#x2F;&#x2F; requires 子句放在函数参数列表之后</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>与 <code>auto</code> 结合使用（用于函数参数）：</strong></p>
<p> C++</p>
 <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对于函数参数，可以直接用 概念名 auto 的形式</span><br><span class="line">&#x2F;&#x2F; 注意：返回值类型如果是 auto，也需要约束，或者明确写出类型</span><br><span class="line">MyIntegral auto add(MyIntegral auto a, MyIntegral auto b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 或者写成</span><br><span class="line">&#x2F;&#x2F; auto add(MyIntegral auto a, MyIntegral auto b) -&gt; MyIntegral auto &#123; &#x2F;&#x2F; C++20 返回类型推导也可以用概念</span><br><span class="line">&#x2F;&#x2F;     return a + b;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line">&#x2F;&#x2F; 更常见的是明确返回值类型或让其自动推导（如果约束允许）</span><br><span class="line">&#x2F;&#x2F; auto add(MyIntegral auto a, MyIntegral auto b) &#123; &#x2F;&#x2F; 返回类型自动推导</span><br><span class="line">&#x2F;&#x2F;     return a + b;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>这四种语法在使用上是等价的，你可以选择自己喜欢的风格。它们都能达到同样的效果：约束传递给 <code>add</code> 函数的参数类型 <code>T</code> 必须满足 <code>MyIntegral</code> 概念。如果尝试用不满足概念的类型（比如 <code>double</code>）去调用 <code>add</code> 函数，编译器会给出清晰的错误信息，指出违反了 <code>MyIntegral</code> 概念。</p>
<hr>
<h2 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a><strong>3. 代码示例</strong></h2><p>下面是一个完整的代码示例，演示了如何定义和使用我们上面讨论的 <code>MyIntegral</code>, <code>Multipliable</code>, 和 <code>Incrementable</code> 概念：</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;concepts&gt;      &#x2F;&#x2F; 包含 &lt;concepts&gt; 头文件以使用概念</span><br><span class="line">#include &lt;type_traits&gt;   &#x2F;&#x2F; 包含 &lt;type_traits&gt; 头文件以使用类型萃取</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --- 概念定义 ---</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 语法一：基于类型萃取</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">concept MyIntegral &#x3D; std::is_integral_v&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 语法二：使用 requires 子句</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">concept Multipliable &#x3D; requires(T a, T b) &#123;</span><br><span class="line">    a * b; &#x2F;&#x2F; 检查语法 a * b 是否有效</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">concept Incrementable &#x3D; requires(T a) &#123;</span><br><span class="line">    a +&#x3D; 1;</span><br><span class="line">    ++a;</span><br><span class="line">    a++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --- 使用概念的函数模板 ---</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 MyIntegral 概念 (语法2：直接在模板参数中使用)</span><br><span class="line">template &lt;MyIntegral T&gt;</span><br><span class="line">T add_integral(T a, T b) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;调用 add_integral: &quot;;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 Multipliable 概念 (语法1：requires 子句在前)</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires Multipliable&lt;T&gt;</span><br><span class="line">void check_multipliable(T a, T b) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;类型支持乘法操作 (*)。\n&quot;;</span><br><span class="line">    &#x2F;&#x2F; 注意：这里只是检查了概念，函数内部不一定真的需要执行 a*b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 Incrementable 概念 (语法4：使用 auto)</span><br><span class="line">void check_incrementable(Incrementable auto val) &#123;</span><br><span class="line">     std::cout &lt;&lt; &quot;类型支持自增操作 (++a, a++, a+&#x3D;1)。\n&quot;;</span><br><span class="line">     &#x2F;&#x2F; 可以在函数内部安全地使用这些操作</span><br><span class="line">     val++;</span><br><span class="line">     ++val;</span><br><span class="line">     val +&#x3D; 1;</span><br><span class="line">     std::cout &lt;&lt; &quot;自增操作后的值 (示例): &quot; &lt;&lt; val &lt;&lt; std::endl; &#x2F;&#x2F; 只是为了演示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i1 &#x3D; 5, i2 &#x3D; 10;</span><br><span class="line">    double d1 &#x3D; 3.14, d2 &#x3D; 2.71;</span><br><span class="line">    std::string s1 &#x3D; &quot;Hello&quot;, s2 &#x3D; &quot; World&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 测试 MyIntegral 概念</span><br><span class="line">    std::cout &lt;&lt; add_integral(i1, i2) &lt;&lt; std::endl; &#x2F;&#x2F; 输出: 调用 add_integral: 15</span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; add_integral(d1, d2) &lt;&lt; std::endl; &#x2F;&#x2F; 编译错误！double 不满足 MyIntegral</span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; add_integral(s1, s2) &lt;&lt; std::endl; &#x2F;&#x2F; 编译错误！string 不满足 MyIntegral</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;\n--- 测试 Multipliable 概念 ---\n&quot;;</span><br><span class="line">    check_multipliable(i1, i2); &#x2F;&#x2F; 输出: 类型支持乘法操作 (*)。</span><br><span class="line">    check_multipliable(d1, d2); &#x2F;&#x2F; 输出: 类型支持乘法操作 (*)。</span><br><span class="line">    &#x2F;&#x2F; check_multipliable(s1, s2); &#x2F;&#x2F; 编译错误！string 不支持 * 操作符</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;\n--- 测试 Incrementable 概念 ---\n&quot;;</span><br><span class="line">    check_incrementable(i1);    &#x2F;&#x2F; 输出: 类型支持自增操作... 自增操作后的值 (示例): 8</span><br><span class="line">    check_incrementable(d1);    &#x2F;&#x2F; 输出: 类型支持自增操作... 自增操作后的值 (示例): 6.14</span><br><span class="line">    &#x2F;&#x2F; check_incrementable(s1); &#x2F;&#x2F; 编译错误！string 不支持自增操作</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 你也可以对指针用 Incrementable (指针支持 ++ 和 +&#x3D; 整数)</span><br><span class="line">    int arr[] &#x3D; &#123;1, 2, 3&#125;;</span><br><span class="line">    int* ptr &#x3D; arr;</span><br><span class="line">    std::cout &lt;&lt; &quot;\n测试指针的 Incrementable:\n&quot;;</span><br><span class="line">    check_incrementable(ptr); &#x2F;&#x2F; 输出: 类型支持自增操作... (指针移动后的地址)</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>编译和运行:</p>
<p>你需要一个支持 C++20 的编译器（例如 GCC 10+ 或 Clang 10+）。编译时需要启用 C++20 标准。</p>
<p>例如，使用 g++：</p>
<p>g++ -std=c++20 your_code_file.cpp -o your_executable</p>
<p>然后运行：</p>
<p>./your_executable</p>
<p>你会看到成功的输出，并且如果你取消注释掉那些会导致编译错误的行，编译器会给出清晰的关于概念约束不满足的错误信息。</p>
<hr>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### **4. QA 闪卡 (QA Flash Cards)**</span><br><span class="line"></span><br><span class="line">- Q: C++ 中的“概念 (Concept)”是什么？</span><br><span class="line">    </span><br><span class="line">    A: 概念是 C++20 引入的一种特性，它允许我们为模板参数指定一组明确的要求或约束。只有满足这些约束的类型才能用于实例化该模板。</span><br><span class="line">    </span><br><span class="line">- Q: 为什么要使用概念？</span><br><span class="line">    </span><br><span class="line">    A: 提高代码清晰度、增强类型安全、在编译时捕获类型错误、并产生更友好的编译器错误信息。</span><br><span class="line">    </span><br><span class="line">- Q: 定义自定义概念的第一种语法是什么？它基于什么？</span><br><span class="line">    </span><br><span class="line">    A: template &lt;typename T&gt; concept Name &#x3D; 式子; 其中式子通常是一个类型萃取 (Type Trait) 的编译时布尔结果，如 std::is_integral_v&lt;T&gt;。</span><br><span class="line">    </span><br><span class="line">- Q: 定义自定义概念的第二种语法是什么？它使用哪个关键字？</span><br><span class="line">    </span><br><span class="line">    A: 使用 requires 子句：template &lt;typename T&gt; concept Name &#x3D; requires(T a) &#123; &#x2F;* 语法要求 *&#x2F;; &#125;;</span><br><span class="line">    </span><br><span class="line">- Q: requires 子句中的表达式检查的是什么？是语法还是语义&#x2F;值？</span><br><span class="line">    </span><br><span class="line">    A: 只检查语法 (syntax)。编译器判断这些表达式对于给定类型是否能够编译通过，不关心表达式的计算结果或逻辑意义。</span><br><span class="line">    </span><br><span class="line">- Q: 如何将自定义概念 MyConcept 应用到一个函数模板 func 的参数 T 上？(至少说出两种方法)</span><br><span class="line">    </span><br><span class="line">    A: 1. template &lt;MyConcept T&gt; void func(T t); 2. template &lt;typename T&gt; requires MyConcept&lt;T&gt; void func(T t); 3. template &lt;typename T&gt; void func(T t) requires MyConcept&lt;T&gt;; 4. void func(MyConcept auto t);</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## **5. 常见误解与易犯错误 (Common Misunderstandings&#x2F;Mistakes)**</span><br><span class="line"></span><br><span class="line">1. **误解概念检查语义：** 最常见的误解是认为概念会检查操作的逻辑意义。例如，认为 &#96;Multipliable&#96; 概念能防止你用一个矩阵类乘以一个不兼容维度的矩阵类（如果乘法操作符本身语法有效的话）。记住，概念只检查语法。</span><br><span class="line">2. **忘记 &#96;#include &lt;concepts&gt;&#96;：** 使用概念（无论是标准库的还是自定义的）通常需要包含 &#96;&lt;concepts&gt;&#96; 头文件。如果使用类型萃取，还需要 &#96;#include &lt;type_traits&gt;&#96;。</span><br><span class="line">3. **语法错误：**</span><br><span class="line">    - 忘记概念定义末尾的分号 &#96;;&#96;。</span><br><span class="line">    - &#96;requires&#96; 子句后面忘记参数列表 &#96;(T a)&#96;（即使为空也要写 &#96;()&#96;，但通常需要参数来检查表达式）或忘记花括号 &#96;&#123;&#125;&#96;。</span><br><span class="line">    - &#96;requires&#96; 子句花括号内的要求语句忘记以分号 &#96;;&#96; 结尾。</span><br><span class="line">4. **混淆 &#96;requires&#96; 关键字的两种用法：** &#96;requires&#96; 既可以用于定义概念（&#96;concept Name &#x3D; requires(...) &#123;...&#125;;&#96;），也可以用于应用概念到模板上（&#96;template &lt;typename T&gt; requires Concept&lt;T&gt; ...&#96; 或 &#96;... requires Concept&lt;T&gt; &#123; ... &#125;&#96;）。注意区分它们的位置和作用。</span><br><span class="line">5. **过度约束：** 有时候可能会定义过于严格的概念，导致一些原本可以工作的类型被拒绝。要仔细考虑你的模板真正需要的最小语法要求是什么。</span><br><span class="line">6. **写成 &#96;require&#96; 而不是 &#96;requires&#96;：** 这是一个常见的拼写错误。关键字是 &#96;requires&#96;。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## **6. 编码练习 (Coding Exercise)**</span><br><span class="line"></span><br><span class="line">现在轮到你来实践了！请你定义一个名为 &#96;Printable&#96; 的概念。这个概念需要检查一个类型 &#96;T&#96; 是否满足以下两个条件：</span><br><span class="line"></span><br><span class="line">1. 该类型的对象 &#96;t&#96; 可以被输出到 &#96;std::ostream&#96;（例如 &#96;std::cout&#96;）。也就是说，&#96;std::cout &lt;&lt; t;&#96; 这条语句在语法上是有效的。</span><br><span class="line">2. 该类型的对象支持大于比较运算符 &#96;&gt;&#96;。也就是说，&#96;t &gt; t;&#96; 这条语句在语法上是有效的。</span><br><span class="line"></span><br><span class="line">然后，补全下面的函数模板 &#96;compare_and_print&#96;，使其参数 &#96;T&#96; 必须满足你定义的 &#96;Printable&#96; 概念，并完成函数体内的逻辑。</span><br><span class="line"></span><br><span class="line">C++</span><br></pre></td></tr></table></figure></div>
<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></string></h1><h1 id="include-需要包含"><a href="#include-需要包含" class="headerlink" title="include  // 需要包含"></a>include <concepts> // 需要包含</concepts></h1><p>// TODO: 在这里定义你的 Printable 概念<br>// template <typename ???><br>// concept Printable = requires(???) {<br>//     ??? ; // 检查输出流操作<br>//     ??? ; // 检查大于比较操作<br>// };</typename></p>
<p>// TODO: 使用 Printable 概念约束模板参数 T<br>// ??? ??? compare_and_print(??? a, ??? b) {<br>//     std::cout &lt;&lt; “比较并打印: \n”;<br>//     std::cout &lt;&lt; “第一个值: “ &lt;&lt; a &lt;&lt; std::endl;<br>//     std::cout &lt;&lt; “第二个值: “ &lt;&lt; b &lt;&lt; std::endl;<br>//     if (a &gt; b) {<br>//         std::cout &lt;&lt; “第一个值更大。\n”;<br>//     } else if (b &gt; a) { // 为了更完整，我们也检查 b &gt; a<br>//         std::cout &lt;&lt; “第二个值更大。\n”;<br>//     } else {<br>//         std::cout &lt;&lt; “两个值相等（根据&gt;判断）。\n”;<br>//     }<br>// }</p>
<p>struct NonPrintable { // 这个结构体不支持 &lt;&lt; 输出<br>    int value;<br>    bool operator&gt;(const NonPrintable&amp; other) const { return value &gt; other.value; }<br>};</p>
<p>struct NonComparable { // 这个结构体不支持 &gt; 比较<br>    int value;<br>};<br>// 让 NonComparable 可打印<br>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NonComparable&amp; nc) {<br>    os &lt;&lt; nc.value;<br>    return os;<br>}</p>
<p>int main() {<br>    int x = 10, y = 5;<br>    compare_and_print(x, y); // 应该可以工作</p>
<pre><code>std::string s1 = &quot;apple&quot;, s2 = &quot;banana&quot;;
compare_and_print(s1, s2); // 应该可以工作 (string 支持 &lt;&lt; 和 &gt;)

// NonPrintable np1{1}, np2{2};
// compare_and_print(np1, np2); // TODO: 取消注释这一行，应该导致编译错误 (不满足 Printable)

// NonComparable nc1{3}, nc2{4};
// compare_and_print(nc1, nc2); // TODO: 取消注释这一行，应该导致编译错误 (不满足 Printable)

return 0;
</code></pre><p>}</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">请你填充上面代码中 &#96;&#x2F;&#x2F; TODO:&#96; 标记的部分。完成后，把你的答案发给我。我会帮你检查并给出反馈！加油！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">homework:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#include &lt;concepts&gt;  &#x2F;&#x2F; 需要包含</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO: 在这里定义你的 Printable 概念</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; template &lt;typename T&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; concept Printable &#x3D; requires(???) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;     ??? ; &#x2F;&#x2F; 检查输出流操作</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;     ??? ; &#x2F;&#x2F; 检查大于比较操作</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line"></span><br><span class="line">concept Printable &#x3D; requires(T a, T b) &#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; b;</span><br><span class="line"></span><br><span class="line">    a &gt; b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO: 使用 Printable 概念约束模板参数 T</span><br><span class="line"></span><br><span class="line">template &lt;Printable T&gt;</span><br><span class="line"></span><br><span class="line">auto compare_and_print(T a, T b) &#123;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;比较并打印: \n&quot;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;第一个值: &quot; &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;第二个值: &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    if (a &gt; b) &#123;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; &quot;第一个值更大。\n&quot;;</span><br><span class="line"></span><br><span class="line">    &#125; else if (b &gt; a) &#123;  &#x2F;&#x2F; 为了更完整，我们也检查 b &gt; a</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; &quot;第二个值更大。\n&quot;;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; &quot;两个值相等（根据&gt;判断）。\n&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">struct NonPrintable &#123;  &#x2F;&#x2F; 这个结构体不支持 &lt;&lt; 输出</span><br><span class="line"></span><br><span class="line">    int value;</span><br><span class="line"></span><br><span class="line">    bool operator&gt;(const NonPrintable&amp; other) const &#123;</span><br><span class="line"></span><br><span class="line">        return value &gt; other.value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">struct NonComparable &#123;  &#x2F;&#x2F; 这个结构体不支持 &gt; 比较</span><br><span class="line"></span><br><span class="line">    int value;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 让 NonComparable 可打印</span><br><span class="line"></span><br><span class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NonComparable&amp; nc) &#123;</span><br><span class="line"></span><br><span class="line">    os &lt;&lt; nc.value;</span><br><span class="line"></span><br><span class="line">    return os;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    int x &#x3D; 10, y &#x3D; 5;</span><br><span class="line"></span><br><span class="line">    compare_and_print(x, y);  &#x2F;&#x2F; 应该可以工作</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    std::string s1 &#x3D; &quot;apple&quot;, s2 &#x3D; &quot;banana&quot;;</span><br><span class="line"></span><br><span class="line">    compare_and_print(s1, s2);  &#x2F;&#x2F; 应该可以工作 (string 支持 &lt;&lt; 和 &gt;)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; NonPrintable np1&#123;1&#125;, np2&#123;2&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; compare_and_print(np1, np2); &#x2F;&#x2F; TODO: 取消注释这一行，应该导致编译错误</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; (不满足 Printable)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; NonComparable nc1&#123;3&#125;, nc2&#123;4&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; compare_and_print(nc1, nc2); &#x2F;&#x2F; TODO: 取消注释这一行，应该导致编译错误</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; (不满足 Printable)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>非常棒！你做得非常好！你提交的代码完全正确地实现了我们要求的功能。</p>
<hr>
<h2 id="7-解决方案评价、标准答案及解释"><a href="#7-解决方案评价、标准答案及解释" class="headerlink" title="7. 解决方案评价、标准答案及解释"></a><strong>7. 解决方案评价、标准答案及解释</strong></h2><p><strong>评价:</strong></p>
<ul>
<li><strong>评分:</strong> ⭐⭐⭐⭐⭐ (5/5 - 非常出色!)</li>
<li><strong>评价:</strong><ul>
<li>你准确地定义了 <code>Printable</code> 概念，使用了 <code>requires</code> 子句来检查两个关键的语法要求：流输出操作 (<code>std::cout &lt;&lt; a;</code>) 和大于比较操作 (<code>a &gt; b;</code>)。参数列表 <code>(T a, T b)</code> 的使用也很恰当。</li>
<li>你成功地将 <code>Printable</code> 概念应用到了 <code>compare_and_print</code> 函数模板上，使用了简洁的 <code>template &lt;Printable T&gt;</code> 语法。</li>
<li>函数体内的逻辑与概念所保证的约束一致。</li>
<li>代码结构清晰，易于理解。</li>
</ul>
</li>
</ul>
<p><strong>标准答案与解释:</strong></p>
<p>你的答案本身就是非常标准的答案！这里我再把它贴出来，并加上一些注释，同时展示一个稍微不同的检查流输出的方式（你的方法也是完全正确的）：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;concepts&gt; // 需要包含</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;  // 包含 &lt;ostream&gt; 以便使用 std::ostream</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Printable 概念定义 ---</span></span><br><span class="line"><span class="comment">// 你的定义方式，完全正确！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Printable_V1 = <span class="keyword">requires</span>(T a, T b) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// 检查是否能输出到 std::cout</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; b; // 检查 b 其实是多余的，因为 a 和 b 类型相同，但无害</span></span><br><span class="line">    a &gt; b;         <span class="comment">// 检查是否支持 &gt; 运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种常见的检查流输出的方式（也正确）</span></span><br><span class="line"><span class="comment">// 这种方式更通用，因为它不依赖于全局的 std::cout，而是检查任何 std::ostream</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Printable_V2 = <span class="keyword">requires</span>(T val, T other_val, <span class="built_in">std</span>::ostream&amp; os) &#123;</span><br><span class="line">    os &lt;&lt; val;       <span class="comment">// 检查是否能输出到任何 ostream 对象</span></span><br><span class="line">    val &gt; other_val; <span class="comment">// 检查是否支持 &gt; 运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在下面使用你的版本 Printable_V1，因为它简洁有效</span></span><br><span class="line"><span class="keyword">using</span> Printable = Printable_V1; <span class="comment">// 给你的版本起个别名，方便下面使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 使用 Printable 概念约束模板参数 T ---</span></span><br><span class="line"><span class="comment">// 使用语法2：直接在模板参数列表中使用概念名</span></span><br><span class="line"><span class="keyword">template</span> &lt;Printable T&gt;</span><br><span class="line"><span class="comment">// 返回类型用 void 更明确，因为函数没有返回值；用 auto 也可以，会自动推导为 void</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compare_and_print</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"比较并打印: \n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"第一个值: "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 安全，因为 Printable 保证了 &lt;&lt; 操作有效</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"第二个值: "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 安全</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123; <span class="comment">// 安全，因为 Printable 保证了 &gt; 操作有效</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"第一个值更大。\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &gt; a) &#123; <span class="comment">// 出于完整性检查 b &gt; a</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"第二个值更大。\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"两个值相等（根据&gt;判断）。\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"------\n"</span>; <span class="comment">// 加个分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 用于测试的结构体 ---</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NonPrintable</span> &#123;</span> <span class="comment">// 这个结构体不支持 &lt;&lt; 输出</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> NonPrintable&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> value &gt; other.value; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NonComparable</span> &#123;</span> <span class="comment">// 这个结构体不支持 &gt; 比较</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 让 NonComparable 可打印</span></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> NonComparable&amp; nc) &#123;</span><br><span class="line">    os &lt;&lt; nc.value;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">5</span>;</span><br><span class="line">    compare_and_print(x, y); <span class="comment">// 输出：比较并打印... 第一个值更大。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">"apple"</span>, s2 = <span class="string">"banana"</span>;</span><br><span class="line">    compare_and_print(s1, s2); <span class="comment">// 输出：比较并打印... 第二个值更大。</span></span><br><span class="line"></span><br><span class="line">    NonPrintable np1&#123;<span class="number">1</span>&#125;, np2&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// compare_and_print(np1, np2); // 取消注释后，编译失败！NonPrintable 不满足 Printable (缺少 &lt;&lt;)</span></span><br><span class="line"></span><br><span class="line">    NonComparable nc1&#123;<span class="number">3</span>&#125;, nc2&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// compare_and_print(nc1, nc2); // 取消注释后，编译失败！NonComparable 不满足 Printable (缺少 &gt;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当你取消注释掉最后两个 <code>compare_and_print</code> 调用并尝试编译时，你会得到清晰的编译器错误信息，指出约束 <code>Printable</code> 未满足，这正是概念带来的好处！</p>
<hr>
<h2 id="8-建议与扩展问题-Suggestions-amp-Extended-Questions"><a href="#8-建议与扩展问题-Suggestions-amp-Extended-Questions" class="headerlink" title="8. 建议与扩展问题 (Suggestions &amp; Extended Questions)"></a><strong>8. 建议与扩展问题 (Suggestions &amp; Extended Questions)</strong></h2><p>你已经掌握了自定义概念的基础！为了进一步深化理解，可以思考和探索以下问题：</p>
<ol>
<li><strong>组合概念：</strong> 如果你有一个 <code>Addable</code> 概念检查 <code>a + b</code> 是否有效，你如何定义一个新的概念 <code>AddableAndPrintable</code>，要求一个类型必须 <em>同时</em> 满足 <code>Addable</code> 和 <code>Printable</code> 两个概念？（提示：想想逻辑运算符）</li>
<li><p><strong><code>requires</code> 表达式 (Requires Expressions)：</strong> 在 <code>requires</code> 子句内部，我们不仅可以写简单的表达式语句，还可以使用更复杂的 <code>requires</code> <em>表达式</em> 来进行更精细的检查。例如，如何检查 <code>a &gt; b</code> 不仅语法有效，而且其返回结果必须能够转换为 <code>bool</code> 类型？</p>
<p> C++</p>
 <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">concept StrictComparable &#x3D; requires(T a, T b) &#123;</span><br><span class="line">    &#123; a &gt; b &#125; -&gt; std::convertible_to&lt;bool&gt;; &#x2F;&#x2F; 注意这种语法 &#123; expression &#125; -&gt; TypeConstraint;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p> 你能尝试修改 <code>Printable</code> 概念，使其包含这个更严格的比较检查吗？</p>
</li>
<li><strong>标准库概念探索：</strong> C++ 标准库在 <code>&lt;concepts&gt;</code> 头文件中提供了许多有用的预定义概念，比如 <code>std::totally_ordered</code> (要求类型支持 <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>)，<code>std::equality_comparable</code> (要求 <code>==</code>, <code>!=</code>)，<code>std::movable</code>, <code>std::copyable</code>, <code>std::invocable</code> 等。花点时间看看这些标准概念的定义和用途，它们能让你的代码更规范。我们的 <code>Printable</code> 概念和 <code>std::totally_ordered</code> 以及流输出有什么关系？</li>
<li><strong>类模板的概念约束：</strong> 我们今天主要将概念用在了函数模板上。你能尝试定义一个类模板，并使用概念来约束它的模板参数吗？例如，一个只能存储 <code>Printable</code> 类型的 <code>Pair</code> 类。</li>
</ol>
<p>这些问题可以帮助你更好地理解概念的强大功能和灵活性。继续探索，你会发现概念是现代 C++ 中一个非常有用的工具！</p>
<p>如果你对这些扩展问题有任何想法或者尝试了新的代码，随时都可以分享给我！学习 C++ 的旅程，我们一起前进！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Learning/">Learning    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a><a class="post-meta__tags" href="/tags/Programming/">Programming    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/273%20-%20constructor/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>273 - constructor</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/276%20-%20Class%20across%20multiple%20files/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>276 - Class across multiple files</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/275 - getter and setter/" title="275 - getter and setter"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">275 - getter and setter</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/309 - 聚合类型统一初始化/" title="309 - 聚合类型统一初始化"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">309 - 聚合类型统一初始化</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/325 - 类内成员初始化/" title="325 - 类内成员初始化"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">325 - 类内成员初始化</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/c_plus_plus_teacher prompt/" title="c_plus_plus_teacher prompt"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">c_plus_plus_teacher prompt</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/diff between constexpr and define/" title="diff between constexpr and define"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">diff between constexpr and define</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/c plus plus template declaration best practice/" title="c plus plus template declaration best practice"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">c plus plus template declaration best practice</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>