<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>312 - cpp 友元函数详解 | Bear's dream</title><meta name="description" content="312 - cpp 友元函数详解"><meta name="keywords" content="Cpp,Coding,Function,Tutorial,Class"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="312 - cpp 友元函数详解"><meta name="twitter:description" content="312 - cpp 友元函数详解"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="312 - cpp 友元函数详解"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/312%20-%20cpp%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="312 - cpp 友元函数详解"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/312%20-%20cpp%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><link rel="prev" title="305 - 已删除构造 函数使用" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/305%20-%20%E5%B7%B2%E5%88%A0%E9%99%A4%E6%9E%84%E9%80%A0%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"><link rel="next" title="306 -  cpp 初始化列表构造函数详解" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/306%20-%20%20cpp%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">178</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">160</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">23</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-友元函数详解"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">C++ 友元函数详解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-友元函数深度解析：打破封装的特殊权限"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">C++ 友元函数深度解析：打破封装的特殊权限</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-详细讲解：友元函数（Friend-Functions）"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">1. 详细讲解：友元函数（Friend Functions）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-问题的引入：外部函数无法访问私有成员"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">1.1 问题的引入：外部函数无法访问私有成员</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-解决方案：声明友元函数"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">1.2 解决方案：声明友元函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-友元函数的重要特性与注意事项"><span class="toc_mobile_items-number">1.4.3.</span> <span class="toc_mobile_items-text">1.3 友元函数的重要特性与注意事项</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-QA-闪存卡-QA-Flash-Cards"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">2. QA 闪存卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-常见误解和错误-Common-Misunderstandings-and-Mistakes"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">3. 常见误解和错误 (Common Misunderstandings and Mistakes)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-编程练习-Coding-Exercise"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">4. 编程练习 (Coding Exercise)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-评分与答案解析"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">7. 评分与答案解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#您的解决方案评分：5-5-完美！"><span class="toc_mobile_items-number">1.10.1.</span> <span class="toc_mobile_items-text">您的解决方案评分：5&#x2F;5 - 完美！</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实际答案和解释"><span class="toc_mobile_items-number">1.10.2.</span> <span class="toc_mobile_items-text">实际答案和解释</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-扩展问题与建议-Extended-Questions-for-Investigation"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">8. 扩展问题与建议 (Extended Questions for Investigation)</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-友元函数详解"><span class="toc-number">1.</span> <span class="toc-text">C++ 友元函数详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-友元函数深度解析：打破封装的特殊权限"><span class="toc-number">1.3.</span> <span class="toc-text">C++ 友元函数深度解析：打破封装的特殊权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-详细讲解：友元函数（Friend-Functions）"><span class="toc-number">1.4.</span> <span class="toc-text">1. 详细讲解：友元函数（Friend Functions）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-问题的引入：外部函数无法访问私有成员"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.1 问题的引入：外部函数无法访问私有成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-解决方案：声明友元函数"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.2 解决方案：声明友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-友元函数的重要特性与注意事项"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.3 友元函数的重要特性与注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-QA-闪存卡-QA-Flash-Cards"><span class="toc-number">1.5.</span> <span class="toc-text">2. QA 闪存卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-常见误解和错误-Common-Misunderstandings-and-Mistakes"><span class="toc-number">1.6.</span> <span class="toc-text">3. 常见误解和错误 (Common Misunderstandings and Mistakes)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-编程练习-Coding-Exercise"><span class="toc-number">1.7.</span> <span class="toc-text">4. 编程练习 (Coding Exercise)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">1.8.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">1.9.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-评分与答案解析"><span class="toc-number">1.10.</span> <span class="toc-text">7. 评分与答案解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#您的解决方案评分：5-5-完美！"><span class="toc-number">1.10.1.</span> <span class="toc-text">您的解决方案评分：5&#x2F;5 - 完美！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实际答案和解释"><span class="toc-number">1.10.2.</span> <span class="toc-text">实际答案和解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-扩展问题与建议-Extended-Questions-for-Investigation"><span class="toc-number">1.11.</span> <span class="toc-text">8. 扩展问题与建议 (Extended Questions for Investigation)</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">312 - cpp 友元函数详解</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/312%20-%20cpp%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/312%20-%20cpp%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="C-友元函数详解"><a href="#C-友元函数详解" class="headerlink" title="C++ 友元函数详解"></a>C++ 友元函数详解</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about friend functions.Friend functions are a facility we have in C plus plus to let external functions have access to privatemember variables of our own class.Suppose we have a class called Dog and it has a few private member variables.As you see here we have the dog name, which is an STD string and we have an INT, which is our dogage here.And suppose we have a few functions which use our dog objects in different ways.We have the first function here, which is called debuginfo.It’s going to not return anything.Its return type is void and it is taking a dog object by const reference.But if you look inside, we want to print information about our dog object and we use the dot operatordirectly to try and access something that is private to the dog class.If we try to do this by default, we’re going to get a compiler error because you can’t access privatemembers of our dog class from the outside.And we are just using this function here from the outside.This is not going to work.If we go down here, we have another function which is not going to take any parameter, but insidethe body we are creating a local dog object and trying to access its member variable.So this is not going to work also.But sometimes you want this to work.Suppose you don’t want to go back in your class and set up member variables or whatever, so for whateverreason you want the external function to have access to our private member variables in our class,which is dog here.So how do we do this?We can use friend functions and the way we do this, we declare these functions as our friends in ourclass and we put declarations like this.You say friend, you say the friend keyword, and then you say the prototype for the function.You want to access any member in this class, including private member variables.The moment you do this, the C plus plus compiler is going to let this function access anything fromour dog class here.So if we put this declaration in our dog class and we try to use this functions like this, they aregoing to work now because now they are friends to our dog class.Okay.So before we head over to Visual Studio code and really play with us, here are a few things you needto know about friend functions.The friend function is first declared and alive somewhere, so you can’t declare a friend function thatdoesn’t exist somewhere.If you do that, you’re going to get a compiler error.The implementation for your friend function can really live anywhere.You just have to make sure that the linker is going to find it when it starts linking your application.But the declaration for the friend function has to show up before you use the function.And we already know this, but I just want to repeat that here.To be super clear, the class is going to determine who is its friend.For example, we had to set up the friend declaration from the dog class.It is impossible to set up friendship from the outside.The class that has the members that you want to access has to do the declaration because they are theowner of the data that you are potentially trying to access.The friend declaration can appear anywhere in the class, it can be in the public section, it can bein a private section.So this is really not going to matter.We can have multiple friend functions and we use just so that we set up to friend functions and a friendfunction can also be overloaded.And if you need this, you can use function overloading in your friend functions.We have to use the object name member variable syntax here to access stuff from our friend function.We can’t access them directly because the function is really not a member.So we have to go through an object and have access to any member from the class.So another thing you should know is that friend functions are really not members of the class.Even if the declaration shows up inside the class, they are not member functions.They don’t have direct access to our member functions.That’s why they have to go through the syntax we just described here.And because they are not member functions, they don’t have access to the this pointer.So keep these things in mind and you’re going to be fine using friend functions.Now that you know this, we’re going to head over to Visual Studio code and play with this a littlemore.Okay.Here we are in our working folder.The current project is Friend Functions.We’re going to grab our template files pretty quick and we’re going to put them in place and we aregoing to open this in Visual Studio code by dragging and dropping here, this is going to open our project.We’re going to clean up the.CPP file.Let’s do that.And we’re going to close the left pane here because we don’t need it.We’re going to set up a simple class, which is going to be person, let’s say, dog, because that’swhat we used in the slides a little bit in a little while.So we’re going to set up a private section and inside we’re going to have a Stdstring, which is goingto be the name for the dog, and we’re going to have a net, which is going to be the age after this.We’re going to set up the constructor, which is going to live in a public section for this class.Let’s align this things a little bit properly and we’re going to set up a constructor.The constructor is going to take two parameters.We’re going to say dog here and we’re going to say const Stdstring reference name.That’s going to be the name for the dog.And we’re going to take an age parameter for the age and we’re going to use an initializer list to putthese things in our member variables.So M name is going to be initialized with name and M age is going to be initialized with the age parameterand we’re going to put an empty body because the initialization job was already done by our initializerlist here.This is our class.And suppose we have another function which is going to take a dog object by reference.Let’s go down here and save this.We’re going to say void debug dog info.Suppose we have a function like this which is going to take a dog object by reference and we’re goingto take const dog reference and let’s call this D and suppose we want to print information about thisdog here.So we’re going to say Stdcout and we’re going to say dog and we’re going to say the information nameis going to be D name.We want direct access to the member variables.That’s what we want to do here.And we’re going to say D name and we’re going to say age is D, m age.Okay, we can save that here.And then we’re going to close our output with a square bracket.We’re going to put a new line character.And you see that we have squiggly lines here.And the problem is we can’t really access the private member variables of the dog class here.From the outside, this function Debuginfo is an outsider to our class, so it has no business accessingprivate stuff from our class here.And if we ignore what Visual Studio code is saying here, let’s bring up a terminal and actually seethis before we use the compiler.We’re going to see.M name is inaccessible.M Age is inaccessible from this place here because these are member variables of the class and we can’treally access them from the outside.So what do we do?But before I show you the solution to this, let’s try to pass this through the compiler and see whatis going to happen.We are saying M name is private from this context here, and M age is private.From this context here, we can’t really access private stuff from the outside here.So if we want this setup to work, for example, we don’t want to go in and set up getters and we don’treally want to mark our member variables as public.Let’s see that if you mark them public, this is going to solve the problem.Okay, So because now they are public, we can access them here from the outside.And if we build, the squiggly lines are going to go away.So let’s see that you see that now the build is good, but we don’t want to make our member variablespublic because this is going to expose our implementation details to the outside.Other people will be able to come in and, for example, change our member variables really do all kindsof crazy things.This is bad design.We don’t want this.So we’re going to make them private and we want this syntax here to work.Well, we can get out of this problem by marking this function as a friend function to the dog class,and the syntax to do that is really easy.You just grab the prototype for the function.We’re going to copy this and then we’re going to go somewhere in the dog class.It doesn’t really matter where you can put this in a public section, you can put this in a privatesection.It doesn’t matter.In this case, we’re going to put this first thing in the dog class and it’s going to be in a privatesection because that’s going to be the default access specifier for this class here.So we’re going to say friend and we’re going to say the prototype for the function and then we’re goingto put a semicolon here.The moment we do that, the squiggly line is going to go away.And if we build, we’re going to see that the build is going to be good.Okay, so let’s build.And you see build is good, but we are able to access private stuff from the dog class because now thisfunction is a friend of the dog class.Notice that the friendship was set up from.The class that owns the data.You can’t really set up the friendship relationship from the outside.You can’t come in the function here and say, I want the dog class to be my friend.This has to be done from the class that owns the data you want to access, and the dog class owns themember variables that we really want to access.Now that friendship has been set up, we can come in main and really use our function.For example, let’s set up a dog object and say Dog one, we’re going to give it a name, let’s sayFluffy, and we’re going to give it an age of four.Why not?And then we’re going to go down and say debug dog info, and then we’re going to pass our dog object,which happens to be dog one here.If we build and run, we’re going to see the information printed out on our terminal.Let’s see if the world is good, the world is good.We can bring up a terminal and a clear and run rooster.Now we see that.We see the information about our dog.If we set up another function which creates a local dog object, this is just going to be a way to playwith us.So let’s go down and do that.We’re going to say void.We can call this however we want, and inside we’re going to create a dog object and then we’re goingto print information about this dog directly from this function here.This is another setup you might want to do.So let’s do that.And we’re going to change D to dog one here because that’s the object we want to print data for.So we’re going to say dog one and we’re going to have the same problems.This is an outside function.It can’t really access the member variables for our class here.And just to show you that we can use overloads, we’re going to name this function debug dog info.I think this is going to work because the parameters are different, but we still have the same problem.Dog one is a dog object and we are trying to access private members of our class here and for this towork we should also mark this function as a friend to our class.So let’s grab the prototype.We’re going to go inside the class and we’re going to say friend, and we’re going to put in our prototypeand put a semicolon here.And the moment we do this, we can go in our class and say debug dog info and then we’re not going topass anything in.Let’s comment out the printing line we had before and we’re going to see that.We are going to see the information here.Let’s change the name to Milu inside here and change the age to three.Why not?And then we’re going to world.Okay.The world is good.We can clear and run Rooster.This is going to print our information.And this is working because our functions now are friends to the class.So they really have access to private members of this class.They could even modify information about our class objects.So, for example, we can go in our class here and change the name for the dog.We can come in here and say dog one and name and change this and we’re going to change that back toFluffy and you’re going to see that this is going to work because this guy is a friend to our class.So they have access to our member variables.They can read or modify our member variables.Now, if we print, we’re going to see Fluffy.Even if the dog we declared had a name of Milo.So let’s see that we’re going to build with GCC.The build should be good.We’re going to clear and run Rooster.We’re going to see now the name is Fluffy and we have successfully changed this from a friend functionwhich has all access to our member variables.So hopefully you can see that friend functions can really be dangerous because they allow people todo crazy stuff with your objects from the outside.So as the saying goes, choose your friends carefully because they can do crazy things to your privatemember variables.So this is really all I had to share in this lecture.I hope you found it interesting.We are going to stop here in this one.In the next one, we’re going to see how we can set up friend classes and give them access to our privatemember variables.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，很高兴能为您详细讲解 C++ 中的 <code>friend</code> 函数（友元函数）。作为您的C++导师，我将尽力用最清晰、最全面的方式，结合实际代码和常见问题，帮助您彻底理解这个概念。</p>
<hr>
<h2 id="C-友元函数深度解析：打破封装的特殊权限"><a href="#C-友元函数深度解析：打破封装的特殊权限" class="headerlink" title="C++ 友元函数深度解析：打破封装的特殊权限"></a><strong>C++ 友元函数深度解析：打破封装的特殊权限</strong></h2><p><strong>摘要:</strong> 本节课程将带您深入了解 C++ 中的 <code>friend</code> 函数。<code>friend</code> 函数是一种特殊的非成员函数，它被授予访问一个类中所有私有（<code>private</code>）和保护（<code>protected</code>）成员的权限。我们将探讨为什么需要它、如何声明和使用它，以及使用时需要注意的事项和潜在风险。</p>
<hr>
<h2 id="1-详细讲解：友元函数（Friend-Functions）"><a href="#1-详细讲解：友元函数（Friend-Functions）" class="headerlink" title="1. 详细讲解：友元函数（Friend Functions）"></a>1. 详细讲解：友元函数（Friend Functions）</h2><p>在 C++ 中，我们使用访问说明符（[access specifiers]）来控制类成员的可见性。最常见的有 <code>public</code>（公共）、<code>private</code>（私有）和 <code>protected</code>（保护）。</p>
<ul>
<li><strong><code>public</code> 成员:</strong> 可以在类的外部直接访问。</li>
<li><strong><code>private</code> 成员:</strong> 只能在类的内部（即类的成员函数内部）访问，类的外部无法直接访问。这是实现封装（[encapsulation]）的关键，它隐藏了类的内部实现细节，只暴露必要的接口。</li>
<li><strong><code>protected</code> 成员:</strong> 可以在类的内部以及派生类（[derived classes]）中访问。</li>
</ul>
<p>通常情况下，我们希望将类的内部数据（成员变量）声明为 <code>private</code>，以保护它们不被外部代码随意修改，从而维护数据的一致性和有效性。但是，在某些特定场景下，我们可能需要允许某个非成员函数（或另一个类）访问一个类的 <code>private</code> 或 <code>protected</code> 成员。这时，<code>friend</code> 函数就派上用场了。</p>
<p><code>friend</code> 函数是 C++ 提供的一种机制，它允许我们“授权”特定的非成员函数（或类）拥有访问另一个类的 <code>private</code> 和 <code>protected</code> 成员的特殊权限。尽管它能够访问类的私有数据，但它本身并不是这个类的成员函数。</p>
<p>让我们通过一个具体的例子来理解这个概念。</p>
<h3 id="1-1-问题的引入：外部函数无法访问私有成员"><a href="#1-1-问题的引入：外部函数无法访问私有成员" class="headerlink" title="1.1 问题的引入：外部函数无法访问私有成员"></a>1.1 问题的引入：外部函数无法访问私有成员</h3><p>假设我们有一个 <code>Dog</code> 类，它有一些私有成员变量，例如狗的名字 <code>m_name</code> 和年龄 <code>m_age</code>：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 类的前向声明，因为 debugDogInfo 函数可能在 Dog 类之前被声明或定义</span></span><br><span class="line"><span class="comment">// 如果 debugDogInfo 在 Dog 类之后定义，则不需要，但为了清晰起见，这里加上</span></span><br><span class="line"><span class="comment">// class Dog; // 在此示例中暂时不需要，因为 Dog 类会先完整定义</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name; <span class="comment">// 狗的名字，私有成员</span></span><br><span class="line">    <span class="keyword">int</span> m_age;          <span class="comment">// 狗的年龄，私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，用于初始化 Dog 对象</span></span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">int</span> age)</span><br><span class="line">        : m_name(name), m_age(age) &#123;</span><br><span class="line">        <span class="comment">// 初始化列表已完成初始化，函数体为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的析构函数</span></span><br><span class="line">    ~Dog() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们有一个独立的函数，它尝试打印 Dog 对象的信息</span></span><br><span class="line"><span class="comment">// 注意：这是一个普通的非成员函数，与 Dog 类没有直接关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debugDogInfo</span><span class="params">(<span class="keyword">const</span> Dog&amp; d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗的信息 ["</span>;</span><br><span class="line">    <span class="comment">// 尝试直接访问 Dog 对象的私有成员</span></span><br><span class="line">    <span class="comment">// d.m_name 和 d.m_age</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"名字: "</span> &lt;&lt; d.m_name &lt;&lt; <span class="string">", 年龄: "</span> &lt;&lt; d.m_age; <span class="comment">// 这里会报错！</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"]\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">"旺财"</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    debugDogInfo(myDog); <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的代码中，<code>debugDogInfo</code> 是一个独立的非成员函数，它接收一个 <code>Dog</code> 对象的常量引用。当它尝试访问 <code>d.m_name</code> 和 <code>d.m_age</code> 时，编译器会抛出错误，提示 <code>m_name</code> 和 <code>m_age</code> 是 <code>private</code> 成员，不可访问。</p>
<p>这是因为 <code>debugDogInfo</code> 函数是 <code>Dog</code> 类的“外部”函数，它没有权限直接访问 <code>Dog</code> 类的私有成员。这就是封装的作用。</p>
<h3 id="1-2-解决方案：声明友元函数"><a href="#1-2-解决方案：声明友元函数" class="headerlink" title="1.2 解决方案：声明友元函数"></a>1.2 解决方案：声明友元函数</h3><p>为了让 <code>debugDogInfo</code> 函数能够访问 <code>Dog</code> 类的私有成员，我们可以在 <code>Dog</code> 类内部将 <code>debugDogInfo</code> 声明为它的一个 <code>friend</code> 函数。</p>
<p>声明 <code>friend</code> 函数的方式非常简单：在类定义中，使用 <code>friend</code> 关键字（[friend keyword]）后跟要声明为友元的函数原型（[function prototype]）。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前声明 Dog 类，因为 debugDogInfo 可能在 Dog 类之前被声明或定义</span></span><br><span class="line"><span class="comment">// 并且 debugDogInfo 的参数类型是 Dog。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>;</span> <span class="comment">// 这是必需的，因为友元函数的声明在类内，但其定义可能在类外</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数原型声明</span></span><br><span class="line"><span class="comment">// 注意：这里仍然是一个普通的函数声明，只是为了告诉编译器这个函数存在</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debugDogInfo</span><span class="params">(<span class="keyword">const</span> Dog&amp; d)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个可能的友元函数，不带参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debugDogInfo_NoParams</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将 debugDogInfo 函数声明为 Dog 类的友元</span></span><br><span class="line">    <span class="comment">// 无论放在 public、private 还是 protected 部分，效果都是一样的</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">debugDogInfo</span><span class="params">(<span class="keyword">const</span> Dog&amp; d)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以有多个友元函数，包括函数重载</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">debugDogInfo_NoParams</span><span class="params">()</span></span>; <span class="comment">// 将不带参数的函数也声明为友元</span></span><br><span class="line"></span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">int</span> age)</span><br><span class="line">        : m_name(name), m_age(age) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog对象 ["</span> &lt;&lt; m_name &lt;&lt; <span class="string">", "</span> &lt;&lt; m_age &lt;&lt; <span class="string">"] 被创建。\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Dog() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog对象 ["</span> &lt;&lt; m_name &lt;&lt; <span class="string">"] 被销毁。\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的定义（实现）</span></span><br><span class="line"><span class="comment">// 即使它是友元，它仍然是一个普通的非成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debugDogInfo</span><span class="params">(<span class="keyword">const</span> Dog&amp; d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗的信息 ["</span>;</span><br><span class="line">    <span class="comment">// 现在，作为友元，可以直接访问 Dog 对象的私有成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"名字: "</span> &lt;&lt; d.m_name &lt;&lt; <span class="string">", 年龄: "</span> &lt;&lt; d.m_age;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"]\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debugDogInfo_NoParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">localDog</span><span class="params">(<span class="string">"米卢"</span>, <span class="number">3</span>)</span></span>; <span class="comment">// 在函数内部创建一个 Dog 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"局部狗对象信息 ["</span>;</span><br><span class="line">    <span class="comment">// 友元函数可以访问其友元类任何对象的私有成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"名字: "</span> &lt;&lt; localDog.m_name &lt;&lt; <span class="string">", 年龄: "</span> &lt;&lt; localDog.m_age;</span><br><span class="line">    <span class="comment">// 友元函数甚至可以修改私有成员</span></span><br><span class="line">    localDog.m_name = <span class="string">"小黑"</span>; <span class="comment">// 修改名字</span></span><br><span class="line">    localDog.m_age = <span class="number">4</span>;     <span class="comment">// 修改年龄</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"] 修改后 [名字: "</span> &lt;&lt; localDog.m_name &lt;&lt; <span class="string">", 年龄: "</span> &lt;&lt; localDog.m_age &lt;&lt; <span class="string">"]\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">myDog</span><span class="params">(<span class="string">"旺财"</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    debugDogInfo(myDog); <span class="comment">// 正常调用友元函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--------------------\n\n"</span>;</span><br><span class="line">    debugDogInfo_NoParams(); <span class="comment">// 调用另一个友元函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--------------------\n\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>现在，<code>debugDogInfo</code> 和 <code>debugDogInfo_NoParams</code> 函数都可以成功编译并访问 <code>Dog</code> 类的私有成员了。</p>
<h3 id="1-3-友元函数的重要特性与注意事项"><a href="#1-3-友元函数的重要特性与注意事项" class="headerlink" title="1.3 友元函数的重要特性与注意事项"></a>1.3 友元函数的重要特性与注意事项</h3><ol>
<li><p><strong>友元声明与定义的位置：</strong></p>
<ul>
<li><code>friend</code> 声明必须出现在类的内部。它可以在类的 <code>public</code>、<code>private</code> 或 <code>protected</code> 部分，这不影响友元函数自身的访问权限，因为友元函数不是类的成员。</li>
<li>友元函数的定义（实现）通常在类的外部，就像普通的非成员函数一样。编译器只需要在类内部看到友元函数的声明即可。</li>
<li>友元函数在被调用之前，其原型（或定义）必须是可见的。如果友元函数定义在 <code>main</code> 函数之后，那么在 <code>main</code> 函数或类中使用它之前，必须有一个前向声明（[forward declaration]）。</li>
<li>友元函数必须是“真实存在的”，你不能声明一个不存在的函数为友元。</li>
</ul>
</li>
<li><p><strong>友元关系是单向的，不可传递：</strong></p>
<ul>
<li>如果类 <code>A</code> 将函数 <code>F</code> 声明为友元，则 <code>F</code> 可以访问 <code>A</code> 的私有成员。但这并不意味着 <code>F</code> 也将 <code>A</code> 视为友元，也不意味着 <code>A</code> 自动成为 <code>F</code> 的友元。</li>
<li>友元关系是单向授予的。类 <code>A</code> 决定谁是它的朋友，而不是外部函数决定它想成为谁的朋友。你不能在 <code>debugDogInfo</code> 函数内部说“我希望 <code>Dog</code> 是我的朋友”。</li>
<li>友元关系不可传递。如果类 <code>A</code> 是类 <code>B</code> 的友元，且 <code>B</code> 是类 <code>C</code> 的友元，这并不意味着 <code>A</code> 也是 <code>C</code> 的友元。</li>
</ul>
</li>
<li><p><strong>友元函数不是类的成员函数：</strong></p>
<ul>
<li>这是最重要的一点。尽管友元函数的声明在类中，但它不属于该类。它仍然是一个独立的、全局的（或命名空间内的）函数。</li>
<li>正因为如此，友元函数不能使用成员选择运算符（<code>.</code>）直接访问成员（例如 <code>m_name</code>），它必须通过一个对象的引用或指针来访问，例如 <code>d.m_name</code> 或 <code>p-&gt;m_name</code>。</li>
<li>友元函数不拥有 <code>this</code> 指针（[this pointer]）。<code>this</code> 指针是成员函数特有的，它指向调用该成员函数的对象。</li>
</ul>
</li>
<li><p><strong>多友元函数与函数重载：</strong></p>
<ul>
<li>一个类可以有任意数量的友元函数。</li>
<li>友元函数也可以被重载（[overloaded]），就像 <code>debugDogInfo(const Dog&amp; d)</code> 和 <code>debugDogInfo_NoParams()</code> 所示。只要它们的参数列表不同，就可以将它们都声明为友元。</li>
</ul>
</li>
<li><p><strong>友元函数操作私有数据：</strong></p>
<ul>
<li>友元函数不仅可以读取类的私有成员，还可以修改它们，如示例中 <code>debugDogInfo_NoParams</code> 修改了 <code>localDog</code> 的名字和年龄。这使得友元函数非常强大，但也带来了潜在的风险。</li>
</ul>
</li>
<li><p><strong>何时使用友元函数？</strong></p>
<ul>
<li><strong>运算符重载（[Operator Overloading]）:</strong> 当需要重载某些二元运算符（如 <code>&lt;&lt;</code> 用于输出流，或 <code>+</code> 用于两个对象相加）时，如果运算符的左操作数不是类对象，那么通常需要将其声明为友元函数。例如，<code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Dog&amp; d);</code>。</li>
<li><strong>特殊工具函数:</strong> 当某个工具函数与类的内部实现紧密耦合，但又不适合作为成员函数时（例如，它可能操作两个不同类的对象，或者它只是一个简单的辅助打印函数）。</li>
<li><strong>工厂模式（[Factory Pattern]）或构建者模式（[Builder Pattern]）:</strong> 在某些设计模式中，工厂或构建者类可能需要访问其创建的对象的私有构造函数或数据。</li>
</ul>
</li>
<li><p><strong>潜在的危险与设计考量：</strong></p>
<ul>
<li>友元函数“打破”了类的封装性。过度使用友元函数会使得类的内部实现细节暴露给更多的外部函数，从而降低了代码的模块化和可维护性。</li>
<li>一旦类的内部结构发生变化，所有依赖于其私有成员的友元函数也可能需要修改，增加了维护成本。</li>
<li>因此，建议谨慎使用 <code>friend</code> 关键字。只有在真正必要且没有更好替代方案时才考虑使用它。良好的设计通常倾向于通过公共接口（<code>public interface</code>）来操作对象。</li>
</ul>
</li>
</ol>
<h2 id="2-QA-闪存卡-QA-Flash-Cards"><a href="#2-QA-闪存卡-QA-Flash-Cards" class="headerlink" title="2. QA 闪存卡 (QA Flash Cards)"></a>2. QA 闪存卡 (QA Flash Cards)</h2><ol>
<li><p><strong>Q: 什么是 C++ 中的 <code>friend</code> 函数？</strong><br><strong>A:</strong> <code>friend</code> 函数是一种在类内部声明的非成员函数，它被授予访问该类的所有 <code>private</code> 和 <code>protected</code> 成员的特殊权限。</p>
</li>
<li><p><strong>Q: 为什么要使用 <code>friend</code> 函数？</strong><br><strong>A:</strong> 当我们希望某个非成员函数能够访问一个类的私有（<code>private</code>）或保护（<code>protected</code>）成员，但又不想将这些成员设为 <code>public</code>，或将该函数设为类的成员函数时，可以使用 <code>friend</code> 函数。常见场景包括运算符重载、某些特殊工具函数等。</p>
</li>
<li><p><strong>Q: 如何声明一个 <code>friend</code> 函数？</strong><br><strong>A:</strong> 在类的定义内部，使用 <code>friend</code> 关键字后跟要声明为友元的函数原型，例如：<code>friend void someFunction(SomeClass&amp; obj);</code>。</p>
</li>
<li><p><strong>Q: <code>friend</code> 函数是类的成员函数吗？它有 <code>this</code> 指针吗？</strong><br><strong>A:</strong> 不，<code>friend</code> 函数不是类的成员函数。它不拥有 <code>this</code> 指针。它仍然是独立的普通函数，只是获得了访问类私有成员的特权。</p>
</li>
<li><p><strong>Q: <code>friend</code> 函数可以重载吗？</strong><br><strong>A:</strong> 是的，<code>friend</code> 函数可以像普通函数一样被重载，只要它们的参数列表不同即可。</p>
</li>
<li><p><strong>Q: <code>friend</code> 声明可以放在类的 <code>private</code> 或 <code>protected</code> 部分吗？这会影响友元函数的访问权限吗？</strong><br><strong>A:</strong> 是的，<code>friend</code> 声明可以放在类的 <code>public</code>、<code>private</code> 或 <code>protected</code> 任何部分。这不会影响友元函数访问类的私有或保护成员的权限，因为友元函数本身不是类的成员。</p>
</li>
<li><p><strong>Q: 友元关系是双向的吗？如果 A 是 B 的友元，B 也是 A 的友元吗？</strong><br><strong>A:</strong> 不，友元关系是单向的。如果类 <code>A</code> 声明函数 <code>F</code> 为友元，<code>F</code> 可以访问 <code>A</code> 的私有成员。但这不意味着 <code>F</code> 将 <code>A</code> 视为友元，也不意味着 <code>F</code> 可以访问 <code>A</code> 的私有成员。友元关系是类主动授予的。</p>
</li>
</ol>
<h2 id="3-常见误解和错误-Common-Misunderstandings-and-Mistakes"><a href="#3-常见误解和错误-Common-Misunderstandings-and-Mistakes" class="headerlink" title="3. 常见误解和错误 (Common Misunderstandings and Mistakes)"></a>3. 常见误解和错误 (Common Misunderstandings and Mistakes)</h2><ol>
<li><p><strong>误解：友元函数是类的成员函数。</strong><br><strong>纠正：</strong> 这是最常见的误解。友元函数不是类的成员。它不属于任何特定的对象，也没有 <code>this</code> 指针。因此，它不能像成员函数那样直接访问 <code>m_name</code>；它必须通过一个对象实例来访问，例如 <code>obj.m_name</code>。</p>
</li>
<li><p><strong>错误：尝试直接访问私有成员，没有通过对象。</strong><br><strong>纠正：</strong> 即使是友元函数，它也需要一个类的对象实例来访问该对象的私有成员。例如，你不能在 <code>debugDogInfo</code> 中写 <code>std::cout &lt;&lt; m_name;</code>，而是必须写 <code>std::cout &lt;&lt; d.m_name;</code>。</p>
</li>
<li><p><strong>误解：友元关系是相互的/可传递的。</strong><br><strong>纠正：</strong> 友元关系是单向的，且不可传递。如果类 <code>A</code> 是类 <code>B</code> 的友元，不意味着 <code>B</code> 是 <code>A</code> 的友元。如果函数 <code>F</code> 是 <code>A</code> 的友元，并且 <code>A</code> 是 <code>B</code> 的友元，这不意味着 <code>F</code> 也是 <code>B</code> 的友元。每个友元关系都必须明确声明。</p>
</li>
<li><p><strong>错误：在类外部声明 <code>friend</code> 关键字。</strong><br><strong>纠正：</strong> <code>friend</code> 关键字只能在类定义内部使用，用于声明友元函数或友元类。你不能在全局作用域或其他函数中声明 <code>friend</code>。</p>
</li>
<li><p><strong>过度使用友元函数。</strong><br><strong>纠正：</strong> 友元函数打破了封装原则。如果一个类的私有成员被太多的外部函数访问，那么类的设计就变得不那么健壮。尽量通过 <code>public</code> 成员函数提供访问私有数据的方式（例如，<code>getter</code> 和 <code>setter</code>），而不是频繁使用友元。只有在确实需要，且没有其他更好的设计模式时，才考虑使用友元。</p>
</li>
<li><p><strong>忘记前向声明（[Forward Declaration]）。</strong><br><strong>纠正：</strong> 如果一个友元函数的原型在类定义之前出现，并且它的参数或返回类型涉及这个类，那么这个类就需要一个前向声明。例如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Dog; // 忘记这个前向声明可能会导致编译错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debugDogInfo</span><span class="params">(<span class="keyword">const</span> Dog&amp; d)</span></span>; <span class="comment">// 这里的 Dog 尚未被完全定义</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">debugDogInfo</span><span class="params">(<span class="keyword">const</span> Dog&amp; d)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<hr>
<h2 id="4-编程练习-Coding-Exercise"><a href="#4-编程练习-Coding-Exercise" class="headerlink" title="4. 编程练习 (Coding Exercise)"></a>4. 编程练习 (Coding Exercise)</h2><p>现在，轮到您来实践了！请完成下面的代码，使其能够成功编译并运行。</p>
<p><strong>任务：</strong></p>
<p>您需要创建一个 <code>Car</code> 类，其中包含一些私有成员变量。然后，编写一个非成员函数 <code>printCarDetails</code>，它能够打印 <code>Car</code> 对象的私有细节。为了实现这一点，您需要将 <code>printCarDetails</code> 声明为 <code>Car</code> 类的友元。</p>
<p>请补全 <code>// TODO: ...</code> 部分的代码。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 1: 声明 Car 类 (前向声明，如果需要的话)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_brand; <span class="comment">// 品牌</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_model; <span class="comment">// 型号</span></span><br><span class="line">    <span class="keyword">int</span> m_mileage;       <span class="comment">// 里程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; brand, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; model, <span class="keyword">int</span> mileage)</span><br><span class="line">        : m_brand(brand), m_model(model), m_mileage(mileage) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car 对象 ["</span> &lt;&lt; m_brand &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"] 被创建。\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2: 将 printCarDetails 函数声明为 Car 类的友元</span></span><br><span class="line">    <span class="comment">// 友元函数原型: void printCarDetails(const Car&amp; car);</span></span><br><span class="line"></span><br><span class="line">    ~Car() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car 对象 ["</span> &lt;&lt; m_brand &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"] 被销毁。\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 3: 实现 printCarDetails 函数</span></span><br><span class="line"><span class="comment">// 该函数应接收一个 Car 对象的常量引用作为参数，并打印其品牌、型号和里程。</span></span><br><span class="line"><span class="comment">// 由于它将是友元函数，所以可以直接访问 Car 对象的私有成员。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">myCar</span><span class="params">(<span class="string">"Toyota"</span>, <span class="string">"Camry"</span>, <span class="number">50000</span>)</span></span>;</span><br><span class="line">    printCarDetails(myCar); <span class="comment">// 调用友元函数来打印细节</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n尝试在友元函数中修改里程。\n"</span>;</span><br><span class="line">    <span class="comment">// 创建一个临时 Car 对象来演示友元函数的修改能力</span></span><br><span class="line">    <span class="function">Car <span class="title">anotherCar</span><span class="params">(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>, <span class="number">10000</span>)</span></span>;</span><br><span class="line">    <span class="comment">// TODO 4: 额外挑战：编写一个名为 'modifyCarMileage' 的友元函数</span></span><br><span class="line">    <span class="comment">//         它接收一个 Car 对象的引用，并将其里程设置为 0。</span></span><br><span class="line">    <span class="comment">//         并在 Car 类中声明它为友元，然后在这里调用它。</span></span><br><span class="line">    <span class="comment">//         观察里程是否被修改。</span></span><br><span class="line">    <span class="comment">//         (您可以先完成主要任务，再尝试这个挑战)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请您在完成上述练习后，再提交您的解决方案。我将在您的解决方案提交后，为您提供详细的评分、正确答案和进一步的建议。</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 1: 声明 Car 类 (前向声明，如果需要的话)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_brand; <span class="comment">// 品牌</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_model; <span class="comment">// 型号</span></span><br><span class="line">    <span class="keyword">int</span> m_mileage;       <span class="comment">// 里程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; brand, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; model, <span class="keyword">int</span> mileage)</span><br><span class="line">        : m_brand(brand), m_model(model), m_mileage(mileage) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car 对象 ["</span> &lt;&lt; m_brand &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"] 被创建。\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2: 将 printCarDetails 函数声明为 Car 类的友元</span></span><br><span class="line">    <span class="comment">// 友元函数原型: void printCarDetails(const Car&amp; car);</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printCarDetails</span><span class="params">(<span class="keyword">const</span> Car&amp; car)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">modifyCarMileage</span><span class="params">(Car&amp; car)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~Car() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car 对象 ["</span> &lt;&lt; m_brand &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"] 被销毁。\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCarDetails</span><span class="params">(<span class="keyword">const</span> Car&amp; car)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car brand is "</span> &lt;&lt; car.m_brand &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car m_model is "</span> &lt;&lt; car.m_model &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car m_mileage is "</span> &lt;&lt; car.m_mileage &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TODO 3: 实现 printCarDetails 函数</span></span><br><span class="line"><span class="comment">// 该函数应接收一个 Car 对象的常量引用作为参数，并打印其品牌、型号和里程。</span></span><br><span class="line"><span class="comment">// 由于它将是友元函数，所以可以直接访问 Car 对象的私有成员。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyCarMileage</span><span class="params">(Car&amp; car)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    car.m_mileage = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">myCar</span><span class="params">(<span class="string">"Toyota"</span>, <span class="string">"Camry"</span>, <span class="number">50000</span>)</span></span>;</span><br><span class="line">    printCarDetails(myCar); <span class="comment">// 调用友元函数来打印细节</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n尝试在友元函数中修改里程。\n"</span>;</span><br><span class="line">    <span class="comment">// 创建一个临时 Car 对象来演示友元函数的修改能力</span></span><br><span class="line">    <span class="function">Car <span class="title">anotherCar</span><span class="params">(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>, <span class="number">10000</span>)</span></span>;</span><br><span class="line">    <span class="comment">// TODO 4: 额外挑战：编写一个名为 'modifyCarMileage' 的友元函数</span></span><br><span class="line">    <span class="comment">//         它接收一个 Car 对象的引用，并将其里程设置为 0。</span></span><br><span class="line">    <span class="comment">//         并在 Car 类中声明它为友元，然后在这里调用它。</span></span><br><span class="line">    <span class="comment">//         观察里程是否被修改。</span></span><br><span class="line">    <span class="comment">//         (您可以先完成主要任务，再尝试这个挑战)</span></span><br><span class="line">    modifyCarMileage(anotherCar);</span><br><span class="line">    printCarDetails(anotherCar);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>太棒了！您的解决方案非常出色，完全正确地完成了所有的任务，包括那个挑战题！</p>
<p>这表明您已经很好地理解了 <code>friend</code> 函数的核心概念、如何声明它，以及它在访问私有成员方面的特殊能力。您甚至注意到了友元函数不仅可以读取私有成员，还可以修改它们，并通过 <code>modifyCarMileage</code> 函数成功演示了这一点。</p>
<h2 id="7-评分与答案解析"><a href="#7-评分与答案解析" class="headerlink" title="7. 评分与答案解析"></a><strong>7. 评分与答案解析</strong></h2><h3 id="您的解决方案评分：5-5-完美！"><a href="#您的解决方案评分：5-5-完美！" class="headerlink" title="您的解决方案评分：5/5 - 完美！"></a><strong>您的解决方案评分：5/5 - 完美！</strong></h3><p>您对 <code>friend</code> 函数的理解和应用都非常到位。所有要求和挑战都得到了正确的实现。</p>
<h3 id="实际答案和解释"><a href="#实际答案和解释" class="headerlink" title="实际答案和解释"></a><strong>实际答案和解释</strong></h3><p>以下是完整的参考答案，并对您完成的每个部分进行详细解释。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 1: 声明 Car 类 (前向声明，如果需要的话)</span></span><br><span class="line"><span class="comment">// 解释: 在此特定场景下，由于 printCarDetails 和 modifyCarMileage 的定义在 Car 类之后，</span></span><br><span class="line"><span class="comment">//       而 Car 类内部的 friend 声明已经知道 Car 类型，所以这个前向声明并非严格必需。</span></span><br><span class="line"><span class="comment">//       但在更复杂的交叉引用或头文件/源文件分离的场景中，它是非常有用的良好实践。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>;</span> <span class="comment">// 前向声明，表示 Car 是一个类，但尚未给出其完整定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的原型声明 (通常放在 Car 类定义之前，或者在 Car 类定义后但 main 函数之前)</span></span><br><span class="line"><span class="comment">// 这样编译器在看到 Car 类内部的 friend 声明时，就已经知道这些函数的签名。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCarDetails</span><span class="params">(<span class="keyword">const</span> Car&amp; car)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyCarMileage</span><span class="params">(Car&amp; car)</span></span>; <span class="comment">// 友元函数，用于修改里程</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_brand; <span class="comment">// 品牌</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_model; <span class="comment">// 型号</span></span><br><span class="line">    <span class="keyword">int</span> m_mileage;       <span class="comment">// 里程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; brand, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; model, <span class="keyword">int</span> mileage)</span><br><span class="line">        : m_brand(brand), m_model(model), m_mileage(mileage) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car 对象 ["</span> &lt;&lt; m_brand &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"] 被创建。\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2: 将 printCarDetails 函数声明为 Car 类的友元</span></span><br><span class="line">    <span class="comment">// 友元函数原型: void printCarDetails(const Car&amp; car);</span></span><br><span class="line">    <span class="comment">// 解释: 这行代码授予 printCarDetails 函数访问 Car 类私有成员的权限。</span></span><br><span class="line">    <span class="comment">//       它的位置（public/private/protected）不影响其友元权限。</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printCarDetails</span><span class="params">(<span class="keyword">const</span> Car&amp; car)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 4 (挑战): 将 modifyCarMileage 函数声明为 Car 类的友元</span></span><br><span class="line">    <span class="comment">// 解释: 同样，这行代码授予 modifyCarMileage 函数访问 Car 类私有成员的权限。</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">modifyCarMileage</span><span class="params">(Car&amp; car)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~Car() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car 对象 ["</span> &lt;&lt; m_brand &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"] 被销毁。\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 3: 实现 printCarDetails 函数</span></span><br><span class="line"><span class="comment">// 该函数应接收一个 Car 对象的常量引用作为参数，并打印其品牌、型号和里程。</span></span><br><span class="line"><span class="comment">// 由于它将是友元函数，所以可以直接访问 Car 对象的私有成员。</span></span><br><span class="line"><span class="comment">// 解释: 作为 Car 的友元，printCarDetails 可以直接通过传入的 Car 对象引用 'car'</span></span><br><span class="line"><span class="comment">//       来访问其私有成员 m_brand, m_model, m_mileage。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCarDetails</span><span class="params">(<span class="keyword">const</span> Car&amp; car)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 车辆详情 ---\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"品牌: "</span> &lt;&lt; car.m_brand &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"型号: "</span> &lt;&lt; car.m_model &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"里程: "</span> &lt;&lt; car.m_mileage &lt;&lt; <span class="string">" 公里\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------------\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 4 (挑战): 实现 modifyCarMileage 函数</span></span><br><span class="line"><span class="comment">// 解释: 作为 Car 的友元，modifyCarMileage 可以直接通过传入的 Car 对象引用 'car'</span></span><br><span class="line"><span class="comment">//       来修改其私有成员 m_mileage。注意这里需要传入非 const 引用，因为要修改对象。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyCarMileage</span><span class="params">(Car&amp; car)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 正在修改里程 ---\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"旧里程: "</span> &lt;&lt; car.m_mileage &lt;&lt; <span class="string">" 公里\n"</span>;</span><br><span class="line">    car.m_mileage = <span class="number">0</span>; <span class="comment">// 直接修改私有成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"新里程: "</span> &lt;&lt; car.m_mileage &lt;&lt; <span class="string">" 公里\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">myCar</span><span class="params">(<span class="string">"Toyota"</span>, <span class="string">"Camry"</span>, <span class="number">50000</span>)</span></span>;</span><br><span class="line">    printCarDetails(myCar); <span class="comment">// 调用友元函数来打印细节</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n尝试在友元函数中修改里程。\n"</span>;</span><br><span class="line">    <span class="function">Car <span class="title">anotherCar</span><span class="params">(<span class="string">"Honda"</span>, <span class="string">"Civic"</span>, <span class="number">10000</span>)</span></span>;</span><br><span class="line">    printCarDetails(anotherCar); <span class="comment">// 修改前的详情</span></span><br><span class="line">    modifyCarMileage(anotherCar); <span class="comment">// 调用友元函数修改里程</span></span><br><span class="line">    printCarDetails(anotherCar); <span class="comment">// 修改后的详情，验证是否成功</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>运行结果示例：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Car 对象 [Toyota Camry] 被创建。</span><br><span class="line">--- 车辆详情 ---</span><br><span class="line">品牌: Toyota</span><br><span class="line">型号: Camry</span><br><span class="line">里程: 50000 公里</span><br><span class="line">----------------</span><br><span class="line"></span><br><span class="line">尝试在友元函数中修改里程。</span><br><span class="line">Car 对象 [Honda Civic] 被创建。</span><br><span class="line">--- 车辆详情 ---</span><br><span class="line">品牌: Honda</span><br><span class="line">型号: Civic</span><br><span class="line">里程: 10000 公里</span><br><span class="line">----------------</span><br><span class="line">--- 正在修改里程 ---</span><br><span class="line">旧里程: 10000 公里</span><br><span class="line">新里程: 0 公里</span><br><span class="line">--------------------</span><br><span class="line">--- 车辆详情 ---</span><br><span class="line">品牌: Honda</span><br><span class="line">型号: Civic</span><br><span class="line">里程: 0 公里</span><br><span class="line">----------------</span><br><span class="line">Car 对象 [Honda Civic] 被销毁。</span><br><span class="line">Car 对象 [Toyota Camry] 被销毁。</span><br></pre></td></tr></table></figure></div>
<h2 id="8-扩展问题与建议-Extended-Questions-for-Investigation"><a href="#8-扩展问题与建议-Extended-Questions-for-Investigation" class="headerlink" title="8. 扩展问题与建议 (Extended Questions for Investigation)"></a><strong>8. 扩展问题与建议 (Extended Questions for Investigation)</strong></h2><p>您已经掌握了 <code>friend</code> 函数的基本用法。为了进一步加深理解并探索相关概念，我建议您研究以下问题：</p>
<ol>
<li><p><strong>友元类（[Friend Classes]）：</strong> 除了友元函数，C++ 还有友元类。</p>
<ul>
<li><strong>问题：</strong> 什么是友元类？如何声明一个类为另一个类的友元？友元类中的所有成员函数是否都能访问友元类的私有成员？</li>
<li><strong>建议：</strong> 尝试编写一个 <code>CarFactory</code> 类，并将其声明为 <code>Car</code> 类的友元，让 <code>CarFactory</code> 能够访问 <code>Car</code> 的私有构造函数（例如，将 <code>Car</code> 的构造函数设为 <code>private</code>，只能通过 <code>CarFactory</code> 来创建 <code>Car</code> 对象）。</li>
</ul>
</li>
<li><p><strong>运算符重载（[Operator Overloading]）与友元函数的关系：</strong></p>
<ul>
<li><strong>问题：</strong> 为什么在重载 <code>&lt;&lt;</code> 运算符（用于 <code>std::cout</code> 输出）时，通常需要将其声明为友元函数？它与成员函数重载运算符有何不同？</li>
<li><strong>建议：</strong> 为您的 <code>Dog</code> 类或 <code>Car</code> 类重载 <code>&lt;&lt;</code> 运算符，使其能够直接通过 <code>std::cout &lt;&lt; myDog;</code> 或 <code>std::cout &lt;&lt; myCar;</code> 来打印对象信息。</li>
</ul>
</li>
<li><p><strong>封装与友元函数的平衡：</strong></p>
<ul>
<li><strong>问题：</strong> <code>friend</code> 函数打破了类的封装性。在实际开发中，何时应该使用 <code>friend</code> 函数，何时应该避免使用它而寻找替代方案（例如，<code>public</code> getter/setter 方法、或者将相关逻辑封装在成员函数中）？</li>
<li><strong>建议：</strong> 思考一下，如果 <code>printCarDetails</code> 不是友元函数，您将如何实现它来打印私有信息？比较这两种方法的优缺点。</li>
</ul>
</li>
<li><p><strong>常量的友元函数（[Const Friend Functions]）:</strong></p>
<ul>
<li><strong>问题：</strong> 如果一个友元函数被声明为 <code>const</code>（就像成员函数一样，但这在非成员函数中通常是针对参数的 <code>const</code> 引用），它能修改类的私有成员吗？</li>
<li><strong>建议：</strong> 回顾 <code>printCarDetails</code> 的参数是 <code>const Car&amp; car</code>。这有什么意义？如果 <code>modifyCarMileage</code> 的参数是 <code>const Car&amp; car</code>，它还能编译通过吗？为什么？</li>
</ul>
</li>
</ol>
<p>通过深入研究这些问题，您将对 C++ 的设计原则、封装、以及 <code>friend</code> 机制的适用场景有更全面的理解。继续努力，您会成为一名非常优秀的 C++ 开发者！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Function/">Function    </a><a class="post-meta__tags" href="/tags/Tutorial/">Tutorial    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/305%20-%20%E5%B7%B2%E5%88%A0%E9%99%A4%E6%9E%84%E9%80%A0%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>305 - 已删除构造 函数使用</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/306%20-%20%20cpp%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>306 -  cpp 初始化列表构造函数详解</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/return type for lambda function template/" title="return type for lambda function template"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">return type for lambda function template</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/259 - Auto Function Templates/" title="259 - Auto Function Templates"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">259 - Auto Function Templates</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/274 - default constructor/" title="274 - default constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">274 - default constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/282 - cpp结构体与类的区别和用法/" title="282 - cpp结构体与类的区别和用法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">282 - cpp结构体与类的区别和用法</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/296 - 构造函数默认参数/" title="296 - 构造函数默认参数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">296 - 构造函数默认参数</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/299 - 显式构造函数/" title="299 - 显式构造函数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">299 - 显式构造函数</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>