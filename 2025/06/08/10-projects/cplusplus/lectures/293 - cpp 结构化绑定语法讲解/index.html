<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>293 - cpp 结构化绑定语法讲解 | Bear's dream</title><meta name="description" content="293 - cpp 结构化绑定语法讲解"><meta name="keywords" content="Cpp,Coding,Learning,Course,Language"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="293 - cpp 结构化绑定语法讲解"><meta name="twitter:description" content="293 - cpp 结构化绑定语法讲解"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="293 - cpp 结构化绑定语法讲解"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/293%20-%20cpp%20%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E8%AF%AD%E6%B3%95%E8%AE%B2%E8%A7%A3/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="293 - cpp 结构化绑定语法讲解"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/293%20-%20cpp%20%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E8%AF%AD%E6%B3%95%E8%AE%B2%E8%A7%A3/"><link rel="prev" title="296 - 构造函数默认参数" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/296%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"><link rel="next" title="300 - cpp构造函数委托" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/300%20-%20cpp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A7%94%E6%89%98/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-结构化绑定语法讲解"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">C++ 结构化绑定语法讲解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#1-标题和摘要"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">1. 标题和摘要</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2-详细解释"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">2. 详细解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#4-问答卡片-QA-Flash-Cards"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">4. 问答卡片 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#5-常见误解或用户可能犯的错误"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">5. 常见误解或用户可能犯的错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#6-编码练习"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">6. 编码练习</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-2"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-2"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-3"><span class="toc_mobile_items-number">7.5.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#include"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">include </span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#include-1"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">include </span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-3"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#7-评价你的解答、给出正确答案和解释"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">7. 评价你的解答、给出正确答案和解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#8-拓展问题与建议"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">8. 拓展问题与建议</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-结构化绑定语法讲解"><span class="toc-number">1.</span> <span class="toc-text">C++ 结构化绑定语法讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-标题和摘要"><span class="toc-number">2.</span> <span class="toc-text">1. 标题和摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-详细解释"><span class="toc-number">3.</span> <span class="toc-text">2. 详细解释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-代码示例"><span class="toc-number">4.</span> <span class="toc-text">3. 代码示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-问答卡片-QA-Flash-Cards"><span class="toc-number">5.</span> <span class="toc-text">4. 问答卡片 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-常见误解或用户可能犯的错误"><span class="toc-number">6.</span> <span class="toc-text">5. 常见误解或用户可能犯的错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-编码练习"><span class="toc-number">7.</span> <span class="toc-text">6. 编码练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">7.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">7.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-2"><span class="toc-number">7.3.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-2"><span class="toc-number">7.4.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-3"><span class="toc-number">7.5.</span> <span class="toc-text">🧑‍💻 User</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include"><span class="toc-number">8.</span> <span class="toc-text">include </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-1"><span class="toc-number">9.</span> <span class="toc-text">include </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-3"><span class="toc-number">9.1.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-评价你的解答、给出正确答案和解释"><span class="toc-number">10.</span> <span class="toc-text">7. 评价你的解答、给出正确答案和解释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-拓展问题与建议"><span class="toc-number">11.</span> <span class="toc-text">8. 拓展问题与建议</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">293 - cpp 结构化绑定语法讲解</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/293%20-%20cpp%20%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E8%AF%AD%E6%B3%95%E8%AE%B2%E8%A7%A3/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/293%20-%20cpp%20%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A%E8%AF%AD%E6%B3%95%E8%AE%B2%E8%A7%A3/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="C-结构化绑定语法讲解"><a href="#C-结构化绑定语法讲解" class="headerlink" title="C++ 结构化绑定语法讲解"></a>C++ 结构化绑定语法讲解</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture we’re going to learn about structured bindings, and structured bindings are a technique.We have to access member variables of a class using some simple syntax.And suppose we have a struct which is really a class with public member variables inside.And this is going to be modeling a point in C plus plus.So we’re going to have the coordinates of a point which are double X and double y here.We could want to access the member variables of this struct very easily using the syntax we see here.So what we do is we use the auto keyword and then we put square brackets and inside we put the placeholdersfor the member variables of our struct.And if we do something like this, we basically going to have a copy of the x member variable storedin a and then we’re going to have a copy of the Y member variable stored in B here.So the order you declare things in is important.So we’re going to go from the first to the last and then we’re going to go from the first to the lastin this order here.So what this is going to do, it’s going to assign the member variables of our point object to A andB here.This is what this syntax here is going to do.And one thing you should know is that this is only going to work if your member variables are public.If they are not public, you’re going to get compiler errors because this is really like accessing usingthe syntax here 0.1 x and 0.1 Y, and the compiler is going to put together the machinery to make thiswork behind the curtains of how it works.But this is going to work.And one thing you should really, really keep in mind is that what you have in A and B are going tobe copies.So if after we happen to change our object and for example, in X, we put 10.1 and in Y, we put 66.2like we do here, and then we print A and B, A and B are not going to pick up.This changes because they are just copies.So this is the syntax for structured bindings.There is a lot more to this, especially with other data structures in C plus plus.But for now we’re going to use this in the context of a struct.Another thing you should know is that it is possible to capture a structured bindings inside a lambdafunction and this is something that was added in C plus plus 20.So for example, we can capture the a variable here in a lambda function and we can use it inside thelambda function like this.Another thing you should know is that at the moment it is not possible to do structured bindings thatuse references.If you want to do that, you doomed.You shouldn’t use structured bindings.But I just want you to know about this syntax.And in this lecture we are learning about it in the context of struct because structured bindings cando really, really much more, especially in more advanced data structures, as we will see later inthe course.But for now, I just want you to be aware of the syntax here and it shouldn’t be foreign to you if yousee it starting from today.Now that you know this, we’re going to head over to Visual Studio code and play with this a littlemore.Okay.Here we are in our working folder.The current project is Structured Bindings.We’re going to grab our template files and we’re going to put them in place.And let’s open this in Visual Studio code by dragging and dropping here, this is going to bring usour folder here and we can close the left sidebar.We don’t need it here and we’re going to put together a struct.It is going to be struct because we want to have public access to our member variables.We’re going to name this point and we’re going to put data inside.We’re not going to put anything complicated in here.We’re just going to put in double X and double Y, and this is going to model our point in C plus plus.What we can do, for example, is set up a point.Let’s do that in main.We’re going to call this point one and then we can say point one X and assign a value to this, let’ssay five and say point one Y, and we’re going to assign a six to this.And at the moment we do this, we can print this point.For example, let’s put in a function which is going to print a point.We’re going to say void print point because we don’t want to do stdcout every time.So we’re going to say print point here and we’re going to take a point by reference.And inside the body we’re going to say Stdcout point.We can save that and we’re going to say X and Y for this point here.So we’re going to say p x and we’re going to say Y.It’s going to be p y.This is how we access member variables of a struct directly and we’re going to put the closing squarebracket and we’re going to end this with Stdendl.I think this could work.So now we could come here and.The main function and say print point and pass 0.1 here.This should work.So let’s build and run this.We’re going to use GCC.You are going to see that the world is good so we can bring up a terminal and really play with this.Let’s clear and run, Rooster.You’re going to see that we have our point, but we can really access this point using structured bindingnotation.And the way we do that, we say auto and we put square bracket and then we say the variables that aregoing to capture the member variables of our struct.So we’re going to assign the point to one to this thing.And what this is going to do is assign the X member variable to A and assign the Y member variable toB, And now if we print A and B, we’re going to have the member variables printed out.Okay, So let’s do that.We’re going to say Stdcout A and we’re going to see the value printed out here and we’re going to printB and we’re going to see the value printed out here.Okay, let’s do that.We’re going to world.The world is good.We can clear and run Rooster.This is going to give us A and B.Another thing you should know is that A and B are copies.They’re not references or anything that has anything to do with the member variables we have in thestructure here.So we’re going to prove this.We’re going to change X and Y and our object, we’re going to print the point and then we’re going toprint A and B, and we see that nothing was affected in A and B here.So let’s do that.We’re going to say 0.1 X and we’re going to change this to anything really.Let’s put in 44.1 and then we’re going to say 0.1 Y and we’re going to put in 55.2.Why not?And then we’re going to print zero point.So we’re going to say print point and we’re going to print 0.1 again.And after this, we’re also going to say what we have in A and B, okay, So let’s clean this up a littlebit, because I think we have a lot of spaces in here, but we can space these things out because Iwant you to see them.What we are doing here, we are setting up a point, we are putting in values and then printing thepoint.We are using structured binding syntax here to assign the member variables of this point object to Aand B So A is going to have the value we have in X and B is going to have the value we have in Y.If we print this, we’re going to see that.Then we’re going to modify our point and then we’re going to print the modified point.But we’re going to see that because A and B are just copies.The change we do here are not going to be reflected in the second print we do for A and B here.This is the goal we have.So let’s build again.The build is good.We can clear and run Rooster.So you see that A and B are five and six first here, and then we modify our point and make it to havean X value of 44.1 and a Y value of 55.2.But you see that A and B don’t grab these changes because A and B are just copies.Please note that at the moment it is not possible to do structured bindings that capture references.So for example, if you’re trying to do something like this, that’s something somebody might do.If you do something like this, you’re going to get compiler errors.This is not supported.Let’s try and build and show you the problem.The compiler error is going to be really weird and we’re going to say expected identifier, AmpersandToken.This is really not supported.This is what the compiler error is trying to say here.So let’s take this out.And the last thing I want to show you is that it is possible to capture structured bindings in a lambdafunction.And if this is something that is important or useful for whatever project you are working on, pleaseuse this.So for example, we can set up a lambda function.We’re going to say auto func and we’re going to say the capture list is going to have a we’re goingto capture the structured bindings variable here and then we’re going to put in our parameter list andthen we’re going to put in our body and then we’re going to print a here, we’re going to do StdcoutA and say that it was captured and we’re going to print this out and then we’re going to call this lambdafunction here so we can say func and this is going to call our lambda function.Let’s build and see that this is actually going to work.So this is working properly.But notice that if you don’t capture a, you’re going to get a weird compiler error.You see we have a squiggly line already here and if you want, you’re going to see that you’re goingto have a compiler error along the lines of the a variable here was not captured.Okay.So we’re going to have the lambda has no capture default auto func and it’s going to say that A wasnot declared in the lambda.A function here.So this is the error you get.You need to capture A to be able to use it in the lambda function here.And I have to say that this is something that is possible in C plus plus 20.In earlier versions of C plus plus, this is going to give you a compiler error.So you should know this.Let’s build and show you that this is going to work.We should see a captured printed here on the console.Let’s clear and run Rooster.And we have a captured five here.If you want, you can capture everything by value.You can use the equal sign to do that.You already know this and this is also going to work and this is also going to capture B, let’s doStdcout We’re going to say be captured and we’re going to print B here.And this is going to work because we have captured everything in the context here in our Lambda function.If the capturing stuff is confusing, please go back and watch the chapter on lambda functions.We talked about this Thanks extensively, but for now we’re going to build and run this.We’re going to use GCC for that.You see, the world is good.We can clear and run Rooster and we’re going to see that B is also captured and the value is in here.This is really all we set out to do in this lecture, teaching you about structured bindings.The syntax is what you see here.And if you do this, you’re going to have a slightly nicer way to use the member variables of your struct.One thing I don’t think I talked about is that structured bindings like we do here are only going towork if you have public member variables.If for example, we change the struct here to be a class, this is going to make the member variablesprivate by default and we will have all kinds of crazy problems.But you see that even on our structured binding we have a squiggly line.This means that we can’t really use structured bindings on a class which has its member variables private.So if we change this to be public, let’s do that.We’re going to see that the squiggly lines are going to go away because the structured bindings onlywork if your member variables are public here.Please remember this and if you remember this, you’re going to use structured bindings however youwant.Another thing I should mention about structured bindings is that it is critical to use the auto keywordhere.So if, for example, you change this to double, let’s do that because some of you are going to askthis question.We’re going to see that we have a squiggly line and it is saying invalid specifier for structured bindingdeclaration.So structured bindings are only going to work if you specify the auto keyword here.This is what the Cplusplus compiler is going to expect.If you violate this, you’re going to get weird compiler errors.This is really all we set out to do in this lecture.I hope you found it interesting.We are going to stop here in this one.In the next one, we’re going to try and recap what we saw in this chapter.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，没问题！作为你的 C++ 启蒙老师，我会尽我所能用最清晰、最易懂的方式来教你。今天我们来学习一个 C++17 引入的很酷的特性——结构化绑定！</p>
<hr>
<h1 id="1-标题和摘要"><a href="#1-标题和摘要" class="headerlink" title="1. 标题和摘要"></a>1. 标题和摘要</h1><p><strong>标题：</strong> C++ 结构化绑定 (Structured Bindings) 入门：轻松访问成员变量</p>
<p><strong>摘要：</strong><br>本节课我们将学习 C++ 中的结构化绑定 (Structured Bindings)。这是一种自 C++17 起引入的便捷语法，允许我们用一种非常简洁的方式直接将 <code>struct</code> (结构体) 或 <code>class</code> (类)（当其成员是公开的时）的成员变量分解到独立的具名变量中。我们将重点了解它的基本用法、它是如何创建成员副本的，以及它在 <code>public</code> (公有) 成员访问权限下的工作方式。</p>
<hr>
<h1 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h1><p>让我们一步一步来揭开结构化绑定的神秘面纱。</p>
<p><strong>2.1 什么是结构化绑定 (Structured Bindings)？</strong></p>
<p>想象一下，你有一个表示二维空间点的结构体，它有两个成员：x 坐标和 y 坐标。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>在没有结构化绑定之前，如果你想分别获取 x 和 y 的值，你可能会这样做：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point p = &#123;<span class="number">10.0</span>, <span class="number">20.0</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> coord_x = p.x;</span><br><span class="line"><span class="keyword">double</span> coord_y = p.y;</span><br></pre></td></tr></table></figure></div>
<p>这没什么问题，但如果成员变量很多，或者你想让代码更简洁，结构化绑定就派上用场了。它允许你用一行代码就“解包” <code>Point</code> 对象的成员到单独的变量中。</p>
<p><strong>2.2 结构化绑定的基本语法</strong></p>
<p>结构化绑定的核心语法如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [变量名<span class="number">1</span>, 变量名<span class="number">2</span>, ...] = 对象实例;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>auto</code>：这是<strong>必须</strong>使用的关键字 (keyword)。编译器会自动推断 <code>变量名1</code>, <code>变量名2</code> 等的类型。你不能在这里显式指定类型（比如用 <code>double</code> 替换 <code>auto</code>）。</li>
<li><code>[]</code> (方括号)：里面是你为解包出来的成员变量起的新名字，用逗号隔开。</li>
<li><code>=</code>：赋值操作符。</li>
<li><code>对象实例</code>：通常是一个 <code>struct</code>、<code>class</code>（具有公开成员）、<code>std::pair</code>、<code>std::tuple</code> 或数组的实例。</li>
</ul>
<p>对于我们上面的 <code>Point</code> 例子，使用结构化绑定会是这样：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point p1 = &#123;<span class="number">5.0</span>, <span class="number">6.0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [a, b] = p1; <span class="comment">// 这就是结构化绑定！</span></span><br><span class="line"><span class="comment">// 此时，a 的值是 p1.x (5.0)，b 的值是 p1.y (6.0)</span></span><br></pre></td></tr></table></figure></div>
<p><strong>2.3 它是如何工作的？——顺序的重要性</strong></p>
<p>结构化绑定会按照 <code>struct</code> 或 <code>class</code> 中成员变量的<strong>声明顺序</strong>将它们的值赋给方括号中对应位置的变量。</p>
<ul>
<li><code>Point</code> 中第一个声明的成员是 <code>x</code>，所以 <code>p1.x</code> 的值赋给了方括号中的第一个变量 <code>a</code>。</li>
<li><code>Point</code> 中第二个声明的成员是 <code>y</code>，所以 <code>p1.y</code> 的值赋给了方括号中的第二个变量 <code>b</code>。</li>
</ul>
<p>所以，<code>auto [first, second] = p1;</code> 和 <code>auto [myX, myY] = p1;</code> 都是可以的，变量名由你决定，但它们总是按顺序接收值。</p>
<p><strong>2.4 关键特性：默认创建的是副本 (Copies)</strong></p>
<p>这是非常重要的一点！当你使用 <code>auto [a, b] = p1;</code> 这样的形式时，变量 <code>a</code> 和 <code>b</code> 得到的是 <code>p1.x</code> 和 <code>p1.y</code> 的<strong>副本 (copy)</strong>。</p>
<p>这意味着：</p>
<ul>
<li><code>a</code> 和 <code>b</code> 是独立于 <code>p1</code> 成员的新变量。</li>
<li>如果在结构化绑定之后修改了 <code>p1.x</code> 或 <code>p1.y</code> 的值，<code>a</code> 和 <code>b</code> 的值<strong>不会</strong>改变。</li>
<li>同样，修改 <code>a</code> 或 <code>b</code> 的值也<strong>不会</strong>影响 <code>p1.x</code> 或 <code>p1.y</code>。</li>
</ul>
<p>我们会在下面的代码示例中清楚地看到这一点。</p>
<p><strong>2.5 访问权限：仅适用于公有 (Public) 成员</strong></p>
<p>结构化绑定在尝试访问对象的成员时，遵循 C++ 的访问权限规则。它本质上是编译器为你自动生成类似 <code>object.member1</code>, <code>object.member2</code> 这样的访问代码。</p>
<ul>
<li>对于 <code>struct</code> (结构体)，成员默认是 <code>public</code> (公有) 的，所以结构化绑定可以直接使用。</li>
<li>对于 <code>class</code> (类)，成员默认是 <code>private</code> (私有) 的。如果你尝试对一个具有 <code>private</code> 成员的 <code>class</code> 对象使用结构化绑定，会导致编译错误 (compiler error)，因为外部代码无权访问私有成员。<ul>
<li>如果 <code>class</code> 的成员被显式声明为 <code>public</code>，那么结构化绑定就可以用于这个 <code>class</code> 对象。</li>
</ul>
</li>
</ul>
<p><strong>2.6 <code>auto</code> 关键字是强制的</strong></p>
<p>如前所述，你必须使用 <code>auto</code> 关键字。如果你尝试用具体的类型（如 <code>double</code>）来代替 <code>auto</code>，比如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范！</span></span><br><span class="line"><span class="keyword">double</span> [val_x, val_y] = p1; <span class="comment">// 这会导致编译错误</span></span><br></pre></td></tr></table></figure></div>
<p>编译器会报错，因为它期望 <code>auto</code> 来配合结构化绑定的声明。</p>
<p><strong>2.7 关于引用 (References) 的说明 (根据课程内容)</strong></p>
<p>课程内容特别提到，在当前（或者说，在它描述的C++版本或特定上下文中）不直接支持通过结构化绑定来创建原始成员的引用 (reference)，例如尝试这样做：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据课程内容，以下方式不被支持，会导致编译错误</span></span><br><span class="line"><span class="comment">// auto&amp; [ref_x, ref_y] = p1;</span></span><br></pre></td></tr></table></figure></div>
<p>课程指出这样做是“注定要失败的”，并建议如果需要引用，则不应使用结构化绑定。<br><em>(助教小提示: 尽管现代C++ (C++17及以后) 实际上是支持 <code>auto&amp;</code> 和 <code>auto&amp;&amp;</code> 的结构化绑定的，从而可以绑定到引用。但为了遵循你提供的课程材料，我们在这里强调课程中的观点。了解课程材料的特定教学点很重要。)</em></p>
<p><strong>2.8 结构化绑定与 Lambda 函数 (Lambda function) (C++20)</strong></p>
<p>从 C++20 开始，结构化绑定声明的变量可以被捕获到 Lambda 表达式 (Lambda function) 中。这非常方便。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Point p_lambda = &#123;<span class="number">7.0</span>, <span class="number">8.0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x_val, y_val] = p_lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> my_lambda = [x_val] &#123; <span class="comment">// 按值捕获 x_val</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambda captured x_val: "</span> &lt;&lt; x_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">my_lambda(); <span class="comment">// 调用 lambda</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以按值捕获所有在作用域内的变量，包括结构化绑定产生的变量</span></span><br><span class="line"><span class="keyword">auto</span> another_lambda = [=] &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambda captured x_val: "</span> &lt;&lt; x_val &lt;&lt; <span class="string">" and y_val: "</span> &lt;&lt; y_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">another_lambda();</span><br></pre></td></tr></table></figure></div>
<p>如果 lambda 试图使用一个未被捕获的结构化绑定变量，编译器会报错，提示该变量未在 lambda 的捕获列表 (capture list) 中。</p>
<p><strong>2.9 结构化绑定的适用范围</strong></p>
<p>虽然本课主要关注 <code>struct</code>，但结构化绑定也适用于其他类型，比如：</p>
<ul>
<li><code>std::pair</code></li>
<li><code>std::tuple</code></li>
<li>原生数组 (C-style arrays)</li>
</ul>
<p>这使得从这些数据结构中提取元素变得异常简单。</p>
<hr>
<h1 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h1><p>让我们通过一个完整的例子来演示以上知识点。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; // 只是为了包含一些常用头文件，本例中未直接使用 vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个表示点的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="comment">// 默认成员是 public</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果我们用 class 并且不指定 public，成员默认是 private</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointClassPrivate</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x_coord; <span class="comment">// 默认 private</span></span><br><span class="line">    <span class="keyword">double</span> y_coord; <span class="comment">// 默认 private</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PointClassPrivate(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : x_coord(x), y_coord(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// 如果想让结构化绑定工作，需要提供 public 的 getter 方法</span></span><br><span class="line">    <span class="comment">// 或者将成员设为 public (如下面的 PointClassPublic)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointClassPublic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x_coord; <span class="comment">// 显式声明为 public</span></span><br><span class="line">    <span class="keyword">double</span> y_coord; <span class="comment">// 显式声明为 public</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPoint</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point: [x="</span> &lt;&lt; p.x &lt;&lt; <span class="string">", y="</span> &lt;&lt; p.y &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 结构化绑定基础 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Point p1 = &#123;<span class="number">5.0</span>, <span class="number">6.0</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Original p1: "</span>;</span><br><span class="line">    printPoint(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构化绑定</span></span><br><span class="line">    <span class="keyword">auto</span> [a, b] = p1; <span class="comment">// a 获取 p1.x 的副本, b 获取 p1.y 的副本</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Structured binding: a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 证明 a, b 是副本 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 修改原始对象 p1 的成员</span></span><br><span class="line">    p1.x = <span class="number">44.1</span>;</span><br><span class="line">    p1.y = <span class="number">55.2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Modified p1: "</span>;</span><br><span class="line">    printPoint(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次打印 a 和 b，它们的值没有改变</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a and b after p1 modification: a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"(See? a and b were copies and were not affected by changes to p1.x and p1.y)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 a 和 b，p1 的成员也不会改变</span></span><br><span class="line">    a = <span class="number">100.0</span>;</span><br><span class="line">    b = <span class="number">200.0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nModified a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 after a and b modification: "</span>;</span><br><span class="line">    printPoint(p1);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"(p1 was not affected by changes to a and b)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- auto 关键字是必须的 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 下面的代码如果取消注释，会导致编译错误</span></span><br><span class="line">    <span class="comment">// double [x_coord, y_coord] = p1;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "This won't compile." &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Attempting 'double [x_c, y_c] = p1;' would cause a compiler error."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error message might be: 'invalid specifier for structured binding declaration'"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 成员访问权限 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Using struct (default public members): Works!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Point p_struct = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [sx, sy] = p_struct;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Struct binding: sx = "</span> &lt;&lt; sx &lt;&lt; <span class="string">", sy = "</span> &lt;&lt; sy &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nUsing class with explicit public members: Works!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    PointClassPublic p_class_pub = &#123;<span class="number">3.3</span>, <span class="number">4.4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [cpx, cpy] = p_class_pub; <span class="comment">// 访问 p_class_pub.x_coord 和 p_class_pub.y_coord</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Class public binding: cpx = "</span> &lt;&lt; cpx &lt;&lt; <span class="string">", cpy = "</span> &lt;&lt; cpy &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nUsing class with default private members: Fails!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">PointClassPrivate <span class="title">p_class_priv</span><span class="params">(<span class="number">5.5</span>, <span class="number">6.6</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 下面的代码如果取消注释，会导致编译错误</span></span><br><span class="line">    <span class="comment">// auto [cvx, cvy] = p_class_priv; // 错误：x_coord 和 y_coord 是私有的</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "This won't compile because members are private." &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Attempting 'auto [cvx, cvy] = p_class_priv;' would cause a compiler error."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error might be related to inaccessible members."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 结构化绑定与 Lambda (C++20) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Point p_lambda_demo = &#123;<span class="number">7.7</span>, <span class="number">8.8</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [lx, ly] = p_lambda_demo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕获单个结构化绑定变量</span></span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [lx]() &#123; <span class="comment">// 按值捕获 lx</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambda1 (captures lx): lx = "</span> &lt;&lt; lx &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// ly = 10; // 错误: ly 未被捕获 (如果取消注释)</span></span><br><span class="line">        <span class="comment">// 同时，lx 是按值捕获的副本，修改它不影响外部的 lx</span></span><br><span class="line">    &#125;;</span><br><span class="line">    lambda1();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认按值捕获 [=] 来捕获所有用到的外部变量</span></span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [=]() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambda2 (captures with [=]): lx = "</span> &lt;&lt; lx &lt;&lt; <span class="string">", ly = "</span> &lt;&lt; ly &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    lambda2();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试使用未捕获的变量会导致编译错误</span></span><br><span class="line">    <span class="keyword">auto</span> lambda_error_example = []() &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; "Trying to use lx without capture: " &lt;&lt; lx &lt;&lt; std::endl; // 这会编译失败</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A lambda trying to use 'lx' or 'ly' without capturing them would fail to compile."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 关于引用绑定 (根据课程内容) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 根据课程说明，以下方式是不支持的</span></span><br><span class="line">    <span class="comment">// Point p_ref_test = &#123;9.1, 9.2&#125;;</span></span><br><span class="line">    <span class="comment">// auto&amp; [rx, ry] = p_ref_test; // 课程指出这会产生编译错误 "expected identifier before ‘&amp;’ token"</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"As per the lecture, 'auto&amp; [rx, ry] = p_obj;' is stated to cause a compiler error."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The lecture suggests this syntax for reference binding is not supported."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>编译和运行说明:</strong><br>如果你用的是支持 C++17 (或更高版本，对于 lambda 捕获结构化绑定则需要 C++20) 的编译器 (compiler)，例如 GCC 7+ 或 Clang 5+：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++17 your_file_name.cpp -o structured_bindings_demo</span><br><span class="line">./structured_bindings_demo</span><br></pre></td></tr></table></figure></div><br>如果需要 lambda 捕获结构化绑定的功能，请使用 <code>-std=c++20</code>：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++20 your_file_name.cpp -o structured_bindings_demo</span><br><span class="line">./structured_bindings_demo</span><br></pre></td></tr></table></figure></div></p>
<hr>
<h1 id="4-问答卡片-QA-Flash-Cards"><a href="#4-问答卡片-QA-Flash-Cards" class="headerlink" title="4. 问答卡片 (QA Flash Cards)"></a>4. 问答卡片 (QA Flash Cards)</h1><p>这里有一些卡片，帮助你巩固记忆：</p>
<ol>
<li><p><strong>问：</strong> 什么是结构化绑定 (Structured Bindings)？<br><strong>答：</strong> C++17 引入的一种语法，允许将 <code>struct</code>、<code>class</code> (公有成员)、<code>pair</code>、<code>tuple</code> 或数组的成员/元素直接解包到独立的变量中。</p>
</li>
<li><p><strong>问：</strong> 结构化绑定的基本语法是什么？<br><strong>答：</strong> <code>auto [var1, var2, ...] = object;</code></p>
</li>
<li><p><strong>问：</strong> 在结构化绑定 <code>auto [a, b] = obj;</code> 中，<code>a</code> 和 <code>b</code> 是 <code>obj</code> 成员的副本还是引用？<br><strong>答：</strong> 默认情况下，它们是副本 (copies)。</p>
</li>
<li><p><strong>问：</strong> 结构化绑定要求对象的成员具有什么访问权限？<br><strong>答：</strong> <code>public</code> (公有) 访问权限。</p>
</li>
<li><p><strong>问：</strong> 在声明结构化绑定时，必须使用哪个关键字来代替具体的类型？<br><strong>答：</strong> <code>auto</code> 关键字。</p>
</li>
<li><p><strong>问：</strong> 结构化绑定解包成员是基于成员名称还是声明顺序？<br><strong>答：</strong> 基于成员在 <code>struct</code> 或 <code>class</code> 中的声明顺序。</p>
</li>
<li><p><strong>问：</strong> 结构化绑定声明的变量可以被 Lambda 函数捕获吗？<br><strong>答：</strong> 可以，自 C++20 起，它们可以像普通变量一样被捕获。</p>
</li>
<li><p><strong>问：</strong> 根据本课程的讲解，如果尝试 <code>auto&amp; [x, y] = obj;</code> 会怎样？<br><strong>答：</strong> 根据本课程的讲解，这会导致编译错误，因为课程指出这种形式的引用绑定不被支持。</p>
</li>
</ol>
<hr>
<h1 id="5-常见误解或用户可能犯的错误"><a href="#5-常见误解或用户可能犯的错误" class="headerlink" title="5. 常见误解或用户可能犯的错误"></a>5. 常见误解或用户可能犯的错误</h1><ol>
<li><strong>误以为是引用绑定：</strong> 最常见的误解是认为 <code>auto [a, b] = obj;</code> 中的 <code>a</code> 和 <code>b</code> 是 <code>obj</code> 成员的引用。然后惊讶地发现修改 <code>obj.x</code> 并没有改变 <code>a</code> 的值。记住，默认是<strong>副本</strong>！</li>
<li><strong>忘记 <code>auto</code> 关键字：</strong> 新手可能会尝试写 <code>MyStructType [var1, var2] = myStructInstance;</code> 或者 <code>double [x, y] = myPoint;</code>。这是错误的，必须使用 <code>auto</code>。</li>
<li><strong>对私有成员使用：</strong> 尝试对一个 <code>class</code> 的私有成员使用结构化绑定，例如 <code>MyClass instance; auto [m1, m2] = instance;</code> (其中 <code>m1</code>, <code>m2</code> 对应 <code>MyClass</code> 的私有成员)，这将导致编译失败。</li>
<li><strong>变量名和成员名不匹配的困惑：</strong> <code>auto [apple, banana] = myPoint;</code> 这里的 <code>apple</code> 仍然会得到 <code>myPoint.x</code> 的值（如果 <code>x</code> 是第一个成员），<code>banana</code> 得到 <code>myPoint.y</code> 的值（如果 <code>y</code> 是第二个成员）。变量名是你自己起的，和原始成员名无关，只和顺序有关。</li>
<li><strong>对课程中关于 <code>auto&amp;</code> 的说明感到困惑：</strong> 用户可能会在别处看到 <code>auto&amp;</code> 用于结构化绑定并成功编译，然后对本课程中指出的“不支持”感到困惑。关键在于理解本课程的教学上下文——它可能基于一个较早的理解或特定的编译器行为来简化教学。<em>(助教再次提示：现代C++是支持的，但我们需根据你提供的课程材料来教学)</em></li>
<li><strong>Lambda 捕获问题 (C++20前)：</strong> 在 C++20 之前，直接捕获结构化绑定中声明的变量到 lambda 中是不支持的或有问题的。如果用户的编译器不是 C++20 模式，尝试捕获可能会失败。</li>
<li><strong>不理解顺序的重要性：</strong> 如果一个结构体是 <code>struct Data { int id; std::string name; };</code>，那么 <code>auto [s, i] = myData;</code> 将导致 <code>s</code> 获得 <code>id</code> 的值，<code>i</code> 获得 <code>name</code> 的值，这可能不是用户期望的，因为类型不匹配（<code>std::string</code> 赋给 <code>int</code> 或反之），可能导致编译错误或隐式转换问题。</li>
</ol>
<hr>
<h1 id="6-编码练习"><a href="#6-编码练习" class="headerlink" title="6. 编码练习"></a>6. 编码练习</h1><p>现在，轮到你来试试身手了！下面有一个 <code>Student</code> 结构体，请你补全代码，使用结构化绑定来获取 <code>name</code> 和 <code>age</code> 成员，并打印它们。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注意：这里可以添加一个构造函数来方便初始化</span></span><br><span class="line">    Student(<span class="built_in">std</span>::<span class="built_in">string</span> n, <span class="keyword">int</span> a) : name(n), age(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在这里使用结构化绑定来从 s1 中获取 name 和 age</span></span><br><span class="line">    <span class="comment">// 将 name 存储在名为 studentName 的变量中</span></span><br><span class="line">    <span class="comment">// 将 age 存储在名为 studentAge 的变量中</span></span><br><span class="line">    <span class="comment">// ______ [____________, ____________] = ___; // 填空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 打印 studentName 和 studentAge</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "学生姓名: " &lt;&lt; ___________ &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "学生年龄: " &lt;&lt; ___________ &lt;&lt; "岁" &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请你思考一下，然后在空白处填上正确的代码。完成后告诉我你的答案，我会帮你检查！加油！</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>开始之前我问个问题, 是不是说只要有private变量或者函数的class就不能用structure binding了?</p>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>问得好！这是一个非常关键的点，能帮助你更深入地理解结构化绑定的工作原理。</p>
<p>简单来说，不完全是“只要有 private 变量或函数的 class 就不能用”。更准确的说法是：</p>
<p><strong>结构化绑定 (Structured Binding) 要求它尝试访问并解包的那些非静态数据成员 (non-static data members) 必须是 <code>public</code> (公有的)。</strong></p>
<p>让我详细解释一下：</p>
<ol>
<li><strong>针对数据成员 (Data Members)：</strong> 结构化绑定是用来“解开”对象的数据成员的。它会按照这些数据成员在类或结构体中声明的顺序，依次将它们赋值给你在方括号 <code>[]</code> 中提供的变量。</li>
<li><strong>访问权限检查 (Access Check)：</strong> 当结构化绑定尝试访问这些数据成员时，C++ 的访问权限规则会生效。如果它试图访问一个 <code>private</code> (私有) 或 <code>protected</code> (受保护) 的成员（并且当前上下文无权访问），编译器就会报错。</li>
<li><strong>所有参与绑定的成员都必须可访问：</strong> 结构化绑定会尝试解包从第一个非静态数据成员开始的所有成员（或者直到你提供的变量数量用尽为止）。如果在这个过程中，遇到的任何一个需要被解包的成员是 <code>private</code> 或 <code>protected</code>，那么整个结构化绑定就会失败。</li>
<li><strong>私有函数 (Private Functions) 的影响：</strong> 类中是否有私有成员函数通常<strong>不直接</strong>影响结构化绑定。结构化绑定关心的是数据成员。只要那些它需要解包的数据成员是 <code>public</code> 的，即使类里有私有函数，结构化绑定也能工作。</li>
<li><strong>混合访问权限 (Mixed Access Specifiers)：</strong><ul>
<li>如果一个类有部分 <code>public</code> 数据成员和部分 <code>private</code> 数据成员：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MixedAccess</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> public_data;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> private_data; <span class="comment">// 这个是私有的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> another_public_data;</span><br><span class="line"></span><br><span class="line">    MixedAccess(<span class="keyword">int</span> p, <span class="keyword">int</span> priv, <span class="built_in">std</span>::<span class="built_in">string</span> s) : public_data(p), private_data(priv), another_public_data(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MixedAccess <span class="title">obj</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="comment">// auto [a, b, c] = obj; // 编译错误！因为 private_data 是私有的，无法在外部通过结构化绑定访问。</span></span><br><span class="line">                       <span class="comment">// 结构化绑定会按顺序尝试访问 public_data, private_data, another_public_data</span></span><br></pre></td></tr></table></figure></div>
在这个例子中，即使 <code>public_data</code> 和 <code>another_public_data</code> 是公有的，但因为 <code>private_data</code> 夹在中间（按声明顺序）并且是私有的，所以当你试图解包所有三个成员时，结构化绑定会失败。</li>
<li>如果所有你想绑定的成员都在 <code>private</code> 成员之前声明并且是 <code>public</code> 的，那么部分绑定是可能的，但这依赖于结构化绑定如何处理成员数量不匹配的情况（通常它会尝试绑定所有非静态数据成员）。但更安全的理解是，所有将被解包的成员都需要是公有的。<br>C++标准规定，结构化绑定会考虑类中所有的非静态数据成员。如果其中任何一个是不可访问的，那么绑定就会失败。</li>
</ul>
</li>
</ol>
<p><strong>总结一下：</strong></p>
<ul>
<li><strong>不是</strong> “只要有 <code>private</code> 成员就完全不能用”。</li>
<li>而是 “结构化绑定试图访问的<strong>所有非静态数据成员</strong>都必须是 <code>public</code> 的”。</li>
<li>如果一个类所有数据成员都是 <code>private</code> 的，那么你肯定不能对其实例使用结构化绑定。</li>
<li>如果一个类的数据成员有 <code>public</code> 也有 <code>private</code>，那么结构化绑定会因为无法访问 <code>private</code> 成员而失败。</li>
<li>类中的 <code>private</code> 成员函数本身不阻止对 <code>public</code> 数据成员的结构化绑定。</li>
</ul>
<p>所以，你提出的问题触及了核心，关键在于<strong>哪些成员</strong>是 <code>private</code> 的（数据成员还是函数成员），以及结构化绑定具体要访问哪些成员。对于 <code>class</code>，如果你想用结构化绑定，通常需要确保所有非静态数据成员都是 <code>public</code> 的（这使得它在行为上更像一个 <code>struct</code>）。</p>
<p>现在你可以继续尝试填写练习代码了！如果还有疑问，随时问我。</p>
<hr>
<h2 id="🧑‍💻-User-2"><a href="#🧑‍💻-User-2" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>那如果是这个class有method呢?</p>
<hr>
<h2 id="🤖-Assistant-2"><a href="#🤖-Assistant-2" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好问题！这个问题能帮助我们进一步明确结构化绑定的作用对象。</p>
<p><strong>对于一个有成员函数 (methods) 的 <code>class</code>，结构化绑定的行为如下：</strong></p>
<ol>
<li><strong>结构化绑定主要关注的是类的非静态数据成员 (non-static data members)。</strong> 它尝试将这些数据成员的值“解包”到你提供的独立变量中。</li>
<li><strong>成员函数 (methods) 本身不参与结构化绑定的解包过程。</strong> 你不能通过结构化绑定将一个成员函数赋值给一个变量。成员函数是类的行为或操作，而不是可以直接提取并赋值给独立变量的数据片段。</li>
<li><strong>只要那些将被结构化绑定访问和解包的非静态数据成员是 <code>public</code> (公有的)，即使类中包含成员函数（无论是 <code>public</code>、<code>private</code> 还是 <code>protected</code>），结构化绑定仍然可以正常工作。</strong></li>
</ol>
<p>简单来说：<strong>类中有成员函数不会阻止结构化绑定，前提是它要绑定的数据成员是公有的。</strong></p>
<p>让我们看一个例子：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // 为了 std::sqrt</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> radius;      <span class="comment">// 公有数据成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> color;  <span class="comment">// 公有数据成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Circle(<span class="keyword">double</span> r, <span class="built_in">std</span>::<span class="built_in">string</span> c) : radius(r), color(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14159</span> * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">describe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is a "</span> &lt;&lt; color &lt;&lt; <span class="string">" circle with radius "</span> &lt;&lt; radius </span><br><span class="line">                  &lt;&lt; <span class="string">". Area: "</span> &lt;&lt; getArea() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员函数 (不影响结构化绑定对公有数据成员的访问)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internalCalculation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Performing internal calculation..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Circle <span class="title">c1</span><span class="params">(<span class="number">5.0</span>, <span class="string">"Red"</span>)</span></span>;</span><br><span class="line">    c1.describe(); <span class="comment">// 调用成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构化绑定来获取公有的数据成员 radius 和 color</span></span><br><span class="line">    <span class="comment">// 成员函数 getArea(), describe(), internalCalculation() 不会被绑定</span></span><br><span class="line">    <span class="keyword">auto</span> [rad, col] = c1; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nAfter structured binding:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Radius extracted: "</span> &lt;&lt; rad &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Color extracted: "</span> &lt;&lt; col &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rad 和 col 是 c1.radius 和 c1.color 的副本</span></span><br><span class="line">    rad = <span class="number">10.0</span>; <span class="comment">// 修改 rad 不会影响 c1.radius</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c1.radius after modifying 'rad': "</span> &lt;&lt; c1.radius &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 仍然是 5.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你仍然可以调用对象的成员函数</span></span><br><span class="line">    <span class="comment">// double area = c1.getArea(); // 这是可以的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你不能这样做：</span></span><br><span class="line">    <span class="comment">// auto [r, clr, area_func] = c1; // 错误！结构化绑定不解包成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个例子中：</p>
<ul>
<li><code>Circle</code> 类有公有数据成员 <code>radius</code> 和 <code>color</code>。</li>
<li>它也有公有成员函数 <code>getArea()</code>、<code>describe()</code> 和一个私有成员函数 <code>internalCalculation()</code>。</li>
<li>结构化绑定 <code>auto [rad, col] = c1;</code> 成功地将 <code>c1.radius</code> 的值赋给了 <code>rad</code>，将 <code>c1.color</code> 的值赋给了 <code>col</code>。</li>
<li>成员函数的存在（无论是公有还是私有）并没有影响结构化绑定对公有数据成员的访问。</li>
<li>结构化绑定并没有，也不能，把 <code>getArea()</code> 或 <code>describe()</code> 这样的成员函数“解包”出来。</li>
</ul>
<p><strong>总结关键点：</strong></p>
<ul>
<li>结构化绑定的目标是<strong>非静态数据成员</strong>。</li>
<li>成员函数（方法）<strong>不参与</strong>解包。</li>
<li>只要目标数据成员是 <code>public</code>，类中有无成员函数或成员函数的访问权限如何，都不影响结构化绑定对这些<strong>公有数据成员</strong>的解包。</li>
</ul>
<p>所以，你可以放心地在有成员函数的类上使用结构化绑定，只要你关注的是那些可公开访问的数据成员。</p>
<p>现在，你可以尝试完成之前的编码练习了！如果你还有其他问题，尽管问。</p>
<hr>
<h2 id="🧑‍💻-User-3"><a href="#🧑‍💻-User-3" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></string></h1><p>struct Student {<br>    std::string name;<br>    int age;<br>    // 注意：这里可以添加一个构造函数来方便初始化<br>    Student(std::string n, int a) : name(n), age(a) {}<br>};</p>
<p>int main() {<br>    Student s1(“小明”, 12);</p>
<pre><code>// TODO: 在这里使用结构化绑定来从 s1 中获取 name 和 age
// 将 name 存储在名为 studentName 的变量中
// 将 age 存储在名为 studentAge 的变量中
// ______ [____________, ____________] = ___; // 填空
auto [studentName, studentAge] = s1;

// TODO: 打印 studentName 和 studentAge
// std::cout &lt;&lt; &quot;学生姓名: &quot; &lt;&lt; ___________ &lt;&lt; std::endl;
// std::cout &lt;&lt; &quot;学生年龄: &quot; &lt;&lt; ___________ &lt;&lt; &quot;岁&quot; &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;学生姓名: &quot; &lt;&lt; studentName &lt;&lt; std::endl;
std::cout &lt;&lt; &quot;学生年龄: &quot; &lt;&lt; studentAge &lt;&lt; &quot;岁&quot; &lt;&lt; std::endl;

return 0;
</code></pre><p>}</p>
<hr>
<h2 id="🤖-Assistant-3"><a href="#🤖-Assistant-3" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，我们来看一下你的解答！</p>
<hr>
<h1 id="7-评价你的解答、给出正确答案和解释"><a href="#7-评价你的解答、给出正确答案和解释" class="headerlink" title="7. 评价你的解答、给出正确答案和解释"></a>7. 评价你的解答、给出正确答案和解释</h1><p><strong>你的解答：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注意：这里可以添加一个构造函数来方便初始化</span></span><br><span class="line">    Student(<span class="built_in">std</span>::<span class="built_in">string</span> n, <span class="keyword">int</span> a) : name(n), age(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在这里使用结构化绑定来从 s1 中获取 name 和 age</span></span><br><span class="line">    <span class="comment">// 将 name 存储在名为 studentName 的变量中</span></span><br><span class="line">    <span class="comment">// 将 age 存储在名为 studentAge 的变量中</span></span><br><span class="line">    <span class="keyword">auto</span> [studentName, studentAge] = s1; <span class="comment">// 你填写的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 打印 studentName 和 studentAge</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"学生姓名: "</span> &lt;&lt; studentName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 你填写的代码</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"学生年龄: "</span> &lt;&lt; studentAge &lt;&lt; <span class="string">"岁"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 你填写的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>评价：</strong></p>
<p>太棒了！你的解答是<strong>完全正确的</strong>！ 💯</p>
<ul>
<li>你正确地使用了 <code>auto</code> 关键字。</li>
<li>你使用了方括号 <code>[]</code> 来声明新的变量名 <code>studentName</code> 和 <code>studentAge</code>。</li>
<li>你将 <code>s1</code> 对象赋值给了结构化绑定声明。</li>
<li><code>studentName</code> 将会按顺序接收 <code>s1.name</code> 的副本，<code>studentAge</code> 将会按顺序接收 <code>s1.age</code> 的副本。</li>
<li>后续的打印语句也正确地使用了这两个新变量。</li>
</ul>
<p><strong>没有任何问题，非常出色！</strong> 这表明你已经理解了结构化绑定的基本用法。</p>
<p><strong>标准答案（与你的答案一致）：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注意：这里可以添加一个构造函数来方便初始化</span></span><br><span class="line">    Student(<span class="built_in">std</span>::<span class="built_in">string</span> n, <span class="keyword">int</span> a) : name(n), age(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">"小明"</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构化绑定来从 s1 中获取 name 和 age</span></span><br><span class="line">    <span class="comment">// 将 name 存储在名为 studentName 的变量中</span></span><br><span class="line">    <span class="comment">// 将 age 存储在名为 studentAge 的变量中</span></span><br><span class="line">    <span class="keyword">auto</span> [studentName, studentAge] = s1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 studentName 和 studentAge</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"学生姓名: "</span> &lt;&lt; studentName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"学生年龄: "</span> &lt;&lt; studentAge &lt;&lt; <span class="string">"岁"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释：</strong></p>
<p>正如我们在课程中讨论的：</p>
<ol>
<li><code>Student</code> 是一个 <code>struct</code>，它的成员 <code>name</code> 和 <code>age</code> 默认是 <code>public</code> (公有的)。</li>
<li><code>auto [studentName, studentAge] = s1;</code> 这行代码就是结构化绑定的核心。<ul>
<li><code>auto</code>：编译器会自动推断 <code>studentName</code> 的类型为 <code>std::string</code>，<code>studentAge</code> 的类型为 <code>int</code>。</li>
<li><code>[studentName, studentAge]</code>：声明了两个新的变量。<code>studentName</code> 会对应 <code>Student</code> 结构体中声明的第一个成员 (<code>name</code>)，<code>studentAge</code> 会对应第二个成员 (<code>age</code>)。</li>
<li><code>= s1</code>：将 <code>s1</code> 对象的值“解包”赋给这些新变量。</li>
</ul>
</li>
<li>重要的是要记住，<code>studentName</code> 得到的是 <code>s1.name</code> 的一个<strong>副本 (copy)</strong>，<code>studentAge</code> 得到的是 <code>s1.age</code> 的一个<strong>副本 (copy)</strong>。如果你后续修改 <code>s1.name</code> 或 <code>s1.age</code>，<code>studentName</code> 和 <code>studentAge</code> 的值不会改变，反之亦然。</li>
</ol>
<p>你的代码运行后会输出：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">学生姓名: 小明</span><br><span class="line">学生年龄: 12岁</span><br></pre></td></tr></table></figure></div><br>这完全符合预期。</p>
<hr>
<h1 id="8-拓展问题与建议"><a href="#8-拓展问题与建议" class="headerlink" title="8. 拓展问题与建议"></a>8. 拓展问题与建议</h1><p>你已经很好地掌握了基础，下面是一些可以让你进一步思考和探索的建议和问题：</p>
<ol>
<li><p><strong>绑定到引用：</strong><br>虽然我们之前的课程内容指出 <code>auto&amp; [rx, ry] = obj;</code> 可能会有问题，但实际上从 C++17 开始，结构化绑定是支持绑定到引用的。你可以尝试一下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(<span class="string">"小红"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span>&amp; [nameRef, ageRef] = s2;</span><br><span class="line">nameRef = <span class="string">"小华"</span>; <span class="comment">// 修改 nameRef</span></span><br><span class="line">ageRef = <span class="number">11</span>;     <span class="comment">// 修改 ageRef</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"s2.name: "</span> &lt;&lt; s2.name &lt;&lt; <span class="string">", s2.age: "</span> &lt;&lt; s2.age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></div>
<p>看看 <code>s2</code> 的成员是否真的被修改了。这会帮助你理解副本绑定和引用绑定的区别。<em>请注意，这与之前课程中提到的“不支持”的说法有所不同，这是对现代 C++ 更准确的描述。</em></p>
</li>
<li><p><strong>绑定到 <code>const</code> 引用：</strong><br>如果你不希望通过结构化绑定修改原始对象，但又想避免不必要的拷贝（特别是对于大的对象），可以绑定到 <code>const</code> 引用：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">s3</span><span class="params">(<span class="string">"小刚"</span>, <span class="number">13</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; [constNameRef, constAgeRef] = s3;</span><br><span class="line"><span class="comment">// constNameRef = "新名字"; // 这行代码如果取消注释，会导致编译错误</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Const Ref Name: "</span> &lt;&lt; constNameRef &lt;&lt; <span class="string">", Const Ref Age: "</span> &lt;&lt; constAgeRef &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></div>
<p>思考一下这样做的好处。</p>
</li>
<li><p><strong>结构化绑定与 <code>std::pair</code> 和 <code>std::tuple</code>：</strong><br>结构化绑定不仅仅用于自定义的 <code>struct</code> 或 <code>class</code>。它对于标准库中的 <code>std::pair</code> 和 <code>std::tuple</code> 非常有用。<br>尝试创建一个 <code>std::pair&lt;std::string, int&gt;</code> 和一个 <code>std::tuple&lt;std::string, int, double&gt;</code>，然后使用结构化绑定来获取它们的值。<br>例如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // for std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;   // for std::tuple</span></span></span><br><span class="line"></span><br><span class="line">std::pair&lt;std::string, int&gt; myPair("test_pair", 100);</span><br><span class="line"><span class="keyword">auto</span> [str_val, int_val] = myPair;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pair: "</span> &lt;&lt; str_val &lt;&lt; <span class="string">", "</span> &lt;&lt; int_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">std::tuple&lt;std::string, int, double&gt; myTuple("test_tuple", 200, 3.14);</span><br><span class="line"><span class="keyword">auto</span> [s_tuple, i_tuple, d_tuple] = myTuple;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Tuple: "</span> &lt;&lt; s_tuple &lt;&lt; <span class="string">", "</span> &lt;&lt; i_tuple &lt;&lt; <span class="string">", "</span> &lt;&lt; d_tuple &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>结构化绑定与数组：</strong><br>你也可以对原生数组使用结构化绑定：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [x, y, z] = arr;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Array elements: "</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">", "</span> &lt;&lt; z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// x = arr[0], y = arr[1], z = arr[2]</span></span><br></pre></td></tr></table></figure></div>
<p>思考一下如果数组元素的数量和方括号中变量的数量不匹配会发生什么？（提示：通常会导致编译错误，数量必须匹配）。</p>
</li>
<li><p><strong>忽略某些成员：</strong><br>如果你只想绑定结构体或元组中的某些成员，而忽略其他的，可以使用 <code>std::ignore</code> (需要包含 <code>&lt;tuple&gt;</code> 头文件)：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">s4</span><span class="params">(<span class="string">"小李"</span>, <span class="number">14</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> [studentNameOnly, <span class="built_in">std</span>::ignore] = s4; <span class="comment">// 忽略 age</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Only name: "</span> &lt;&lt; studentNameOnly &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>深入了解结构化绑定的实现机制（可选，较高级）：</strong><br>如果你有兴趣，可以研究一下编译器大致是如何实现结构化绑定的。它通常涉及到匿名对象的创建或者直接访问成员，但具体的底层机制对于初学者来说可能比较复杂。</p>
</li>
</ol>
<p>这些拓展问题将帮助你更全面地理解结构化绑定的强大功能和灵活性。继续保持这种学习的热情，你会在 C++ 的世界里发现更多有趣的东西！</p>
<p>如果你对这些拓展问题中的任何一个有疑问，或者想尝试后分享你的代码和发现，我随时都在这里！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Learning/">Learning    </a><a class="post-meta__tags" href="/tags/Course/">Course    </a><a class="post-meta__tags" href="/tags/Language/">Language    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/296%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>296 - 构造函数默认参数</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/300%20-%20cpp%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A7%94%E6%89%98/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>300 - cpp构造函数委托</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/260 - Named Template Parameters for Lambdas/" title="260 - Named Template Parameters for Lambdas"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">260 - Named Template Parameters for Lambdas</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/267 - requires clause/" title="267 - requires clause"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">267 - requires clause</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/341 - Linkage Cpp/" title="341 - Linkage Cpp"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">341 - Linkage Cpp</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/c_plus_plus_teacher prompt/" title="c_plus_plus_teacher prompt"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">c_plus_plus_teacher prompt</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/255 - Cpp decltype and Trailing Return Types/" title="255 - Cpp decltype and Trailing Return Types"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">255 - Cpp decltype and Trailing Return Types</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/261 - Type traits/" title="261 - Type traits"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">261 - Type traits</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>