<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>320 - cpp成员常量 pre cpp17 | Bear's dream</title><meta name="description" content="320 - cpp成员常量 pre cpp17"><meta name="keywords" content="Cpp,Coding,Tutorial,Configuration,Class"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="320 - cpp成员常量 pre cpp17"><meta name="twitter:description" content="320 - cpp成员常量 pre cpp17"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="320 - cpp成员常量 pre cpp17"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/320%20-%20cpp%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F%20pre%20cpp17/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="320 - cpp成员常量 pre cpp17"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/320%20-%20cpp%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F%20pre%20cpp17/"><link rel="prev" title="319 - Class Const" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/319%20-%20Class%20Const/"><link rel="next" title="322 - Different Type Members" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/322%20-%20Different%20Type%20Members/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">178</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">160</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">23</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-成员常量"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">C++成员常量</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#掌握C-类中的静态常量与非常量成员变量（C-17之前）"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">掌握C++类中的静态常量与非常量成员变量（C++17之前）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#详细讲解"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">详细讲解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-静态常量成员变量-Static-Const-Member-Variables"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">1. 静态常量成员变量 (Static Const Member Variables)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-1-仅允许在类声明中初始化的类型-integral-types-和-enum"><span class="toc_mobile_items-number">2.1.1.1.</span> <span class="toc_mobile_items-text">1.1 仅允许在类声明中初始化的类型 (integral types 和 enum)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1-2-必须在对应的-cpp文件（定义文件）中初始化的类型"><span class="toc_mobile_items-number">2.1.1.2.</span> <span class="toc_mobile_items-text">1.2 必须在对应的.cpp文件（定义文件）中初始化的类型</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-静态初始化顺序问题-Static-Initialization-Order-Fiasco"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">1.3 静态初始化顺序问题 (Static Initialization Order Fiasco)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-非常量成员变量-Non-Static-Const-Member-Variables"><span class="toc_mobile_items-number">2.1.3.</span> <span class="toc_mobile_items-text">2. 非常量成员变量 (Non-Static Const Member Variables)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-C-17及之后的变化-简要提及"><span class="toc_mobile_items-number">2.1.4.</span> <span class="toc_mobile_items-text">3. C++17及之后的变化 (简要提及)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#QA-闪卡-QA-Flashcards"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">QA 闪卡 (QA Flashcards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#常见误解或错误-Common-Misunderstanding-or-Mistake"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">常见误解或错误 (Common Misunderstanding or Mistake)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#编程练习-Coding-Exercise"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">编程练习 (Coding Exercise)</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-成员常量"><span class="toc-number">1.</span> <span class="toc-text">C++成员常量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#掌握C-类中的静态常量与非常量成员变量（C-17之前）"><span class="toc-number">2.</span> <span class="toc-text">掌握C++类中的静态常量与非常量成员变量（C++17之前）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#详细讲解"><span class="toc-number">2.1.</span> <span class="toc-text">详细讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-静态常量成员变量-Static-Const-Member-Variables"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 静态常量成员变量 (Static Const Member Variables)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-仅允许在类声明中初始化的类型-integral-types-和-enum"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1.1 仅允许在类声明中初始化的类型 (integral types 和 enum)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-必须在对应的-cpp文件（定义文件）中初始化的类型"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">1.2 必须在对应的.cpp文件（定义文件）中初始化的类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-静态初始化顺序问题-Static-Initialization-Order-Fiasco"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.3 静态初始化顺序问题 (Static Initialization Order Fiasco)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-非常量成员变量-Non-Static-Const-Member-Variables"><span class="toc-number">2.1.3.</span> <span class="toc-text">2. 非常量成员变量 (Non-Static Const Member Variables)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-C-17及之后的变化-简要提及"><span class="toc-number">2.1.4.</span> <span class="toc-text">3. C++17及之后的变化 (简要提及)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QA-闪卡-QA-Flashcards"><span class="toc-number">2.2.</span> <span class="toc-text">QA 闪卡 (QA Flashcards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见误解或错误-Common-Misunderstanding-or-Mistake"><span class="toc-number">2.3.</span> <span class="toc-text">常见误解或错误 (Common Misunderstanding or Mistake)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编程练习-Coding-Exercise"><span class="toc-number">2.4.</span> <span class="toc-text">编程练习 (Coding Exercise)</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">320 - cpp成员常量 pre cpp17</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/320%20-%20cpp%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F%20pre%20cpp17/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/320%20-%20cpp%E6%88%90%E5%91%98%E5%B8%B8%E9%87%8F%20pre%20cpp17/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="C-成员常量"><a href="#C-成员常量" class="headerlink" title="C++成员常量"></a>C++成员常量</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to see how to model static, constant member variables.If we don’t have access to a C plus plus 17 compiler or later, we’re also going to see how to workwith constant member variables that happen not to be static.And here is the rule before C plus plus 17, you couldn’t really do much in terms of initializing yourmember variables in the class declaration if they are static only integral types and by this I meanint and enum types where initialize able from the class declaration.Any other type would have to go in the CPP file and be initialized from there as we are about to see.So this is the rule.Let’s look at an example here.Here we have a cylinder class and inside we have a bunch of member variables.I put in many types so that you can really see this in action and have many examples to go by.But on top here, we’re going to have what we could initialize in the class declaration.And I mean wherever you declare your class within the curly braces, that includes your class.And before C plus plus 17, you could only do this for integral types and enum you see int constant.Here is an int and a color constant.Here is an enum.So if we initialize these guys in the class definition itself, this would work before C plus plus 17,but any other thing would give you a compiler error.So if we go down here, for example, we have a bunch of member variables.They are static.You see that they have the static keyword in front, but we have many types.So we have a string, we have a car pointer, we have an int, we have a float.All of these things wouldn’t be initialized in the header file.If you tried to do this, you’re going to get a compiler error or I should say in the class definition,you couldn’t really initialize this thing in the class declaration here.If you do that, you’re going to get a compiler error down here.You see that we have our double constant, which is pi here.We can’t also initialize this in the class declaration because it is not in line.So we will have to do that in the CPP file.So how do you exactly initialize these guys in the CPP file?Well, I have an example for you.Here is how you could do that.Our string would be initialized like this.You have to specify the type for what you want to initialize.You have to set the class in which it’s live and using the double colon syntax here.And then you say the variable and then you initialize that either using curly braces or parents.Any kind of initialization is going to work here.We do the same for Pi and our car pointer constant.We’re going to initialize this with a string literal.This is going to work.We have an array and we can initialize that using curly braces like this.We have a float.We’re going to initialize that like this with a float literal and we can initialize a string array justlike we do here.And this is going to work.Okay, so this is fine and dandy, but what about constant member variables that are not static?Let’s go down here and look at an example.We have weird float here.We have wild C string and we have weird int array constant.If we try to initialize these guys in the header file, we’re going to get a compiler error.This is not going to work.But if we do that in the CPP file, please remember that these guys are not static, so you will haveto initialize them like you initialize any other member variable, but because they are const they canonly be initialized through an initializer list.And this is what we have here.So we’re going to initialize weird float with a float literal or a double literal here, but we’re goingto have a narrowing conversion here.We’re going to initialize our weird C string member variable with a string literal and we’re going toinitialize our array of int using the syntax you see here.And this is going to work.We have to go through an initializer list.If our member variable happens to be a constant, if you don’t go through an initializer list and tryto do something like this in the body of the constructor, you’re going to get a compiler error.This is not allowed.So this is another case where we can only do this using initializer lists.And if you don’t use initializer lists, you basically won’t have a way to initialize your constantThis is the only way we have.Another thing I want you to know before we head over to Visual Studio code and play with this is thatif you use a.Static member variable to initialize another variable.You will be basically setting yourself up for disaster because static initialization order is not guaranteed.So if you run your program, some variable might be initialized before another one.And if you run the program again, the order of initialization might change.So sometimes if you are out of luck, you might try to use a variable which hasn’t been set up yet.Try to initialize another variable and your program is going to crash.My recommendation is to never use static member variables to initialize as static member variables becausethat’s really bad.It is recommended to only use static member variables once you have hit the main function because rememberthey are initialized before the main function runs.You should really know this.Now that we know this, we’re going to head over to Visual Studio code and play with this a little more.Okay, Here we are in our working folder.The current project is static constants before C plus plus 17.Here we are going to grab our template files and we’re going to put them in place pretty quick.Let’s do that.And we are going to open this in Visual Studio code by dragging and dropping here, this is going toopen our folder.We can open the main CPP file and clean this up a little bit and we are going to put in our cylinderclass because that’s what we’re going to play with.So let’s put in the files for that.We’re going to create a cylinder dot h file and we’re going to put together a cylinder dot CPP file.I am going to grab the file for the header and I put that in here.And if you don’t want to type all this, you can just grab the file from the resource section on thiscourse.You’re going to have access to this and you can use this however you want.I realize I have put this in the CPP file.It should be in the header file.So let’s correct this.And inside you see that we have basically a lot of member variables and we want to play with differenttypes so that you can really see how we do this in C plus plus versions lower than C plus plus 17,because sometimes you’re going to run into this.If you go down here, we’re going to see that int and enum can be initialized in the class declaration.This is what we should say here.Okay, So you see that we have our static const and we are initializing this right here.If we want we can even use the curly braces.Let’s do that.This is going to work.We’re going to go down and initialize our color, which is an enum that we just declared here.And again here we can also use curly braces.This is going to work.Let’s grab our thing here and put that in place.This is going to work.And this is really all we could do before a C plus plus 17 in terms of initial using our static membervariables inside the class declaration for other types, you will have to put the initialization ina CPP file.So here you see a bunch of types.We have a string, we have a character pointer, which is going to be a C string.We have an INT, we have a float, we have an array of constants, we have an array of strings.All these things will have to be initialized in the CPP file.If you go down, you’re going to see that we have our Pi member variable, which is static.So this is also going to be initialized in the CPP file.So I am going to just grab the code and paste that in here and we’re going to try and understand thatthis is including the header file and we’re going to initialize our member variables in the CPP file.You see, we are initializing the default color, we are initializing pi, the character pointer constant,that’s going to be a C string, the array, the float static variable and our string array.You see that we can really initialize anything in the CPP file and this is going to work.We’re going to have access to these things in the main function in a minute.The other thing I want you to see before we head over to the main function is what if you have constantmember variables that are not static because we haven’t really talked about them so far.If you have those kinds of member variables in your class, things are going to be a little different.You see, we have a float, we have a character pointer, we have a net.They are constants, but they are not static.So these are going to belong to the object.They’re not going to be attached to the blueprint or the class itself.Now, if you have to initialize these guys, the only option you have is to go and initialize the listlike we do here, and let’s be consistent here and use curly braces.Let’s take out.The parentheses here and we’re going to use curly braces here.Okay, So this is done.We will have to go through initializer lists.If you try to use the syntax like this and try to change the constant in the body, you won’t be allowedto do this because this is a constant.And at this point we are trying to change the constant.So C plus plus is going to complain.We’re not allowed to do this.The only way you can put a value in your constant is in the initializer list, because the initializerlist is really not going to be changing the value.It’s going to be initializing that and it is going to put the value in.At the moment, the member variable is created.That’s why this is possible.But you can’t do that in the body like we are doing here.If we do this, we’re going to get a compiler error.So now that we have this, we can head over in the main function and play with these things.We’re going to include our cylinder class.Let’s do that and I am going to put in a piece of code to really play with this.Thanks.I don’t want to type all this because you really know most of this.Thanks.The main message is that some things can be initialized in the class declaration, some things can’t.They have to be initialized in the CPP file.But now that we have this things properly initialized, we can really access them in the main functionand do things with them.For example, we have the cylinder, we can print the volume, we can print the default color.This is going to work.We can access our constants.We’re going to get the int constant, the color constant, the character pointer constant.We can get the array and for example, get the second element.We can get the float constant, We can get our string array constant, we can print all these things.If we go down here, you’re going to see that if we try and modify any of those constants, we’re goingto get a compiler error.So let’s wait.You’re going to see a squiggly line here and we’re going to get a compiler error.If we try to modify this.Let’s try and go through GCC and show you the problem.We’re going to get a compiler error.You see that the build finished with errors and we’re going to get an error saying assignment of readonly variable and constant.We can’t change this because it is a constant.So we’re going to comment this out.You have seen this error.The other error I want you to see is if you try to modify the constant member variable in the body ofyour constructor because some people are going to try and do this and they want to know what is beatingthem.So this is not allowed because this guy is really a constant.You have no business modifying it after it has been set up.If you do this, you’re going to get a compiler error.So let’s do this.We’re going to build with GCC so that you can really see these things we are learning.So don’t be afraid to break things a little bit and we’re going to get an error assignment of read onlymember variable weird float.We can’t do that even if we are in our own constructor.This is not allowed and we can go down and try to access some other things.So we have our weird constants here.Weird float is going to be printed out because I think it is in the public scope.You can get access to that.We’re going to print that in our main function and we’re going to print all these things here.So let’s build the program now.It should build because we have fixed every single problem that we had build finished successfully.We can clear and run Rooster.We’re going to see all the data here.And if you go and you’re going to see that we have what we put in here, for example, int array, let’sgo down and see what we had in there.Enter a constant at index three.Let’s go and see what we have.Enter a constant at index 30123.We should get a 40 and that’s what we have here.So this is working like we expect.One thing I want you to see before we wrap up this lecture is that the order static member variablesare initialized and is not guaranteed to be always the same, and that can get you into trouble.To make you understand this, we’re going to set up a new class.Let’s call that bird, for example.And we’re going to put in place two files.One is going to be a header file.Let’s do that.And we’re going to put in place a CPP file for that.We are going to put in place our bird class.It is really simple.All we have inside is a static constant.It is a float, so we can’t really initialize that in the class declaration.We will have to initialize this in the CPP file, but what we’re going to do is not initialize thiswith the literal.We’re going to initialize this with a static member variable coming from the cylinder class.So let’s do that.We’re going to include the cylinder and we’re going to include the bird before that.Let’s do that and then we’re going to say the type of our variable.So let’s grab the name and we’re going to say const float because that’s what it is and we’re goingto say Bird and we’re going to put our scope resolution.Operator.We can grab this from Visual Studio code and we’re going to initialize this.We’re not going to initialize this with a literal.For example, if we put in 45.3 and say, this is a float, this is going to work just fine, but we’renot going to do this.We’re going to initialize this with another static variable coming from the cylinder class.And let’s see if we can find a float.We’re going to find that here float constant.We have it.So we’re going to say cylinder float constant.Let’s use this.And the compiler is going to take this.But the problem is we don’t really know which one is going to be initialized first.It might be the bird wait constant.It might be the float constant here.And if we happen to initialize the weight constant before the float constant is put in place, we willbe trying to access something that doesn’t exist yet to try and initialize our weight constant.And you might guess what is going to happen.You’re going to get a crash.Let’s try and go in main and see if we can get this crash to show up, but we might not be that lucky.So we’re going to try our best here.So we’re going to go down and we’re going to put in the code to print the bird weight constant.For this to work, we will need to include our bird header.So let’s do that.And now our code should compile.At least let’s do that.We’re going to build this with GCC and you’re going to see that the world is good.But if we run the program, we might not get what we expect.So let’s clear and run Rooster.This is working at this point.This is working.This is working.This is working.This is working.So this is working for now.But if you are unlucky, the bird weight constant is going to be initialized first and it is going toeither grab whatever is at this float, constant member variable, the location of this thing in memory.It might grab something that doesn’t exist yet, it might give you junk value.And if you are trying to access critical memory locations, you’re going to get a crash.And this is really bad.So the message here is that the order for a static initialization is not guaranteed.Sometimes bird weight constant is going to be initialized first, sometimes float constant is goingto be initialized first.And if this is not working in your favor, you’re going to get some weird problems.Let’s actually prove that float constant is 6.98.Here it is.So this is working fine, but it might not work all the time.For example, if you run this program on another machine.Static initialization might not work the way it is working here and you might be in trouble.This is really all I had to share in this lecture.I hope you found it interesting.We are going to stop here in this one.The next one we’re going to see how you can set up member variables of the same class that you are declaring.So go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，欢迎来到C++的学习之旅！我是您的专属C++老师，将尽我所能，用最清晰、最易懂的方式带您探索C++的奥秘。</p>
<hr>
<h1 id="掌握C-类中的静态常量与非常量成员变量（C-17之前）"><a href="#掌握C-类中的静态常量与非常量成员变量（C-17之前）" class="headerlink" title="掌握C++类中的静态常量与非常量成员变量（C++17之前）"></a>掌握C++类中的静态常量与非常量成员变量（C++17之前）</h1><p><strong>简介:</strong> 本节将深入讲解C++17标准之前，如何在类中声明和初始化<code>static</code> (静态) 和<code>const</code> (常量) <code>member variables</code> (成员变量)，包括静态常量成员变量和非常量成员变量，并探讨其特有规则和潜在问题。</p>
<hr>
<h2 id="详细讲解"><a href="#详细讲解" class="headerlink" title="详细讲解"></a>详细讲解</h2><p>C++中的类（class）允许我们封装数据和行为。这些数据通常通过成员变量来表示。当我们在类中定义成员变量时，有时会希望它们具有特定的性质，例如：</p>
<ol>
<li><strong>静态 (Static):</strong> 表示这个成员变量不属于类的某个具体对象，而是属于整个类。所有对象共享同一个静态成员变量的副本。</li>
<li><strong>常量 (Const):</strong> 表示这个成员变量一旦被初始化，其值就不能再被修改。</li>
</ol>
<p>将这两者结合起来，就产生了<code>static const</code>成员变量，以及只使用<code>const</code>的非常量成员变量。由于C++语言的演进，在C++17之前和之后，它们的初始化规则有所不同。本节我们将主要关注C++17之前的规则。</p>
<h3 id="1-静态常量成员变量-Static-Const-Member-Variables"><a href="#1-静态常量成员变量-Static-Const-Member-Variables" class="headerlink" title="1. 静态常量成员变量 (Static Const Member Variables)"></a>1. 静态常量成员变量 (Static Const Member Variables)</h3><p><code>static const</code>成员变量是与类本身关联的常量，所有该类的对象共享同一个常量值。在C++17标准之前，对于这类变量的初始化有严格的限制：</p>
<h4 id="1-1-仅允许在类声明中初始化的类型-integral-types-和-enum"><a href="#1-1-仅允许在类声明中初始化的类型-integral-types-和-enum" class="headerlink" title="1.1 仅允许在类声明中初始化的类型 (integral types 和 enum)"></a>1.1 仅允许在类声明中初始化的类型 (<code>integral types</code> 和 <code>enum</code>)</h4><p>在C++17之前，只有<code>integral types</code> (整型，如<code>int</code>, <code>char</code>, <code>short</code>, <code>long long</code>等) 和 <code>enum</code> (枚举) 类型的<code>static const</code>成员变量可以在<code>class declaration</code> (类声明) 内部（也就是类定义的<code>{}</code>花括号内）直接进行<code>initialization</code> (初始化)。</p>
<p><strong>为什么？</strong><br>这是因为这些类型在编译时其值就可以确定，并且它们通常占用固定且较小的内存空间。编译器可以直接将这些常量“烘焙”到程序代码中，而不需要在运行时分配内存。</p>
<p><strong>示例:</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cylinder.h 文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 可以在类声明中初始化的静态常量成员变量 (C++17之前)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> s_int_constant = <span class="number">100</span>; <span class="comment">// 整型</span></span><br><span class="line">    <span class="keyword">enum</span> Color &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Color s_default_color = Color::GREEN; <span class="comment">// 枚举类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Cylinder() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><br>在上面的例子中，<code>s_int_constant</code>和<code>s_default_color</code>可以直接在<code>Cylinder</code>类的定义中初始化。您可以像上面一样使用等号<code>=</code>进行初始化，也可以使用花括号 <code>{}</code> 进行列表初始化，例如 <code>static const int s_int_constant {100};</code>。</p>
<h4 id="1-2-必须在对应的-cpp文件（定义文件）中初始化的类型"><a href="#1-2-必须在对应的-cpp文件（定义文件）中初始化的类型" class="headerlink" title="1.2 必须在对应的.cpp文件（定义文件）中初始化的类型"></a>1.2 必须在对应的<code>.cpp</code>文件（定义文件）中初始化的类型</h4><p>除了<code>integral types</code>和<code>enum</code>之外，其他所有类型的<code>static const</code>成员变量，包括<code>double</code> (双精度浮点型), <code>float</code> (单精度浮点型), <code>std::string</code> (字符串), <code>char*</code> (字符指针), 以及各种数组类型等，都<strong>不能</strong>在<code>class declaration</code>中初始化。它们必须在类的定义文件（通常是<code>.cpp</code>文件，也称为<code>translation unit</code> (翻译单元)）中进行定义和初始化。</p>
<p><strong>为什么？</strong><br>对于非整型或非枚举类型的静态常量，它们的内存分配和初始化可能更复杂，或者其值在编译时无法完全确定（例如，<code>std::string</code>的初始化可能涉及动态内存分配）。因此，C++标准要求它们在类的外部，也就是在<code>.cpp</code>文件中分配存储空间并进行初始化。</p>
<p><strong>初始化语法:</strong><br>在<code>.cpp</code>文件中初始化静态成员变量的语法是：<br><code>类型 类名::静态成员变量名 = 值;</code></p>
<p><strong>示例:</strong><br>假设您的<code>Cylinder</code>类声明（<code>Cylinder.h</code>）如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cylinder.h 文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 包含string头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;  // 包含array头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态常量成员变量，必须在.cpp文件中初始化 (C++17之前)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> s_pi;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> s_company_name;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* s_char_ptr_constant;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> s_int_array_constant[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> s_float_constant;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> s_string_array_constant[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他成员...</span></span><br><span class="line">    Cylinder() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><br>那么在<code>Cylinder.cpp</code>文件中，您需要这样初始化它们：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cylinder.cpp 文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Cylinder.h"</span> <span class="comment">// 包含头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   // 用于示例中的输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态常量成员变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Cylinder::s_pi = <span class="number">3.14159265358979323846</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Cylinder::s_company_name = <span class="string">"我的公司"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* Cylinder::s_char_ptr_constant = <span class="string">"这是一个C风格字符串常量"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Cylinder::s_int_array_constant[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> Cylinder::s_float_constant = <span class="number">6.98f</span>; <span class="comment">// 注意f后缀表示float</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Cylinder::s_string_array_constant[<span class="number">2</span>] = &#123;<span class="string">"字符串A"</span>, <span class="string">"字符串B"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在这里实现类的其他成员函数</span></span><br></pre></td></tr></table></figure></div><br><strong>关键点:</strong></p>
<ul>
<li>在<code>.cpp</code>文件中初始化时，您必须再次指定变量的类型 (<code>const double</code>, <code>const std::string</code>等)。</li>
<li>必须使用<code>类名::</code>来指明这个静态成员变量是属于哪个类的。</li>
<li>可以使用各种形式的初始化（等号<code>=</code>, 花括号<code>{}</code>, 圆括号<code>()</code>）来赋值。</li>
</ul>
<h3 id="1-3-静态初始化顺序问题-Static-Initialization-Order-Fiasco"><a href="#1-3-静态初始化顺序问题-Static-Initialization-Order-Fiasco" class="headerlink" title="1.3 静态初始化顺序问题 (Static Initialization Order Fiasco)"></a>1.3 静态初始化顺序问题 (<code>Static Initialization Order Fiasco</code>)</h3><p>这是一个非常重要的概念，理解不当可能导致程序崩溃或产生<code>undefined behavior</code> (未定义行为)。</p>
<p><strong>问题描述:</strong><br>当您的程序中有多个<code>translation unit</code> (<code>.cpp</code>文件) 并且每个文件中都有需要初始化的<code>static</code>成员变量（无论是<code>const</code>还是非<code>const</code>）时，C++标准<strong>不保证</strong>这些<code>static</code>变量的初始化顺序。</p>
<p><strong>示例:</strong><br>假设我们有两个类：<code>Cylinder</code>和<code>Bird</code>。<br><code>Cylinder.h</code>中有一个<code>static const float s_float_constant</code>。<br><code>Bird.h</code>中有一个<code>static const float s_bird_weight_constant</code>。</p>
<p>如果在<code>Bird.cpp</code>中，我们尝试用<code>Cylinder::s_float_constant</code>来初始化<code>Bird::s_bird_weight_constant</code>：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bird.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bird.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Cylinder.h"</span> <span class="comment">// 需要包含Cylinder的头文件来访问其静态成员</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> Bird::s_bird_weight_constant = Cylinder::s_float_constant; <span class="comment">// 危险！</span></span><br></pre></td></tr></table></figure></div><br><strong>潜在风险:</strong><br>由于静态初始化顺序不确定，可能发生以下两种情况：</p>
<ol>
<li><code>Cylinder::s_float_constant</code>先被初始化，然后<code>Bird::s_bird_weight_constant</code>使用它来初始化。这是我们期望的，程序正常运行。</li>
<li><code>Bird::s_bird_weight_constant</code>先被初始化，此时<code>Cylinder::s_float_constant</code>可能<strong>尚未被初始化</strong>。如果<code>Bird::s_bird_weight_constant</code>试图访问一个未初始化的内存地址，它可能读取到垃圾值，甚至引发内存访问错误导致程序崩溃。</li>
</ol>
<p><strong>解决方案/最佳实践:</strong></p>
<ul>
<li><strong>避免使用一个静态成员变量来初始化另一个静态成员变量。</strong> 除非它们位于同一个<code>translation unit</code>中，并且您能明确它们的初始化顺序（但这通常很难保证）。</li>
<li><strong>推荐的做法是：</strong> 尽量用字面量（如<code>3.14f</code>）或简单的编译时常量来初始化静态成员变量。</li>
<li><strong>延迟初始化 (Lazy Initialization):</strong> 如果必须使用一个静态成员变量来初始化另一个，可以考虑使用函数来延迟初始化，例如单例模式中的局部静态变量，它在第一次调用时才被初始化。但对于<code>const</code>成员，这种方法不直接适用。</li>
<li><strong>确保在<code>main</code>函数开始执行后才使用静态成员变量。</strong> 因为所有静态存储期变量在<code>main</code>函数执行前都会被初始化（如果它们在同一个<code>translation unit</code>中）。</li>
</ul>
<h3 id="2-非常量成员变量-Non-Static-Const-Member-Variables"><a href="#2-非常量成员变量-Non-Static-Const-Member-Variables" class="headerlink" title="2. 非常量成员变量 (Non-Static Const Member Variables)"></a>2. 非常量成员变量 (Non-Static Const Member Variables)</h3><p>这类成员变量是<code>const</code>的，但它们不是<code>static</code>的。这意味着它们属于类的<strong>每个对象</strong>，并且一旦对象创建并初始化后，它们的值就不能改变。</p>
<p><strong>核心规则:</strong><br><code>const</code>成员变量必须在构造函数中通过<code>initializer list</code> (初始化列表) 进行初始化。它们不能在构造函数的函数体内部通过赋值操作进行初始化。</p>
<p><strong>为什么？</strong><br><code>const</code>的含义是“创建后不可更改”。初始化列表是在对象构造阶段，成员变量被分配内存后立即进行值设定的唯一机会。在初始化列表完成后，进入构造函数体时，成员变量已经完成初始化，此时任何赋值操作都将被视为尝试修改一个<code>const</code>变量，这是不允许的。</p>
<p><strong>示例:</strong><br>假设<code>Cylinder</code>类声明（<code>Cylinder.h</code>）如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cylinder.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> m_weird_float;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* m_wild_c_string;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_weird_int_array_constant[<span class="number">3</span>]; <span class="comment">// 非常量、常量数组</span></span><br><span class="line"></span><br><span class="line">    Cylinder(<span class="keyword">float</span> weird_float_val, <span class="keyword">const</span> <span class="keyword">char</span>* c_str_val, <span class="keyword">int</span> arr_val1, <span class="keyword">int</span> arr_val2, <span class="keyword">int</span> arr_val3); <span class="comment">// 构造函数声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><br>在<code>Cylinder.cpp</code>中，您必须使用初始化列表来初始化它们：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cylinder.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Cylinder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; // for strcpy, if needed, but for const char* just direct assignment is fine</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的实现</span></span><br><span class="line">Cylinder::Cylinder(<span class="keyword">float</span> weird_float_val, <span class="keyword">const</span> <span class="keyword">char</span>* c_str_val, <span class="keyword">int</span> arr_val1, <span class="keyword">int</span> arr_val2, <span class="keyword">int</span> arr_val3)</span><br><span class="line">    : m_weird_float(weird_float_val), <span class="comment">// 使用初始化列表初始化float</span></span><br><span class="line">      m_wild_c_string(c_str_val),     <span class="comment">// 使用初始化列表初始化char*</span></span><br><span class="line">      m_weird_int_array_constant&#123;arr_val1, arr_val2, arr_val3&#125; <span class="comment">// 使用初始化列表初始化数组</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在这里尝试赋值会导致编译错误！</span></span><br><span class="line">    <span class="comment">// m_weird_float = 10.0f; // 错误：不能给常量赋值</span></span><br><span class="line">    <span class="comment">// m_wild_c_string = "新的字符串"; // 错误：不能给常量赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><strong>误区提示:</strong><br>很多初学者会尝试在构造函数体内给<code>const</code>成员变量赋值，例如：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">Cylinder::Cylinder(<span class="keyword">float</span> weird_float_val) &#123;</span><br><span class="line">    m_weird_float = weird_float_val; <span class="comment">// 编译错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>这会导致编译错误，因为<code>m_weird_float</code>在进入构造函数体时已经默认初始化（如果类型允许），此时再赋值就成了“修改”一个<code>const</code>变量。</p>
<h3 id="3-C-17及之后的变化-简要提及"><a href="#3-C-17及之后的变化-简要提及" class="headerlink" title="3. C++17及之后的变化 (简要提及)"></a>3. C++17及之后的变化 (简要提及)</h3><p>虽然本节主要关注C++17之前，但有必要知道C++17引入了<code>inline static</code>关键字，允许<code>static const</code>成员变量（以及非<code>const</code>的<code>static</code>成员变量）在类声明中进行定义和初始化，而无需在<code>.cpp</code>文件中单独定义。这大大简化了代码，但其底层仍然需要编译器处理好静态初始化顺序问题。对于非常量成员变量，初始化列表的规则没有改变。</p>
<hr>
<h2 id="QA-闪卡-QA-Flashcards"><a href="#QA-闪卡-QA-Flashcards" class="headerlink" title="QA 闪卡 (QA Flashcards)"></a>QA 闪卡 (QA Flashcards)</h2><ol>
<li><strong>Q1:</strong> 在C++17之前，哪种<code>static const</code>成员变量类型可以在类声明中直接初始化？<br><strong>A1:</strong> <code>integral types</code> (整型) 和 <code>enum</code> (枚举) 类型。</li>
<li><strong>Q2:</strong> 如果<code>static const</code>成员变量不是整型或枚举，在C++17之前应该在哪里进行初始化？<br><strong>A2:</strong> 必须在对应的<code>.cpp</code>文件（<code>translation unit</code>）中进行定义和初始化。</li>
<li><strong>Q3:</strong> 为什么<code>const</code>（非常量）成员变量必须通过构造函数的<code>initializer list</code>进行初始化，而不能在构造函数体内部赋值？<br><strong>A3:</strong> 因为<code>const</code>成员变量在对象创建后不能被修改。<code>initializer list</code>是在成员变量创建时就赋予其初始值的机制，而构造函数体内的赋值操作则是在成员变量已经创建并可能被默认初始化后进行的“修改”行为，这与<code>const</code>的语义冲突。</li>
<li><strong>Q4:</strong> 什么是<code>static initialization order fiasco</code> (静态初始化顺序问题)？它会带来什么风险？<br><strong>A4:</strong> 它是指在程序中，不同<code>translation unit</code>（<code>.cpp</code>文件）中的<code>static</code>变量的初始化顺序是不确定的。风险是如果一个<code>static</code>变量在初始化时尝试访问另一个尚未初始化的<code>static</code>变量，可能导致程序崩溃或产生<code>undefined behavior</code>。</li>
</ol>
<hr>
<h2 id="常见误解或错误-Common-Misunderstanding-or-Mistake"><a href="#常见误解或错误-Common-Misunderstanding-or-Mistake" class="headerlink" title="常见误解或错误 (Common Misunderstanding or Mistake)"></a>常见误解或错误 (Common Misunderstanding or Mistake)</h2><ol>
<li><strong>误解1: 所有<code>static const</code>成员都可以在类内直接初始化。</strong><br><strong>纠正:</strong> 在C++17之前，只有整型和枚举类型可以。其他类型必须在<code>.cpp</code>文件中初始化。尝试在类内初始化非整型/枚举的<code>static const</code>会引发编译错误。</li>
<li><strong>误解2: <code>const</code>成员变量可以在构造函数体内部赋值。</strong><br><strong>纠正:</strong> 这是最常见的错误之一。<code>const</code>成员变量必须且只能通过构造函数的<code>initializer list</code>进行初始化。在构造函数体内部的赋值操作是无效的，并会导致编译错误。</li>
<li><strong>误解3: 静态成员变量的初始化顺序总是确定的。</strong><br><strong>纠正:</strong> 只有在同一个<code>translation unit</code>（<code>.cpp</code>文件）内部，它们的初始化顺序才基本遵循声明顺序。但跨<code>translation unit</code>时，顺序是<strong>不确定</strong>的，这可能导致<code>static initialization order fiasco</code>。</li>
<li><strong>误解4: <code>static const</code>和非<code>static const</code>的初始化方式相同。</strong><br><strong>纠正:</strong> 它们完全不同。<code>static const</code>成员属于类本身，其初始化取决于类型和C++版本（C++17之前需在<code>.cpp</code>文件）。非<code>static const</code>成员属于对象，必须通过构造函数的<code>initializer list</code>初始化。</li>
</ol>
<hr>
<h2 id="编程练习-Coding-Exercise"><a href="#编程练习-Coding-Exercise" class="headerlink" title="编程练习 (Coding Exercise)"></a>编程练习 (Coding Exercise)</h2><p>请根据我们今天所学的内容，完善下面的<code>Product</code>类。</p>
<p><strong>目标：</strong></p>
<ol>
<li>在<code>Product.h</code>中声明一个<code>static const double PI_VALUE</code>，它是一个非整型。</li>
<li>在<code>Product.h</code>中声明一个<code>static const int MAX_ID</code>，它是一个整型。</li>
<li>在<code>Product.h</code>中声明一个非静态的<code>const std::string m_product_name</code>。</li>
<li>在<code>Product.cpp</code>中实现所有必要的初始化。</li>
</ol>
<p><strong><code>Product.h</code>:</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRODUCT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRODUCT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 包含std::string头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 1. 声明一个非整型静态常量 PI_VALUE</span></span><br><span class="line">    <span class="comment">// (请在这里添加声明)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 声明一个整型静态常量 MAX_ID，并直接在类内初始化</span></span><br><span class="line">    <span class="comment">// (请在这里添加声明和初始化)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 声明一个非静态常量成员变量 m_product_name</span></span><br><span class="line">    <span class="comment">// (请在这里添加声明)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，需要接收一个参数来初始化 m_product_name</span></span><br><span class="line">    Product(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印产品信息的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PRODUCT_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>Product.cpp</code>:</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Product.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 在这里定义和初始化 Product::PI_VALUE</span></span><br><span class="line"><span class="comment">// (请在这里完成)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Product::MAX_ID 已经在头文件中初始化，所以这里不需要再定义/初始化了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 实现 Product 构造函数，初始化 m_product_name</span></span><br><span class="line">Product::Product(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span><br><span class="line">    <span class="comment">// (请在这里使用初始化列表初始化 m_product_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"产品 '"</span> &lt;&lt; m_product_name &lt;&lt; <span class="string">"' 已创建。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Product::printInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"产品名称: "</span> &lt;&lt; m_product_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PI 值: "</span> &lt;&lt; PI_VALUE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"最大ID: "</span> &lt;&lt; MAX_ID &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>请您尝试完成 <code>Product.h</code> 和 <code>Product.cpp</code> 文件中的空白部分，然后我将为您提供解决方案、评分和进一步的建议。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Tutorial/">Tutorial    </a><a class="post-meta__tags" href="/tags/Configuration/">Configuration    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/319%20-%20Class%20Const/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>319 - Class Const</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/322%20-%20Different%20Type%20Members/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>322 - Different Type Members</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/274 - default constructor/" title="274 - default constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">274 - default constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/282 - cpp结构体与类的区别和用法/" title="282 - cpp结构体与类的区别和用法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">282 - cpp结构体与类的区别和用法</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/296 - 构造函数默认参数/" title="296 - 构造函数默认参数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">296 - 构造函数默认参数</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/313 - friend of class/" title="313 - friend of class"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">313 - friend of class</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/318 - inline static variable/" title="318 - inline static variable"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">318 - inline static variable</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/312 - cpp 友元函数详解/" title="312 - cpp 友元函数详解"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">312 - cpp 友元函数详解</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>