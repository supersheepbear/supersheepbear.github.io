<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>297 - 构造函数初始化列表 | Bear's dream</title><meta name="description" content="297 - 构造函数初始化列表"><meta name="keywords" content="Coding,Cpp,Course,Class,Constructor"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="297 - 构造函数初始化列表"><meta name="twitter:description" content="297 - 构造函数初始化列表"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="297 - 构造函数初始化列表"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/297%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="297 - 构造函数初始化列表"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/297%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"><link rel="prev" title="299 - 显式构造函数" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/299%20-%20%E6%98%BE%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"><link rel="next" title="305 - 已删除构造 函数使用" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/305%20-%20%E5%B7%B2%E5%88%A0%E9%99%A4%E6%9E%84%E9%80%A0%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#构造函数初始化列表"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">构造函数初始化列表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-构造函数中的初始化列表-Initializer-Lists-深度解析"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">C++构造函数中的初始化列表 (Initializer Lists) 深度解析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-详细讲解-构造函数与初始化列表"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">1. 详细讲解: 构造函数与初始化列表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-什么是初始化列表？"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">1.1 什么是初始化列表？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-为什么推荐使用初始化列表？"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">1.2 为什么推荐使用初始化列表？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-代码示例"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">2. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-QA-闪卡"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">3. QA 闪卡</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-常见误解或错误"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">4. 常见误解或错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-编程练习"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">5. 编程练习</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-2"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#include-“book-h”"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">include “book.h”</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-2"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-评分与答案解析"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">7. 评分与答案解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-1-解决方案评分"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">7.1 解决方案评分</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-实际答案与解释"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">7.2 实际答案与解释</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-进一步探索与思考"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">8. 进一步探索与思考</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#构造函数初始化列表"><span class="toc-number">1.</span> <span class="toc-text">构造函数初始化列表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-构造函数中的初始化列表-Initializer-Lists-深度解析"><span class="toc-number">1.3.</span> <span class="toc-text">C++构造函数中的初始化列表 (Initializer Lists) 深度解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-详细讲解-构造函数与初始化列表"><span class="toc-number">1.4.</span> <span class="toc-text">1. 详细讲解: 构造函数与初始化列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-什么是初始化列表？"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.1 什么是初始化列表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-为什么推荐使用初始化列表？"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.2 为什么推荐使用初始化列表？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-代码示例"><span class="toc-number">1.5.</span> <span class="toc-text">2. 代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-QA-闪卡"><span class="toc-number">1.6.</span> <span class="toc-text">3. QA 闪卡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-常见误解或错误"><span class="toc-number">1.7.</span> <span class="toc-text">4. 常见误解或错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-编程练习"><span class="toc-number">1.8.</span> <span class="toc-text">5. 编程练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">1.9.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">1.10.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-2"><span class="toc-number">1.11.</span> <span class="toc-text">🧑‍💻 User</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include-“book-h”"><span class="toc-number">2.</span> <span class="toc-text">include “book.h”</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-2"><span class="toc-number">2.1.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-评分与答案解析"><span class="toc-number">2.2.</span> <span class="toc-text">7. 评分与答案解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-解决方案评分"><span class="toc-number">2.2.1.</span> <span class="toc-text">7.1 解决方案评分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-实际答案与解释"><span class="toc-number">2.2.2.</span> <span class="toc-text">7.2 实际答案与解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-进一步探索与思考"><span class="toc-number">2.3.</span> <span class="toc-text">8. 进一步探索与思考</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">297 - 构造函数初始化列表</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/297%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/297%20-%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p> In this lecture, we’re going to learn about initializer lists with constructors.We already know that we can set up a class like Cylinder and use a constructor like this.And when we set up this constructor, what we have been using is member wise copy initialization.And what do I mean by that?Well, we have been implementing our constructor like this.We pass the parameters in here and inside the body of the constructor we do member wise assignment.For example, we take the radius parameter and assign that to our member variable for best radius andwe take height param and we assign this to our height member variable.This is what we have been doing and it works just fine.But in this lecture we’re going to see that we have another syntax which might be better to do the samething, and it is using initializer lists like we see here.The syntax is you’re going to specify your parameter list like you see here.This is the same thing we have been using before.But what you do after your parameter list, you put a colon like you see here and then you say whichone of your member variable you want to initialize with this parameters.So we want to initialize base radius with radius param.We specify that with this parentheses here we put a comma and we say that we want to initialize ourheight member variable with height param.And when we do this we don’t need to do any member wise assignment in the body of the constructor.The object is going to be initialized when it is being created and the next lecture we’re going to reallysee the difference between these two ways of constructing your objects member wise, copy initializationand initializer list initialization.But in this lecture I just want you to be familiar with the syntax for initializer lists, initializationwith your constructors, and this is the way to do this.Again, we have our parameter list, we put a colon and then we specify our initializations.With the Syntaxes.Here we specify that we want the base radius to be initialized with radius param.We specify that we want height to be initialized with height param using this syntax here.And for the last one you don’t put anything, you just put the body of your constructor and the compileris going to take this and it is going to use this to initialize your member variables.Okay.Initializer lists have a few benefits.One of the benefits is that they avoid unnecessary copies.You have seen that if we do member wise copy initialization, we are using the assignment operator andif for example, you have member variables that are objects that’s going to cause copies.And suppose you have a member variable, which is a string and you are copying that many strings.This is really bad and in many cases it’s going to lead to memory waste because you are copying a lotof things and you’re going to waste a lot of CPU cycles with initializer lists.Your objects are initialized when they are created and you don’t really have to do any copy after theobject is created.But this is really not the topic of this lecture.We’re going to see more about this later.For now, I just want you to know that initializer lists have a few benefits, but in some cases theyare the only way you have to initialize an object.And we will have a chance to see this later in the course when we have more tools to really set thisup.For now, we’re going to head over to Visual Studio Code and see how we can play with initializer lists.Okay, here we are in our working folder.The current project is initializer lists for constructors.We’re going to grab our template files, we’re going to put them in place and we are going to open thisin Visual Studio code.But before we do, I think it is a good idea to grab our files and use them for the cylinder class.We’re going to grab them from the last lecture.We can do that.If you don’t have them.Please check the resources section of this lecture.You’re going to find the source code attached and then you can grab the cylinder files and use themin your project.I am just going to put them in here because I don’t want to type this.It’s going to waste time.So let’s open this in Visual Studio code.By dragging and dropping here, this is going to open our project.We’re going to have the main file and we’re going to have our cylinder files, we’re going to have theheader file and the CPP file, and we can close the left pane here and do whatever it is we want todo here.What we really want to see is how to use initializer lists and initialize our member variables in ourconstructors.For example, if we look at the second constructor.Here and at the implementation we have in the CPP file, we’re going to see that we are doing memberwise copy initialization.And what we mean by that is that we are taking the parameters and copying them manually into our membervariables.So this is what we have been doing all along.It is working, but now we want to see how we can use initializer lists to initialize our member variablesbecause initializer lists have a few benefits.We are going to comment out what we have so far and we’re going to see how we can use initializer list.The syntax is going to be almost the same.We’re going to say the name of the class.We’re going to say which constructor we want to implement here.We’re going to say double read param the same thing we had in the other constructor and we’re goingto say double height param.But the similarities end here after this point where we have our parameters and we’re going to go downand specify a column, you don’t really have to go down.You can do this on one line, but splitting this in different lines is better.Let’s do this on the same line just to show you that it is possible.So we’re going to say, let’s say double param here.So we’re going to say that we want to initialize our base radius with our read param and we’re goingto put a comma and we’re going to say that we want to initialize our height with height param.I think we can say that.And you see that this is good syntax, it is accepted by the compiler.Now that we have this and we can actually go to the next line and put in our body and the compiler isgoing to take this.And with this in place we can go in the main function, include our class, we’re going to include cylinderand we’re going to take out what we don’t need here.We’re going to go in the main function, create our cylinder object, we’re going to call this C one,and we’re going to only specify one parameter.I think we can do that because our constructor has a default parameter for the second parameter here.So we can do this.And if we print the volume or we can even print the member variables, let’s say base red and we’regoing to print the base radius down, I’m going to say get base radius and we’re going to call a functionhere.We’re going to put in our parentheses, we’re going to put out the height and we’re going to put outthe volume.If we do this, we’re going to see our information printed out on the console.We can bring up a terminal because we want to run this program and then we’re going to build with GCClike we have been doing all along.So you see that the world is actually good and we are using our implementation with initializer lists.Here again, the syntax is to say a colon after your parameter list.Then you say which one you want to initialize with what.For example, the base radius here is going to be initialized with red param and the height is goingto be initialized with height param and we specify our initializers in parentheses like this.This is the syntax and it is going to work.So this is really long.Some people like to split this into different lines and put our initializers on a second line.Even if you want.If you have many member variables here, you can split this again on different lines and this is goingto work and it is going to be much more readable.Again, if we build this, this is going to build just fine.We’re going to run the test to build with GCC, you’re going to see that it is going to build fine andwe’re going to have our information here.So let’s clear and run Rooster.We’re going to see that the base radius is five.It is what we specified here.If we go in our declaration for the constructor, we’re going to see that the default parameter is five.And we can prove this because the height is five here and we have our volume.If you plug this in, you’re going to see that you get this volume here and it is using the formulawe have in our volume function implementation here.This is really all I wanted you to see in this lecture.The syntax you can use to use initializer lists and it is really cool.The body is going to be empty because by the time your object is created, it’s already going to beinitialized.And this is the syntax I usually recommend to do your constructors if you can, because it has a fewbenefits as we’re going to see in the next few lectures.We are going to stop here in this lecture and the next one we’re going to try and compare initializerlists, initialization with member wise, copy initialization.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，C++新同学！很高兴能和你一起探索C++的奇妙世界。我是你的C++老师，我们将一起学习最地道的C++知识。</p>
<hr>
<h2 id="C-构造函数中的初始化列表-Initializer-Lists-深度解析"><a href="#C-构造函数中的初始化列表-Initializer-Lists-深度解析" class="headerlink" title="C++构造函数中的初始化列表 (Initializer Lists) 深度解析"></a>C++构造函数中的初始化列表 (Initializer Lists) 深度解析</h2><p><strong>简介</strong>: 本次课程将深入探讨C++构造函数中一种高效、推荐的成员变量初始化方式——初始化列表。我们将学习它的语法、与传统赋值方式的区别，以及使用它带来的诸多好处，并通过实际代码示例加深理解。</p>
<hr>
<h2 id="1-详细讲解-构造函数与初始化列表"><a href="#1-详细讲解-构造函数与初始化列表" class="headerlink" title="1. 详细讲解: 构造函数与初始化列表"></a>1. 详细讲解: 构造函数与初始化列表</h2><p>我们都知道，当定义一个类（<code>class</code>）时，通常会为它提供一个或多个<strong>构造函数</strong> (<code>constructor</code>) 来初始化类的<strong>成员变量</strong> (<code>member variable</code>)。过去，我们可能习惯于在构造函数的<strong>函数体</strong> (<code>function body</code>) 内部，使用<strong>赋值运算符</strong> (<code>assignment operator</code>) 来进行成员变量的初始化。这种方式被称为“<strong>逐成员赋值</strong> (<code>member-wise assignment</code>)”。</p>
<p>让我们以一个 <code>Cylinder</code> (圆柱体) 类为例来回顾一下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> base_radius; <span class="comment">// 基底半径</span></span><br><span class="line">    <span class="keyword">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传统构造函数实现方式 (逐成员赋值)</span></span><br><span class="line">    Cylinder(<span class="keyword">double</span> radius_param, <span class="keyword">double</span> height_param) &#123;</span><br><span class="line">        base_radius = radius_param; <span class="comment">// 赋值</span></span><br><span class="line">        height = height_param;       <span class="comment">// 赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 其他方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这种方法虽然可行，但在某些情况下效率不高，并且有其局限性。C++为我们提供了另一种更优、更高效的成员变量初始化机制：<strong>初始化列表</strong> (<code>initializer lists</code>)。</p>
<h3 id="1-1-什么是初始化列表？"><a href="#1-1-什么是初始化列表？" class="headerlink" title="1.1 什么是初始化列表？"></a>1.1 什么是初始化列表？</h3><p>初始化列表是C++构造函数特有的一种语法，它允许你在构造函数的<strong>参数列表</strong> (<code>parameter list</code>) 之后，<strong>冒号</strong> (<code>:</code>) 之前，直接指定成员变量的初始值。</p>
<p>来看一下使用初始化列表的 <code>Cylinder</code> 构造函数：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> base_radius; <span class="comment">// 基底半径</span></span><br><span class="line">    <span class="keyword">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用初始化列表的构造函数</span></span><br><span class="line">    Cylinder(<span class="keyword">double</span> radius_param, <span class="keyword">double</span> height_param)</span><br><span class="line">        : base_radius(radius_param), <span class="comment">// 初始化列表：将radius_param赋值给base_radius</span></span><br><span class="line">          height(height_param)       <span class="comment">// 初始化列表：将height_param赋值给height</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数体可以为空，因为成员变量已经初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 其他方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong>语法解析</strong>:</p>
<ol>
<li>在构造函数的参数列表（例如 <code>(double radius_param, double height_param)</code>）的右括号 <code>)</code> 之后，紧接着添加一个<strong>冒号</strong> (<code>:</code> )。</li>
<li>冒号后面跟着一个或多个初始化表达式，每个表达式用<strong>逗号</strong> (<code>,</code>) 分隔。</li>
<li>每个初始化表达式的格式是：<code>成员变量名(参数名 或 初始值)</code>。例如，<code>base_radius(radius_param)</code> 表示用 <code>radius_param</code> 来初始化 <code>base_radius</code>。</li>
<li>最后一个初始化表达式后不需要逗号，直接跟着构造函数的函数体 <code>{}</code>。</li>
<li>为了代码的可读性，当成员变量较多时，通常会将初始化列表中的每个成员放在新的一行。</li>
</ol>
<h3 id="1-2-为什么推荐使用初始化列表？"><a href="#1-2-为什么推荐使用初始化列表？" class="headerlink" title="1.2 为什么推荐使用初始化列表？"></a>1.2 为什么推荐使用初始化列表？</h3><p>使用初始化列表有以下几个显著的优点：</p>
<ol>
<li><p><strong>避免不必要的拷贝</strong> (<code>avoid unnecessary copies</code>)：<br>当我们在构造函数体内使用赋值的方式初始化成员变量时，实际上是发生了两次操作：</p>
<ul>
<li>首先，成员变量会先进行一次<strong>默认构造</strong> (<code>default construction</code>)。</li>
<li>然后，再通过<strong>赋值操作</strong> (<code>assignment operation</code>) 将参数值赋给成员变量。<br>特别是当成员变量是自定义类对象（如 <code>std::string</code>）时，默认构造可能创建一个空对象，然后赋值操作又会销毁这个空对象并重新创建一个新的对象。这会导致不必要的临时对象创建和销毁，浪费CPU周期和内存。<br>而使用初始化列表时，成员变量在<strong>对象创建时</strong> (<code>object creation</code>) 就直接通过提供的参数进行<strong>构造</strong> (<code>construction</code>) 和初始化，避免了先默认构造再赋值的二次操作。这就像是你建造一栋房子时，直接把家具放进去，而不是先建好空房子再搬家具。</li>
</ul>
</li>
<li><p><strong>效率更高</strong>: 由于避免了额外的拷贝和赋值操作，初始化列表通常比在构造函数体内赋值的方式更高效。</p>
</li>
<li><p><strong>某些成员变量必须通过初始化列表初始化</strong>:<br>这是初始化列表最重要的一个原因，甚至可以说在某些情况下是“唯一”的初始化方式。</p>
<ul>
<li><strong>常量成员变量</strong> (<code>const member variables</code>): <code>const</code> 成员变量在定义后就不能被修改，因此它们必须在对象构造时就被赋予一个初始值。构造函数体内的赋值操作属于修改，而不是初始化。</li>
<li><strong>引用成员变量</strong> (<code>reference member variables</code>): 引用在定义时就必须被初始化，并且一旦绑定就不能更改绑定的对象。</li>
<li><strong>没有默认构造函数的类类型成员变量</strong>: 如果一个类类型的成员变量没有提供<strong>默认构造函数</strong> (<code>default constructor</code>) (即没有无参数的构造函数)，那么它就无法在构造函数体内被“默认构造”，因此你必须通过初始化列表显式地调用其带参数的构造函数来初始化它。</li>
<li><strong>基类构造函数调用</strong>: 当派生类构造时，它需要负责调用其基类的构造函数来初始化基类部分。基类的构造函数也必须通过初始化列表来调用。</li>
</ul>
<p>这些情况下，如果你不使用初始化列表，编译器会报错。</p>
</li>
<li><p><strong>强制初始化所有成员</strong>: 有些人认为，使用初始化列表可以清晰地表明所有成员变量都已在构造时被考虑和初始化，提高了代码的清晰度。</p>
</li>
</ol>
<p>因此，强烈建议你在编写C++构造函数时，尽可能地使用初始化列表来初始化你的成员变量。</p>
<hr>
<h2 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h2><p>下面是一个完整的 <code>Cylinder</code> 类示例，展示了如何使用初始化列表。</p>
<p><strong><code>cylinder.h</code> 文件</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CYLINDER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYLINDER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; // For M_PI or pi constant if needed</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个常量PI，也可以使用M_PI（需要定义_USE_MATH_DEFINES）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> base_radius; <span class="comment">// 圆柱体基底半径</span></span><br><span class="line">    <span class="keyword">double</span> height;      <span class="comment">// 圆柱体高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数1: 默认构造函数，使用初始化列表给默认值</span></span><br><span class="line">    Cylinder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数2: 带参数的构造函数，演示初始化列表</span></span><br><span class="line">    <span class="comment">// 为height_param设置了默认参数，这样可以用一个参数或两个参数构造</span></span><br><span class="line">    Cylinder(<span class="keyword">double</span> radius_param, <span class="keyword">double</span> height_param = <span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数 (如果自定义了，也常使用初始化列表)</span></span><br><span class="line">    <span class="comment">// Cylinder(const Cylinder&amp; source); // 暂时不深入，但要知道也是用初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取基底半径</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_base_radius</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取高度</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_height</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算圆柱体体积</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">volume</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置基底半径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_base_radius</span><span class="params">(<span class="keyword">double</span> radius_param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置高度</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_height</span><span class="params">(<span class="keyword">double</span> height_param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数 (这里很简单，但对于资源管理很重要)</span></span><br><span class="line">    ~Cylinder();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CYLINDER_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>cylinder.cpp</code> 文件</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cylinder.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数1: 默认构造函数实现，使用初始化列表</span></span><br><span class="line">Cylinder::Cylinder()</span><br><span class="line">    : base_radius(<span class="number">2.0</span>), <span class="comment">// 默认半径2.0</span></span><br><span class="line">      height(<span class="number">3.0</span>)       <span class="comment">// 默认高度3.0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"默认构造函数被调用，通过初始化列表初始化。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数2: 带参数的构造函数实现，使用初始化列表</span></span><br><span class="line">Cylinder::Cylinder(<span class="keyword">double</span> radius_param, <span class="keyword">double</span> height_param)</span><br><span class="line">    : base_radius(radius_param), <span class="comment">// 使用参数初始化base_radius</span></span><br><span class="line">      height(height_param)       <span class="comment">// 使用参数初始化height</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数体可以为空，因为成员变量已经通过初始化列表完全初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"带参数构造函数被调用，通过初始化列表初始化。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取基底半径</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cylinder::get_base_radius</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base_radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取高度</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cylinder::get_height</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算圆柱体体积</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cylinder::volume</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * base_radius * base_radius * height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置基底半径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cylinder::set_base_radius</span><span class="params">(<span class="keyword">double</span> radius_param)</span> </span>&#123;</span><br><span class="line">    base_radius = radius_param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置高度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cylinder::set_height</span><span class="params">(<span class="keyword">double</span> height_param)</span> </span>&#123;</span><br><span class="line">    height = height_param;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Cylinder::~Cylinder() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cylinder 对象被销毁。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code> 文件</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cylinder.h"</span> <span class="comment">// 包含Cylinder类的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 使用默认构造函数创建对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 创建 C1 (默认构造函数) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Cylinder c1; <span class="comment">// 调用 Cylinder() 默认构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"C1 - 半径: "</span> &lt;&lt; c1.get_base_radius()</span><br><span class="line">              &lt;&lt; <span class="string">", 高度: "</span> &lt;&lt; c1.get_height()</span><br><span class="line">              &lt;&lt; <span class="string">", 体积: "</span> &lt;&lt; c1.volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用带一个参数的构造函数创建对象 (因为height_param有默认值)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 创建 C2 (带一个参数的构造函数) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Cylinder <span class="title">c2</span><span class="params">(<span class="number">10.0</span>)</span></span>; <span class="comment">// 调用 Cylinder(10.0, 5.0) 构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"C2 - 半径: "</span> &lt;&lt; c2.get_base_radius()</span><br><span class="line">              &lt;&lt; <span class="string">", 高度: "</span> &lt;&lt; c2.get_height()</span><br><span class="line">              &lt;&lt; <span class="string">", 体积: "</span> &lt;&lt; c2.volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用带两个参数的构造函数创建对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 创建 C3 (带两个参数的构造函数) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Cylinder <span class="title">c3</span><span class="params">(<span class="number">7.0</span>, <span class="number">15.0</span>)</span></span>; <span class="comment">// 调用 Cylinder(7.0, 15.0) 构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"C3 - 半径: "</span> &lt;&lt; c3.get_base_radius()</span><br><span class="line">              &lt;&lt; <span class="string">", 高度: "</span> &lt;&lt; c3.get_height()</span><br><span class="line">              &lt;&lt; <span class="string">", 体积: "</span> &lt;&lt; c3.volume() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序结束时，c1, c2, c3 对象会被销毁，析构函数会被调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>如何编译和运行 (在终端)</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp cylinder.cpp -o cylinder_app -std=c++11 <span class="comment"># 或者更高的标准如-std=c++17</span></span><br><span class="line">./cylinder_app</span><br></pre></td></tr></table></figure></div>
<p>运行结果会显示每个对象创建时构造函数被调用的消息，以及它们的成员值和计算出的体积。</p>
<hr>
<h2 id="3-QA-闪卡"><a href="#3-QA-闪卡" class="headerlink" title="3. QA 闪卡"></a>3. QA 闪卡</h2><ol>
<li><p><strong>Q</strong>: 什么是构造函数中的初始化列表？<br><strong>A</strong>: 初始化列表是C++构造函数特有的语法，用于在构造函数体执行之前，直接初始化类的成员变量。</p>
</li>
<li><p><strong>Q</strong>: 初始化列表的语法是怎样的？<br><strong>A</strong>: 在构造函数的参数列表后，紧跟一个冒号 <code>:</code>，然后列出要初始化的成员变量及其对应的初始值，用逗号 <code>,</code> 分隔。例如：<code>MyClass(int x) : member_var(x) {}</code>。</p>
</li>
<li><p><strong>Q</strong>: 相较于在构造函数体内赋值，使用初始化列表有哪些主要优势？<br><strong>A</strong>: 主要优势包括：避免不必要的拷贝（尤其是对于类类型成员变量），更高效的初始化过程，以及在某些情况下是初始化 <code>const</code> 成员、引用成员或没有默认构造函数的类类型成员的唯一方式。</p>
</li>
<li><p><strong>Q</strong>: 什么时候必须使用初始化列表？<br><strong>A</strong>: 必须使用初始化列表的情况包括：初始化 <code>const</code> 成员变量、初始化引用成员变量、初始化没有默认构造函数的类类型成员变量，以及调用基类的构造函数。</p>
</li>
</ol>
<hr>
<h2 id="4-常见误解或错误"><a href="#4-常见误解或错误" class="headerlink" title="4. 常见误解或错误"></a>4. 常见误解或错误</h2><ol>
<li><p><strong>忘记冒号或语法错误</strong>: 初学者常会忘记在参数列表后添加冒号，或者将初始化列表的格式搞错，例如使用等号 <code>=</code> 而不是括号 <code>()</code>。</p>
<ul>
<li><strong>错误示例</strong>: <code>MyClass(int x) { member_var = x; }</code> (这是赋值，不是初始化列表)</li>
<li><strong>错误示例</strong>: <code>MyClass(int x) : member_var = x {}</code> (初始化列表不能用等号，除非是C++11的统一初始化语法，但通常用括号表示)</li>
<li><strong>正确示例</strong>: <code>MyClass(int x) : member_var(x) {}</code></li>
</ul>
</li>
<li><p><strong>混淆初始化和赋值</strong>: 认为在构造函数体内赋值和使用初始化列表是一回事。实际上，初始化是在对象创建时进行的，而赋值是在对象已经存在后进行的。对于基本数据类型（如 <code>int</code>, <code>double</code>），区别可能不那么明显，但对于复杂对象，区别巨大。</p>
</li>
<li><p><strong>在初始化列表中使用未声明的变量</strong>: 确保在初始化列表中使用的变量名是构造函数的参数名或类中定义的成员变量名。</p>
<ul>
<li><strong>错误示例</strong>: <code>Cylinder(double r) : base_radius(radius) {}</code> (如果 <code>radius</code> 未声明为参数或全局变量)</li>
</ul>
</li>
<li><p><strong>初始化顺序的误解</strong>: 初始化列表中的成员变量初始化顺序<strong>不</strong>取决于它们在初始化列表中出现的顺序，而是取决于它们在类中<strong>声明的顺序</strong>。这是一个非常常见的C++陷阱。如果初始化列表中的某个成员变量依赖于另一个成员变量的值，而后者在类中声明的位置靠后，可能会导致未定义的行为。</p>
<ul>
<li><strong>示例</strong>:<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">// a 在 b 之后声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 尽管这里先初始化a，再初始化b，但实际的初始化顺序是 b (先声明), 然后 a (后声明)</span></span><br><span class="line">    MyClass() : a(b + <span class="number">1</span>), b(<span class="number">10</span>) &#123;&#125; <span class="comment">// 错误！b 尚未初始化时就被a使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
正确的做法是确保依赖项先被声明：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">// a 在 b 之后声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 尽管这里先初始化a，再初始化b，但实际的初始化顺序是 b (先声明), 然后 a (后声明)</span></span><br><span class="line">    MyClass() : b(<span class="number">10</span>), a(b + <span class="number">1</span>) &#123;&#125; <span class="comment">// b先初始化为10，然后a可以安全地使用b+1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
所以，始终按照成员变量在类中声明的顺序来排列初始化列表，以避免这种潜在的问题，并提高代码的可读性。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-编程练习"><a href="#5-编程练习" class="headerlink" title="5. 编程练习"></a>5. 编程练习</h2><p>现在，轮到你来动手了！</p>
<p>请修改下面的 <code>Book</code> 类，将其构造函数从传统的逐成员赋值方式改为使用<strong>初始化列表</strong>的方式来初始化成员变量。</p>
<p><strong><code>book.h</code> 文件</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOOK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> title;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> author;</span><br><span class="line">    <span class="keyword">int</span> publication_year;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数声明 (你需要在这里修改，并修改.cpp文件中的实现)</span></span><br><span class="line">    Book(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; title_param, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; author_param, <span class="keyword">int</span> year_param, <span class="keyword">double</span> price_param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取书名</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">get_title</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取作者</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">get_author</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取出版年份</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_publication_year</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取价格</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">get_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印书籍信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// BOOK_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>book.cpp</code> 文件 (你需要填充 <code>Book</code> 构造函数的实现)</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"book.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请在这里修改 Book 构造函数的实现，使用初始化列表来初始化成员变量</span></span><br><span class="line">Book::Book(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; title_param, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; author_param, <span class="keyword">int</span> year_param, <span class="keyword">double</span> price_param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 旧的实现方式 (你需要替换掉这些行，使用初始化列表)</span></span><br><span class="line">    <span class="comment">// this-&gt;title = title_param;</span></span><br><span class="line">    <span class="comment">// this-&gt;author = author_param;</span></span><br><span class="line">    <span class="comment">// this-&gt;publication_year = year_param;</span></span><br><span class="line">    <span class="comment">// this-&gt;price = price_param;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book 构造函数被调用！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Book::get_title</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Book::get_author</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> author;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Book::get_publication_year</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> publication_year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Book::get_price</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Book::print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"书名: "</span> &lt;&lt; title &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"作者: "</span> &lt;&lt; author &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"出版年份: "</span> &lt;&lt; publication_year &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"价格: "</span> &lt;&lt; price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code> 文件 (无需修改，用于测试)</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"book.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Book对象</span></span><br><span class="line">    <span class="function">Book <span class="title">my_book</span><span class="params">(<span class="string">"C++ Primer"</span>, <span class="string">"Stanley B. Lippman"</span>, <span class="number">2012</span>, <span class="number">59.99</span>)</span></span>;</span><br><span class="line">    my_book.print_info();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建另一个Book对象</span></span><br><span class="line">    <span class="function">Book <span class="title">another_book</span><span class="params">(<span class="string">"The Lord of the Rings"</span>, <span class="string">"J.R.R. Tolkien"</span>, <span class="number">1954</span>, <span class="number">25.00</span>)</span></span>;</span><br><span class="line">    another_book.print_info();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试创建多个Book对象到vector中</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Book&gt; books;</span><br><span class="line">    books.push_back(Book(<span class="string">"Effective C++"</span>, <span class="string">"Scott Meyers"</span>, <span class="number">1991</span>, <span class="number">35.50</span>));</span><br><span class="line">    books.push_back(Book(<span class="string">"Clean Code"</span>, <span class="string">"Robert C. Martin"</span>, <span class="number">2008</span>, <span class="number">45.00</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- Vector 中的书籍信息 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; book : books) &#123;</span><br><span class="line">        book.print_info();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请你提交 <code>book.cpp</code> 中 <code>Book</code> 构造函数的修改方案。</p>
<hr>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>回答之前我问个问题, 那个初始化列表的括号里,  是否可以是表达式?</p>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常棒的问题！提得非常好！</p>
<p>是的，初始化列表的括号 <code>()</code> 里<strong>可以是任意有效的C++表达式</strong>。</p>
<p>这意味着，你不仅可以使用传递给构造函数的参数来初始化成员变量，还可以使用：</p>
<ul>
<li><strong>字面量</strong> (<code>literals</code>) (例如 <code>5</code>、<code>3.14</code>、<code>&quot;hello&quot;</code>)</li>
<li><strong>其他成员变量</strong> (但要注意它们的<strong>声明顺序</strong>，因为初始化顺序是按照成员变量在类中的声明顺序，而不是初始化列表中的顺序)</li>
<li><strong>函数调用</strong> (<code>function calls</code>)</li>
<li><strong>算术表达式</strong> (<code>arithmetic expressions</code>)</li>
<li>等等… 任何能产生一个值的表达式都可以。</li>
</ul>
<p><strong>例子</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> unit_price;</span><br><span class="line">    <span class="keyword">int</span> quantity;</span><br><span class="line">    <span class="keyword">double</span> total_cost; <span class="comment">// 总价，可以通过其他成员计算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，使用初始化列表中的表达式</span></span><br><span class="line">    Product(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; n, <span class="keyword">double</span> price, <span class="keyword">int</span> qty)</span><br><span class="line">        : name(n),                       <span class="comment">// 使用参数初始化</span></span><br><span class="line">          unit_price(price),             <span class="comment">// 使用参数初始化</span></span><br><span class="line">          quantity(qty),                 <span class="comment">// 使用参数初始化</span></span><br><span class="line">          total_cost(unit_price * quantity) <span class="comment">// 在这里使用表达式，计算总价</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Product '"</span> &lt;&lt; name &lt;&lt; <span class="string">"' created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; name</span><br><span class="line">                  &lt;&lt; <span class="string">", Price: "</span> &lt;&lt; unit_price</span><br><span class="line">                  &lt;&lt; <span class="string">", Quantity: "</span> &lt;&lt; quantity</span><br><span class="line">                  &lt;&lt; <span class="string">", Total Cost: "</span> &lt;&lt; total_cost &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">item1</span><span class="params">(<span class="string">"Laptop"</span>, <span class="number">1200.50</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    item1.print_info(); <span class="comment">// Output: Total Cost: 2401</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Product <span class="title">item2</span><span class="params">(<span class="string">"Mouse"</span>, <span class="number">25.00</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    item2.print_info(); <span class="comment">// Output: Total Cost: 125</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中，<code>total_cost(unit_price * quantity)</code> 就是一个非常典型的在初始化列表内使用表达式的例子。<code>unit_price * quantity</code> 是一个算术表达式，它的计算结果会被用来初始化 <code>total_cost</code>。</p>
<p><strong>重要提示</strong>: 就像我之前强调的，尽管 <code>total_cost</code> 的初始化依赖于 <code>unit_price</code> 和 <code>quantity</code>，但如果 <code>unit_price</code> 和 <code>quantity</code> 在类成员变量声明的顺序中位于 <code>total_cost</code> 之前，那么这个表达式是安全的。C++会保证成员变量按照它们在类定义中的声明顺序进行初始化。</p>
<p>理解这一点非常关键，因为它大大增加了初始化列表的灵活性和实用性！</p>
<p>现在请你提交之前留下的 <code>Book</code> 类的编程练习解决方案吧！</p>
<hr>
<h2 id="🧑‍💻-User-2"><a href="#🧑‍💻-User-2" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><h1 id="include-“book-h”"><a href="#include-“book-h”" class="headerlink" title="include “book.h”"></a>include “book.h”</h1><p>// 请在这里修改 Book 构造函数的实现，使用初始化列表来初始化成员变量<br>Book::Book(const std::string&amp; title_param, const std::string&amp; author_param, int year_param, double price_param)<br>     : title(title_param),<br>     author(author_param),<br>     publication_year(year_param),<br>     price(price_param)<br>{<br>    // 旧的实现方式 (你需要替换掉这些行，使用初始化列表)<br>    // this-&gt;title = title_param;<br>    // this-&gt;author = author_param;<br>    // this-&gt;publication_year = year_param;<br>    // this-&gt;price = price_param;</p>
<pre><code>std::cout &lt;&lt; &quot;Book 构造函数被调用！&quot; &lt;&lt; std::endl;
</code></pre><p>}</p>
<p>std::string Book::get_title() const {<br>    return title;<br>}</p>
<p>std::string Book::get_author() const {<br>    return author;<br>}</p>
<p>int Book::get_publication_year() const {<br>    return publication_year;<br>}</p>
<p>double Book::get_price() const {<br>    return price;<br>}</p>
<p>void Book::print_info() const {<br>    std::cout &lt;&lt; “——————————“ &lt;&lt; std::endl;<br>    std::cout &lt;&lt; “书名: “ &lt;&lt; title &lt;&lt; std::endl;<br>    std::cout &lt;&lt; “作者: “ &lt;&lt; author &lt;&lt; std::endl;<br>    std::cout &lt;&lt; “出版年份: “ &lt;&lt; publication_year &lt;&lt; std::endl;<br>    std::cout &lt;&lt; “价格: “ &lt;&lt; price &lt;&lt; std::endl;<br>    std::cout &lt;&lt; “——————————“ &lt;&lt; std::endl;<br>}</p>
<hr>
<h2 id="🤖-Assistant-2"><a href="#🤖-Assistant-2" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>太棒了！你的解决方案<strong>完全正确</strong>！👏</p>
<h2 id="7-评分与答案解析"><a href="#7-评分与答案解析" class="headerlink" title="7. 评分与答案解析"></a>7. 评分与答案解析</h2><h3 id="7-1-解决方案评分"><a href="#7-1-解决方案评分" class="headerlink" title="7.1 解决方案评分"></a>7.1 解决方案评分</h3><p><strong>得分：5/5 (完美)</strong></p>
<p>你的代码清晰、准确地展示了如何使用初始化列表来初始化 <code>Book</code> 类的所有成员变量。你完全理解了初始化列表的语法和目的，并将其应用于实际场景。非常棒！</p>
<h3 id="7-2-实际答案与解释"><a href="#7-2-实际答案与解释" class="headerlink" title="7.2 实际答案与解释"></a>7.2 实际答案与解释</h3><p><strong>你的代码就是正确答案</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"book.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请在这里修改 Book 构造函数的实现，使用初始化列表来初始化成员变量</span></span><br><span class="line">Book::Book(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; title_param, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; author_param, <span class="keyword">int</span> year_param, <span class="keyword">double</span> price_param)</span><br><span class="line">     : title(title_param),             <span class="comment">// 使用title_param初始化title</span></span><br><span class="line">       author(author_param),           <span class="comment">// 使用author_param初始化author</span></span><br><span class="line">       publication_year(year_param),   <span class="comment">// 使用year_param初始化publication_year</span></span><br><span class="line">       price(price_param)              <span class="comment">// 使用price_param初始化price</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数体可以为空，因为所有成员都已在初始化列表阶段完成初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book 构造函数被调用！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (其他方法保持不变)</span></span><br></pre></td></tr></table></figure></div>
<p><strong>解释</strong>:</p>
<ul>
<li>你正确地在构造函数的参数列表 <code>)</code> 之后使用了冒号 <code>:</code>。</li>
<li>你为每个成员变量（<code>title</code>, <code>author</code>, <code>publication_year</code>, <code>price</code>）都提供了初始化表达式，并用逗号 <code>,</code> 将它们分隔开。</li>
<li>你使用了构造函数传入的参数 (<code>title_param</code>, <code>author_param</code>, <code>year_param</code>, <code>price_param</code>) 来初始化对应的成员变量。</li>
<li>这个构造函数的函数体现在是空的（除了那行输出语句），这正是使用初始化列表的典型表现：所有初始化工作都在进入函数体之前完成。</li>
</ul>
<p><strong>这样做的好处</strong>:</p>
<ol>
<li>对于 <code>std::string</code> 这样的类类型成员（<code>title</code> 和 <code>author</code>），使用初始化列表可以避免一次默认构造和一次赋值操作。它直接调用 <code>std::string</code> 的带参数构造函数来初始化这些成员，效率更高。</li>
<li>对于 <code>int</code> 和 <code>double</code> 这样的内置类型成员，虽然效率提升不那么明显，但语法保持了一致性，并且仍然是推荐的做法。</li>
<li>如果未来 <code>Book</code> 类中加入了 <code>const</code> 成员或引用成员，或者一个没有默认构造函数的自定义类对象成员，你现在已经掌握的这种初始化方式将是<strong>唯一的</strong>选择。</li>
</ol>
<p>你已经很好地掌握了构造函数初始化列表的基本用法和重要性！</p>
<h2 id="8-进一步探索与思考"><a href="#8-进一步探索与思考" class="headerlink" title="8. 进一步探索与思考"></a>8. 进一步探索与思考</h2><p>你已经对初始化列表有了很好的理解。为了让你成为更专业的C++开发者，这里有一些深入和扩展的问题，你可以思考和研究：</p>
<ol>
<li><p><strong>成员变量初始化顺序的真相</strong>:<br>我们课堂上提到了一个常见误解：“初始化列表中的成员变量初始化顺序不取决于它们在初始化列表中出现的顺序，而是取决于它们在类中<strong>声明的顺序</strong>。”</p>
<ul>
<li>请你尝试编写一个示例类，包含两个 <code>int</code> 成员，让它们在类中的声明顺序和在初始化列表中的顺序<strong>不一致</strong>，并且让其中一个成员的初始化依赖于另一个。观察编译器是否会给出警告或错误，并分析运行结果。这能帮你更深刻地理解这个“陷阱”。</li>
</ul>
</li>
<li><p><strong>默认成员初始化器 (Default Member Initializers) (C++11及更高版本)</strong>:<br>在C++11标准之后，你可以在类的定义中直接为非静态成员变量提供默认值。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">10</span>; <span class="comment">// 默认成员初始化器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name&#123;<span class="string">"Default"</span>&#125;; <span class="comment">// 也可以使用花括号初始化</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass() &#123;&#125; <span class="comment">// 如果不提供初始化列表，这些默认值将生效</span></span><br><span class="line">    MyClass(<span class="keyword">int</span> v) : value(v) &#123;&#125; <span class="comment">// 如果在初始化列表提供了，则会覆盖默认值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>了解这种方式的语法和用法。它与初始化列表有何关系？它们的使用优先级是怎样的？什么时候使用默认成员初始化器，什么时候使用初始化列表？</li>
</ul>
</li>
<li><p><strong>委托构造函数 (Delegating Constructors) (C++11及更高版本)</strong>:<br>C++11允许一个构造函数调用（或“委托”）同一个类的另一个构造函数来完成初始化工作。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> val) : a(val), b(<span class="number">0.0</span>) &#123;&#125; <span class="comment">// 基础构造函数</span></span><br><span class="line">    MyClass() : MyClass(<span class="number">0</span>) &#123;&#125; <span class="comment">// 委托构造函数，调用上面的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>了解委托构造函数的语法和使用场景。它如何帮助你避免代码重复？</li>
</ul>
</li>
<li><p><strong>统一初始化 (Uniform Initialization) / 大括号初始化 (Brace Initialization) (C++11及更高版本)</strong>:<br>C++11引入了使用花括号 <code>{}</code> 进行初始化的方式，这被称为统一初始化，旨在提供一种统一的初始化语法。</p>
<ul>
<li><code>Type var{value};</code></li>
<li><code>Type var = {value};</code></li>
<li><code>new Type{value};</code></li>
<li>甚至在初始化列表中：<code>member_var{param}</code></li>
<li>研究这种初始化方式。它与圆括号 <code>()</code> 的初始化方式有何不同？特别是要了解它与 <code>std::initializer_list</code> 类型 (<code>std::initializer_list</code> 是一个特殊的类模板，与构造函数初始化列表中的花括号初始化有些关联，但概念上不同，但它们都使用花括号) 的关联以及它的“非收窄转换” (<code>non-narrowing conversions</code>) 特性。</li>
</ul>
</li>
<li><p><strong>拷贝构造函数 (Copy Constructor) 和移动构造函数 (Move Constructor) 中的初始化列表</strong>:<br>我们这次主要讲了普通构造函数。在拷贝构造函数和C++11引入的移动构造函数中，初始化列表同样至关重要。</p>
<ul>
<li>尝试为 <code>Cylinder</code> 或 <code>Book</code> 类实现一个<strong>拷贝构造函数</strong>：<code>Book(const Book&amp; other);</code>。你会发现初始化列表在其中扮演了关键角色。</li>
<li>如果你想进一步挑战，可以尝试了解<strong>移动构造函数</strong>：<code>Book(Book&amp;&amp; other);</code>。它如何通过初始化列表实现资源的“移动”而不是“拷贝”，从而提高效率？</li>
</ul>
</li>
</ol>
<p>这些都是C++中关于构造和初始化非常重要的概念，掌握它们将大大提升你的C++编程能力和代码质量。加油！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Course/">Course    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Constructor/">Constructor    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/299%20-%20%E6%98%BE%E5%BC%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>299 - 显式构造函数</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/305%20-%20%E5%B7%B2%E5%88%A0%E9%99%A4%E6%9E%84%E9%80%A0%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>305 - 已删除构造 函数使用</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/274 - default constructor/" title="274 - default constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">274 - default constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/273 - constructor/" title="273 - constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">273 - constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/280 - 构造与析构顺序 倒序析构/" title="280 - 构造与析构顺序 倒序析构"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">280 - 构造与析构顺序 倒序析构</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/296 - 构造函数默认参数/" title="296 - 构造函数默认参数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">296 - 构造函数默认参数</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/305 - 已删除构造 函数使用/" title="305 - 已删除构造 函数使用"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">305 - 已删除构造 函数使用</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/300 - cpp构造函数委托/" title="300 - cpp构造函数委托"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">300 - cpp构造函数委托</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>