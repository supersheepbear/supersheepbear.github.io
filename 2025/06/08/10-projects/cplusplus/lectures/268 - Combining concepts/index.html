<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>268 - Combining concepts | Bear's dream</title><meta name="description" content="268 - Combining concepts"><meta name="keywords" content="Coding,Cpp,Function,Language,Concept"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="268 - Combining concepts"><meta name="twitter:description" content="268 - Combining concepts"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="268 - Combining concepts"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/268%20-%20Combining%20concepts/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="268 - Combining concepts"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/268%20-%20Combining%20concepts/"><link rel="prev" title="259 - Auto Function Templates" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/259%20-%20Auto%20Function%20Templates/"><link rel="next" title="267 - requires clause" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/267%20-%20requires%20clause/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#268-Combining-Concepts"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">268 - Combining Concepts</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-标题和摘要"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">1. 标题和摘要</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-详细解释"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">2. 详细解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-常见误解或错误-Common-Misunderstandings-Mistakes"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">5. 常见误解或错误 (Common Misunderstandings&#x2F;Mistakes)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-编码练习-Coding-Exercise"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">6. 编码练习 (Coding Exercise)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-评价你的解答、正确答案和解释"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">7. 评价你的解答、正确答案和解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-扩展问题与探索建议-Extended-Questions-amp-Suggestions"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">8. 扩展问题与探索建议 (Extended Questions &amp; Suggestions)</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#268-Combining-Concepts"><span class="toc-number">1.</span> <span class="toc-text">268 - Combining Concepts</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-标题和摘要"><span class="toc-number">1.1.</span> <span class="toc-text">1. 标题和摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-详细解释"><span class="toc-number">1.2.</span> <span class="toc-text">2. 详细解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-代码示例"><span class="toc-number">1.3.</span> <span class="toc-text">3. 代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc-number">1.4.</span> <span class="toc-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见误解或错误-Common-Misunderstandings-Mistakes"><span class="toc-number">1.5.</span> <span class="toc-text">5. 常见误解或错误 (Common Misunderstandings&#x2F;Mistakes)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-编码练习-Coding-Exercise"><span class="toc-number">1.6.</span> <span class="toc-text">6. 编码练习 (Coding Exercise)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-评价你的解答、正确答案和解释"><span class="toc-number">1.7.</span> <span class="toc-text">7. 评价你的解答、正确答案和解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-扩展问题与探索建议-Extended-Questions-amp-Suggestions"><span class="toc-number">1.8.</span> <span class="toc-text">8. 扩展问题与探索建议 (Extended Questions &amp; Suggestions)</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">268 - Combining concepts</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/268%20-%20Combining%20concepts/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/268%20-%20Combining%20concepts/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="268-Combining-Concepts"><a href="#268-Combining-Concepts" class="headerlink" title="268 - Combining Concepts"></a>268 - Combining Concepts</h1><p><a href="https://gemini.google.com/u/2/app/3982bc96df1cc48f" target="_blank" rel="external nofollow noopener noreferrer">https://gemini.google.com/u/2/app/3982bc96df1cc48f</a></p>
<p>好的，新同学你好！我是你的 C++ 老师。别担心，C++ 看起来可能有点复杂，但我们会一步一步来，用最清晰易懂的方式学习。这节课我们来学习一个 C++20 引入的很酷的特性：概念（Concept）的组合。</p>
<h2 id="1-标题和摘要"><a href="#1-标题和摘要" class="headerlink" title="1. 标题和摘要"></a>1. 标题和摘要</h2><p><strong>标题：</strong> C++ 概念：使用逻辑运算符组合约束</p>
<p><strong>摘要：</strong> 本节课讲解如何使用逻辑与（<code>&amp;&amp;</code> - AND）和逻辑或（<code>||</code> - OR）运算符将多个 C++ 概念（Concept）组合起来，对模板参数施加更复杂的约束。我们将通过示例代码学习其语法和应用场景，并了解一种不推荐的“内联”定义方式。</p>
<h2 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h2><p>我们之前可能已经接触过 C++ 的模板（template），它允许我们编写通用的代码，可以处理不同类型的数据。但有时候，我们希望对这些“不同类型”进行一些限制，不是任何类型都适用。比如，一个函数可能只接受整数，或者只接受能进行比较的类型。</p>
<p>C++20 引入了 <strong>概念（Concept）</strong> 这个强大的特性，它允许我们明确地定义对模板参数的 <strong>要求（requirements）</strong>。这些要求可以是语法上的（比如，要求某个类型必须有某个成员函数），也可以是语义上的（比如，通过 <code>requires</code> 表达式检查某个表达式的值）。</p>
<p>这节课的核心是，我们不仅能定义单个概念，还能像拼积木一样，把多个概念 <strong>组合</strong> 起来，形成更复杂、更精确的约束条件。怎么组合呢？就是使用我们熟悉的 <strong>逻辑运算符（logical operators）</strong>：</p>
<ul>
<li><strong>逻辑与 (Logical AND - <code>&amp;&amp;</code>)</strong>：表示 <strong>同时满足</strong> 多个概念。如果一个类型需要满足 <code>ConceptA &amp;&amp; ConceptB</code>，那么它必须 <strong>既</strong> 满足 <code>ConceptA</code> <strong>又</strong> 满足 <code>ConceptB</code>。</li>
<li><strong>逻辑或 (Logical OR - <code>||</code>)</strong>：表示 <strong>满足其中任意一个</strong> 概念即可。如果一个类型需要满足 <code>ConceptA || ConceptB</code>，那么它 <strong>要么</strong> 满足 <code>ConceptA</code>，<strong>要么</strong> 满足 <code>ConceptB</code>，或者两者都满足。</li>
</ul>
<p><strong>让我们来看一个例子：<code>TinyType</code> 概念</strong></p>
<p>在讲解组合之前，我们先回顾（或学习）一个简单的概念 <code>TinyType</code>。</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">concept TinyType &#x3D; requires(T t) &#123;</span><br><span class="line">    &#x2F;&#x2F; 简单要求 (simple requirement): 检查 sizeof(T) &lt; 4 这个语法是否有效</span><br><span class="line">    sizeof(T) &lt; 4;</span><br><span class="line">    &#x2F;&#x2F; 嵌套要求 (nested requirement): 不仅检查语法，还要求表达式的值必须为 true</span><br><span class="line">    &#123; sizeof(T) &lt; 4 &#125; -&gt; std::convertible_to&lt;bool&gt;; &#x2F;&#x2F; C++20 语法，确保结果可转为 bool</span><br><span class="line">    requires sizeof(T) &lt; 4; &#x2F;&#x2F; 更直接的方式强制要求表达式为 true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这个 <code>TinyType</code> 概念是用来检查一个类型 <code>T</code> 所占用的内存大小（用 <code>sizeof(T)</code> 获取）是否小于 4 个字节。</p>
<ul>
<li><code>sizeof(T) &lt; 4;</code> 这是一个 <strong>简单要求（simple requirement）</strong>，它只检查这个表达式在语法上是否有效。</li>
<li><code>requires sizeof(T) &lt; 4;</code> 这是一个 <strong>嵌套要求（nested requirement）</strong>。它不仅检查语法，还 <strong>强制要求</strong> <code>sizeof(T) &lt; 4</code> 这个表达式的计算结果必须是 <code>true</code>。如果结果是 <code>false</code>，即使语法没错，这个概念也不会被满足。</li>
</ul>
<p><strong>如何在一个函数模板中使用和组合概念？</strong></p>
<p>我们通常在函数模板的声明中使用 <code>requires</code> 子句来应用概念。</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">&#x2F;&#x2F; requires 子句 (requires clause) 开始</span><br><span class="line">requires ConceptA&lt;T&gt; &amp;&amp; ConceptB&lt;T&gt; &#x2F;&#x2F; 或者 ConceptA&lt;T&gt; || ConceptB&lt;T&gt;</span><br><span class="line">T func(T param) &#123;</span><br><span class="line">    &#x2F;&#x2F; 函数体</span><br><span class="line">    return param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里的 <code>requires</code> 关键字（keyword）后面跟着的就是对模板参数 <code>T</code> 的约束条件。</p>
<p><strong>组合示例 1：使用逻辑或 (<code>||</code>)</strong></p>
<p>假设我们想让一个函数 <code>add</code> 既能处理整数类型，也能处理浮点数类型。我们可以使用标准库里预定义的 <code>std::integral</code> 和 <code>std::floating_point</code> 概念，并用 <code>||</code> 把它们组合起来。</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;concepts&gt; &#x2F;&#x2F; 需要包含 concepts 头文件</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires std::integral&lt;T&gt; || std::floating_point&lt;T&gt; &#x2F;&#x2F; 要求 T 要么是整数，要么是浮点数</span><br><span class="line">T add(T a, T b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>std::integral&lt;T&gt;</code>：检查类型 <code>T</code> 是否是整数类型（如 <code>int</code>, <code>char</code>, <code>long long</code> 等）。</li>
<li><code>std::floating_point&lt;T&gt;</code>：检查类型 <code>T</code> 是否是浮点数类型（如 <code>float</code>, <code>double</code> 等）。</li>
<li><code>||</code>：表示 <code>T</code> 只需要满足这两个概念中的 <strong>任何一个</strong> 就可以了。</li>
</ul>
<p>所以，你可以用 <code>int</code> 或者 <code>double</code> 来调用 <code>add</code> 函数，都没问题。但是如果你尝试用 <code>std::string</code> 或者其他不满足这两个概念中任何一个的类型来调用，编译器就会报错，因为它不满足我们设定的约束。</p>
<p><strong>组合示例 2：使用逻辑与 (<code>&amp;&amp;</code>)</strong></p>
<p>现在，假设我们想让 <code>add</code> 函数的要求更严格：它处理的类型 <strong>必须</strong> 是整数类型，<strong>并且</strong> 这个类型的内存大小必须小于 4 字节（满足我们之前定义的 <code>TinyType</code>）。这时我们就需要用 <code>&amp;&amp;</code>。</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; (假设 TinyType 概念已定义如上)</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires std::integral&lt;T&gt; &amp;&amp; TinyType&lt;T&gt; &#x2F;&#x2F; 要求 T 必须同时是整数 并且 满足 TinyType</span><br><span class="line">T add(T a, T b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>&amp;&amp;</code>：表示 <code>T</code> 必须 <strong>同时满足</strong> <code>std::integral&lt;T&gt;</code> <strong>和</strong> <code>TinyType&lt;T&gt;</code> 这两个条件。</li>
</ul>
<p>那么：</p>
<ul>
<li>如果你用 <code>int</code> (通常占用 4 字节或更少，具体取决于系统，但我们假设它在某些系统上是 4 字节，那么它可能不满足 <code>&lt; 4</code>，但如果是 <code>short</code> 或 <code>char</code> 通常可以) 调用 <code>add</code>，这取决于 <code>int</code> 的实际大小。如果 <code>sizeof(int)</code> 是 4，那么 <code>TinyType&lt;int&gt;</code> 为 <code>false</code>，调用失败。如果 <code>sizeof(short)</code> 是 2，那么 <code>short</code> 类型既是 <code>integral</code> 也是 <code>TinyType</code>，可以调用。</li>
<li>如果你用 <code>long long int</code> (通常占用 8 字节) 调用 <code>add</code>，它满足 <code>std::integral&lt;long long int&gt;</code>，但不满足 <code>TinyType&lt;long long int&gt;</code> (因为 8 不小于 4)，所以调用会失败。</li>
<li>如果你用 <code>double</code> (浮点数) 调用 <code>add</code>，它不满足 <code>std::integral&lt;double&gt;</code>，所以调用也会失败（即使它可能满足或不满足 <code>TinyType</code>，但 <code>&amp;&amp;</code> 要求两者都满足）。</li>
</ul>
<p><strong>一种不推荐的方式：内联定义概念</strong></p>
<p>C++ 语法甚至允许你不在 <code>requires</code> 子句中直接使用已命名的概念，而是直接把概念的定义（<code>requires</code> 表达式）写在里面。</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires std::integral&lt;T&gt; &amp;&amp; requires(T t) &#123; requires sizeof(T) &lt; 4; &#125; &#x2F;&#x2F; 直接把 TinyType 的核心要求写在这里</span><br><span class="line">T func(T param) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>你看，<code>requires std::integral&lt;T&gt; &amp;&amp; requires(T t) { requires sizeof(T) &lt; 4; }</code> 这一长串就是约束。虽然语法上是合法的，并且能达到和 <code>requires std::integral&lt;T&gt; &amp;&amp; TinyType&lt;T&gt;</code> 一样的效果，但它让函数声明变得非常冗长和难以阅读。通常我们<strong>强烈建议</strong>将复杂的约束封装成一个<strong>命名良好的概念</strong>，然后在 <code>requires</code> 子句中使用这个名字，这样代码会清晰得多。</p>
<p><strong>总结一下：</strong></p>
<ul>
<li>使用 <code>&amp;&amp;</code> 和 <code>||</code> 可以组合多个概念。</li>
<li><code>&amp;&amp;</code> 表示必须<strong>同时</strong>满足所有条件。</li>
<li><code>||</code> 表示只需满足<strong>任意一个</strong>条件。</li>
<li>组合概念可以用在函数模板的 <code>requires</code> 子句中，来精确控制允许使用的类型。</li>
<li>避免在 <code>requires</code> 子句中直接写复杂的 <code>requires</code> 表达式（内联定义），优先使用命名概念。</li>
</ul>
<h2 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h2><p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;concepts&gt; &#x2F;&#x2F; 引入概念库</span><br><span class="line">#include &lt;string&gt;   &#x2F;&#x2F; 引入字符串库</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义 TinyType 概念</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">concept TinyType &#x3D; requires(T t) &#123;</span><br><span class="line">    &#x2F;&#x2F; 要求 sizeof(T) &lt; 4 这个表达式必须为 true</span><br><span class="line">    requires sizeof(T) &lt; 4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 示例函数 1: 使用 || 组合概念</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires std::integral&lt;T&gt; || std::floating_point&lt;T&gt; &#x2F;&#x2F; T 必须是整数或浮点数</span><br><span class="line">T add_or(T a, T b) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;使用 add_or (整数或浮点数): &quot;;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 示例函数 2: 使用 &amp;&amp; 组合概念</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires std::integral&lt;T&gt; &amp;&amp; TinyType&lt;T&gt; &#x2F;&#x2F; T 必须同时是整数并且小于4字节</span><br><span class="line">T add_and(T a, T b) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;使用 add_and (整数且小于4字节): &quot;;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 示例函数 3: (不推荐) 内联定义概念</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires std::integral&lt;T&gt; &amp;&amp; requires(T t) &#123; requires sizeof(T) &lt; 4; &#125; &#x2F;&#x2F; T 必须是整数并且小于4字节 (内联)</span><br><span class="line">T add_inline(T a, T b) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;使用 add_inline (内联定义): &quot;;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a &#x3D; 5, b &#x3D; 3;          &#x2F;&#x2F; int: 整数, 通常 4 字节</span><br><span class="line">    short c &#x3D; 1, d &#x3D; 2;        &#x2F;&#x2F; short: 整数, 通常 2 字节 (&lt; 4)</span><br><span class="line">    double e &#x3D; 1.5, f &#x3D; 2.5;   &#x2F;&#x2F; double: 浮点数, 通常 8 字节</span><br><span class="line">    long long g &#x3D; 10, h &#x3D; 20;  &#x2F;&#x2F; long long: 整数, 通常 8 字节</span><br><span class="line">    std::string s1 &#x3D; &quot;a&quot;, s2 &#x3D; &quot;b&quot;; &#x2F;&#x2F; string: 不是整数也不是浮点数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 测试 add_or (||)</span><br><span class="line">    std::cout &lt;&lt; add_or(a, b) &lt;&lt; std::endl;  &#x2F;&#x2F; 输出: 使用 add_or (整数或浮点数): 8 (int 满足 integral)</span><br><span class="line">    std::cout &lt;&lt; add_or(c, d) &lt;&lt; std::endl;  &#x2F;&#x2F; 输出: 使用 add_or (整数或浮点数): 3 (short 满足 integral)</span><br><span class="line">    std::cout &lt;&lt; add_or(e, f) &lt;&lt; std::endl;  &#x2F;&#x2F; 输出: 使用 add_or (整数或浮点数): 4 (double 满足 floating_point)</span><br><span class="line">    std::cout &lt;&lt; add_or(g, h) &lt;&lt; std::endl;  &#x2F;&#x2F; 输出: 使用 add_or (整数或浮点数): 30 (long long 满足 integral)</span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; add_or(s1, s2) &lt;&lt; std::endl; &#x2F;&#x2F; 编译错误！string 既不是 integral 也不是 floating_point</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 测试 add_and (&amp;&amp;)</span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; add_and(a, b) &lt;&lt; std::endl; &#x2F;&#x2F; 编译错误（如果 sizeof(int) &gt;&#x3D; 4）！int 满足 integral 但不满足 TinyType</span><br><span class="line">    std::cout &lt;&lt; add_and(c, d) &lt;&lt; std::endl;  &#x2F;&#x2F; 输出: 使用 add_and (整数且小于4字节): 3 (short 满足 integral 和 TinyType)</span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; add_and(e, f) &lt;&lt; std::endl; &#x2F;&#x2F; 编译错误！double 不满足 integral</span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; add_and(g, h) &lt;&lt; std::endl; &#x2F;&#x2F; 编译错误！long long 不满足 TinyType (sizeof &gt;&#x3D; 4)</span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; add_and(s1, s2) &lt;&lt; std::endl; &#x2F;&#x2F; 编译错误！string 不满足 integral</span><br><span class="line"></span><br><span class="line">     std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 测试 add_inline (与 add_and 效果相同)</span><br><span class="line">    std::cout &lt;&lt; add_inline(c, d) &lt;&lt; std::endl; &#x2F;&#x2F; 输出: 使用 add_inline (内联定义): 3 (short 满足 integral 和 TinyType)</span><br><span class="line">    &#x2F;&#x2F; 其他调用同样会根据是否同时满足 integral 和 sizeof &lt; 4 来决定成功或失败</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 打印一些类型的大小以供参考 (结果可能因系统而异)</span><br><span class="line">    std::cout &lt;&lt; &quot;\n类型大小参考:\n&quot;;</span><br><span class="line">    std::cout &lt;&lt; &quot;sizeof(int): &quot; &lt;&lt; sizeof(int) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;sizeof(short): &quot; &lt;&lt; sizeof(short) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;sizeof(double): &quot; &lt;&lt; sizeof(double) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;sizeof(long long): &quot; &lt;&lt; sizeof(long long) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><em>注意：</em> <code>sizeof(int)</code> 的大小在不同系统或编译器设置下可能是 4 字节或更大/更小。上述代码假设 <code>sizeof(short)</code> &lt; 4，而 <code>sizeof(int)</code> 可能等于或大于 4， <code>sizeof(long long)</code> 大于 4。你需要根据你的实际编译环境来判断 <code>int</code> 是否满足 <code>TinyType</code>。</p>
<h2 id="4-QA-闪卡-QA-Flash-Cards"><a href="#4-QA-闪卡-QA-Flash-Cards" class="headerlink" title="4. QA 闪卡 (QA Flash Cards)"></a>4. QA 闪卡 (QA Flash Cards)</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>问题 (Question)</strong></td>
<td><strong>答案 (Answer)</strong></td>
</tr>
<tr>
<td>如何组合两个 C++ 概念，要求类型<strong>同时</strong>满足两者？</td>
<td>使用逻辑与运算符 <code>&amp;&amp;</code> (AND)。例如：<code>requires ConceptA&lt;T&gt; &amp;&amp; ConceptB&lt;T&gt;</code>。</td>
</tr>
<tr>
<td>如何组合两个 C++ 概念，要求类型满足<strong>其中任意一个</strong>即可？</td>
<td>使用逻辑或运算符 `</td>
</tr>
<tr>
<td><code>std::integral&lt;T&gt;</code> 这个概念是检查什么的？</td>
<td>检查类型 <code>T</code> 是否是 C++ 标准定义的整数类型之一。</td>
</tr>
<tr>
<td>为什么不推荐在 <code>requires</code> 子句中直接写复杂的 <code>requires</code> 表达式（内联定义）？</td>
<td>会让函数模板的声明变得非常冗长、难以阅读和维护。最好定义成一个命名的概念。</td>
</tr>
<tr>
<td><code>requires { sizeof(T) &lt; 4 }</code> 和 <code>requires requires sizeof(T) &lt; 4;</code> 有什么区别？</td>
<td>前者是复合要求(compound requirement)，可以检查更复杂的语法结构。后者是嵌套要求(nested requirement)，明确要求里面的表达式为<code>true</code>。对于简单布尔检查，嵌套要求更直接。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-常见误解或错误-Common-Misunderstandings-Mistakes"><a href="#5-常见误解或错误-Common-Misunderstandings-Mistakes" class="headerlink" title="5. 常见误解或错误 (Common Misunderstandings/Mistakes)"></a>5. 常见误解或错误 (Common Misunderstandings/Mistakes)</h2><ol>
<li><strong>混淆 <code>&amp;&amp;</code> 和 <code>||</code></strong>：最常见的错误是该用 <code>&amp;&amp;</code>（与）的时候用了 <code>||</code>（或），或者反过来。务必想清楚你是要求 <strong>所有</strong> 条件都满足，还是 <strong>任一</strong> 条件满足即可。</li>
<li><strong>忘记包含 <code>&lt;concepts&gt;</code> 头文件</strong>：使用标准概念（如 <code>std::integral</code>）或定义自己的概念都需要包含这个头文件。</li>
<li><strong><code>requires</code> 子句语法错误</strong>：<code>requires</code> 关键字后面直接跟约束表达式，或者跟一个 <code>requires</code> 表达式。例如 <code>requires requires ConceptA&lt;T&gt;</code> 是错误的，应该是 <code>requires ConceptA&lt;T&gt;</code>。</li>
<li><strong>对 <code>sizeof</code> 的误解</strong>：<code>sizeof</code> 返回的是类型占用的字节数，这个值在不同平台和编译器下可能不同。依赖 <code>sizeof</code> 的概念（如 <code>TinyType</code>）可能不具备完全的可移植性，除非你明确知道目标平台的类型大小。</li>
<li><strong>过度复杂的内联概念</strong>：如前所述，虽然语法允许，但在 <code>requires</code> 子句中写一长串 <code>requires { ... }; requires ...;</code> 会严重降低代码可读性。</li>
</ol>
<h2 id="6-编码练习-Coding-Exercise"><a href="#6-编码练习-Coding-Exercise" class="headerlink" title="6. 编码练习 (Coding Exercise)"></a>6. 编码练习 (Coding Exercise)</h2><p>现在，请你来完成一个小练习。我们有一个概念 <code>HasToString</code>，用于检查一个类型是否有 <code>.toString()</code> 成员函数。请你修改下面的函数模板 <code>processData</code>，使其<strong>同时</strong>满足以下两个条件：</p>
<ol>
<li>类型 <code>T</code> 必须是<strong>有符号整数</strong>（可以使用标准概念 <code>std::signed_integral</code>）。</li>
<li>类型 <code>T</code> 必须<strong>满足</strong> <code>HasToString</code> 概念。</li>
</ol>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;concepts&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt; &#x2F;&#x2F; 只是为了让 HasToString 有个例子</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设这个概念检查类型是否有 toString() 成员函数</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">concept HasToString &#x3D; requires(T obj) &#123;</span><br><span class="line">    &#123; obj.toString() &#125; -&gt; std::convertible_to&lt;std::string&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一个满足 HasToString 的示例类型 (仅用于演示)</span><br><span class="line">struct MyData &#123;</span><br><span class="line">    int value;</span><br><span class="line">    std::string toString() const &#123;</span><br><span class="line">        return &quot;MyData&#123;&quot; + std::to_string(value) + &quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一个不满足 HasToString 的示例类型</span><br><span class="line">struct SimpleData &#123;</span><br><span class="line">    int value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 请修改下面的 requires 子句</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires &#x2F;* 在这里填入正确的组合概念 *&#x2F;</span><br><span class="line">void processData(const T&amp; data) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Processing data: &quot; &lt;&lt; data.toString() &lt;&lt; &quot; (Value is signed integral)&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F; 编译成功的例子 (需要你正确填写 requires 子句)</span><br><span class="line">    &#x2F;&#x2F; MyInt a &#x3D; -10; &#x2F;&#x2F; 假设 MyInt 是一个同时满足 signed_integral 和 HasToString 的类型</span><br><span class="line">    &#x2F;&#x2F; processData(a);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 编译失败的例子</span><br><span class="line">    &#x2F;&#x2F; int b &#x3D; 5;         &#x2F;&#x2F; 满足 signed_integral 但不满足 HasToString</span><br><span class="line">    &#x2F;&#x2F; unsigned int c &#x3D; 5; &#x2F;&#x2F; 不满足 signed_integral</span><br><span class="line">    &#x2F;&#x2F; SimpleData d&#123;1&#125;;  &#x2F;&#x2F; 不满足 signed_integral 也不满足 HasToString</span><br><span class="line">    &#x2F;&#x2F; MyData e&#123;2&#125;;      &#x2F;&#x2F; 满足 HasToString 但不满足 signed_integral (因为 MyData 不是整数类型)</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;请在代码中填写 requires 子句并尝试编译&#x2F;运行合适的例子。&quot; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请你在 <code>/* 在这里填入正确的组合概念 */</code> 这部分填入正确的代码，使得 <code>processData</code> 函数能够正确地约束模板参数 <code>T</code>。完成后请把你的答案告诉我。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  // 只是为了让 HasToString 有个例子</span></span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这个概念检查类型是否有 toString() 成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">concept</span> HasToString = <span class="keyword">requires</span>(T obj) &#123;</span><br><span class="line"></span><br><span class="line">    &#123; obj.toString() &#125; -&gt; <span class="built_in">std</span>::convertible_to&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个满足 HasToString 的示例类型 (仅用于演示)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyData</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MyData&#123;"</span> + <span class="built_in">std</span>::to_string(value) + <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个不满足 HasToString 的示例类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleData</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 请修改下面的 requires 子句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> <span class="built_in">std</span>::signed_integral&lt;T&gt; &amp;&amp; HasToString&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processData</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Processing data: "</span> &lt;&lt; data.toString()</span><br><span class="line"></span><br><span class="line">              &lt;&lt; <span class="string">" (Value is signed integral)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译成功的例子 (需要你正确填写 requires 子句)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyInt a = -10; // 假设 MyInt 是一个同时满足 signed_integral 和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HasToString 的类型 processData(a);</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译失败的例子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int b = 5;         // 满足 signed_integral 但不满足 HasToString</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// unsigned int c = 5; // 不满足 signed_integral</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SimpleData d&#123;1&#125;;  // 不满足 signed_integral 也不满足 HasToString</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyData e&#123;2&#125;;      // 满足 HasToString 但不满足 signed_integral (因为</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MyData 不是整数类型)</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"请在代码中填写 requires 子句并尝试编译/运行合适的例子。"</span></span><br><span class="line"></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="7-评价你的解答、正确答案和解释"><a href="#7-评价你的解答、正确答案和解释" class="headerlink" title="7. 评价你的解答、正确答案和解释"></a>7. 评价你的解答、正确答案和解释</h2><p><strong>评价:</strong></p>
<p>你的解答非常棒！完全正确！</p>
<p><strong>评级：</strong> 5/5 ⭐⭐⭐⭐⭐ (满分!)</p>
<p><strong>正确答案：</strong></p>
<p>你给出的答案正是标准答案：</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires std::signed_integral&lt;T&gt; &amp;&amp; HasToString&lt;T&gt;</span><br><span class="line">void processData(const T&amp; data) &#123;</span><br><span class="line">    &#x2F;&#x2F; ... 函数体 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释：</strong></p>
<p>练习要求类型 <code>T</code> <strong>必须同时</strong> 满足两个条件：</p>
<ol>
<li>是有符号整数 (<code>std::signed_integral&lt;T&gt;</code>)</li>
<li>满足 <code>HasToString&lt;T&gt;</code> 概念</li>
</ol>
<p>因为要求是 “<strong>同时满足</strong>”，所以我们需要使用 <strong>逻辑与 (AND)</strong> 运算符 <code>&amp;&amp;</code> 来组合这两个概念。</p>
<ul>
<li><code>std::signed_integral&lt;T&gt;</code> 确保了类型 <code>T</code> 是像 <code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code> 这样的有符号整数类型，但不包括 <code>unsigned int</code> 或 <code>char</code> (char 的符号性是实现定义的)。</li>
<li><code>HasToString&lt;T&gt;</code> 确保了类型 <code>T</code> 有一个名为 <code>toString</code> 的成员函数，并且该函数的返回值可以转换成 <code>std::string</code>。</li>
<li><code>&amp;&amp;</code> 将这两个要求连接起来，只有当一个类型 <strong>既是</strong> 有符号整数 <strong>又</strong> 拥有 <code>toString</code> 方法时，它才能被用于 <code>processData</code> 函数。</li>
</ul>
<p>如果使用 <code>||</code> (逻辑或)，那么只需要满足其中一个条件即可，这不符合题意。如果只写其中一个概念，则会漏掉另一个约束条件。</p>
<p>关于示例代码的一个说明:</p>
<p>你可能注意到 main 函数里的成功示例 MyInt a = -10; 被注释掉了。这是因为标准的 C++ 整数类型（如 int, long）本身并没有 toString() 成员函数。而我们定义的 MyData 类型有 toString()，但它不是一个整数类型 (integral)。因此，要找到一个同时满足 std::signed_integral 和我们定义的 HasToString 的类型，通常需要我们自己自定义一个类型（比如创建一个像 MyInt 的类，它包装了一个整数并提供了 toString 方法）。这是概念组合威力的体现——我们可以定义非常具体和定制化的类型要求！</p>
<h2 id="8-扩展问题与探索建议-Extended-Questions-amp-Suggestions"><a href="#8-扩展问题与探索建议-Extended-Questions-amp-Suggestions" class="headerlink" title="8. 扩展问题与探索建议 (Extended Questions &amp; Suggestions)"></a>8. 扩展问题与探索建议 (Extended Questions &amp; Suggestions)</h2><p>你已经掌握了组合概念的基础，非常棒！如果你想继续深入，可以尝试探索以下问题：</p>
<ol>
<li><p><strong>探索更多标准概念：</strong> <code>&lt;concepts&gt;</code> 头文件里还有很多有用的预定义概念。尝试查找并理解以下概念的作用：</p>
<ul>
<li><code>std::totally_ordered&lt;T&gt;</code>：要求类型 <code>T</code> 支持全序比较（<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）。</li>
<li><code>std::invocable&lt;F, Args...&gt;</code>：要求类型 <code>F</code> (通常是函数或函数对象) 可以用参数 <code>Args...</code> 来调用。</li>
<li><code>std::derived_from&lt;Derived, Base&gt;</code>：要求类型 <code>Derived</code> 是从类型 <code>Base</code> 公有继承而来的。</li>
<li><code>std::same_as&lt;T, U&gt;</code>：要求类型 <code>T</code> 和 <code>U</code> 是同一种类型。</li>
<li>思考一下，这些概念可以如何组合来表达更复杂的约束？</li>
</ul>
</li>
<li><p><strong>定义更复杂的概念：</strong> 尝试自己定义一个概念，它不仅检查某个成员函数是否存在（语法要求），还检查该函数的返回值是否满足另一个概念（结合嵌套要求或 <code>requires</code> 表达式）。例如，定义一个 <code>HasIntegralSize</code> 概念，要求类型有一个 <code>size()</code> 成员函数，并且 <code>size()</code> 的返回值必须是一个整数类型 (<code>std::integral</code>)。</p>
</li>
<li><p><strong>实现 <code>MyInt</code> 类型：</strong> 尝试动手创建一个简单的 <code>MyInt</code> 类，让它包装一个 <code>int</code> 值，并实现 <code>toString()</code> 方法。然后用你的 <code>MyInt</code> 类型来成功调用 <code>processData</code> 函数。</p>
</li>
<li><p><strong>不同的概念语法：</strong> C++20 提供了几种不同的语法来应用概念约束，除了我们使用的 <code>requires</code> 子句，还有：</p>
<ul>
<li><strong>拖尾 <code>requires</code> 子句 (Trailing requires clause):</strong> <code>template &lt;typename T&gt; T func(T p) requires Concept&lt;T&gt; { ... }</code></li>
<li><strong>约束模板参数 (Constrained template parameter):</strong> <code>template &lt;MyConcept T&gt; T func(T p) { ... }</code> 或者 <code>template &lt;std::integral T&gt; T func(T p) { ... }</code> (直接用概念名代替 <code>typename</code> 或 <code>class</code>)</li>
<li>研究一下这些不同语法的优缺点和适用场景。</li>
</ul>
</li>
</ol>
<p>继续努力，C++ 的世界还有很多有趣的东西等待你去发现！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Function/">Function    </a><a class="post-meta__tags" href="/tags/Language/">Language    </a><a class="post-meta__tags" href="/tags/Concept/">Concept    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/259%20-%20Auto%20Function%20Templates/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>259 - Auto Function Templates</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/267%20-%20requires%20clause/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>267 - requires clause</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/265 - using concept/" title="265 - using concept"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">265 - using concept</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/341 - Linkage Cpp/" title="341 - Linkage Cpp"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">341 - Linkage Cpp</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/return type for lambda function template/" title="return type for lambda function template"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">return type for lambda function template</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/258 - Non type template parameters/" title="258 - Non type template parameters"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">258 - Non type template parameters</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/262 - constexpr if/" title="262 - constexpr if"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">262 - constexpr if</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/259 - Auto Function Templates/" title="259 - Auto Function Templates"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">259 - Auto Function Templates</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>