<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>324 - Nested class | Bear's dream</title><meta name="description" content="324 - Nested class"><meta name="keywords" content="Cpp,Coding,Development,Language,Class"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="324 - Nested class"><meta name="twitter:description" content="324 - Nested class"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="324 - Nested class"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/324%20-%20Nested%20class/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="324 - Nested class"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/324%20-%20Nested%20class/"><link rel="prev" title="322 - Different Type Members" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/322%20-%20Different%20Type%20Members/"><link rel="next" title="323 - cpp静态成员函数" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/323%20-%20cpp%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Cpp-Nest"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Cpp Nest</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-嵌套类-Nested-classes-深度解析与实践"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">C++ 嵌套类 [Nested classes] 深度解析与实践</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-什么是嵌套类-Nested-classes-？"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">1. 什么是嵌套类 [Nested classes]？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-嵌套类的关键特性与访问规则"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">2. 嵌套类的关键特性与访问规则</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-1-内部类-Inner-class-的私有-Private-性"><span class="toc_mobile_items-number">1.3.2.1.</span> <span class="toc_mobile_items-text">2.1 内部类 [Inner class] 的私有 [Private] 性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-2-外部类-Outer-class-对内部类-Inner-class-的访问"><span class="toc_mobile_items-number">1.3.2.2.</span> <span class="toc_mobile_items-text">2.2 外部类 [Outer class] 对内部类 [Inner class] 的访问</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-3-内部类-Inner-class-对外部类-Outer-class-的访问"><span class="toc_mobile_items-number">1.3.2.3.</span> <span class="toc_mobile_items-text">2.3 内部类 [Inner class] 对外部类 [Outer class] 的访问</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-4-定义内部类-Inner-class-成员函数-Member-functions"><span class="toc_mobile_items-number">1.3.2.4.</span> <span class="toc_mobile_items-text">2.4 定义内部类 [Inner class] 成员函数 [Member functions]</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-问答卡片-QA-Flash-Cards"><span class="toc_mobile_items-number">1.3.4.</span> <span class="toc_mobile_items-text">4. 问答卡片 [QA Flash Cards]</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-常见误解与错误-Common-Misunderstanding-or-Mistakes"><span class="toc_mobile_items-number">1.3.5.</span> <span class="toc_mobile_items-text">5. 常见误解与错误 [Common Misunderstanding or Mistakes]</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-编程练习-Coding-Exercise"><span class="toc_mobile_items-number">1.3.6.</span> <span class="toc_mobile_items-text">6. 编程练习 [Coding Exercise]</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Cpp-Nest"><span class="toc-number">1.</span> <span class="toc-text">Cpp Nest</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-嵌套类-Nested-classes-深度解析与实践"><span class="toc-number">1.3.</span> <span class="toc-text">C++ 嵌套类 [Nested classes] 深度解析与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-什么是嵌套类-Nested-classes-？"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 什么是嵌套类 [Nested classes]？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-嵌套类的关键特性与访问规则"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 嵌套类的关键特性与访问规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-内部类-Inner-class-的私有-Private-性"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">2.1 内部类 [Inner class] 的私有 [Private] 性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-外部类-Outer-class-对内部类-Inner-class-的访问"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2.2 外部类 [Outer class] 对内部类 [Inner class] 的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-内部类-Inner-class-对外部类-Outer-class-的访问"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">2.3 内部类 [Inner class] 对外部类 [Outer class] 的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-定义内部类-Inner-class-成员函数-Member-functions"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">2.4 定义内部类 [Inner class] 成员函数 [Member functions]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-代码示例"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-问答卡片-QA-Flash-Cards"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 问答卡片 [QA Flash Cards]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-常见误解与错误-Common-Misunderstanding-or-Mistakes"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. 常见误解与错误 [Common Misunderstanding or Mistakes]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-编程练习-Coding-Exercise"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 编程练习 [Coding Exercise]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">1.4.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">1.5.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">324 - Nested class</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/324%20-%20Nested%20class/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/324%20-%20Nested%20class/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Cpp-Nest"><a href="#Cpp-Nest" class="headerlink" title="Cpp Nest"></a>Cpp Nest</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about nested classes, and this is a feature we have in C plusplus to allow us to declare classes inside other classes.If you look here, we have a class called Outer and it is our outer class.But if you look inside the private section here, you see that we have another class declaration andthe class is called inner.So we can set up things like this if it makes sense for our application.And this is really useful if you want to limit how people can create inner objects and you want themto only be able to do that inside another object.So this is going to become useful.But I personally think this design is really weird and confusing.People are going to have a hard time to really put together the relationship between your classes.But please note that this is my own personal preference if it makes sense for the problem you are tryingto solve with C plus plus.Okay, so this is really all about nesting.But before we head over to Visual Studio code and play with us, let’s see some facts about this one.The inner class is private.It’s objects can’t be created from the outside, like in Main.If you do that, you’re going to get a compiler error because you are trying to access something privateto the object.So if you do this, you’re going to get a compiler error.The outer class doesn’t have access to private members of the inner class.So this is a setup we have and you’re going to have this If you set up inner classes inside outsideclasses, the inner class is going to have access to private sections of the outer class so you canaccess the private member variables and inner can directly access static members of outer, but it can’taccess member variables without going through an object name.And these are some limitations you need to be aware of.I realized some of these things might not make sense yet, so we’re going to head over to Visual Studiocode and play with this a little more.Okay.Here we are in our working folder.The current project is nested classes.We are going to bring in our template file.So let’s do that and we’re going to put them in place.And let’s open this by dragging and dropping on top of Visual Studio code here.This is going to open our project.We’re going to create two files for the class that we want to create.We’re going to create the outer dot h file and the outer dot CPP file to hold our outer class.So let’s do that.We’re going to say outer dot H, this is the header and we’re going to say outer dot CPP.This is going to be our implementation file.I am going to put in my header file information.And what we have is really simple.We have the outer class, we have a public section, we have a private section.Inside the private section, we have a few member variables.We also have a static member variables.And if you go down, you’re going to see that we have our inner class inside.And this is nothing complicated really.It is a simple class.After the declaration of the class, we have to put a semicolon.This is the syntax that Cplusplus expects.And inside our inner function we have to do something with outer function.And we’re going to learn about this little things in a minute when we have put in place the CPP file.Okay, so let’s do that.We’re going to go to the CPP file and put in the implementation for our class.It is nothing complicated really.We just have the implementations for our two constructors that we have in our outer class.We have an on prem constructor and we have a constructor that takes two parameters and we’re going touse these two parameter constructor to do the work for the No parameter constructor here we are goingto delegate.Other than this, this is really simple.We are also going to implement the constructor for inner and you see that we have to use the syntaxlike this to say that the inner constructor is living inside the outer class.So you have to do things like this.If you take out this scope resolution operator, you’re going to get a compiler error because the compileris going to look for this in the header and it’s not going to know where to look because it doesn’tknow where this inner constructor lives.The way to tell the compiler that is to go through the scope resolution operator like this.So this is the first thing you need to know.If we go in our header file, we’re going to see that inner has only one constructor that takes oneparameter and that’s what we are using here.We are using initializer lists to do this.Okay, so let’s look at this a little more.Okay.So now that we have this set up here, let’s try to do some things with our inner class.The first thing you might want to do is to create an object of this class.Let’s do that.We’re going to head over to Main.cpp and we’re going to include outer because that’s the header thatcontains.Our thanks.And we’re going to try and go inside and say inner, okay, inner one, let’s say that and we’re goingto pass a parameter maybe 5.6.I think that’s what this guy takes.Let’s check this.Let’s see what we take.Yes, we take a double parameter.And if we try to do this, this is not going to work because the compiler is going to look to the outsidein here and it’s not going to see any inner class.We don’t have any class called inner declared in the outside scope in the outer dot h file here.So it’s not going to find it and we’re going to get a compiler error.It’s going to say, I don’t know what inner is, let’s do that.We’re going to pass this through GCC.You’re going to see for yourself and it’s going to say inner was not declared in this scope.We don’t know what inner is.So you might think, huh, inner is declared inside another class.What if I use a scope resolution?Operator, let’s do that.We’re going to say outer and we’re going to put a scope resolution operator And the error is going tochange, but you’re going to see that it’s going to know what inner is.It’s going to give us a different compiler error.Let’s build and show you that.And it’s going to say outer inner is private within this context because inner lives in the privatesection of outer, you can see that here we can’t access it from the outside.And that includes trying to create objects from this because this is going to call the constructor ofinner, but the inner constructor is leaving and the private section of outer, so we can’t really accessit.And if we do this, we’re going to get this compiler error that we are seeing here.You might want to try and come here and make this little guy public.If you do this, this is going to work.So let’s do that.We’re going to build again and use the GCC to do that.Now, this is working because if you issue a call like this, it’s going to search for the constructorfor inner.It’s going to go in this header file, it’s going to search and it’s going to find, Aha, I have aconstructor here and I can call it from the main function because it is public and everything is goingto work.Let’s see if we have a member function on inner that we can call, let’s say get double and this isgoing to print the static int and we’re going to see that printed out on the console.So let’s do that.We’re going to say get double and we can say inner one, get double and we’re going to build and seeif we can print and see something on the console.Okay, the build is good.We can clear and run Rooster and if we do this, we have our variable, which is 45.If we go in outer, we’re going to see that this little guy is 45 and we are accessing that from ourmember function of the inner class.And this is really cool.Okay, so now you note that if you set up your inner class to be in a private section, you want tobe able to use that from the outside by creating objects like we do in here.So you should note that another thing I want to bring to your attention is that the outer class heredoesn’t have access to private members of the inner class.Let’s go and see what we can have here.We have Innovare and inside the do something method of outer Here we have an inner object.We can do that because this is a member function of outer, so it can use the private members of inner.This is not going to give us a problem.But if we try to access a private member from the outer class, we’re going to get a compiler errorand outer doesn’t have access to private parts of the inner.We have to go through setters and getters to do that if you want to access these guys.So this is the message here.Let’s try and build and we’re going to see a compiler error.So we’re going to see inner Var is private within this context.We can’t really access that here.If you do that, you’re going to get a compiler error, but you can go through a getter function tohave access to whatever you want.So for example, if we go in inner and set up a member function, we can return the member variablefrom that member function and have access to that inside our dosomething function here.So for example, we can go down here and say get double and try to print that out.Why not?And we can see the member function called here on top get double.This is how you can use this.So if we call, do something on our outer object that we create, we’re going to see this message here.So let’s try this out.Let’s build and show you that this is working first and we have a problem.Class, outer inner is private in this context.We can’t create objects of outer.So this is the problem we have in main.We can take this out and build again.And before we build, we’re going to create an object of outer.So we’re going to say outer one and we’re going to give it whatever it wants.Let’s see what the constructor of outer is taking.We’re going to pass in an INT and the double.Let’s do that.We’re.Going to pass in a ten and a 20.1.Why not?And we can do something with our we can say outer one, do something.And if we build this should world just fine, we’re going to use GCC for that.You’re going to see that the world is good.We can clear and run rooster and created an inner object with a value of ten.So let’s look at this.We’re going to see what we have in the constructor.We do something.We create an inner object, we put in a value, and then we’re going to print the member variable througha getter that we have here.This is the setup you can use to have access to member variables of your private nested class if youhappen to need that in your application.But instead, class is going to have access to private members of the global class and this is goingto work if you go through the object names.So let’s go down here and really show you that we have a function called Do something with Outer andwe pass a pointer to outer and then we’re going to go through this pointer to access the member variablesof outer.And we are doing this from the inside of the inner object.And this is going to work.So to be able to try this out, we’re going to go in a method that we have in outer which is going tocreate our object and we’re going to call the do something with outer method and we’re going to passthe this object because that’s going to be the outer object we will be working on.So we’re going to do that.And let’s comment out all this we had on top here because it’s going to be confusing if we have thisand we’re going to see what we see in this call here.So let’s build and see that this world’s the world is good.And if we run this, let’s do that.We’re going to run this.And you see, this is inner access.Private parts of outer MVR is one.And we’re going to see that printed out here.I realize this is really convoluted, but you need to know this.If you’re going to use nested classes in your design.So we are really accessing a private member of the outer class, which is mvar here inside an innerclass object.And this is going to work.Another thing you should know is that from your nested class you have access to static members of theenclosing class without going through the object name.And we are accessing this static member function here without really going through an object name.And you’re going to see that this is going to work.If we’re trying to compile this, this is going to work just fine.Let’s use GCC and show you that and you see that the world is good.So this is really all I have to share in terms of nesting the classes inside other classes.Again, these are a few things you need to remember.When inner is private, you can’t create objects of inner from the outside.If you do that, you’re going to get a compiler error.Outer doesn’t have access to private sections of nested classes.If you’re trying to access that, you’re going to get a compiler error.But inner has access to the private section of the enclosing class and the inner can also directly accessstatic members of the outer class, but it can’t access regular member variables which are not staticwithout going through object names.And this is really all you need to know.If you keep these things in your mind, you’re going to be able to use nested classes fairly easilyin your career as a C plus plus developer.We are going to stop here in this lecture and the next one we’re going to try and zoom in on in classmember initialization.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>你好！很高兴能帮助你学习 C++ 中一个非常有趣的特性——<strong>嵌套类</strong>。作为你的C++专业开发导师和全球最好的老师，我将用最清晰、最易懂的方式，带你一步步掌握这个知识点。</p>
<hr>
<h2 id="C-嵌套类-Nested-classes-深度解析与实践"><a href="#C-嵌套类-Nested-classes-深度解析与实践" class="headerlink" title="C++ 嵌套类 [Nested classes] 深度解析与实践"></a><strong>C++ 嵌套类 [Nested classes] 深度解析与实践</strong></h2><p><strong>内容概要:</strong><br>本课程将详细讲解 C++ 中的嵌套类 [Nested classes]：即在一个类 [Class] 的内部定义另一个类。我们将探讨它的用途、访问规则、如何定义其成员，并通过详细的代码示例、问答卡片和常见误区分析，确保你彻底理解并能熟练运用这一概念。</p>
<hr>
<h3 id="1-什么是嵌套类-Nested-classes-？"><a href="#1-什么是嵌套类-Nested-classes-？" class="headerlink" title="1. 什么是嵌套类 [Nested classes]？"></a><strong>1. 什么是嵌套类 [Nested classes]？</strong></h3><p>想象一下，你有一个大盒子 (外部类 [Outer class])，然后在这个大盒子里面，你又放了一个小盒子 (内部类 [Inner class])。这就是 C++ <strong>嵌套类</strong>的本质：一个类 [Class] 在另一个类的内部被声明。</p>
<p><strong>定义:</strong><br>一个<strong>嵌套类</strong> [Nested classes] 是指在另一个类（我们称之为<strong>外部类</strong> [Outer class]）的声明范围内定义的类。它通常被声明在外部类的 <code>public</code>（公有 [Public]）、<code>protected</code> 或 <code>private</code>（私有 [Private]）部分。</p>
<p><strong>为何使用嵌套类？</strong><br>虽然在某些场景下，嵌套类的设计可能看起来有点“怪异”或复杂，但它有其独特的应用场景：</p>
<ul>
<li><strong>逻辑组织与封装:</strong> 当一个类的存在与另一个类紧密相关，且逻辑上是后者的一个组成部分时，将其声明为嵌套类可以更好地体现这种从属关系，并增强封装性。例如，一个 <code>LinkedList</code> 类内部可能会有一个 <code>Node</code>（节点）类，<code>Node</code> 只有在 <code>LinkedList</code> 内部才有意义。</li>
<li><strong>限制对象创建:</strong> 这是嵌套类的一个重要用途。你可以将<strong>内部类</strong> [Inner class] 声明为<strong>私有</strong> [Private]，从而限制只有<strong>外部类</strong> [Outer class] 才能创建它的对象，外部代码无法直接访问和创建内部类的实例。这为程序设计提供了一种强大的控制机制。</li>
</ul>
<p><strong>设计考量:</strong><br>课程中提到，这种设计可能“奇怪且令人困惑”，这确实是许多开发者的个人看法。它的主要缺点可能是增加了代码的复杂度和可读性，尤其是在层级较深或滥用时。因此，在使用嵌套类时，务必权衡其带来的组织优势和可能引入的复杂性，确保它能真正解决你的问题，而不是为了用而用。</p>
<h3 id="2-嵌套类的关键特性与访问规则"><a href="#2-嵌套类的关键特性与访问规则" class="headerlink" title="2. 嵌套类的关键特性与访问规则"></a><strong>2. 嵌套类的关键特性与访问规则</strong></h3><p>理解嵌套类最重要的部分是它与外部类之间的访问权限。这有点像“家庭关系”：</p>
<h4 id="2-1-内部类-Inner-class-的私有-Private-性"><a href="#2-1-内部类-Inner-class-的私有-Private-性" class="headerlink" title="2.1 内部类 [Inner class] 的私有 [Private] 性"></a><strong>2.1 内部类 [Inner class] 的私有 [Private] 性</strong></h4><ul>
<li><p><strong>核心规则：</strong> 如果<strong>内部类</strong> [Inner class] 被声明在<strong>外部类</strong> [Outer class] 的<strong>私有</strong> [Private] 部分，那么在外部类的外部（比如 <code>main</code> 函数中），你将无法直接创建该<strong>内部类</strong> [Inner class] 的对象。尝试这样做会导致<strong>编译错误</strong> [Compiler error]。</p>
</li>
<li><p><strong>示例代码（尝试创建私有内部类对象 -&gt; 编译错误）：</strong><br>假设 <code>Outer::Inner</code> 在 <code>Outer</code> 类的 <code>private:</code> 部分声明。</p>
<p><strong><code>Outer.h</code> 文件:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OUTER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTER_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Outer(<span class="keyword">int</span> val1, <span class="keyword">double</span> val2);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>; <span class="comment">// 外部类的一个方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var1;</span><br><span class="line">    <span class="keyword">double</span> m_var2;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_outer_static_var; <span class="comment">// 外部类的静态成员变量 [Static member variables]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类 [Inner class] 声明在 private 部分</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Inner(<span class="keyword">double</span> val);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getDouble</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doSomethingWithOuter</span><span class="params">(Outer* outer_obj)</span></span>; <span class="comment">// 访问外部类的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">accessOuterStatic</span><span class="params">()</span></span>; <span class="comment">// 访问外部类的静态成员</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> m_inner_val;</span><br><span class="line">        <span class="comment">// int m_inner_private_var; // 内部类的私有成员，用于后续示例</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Inner m_inner_obj; <span class="comment">// 外部类内部可以创建内部类对象</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// OUTER_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>Outer.cpp</code> 文件:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Outer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化外部类的静态成员变量 [Static member variables]</span></span><br><span class="line"><span class="keyword">int</span> Outer::s_outer_static_var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部类构造函数 [Constructor]</span></span><br><span class="line">Outer::Outer(<span class="keyword">int</span> val1, <span class="keyword">double</span> val2) : m_var1(val1), m_var2(val2), m_inner_obj(val2) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Outer对象已创建，m_var1: "</span> &lt;&lt; m_var1 &lt;&lt; <span class="string">", m_var2: "</span> &lt;&lt; m_var2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类构造函数 [Constructor] 的定义需要使用作用域解析运算符 [Scope Resolution Operator]</span></span><br><span class="line"><span class="comment">// 语法: 外部类名::内部类名::成员名</span></span><br><span class="line">Outer::Inner::Inner(<span class="keyword">double</span> val) : m_inner_val(val) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inner对象已创建，值为: "</span> &lt;&lt; m_inner_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Outer::Inner::getDouble() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inner的成员变量 m_inner_val: "</span> &lt;&lt; m_inner_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Outer::doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Outer::doSomething() 被调用."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 外部类可以访问内部类的公有方法</span></span><br><span class="line">    m_inner_obj.getDouble();</span><br><span class="line">    <span class="comment">// 尝试访问内部类的私有成员 (假设 Inner 有一个 private int m_inner_private_var;)</span></span><br><span class="line">    <span class="comment">// m_inner_obj.m_inner_private_var = 10; // 错误：外部类不能直接访问内部类的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类访问外部类私有成员的示例</span></span><br><span class="line"><span class="keyword">void</span> Outer::Inner::doSomethingWithOuter(Outer* outer_obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (outer_obj) &#123;</span><br><span class="line">        <span class="comment">// 内部类可以访问外部类对象的私有成员变量 [Member variables] (通过外部类对象指针/引用)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inner访问Outer的m_var1: "</span> &lt;&lt; outer_obj-&gt;m_var1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inner访问Outer的m_var2: "</span> &lt;&lt; outer_obj-&gt;m_var2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部类访问外部类静态成员的示例</span></span><br><span class="line"><span class="keyword">void</span> Outer::Inner::accessOuterStatic() &#123;</span><br><span class="line">    <span class="comment">// 内部类可以直接访问外部类的静态 [Static] 成员，无需通过对象实例</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inner访问Outer的静态变量 s_outer_static_var: "</span> &lt;&lt; s_outer_static_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code> 文件（导致编译错误的部分）：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Outer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试直接创建私有内部类 [Inner class] 的对象</span></span><br><span class="line">    <span class="comment">// Outer::Inner inner_obj_main(99.9); // 编译错误！因为 Outer::Inner 是私有的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"程序继续执行..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>编译输出（类似）：</strong><br><code>error: ‘class Outer::Inner’ is private within this context</code></p>
</li>
<li><p><strong>如何变为可访问（改为公有 [Public]）：</strong><br>如果你希望在外部能够创建<strong>内部类</strong> [Inner class] 的对象，你需要将它声明在<strong>外部类</strong> [Outer class] 的 <code>public:</code>（公有 [Public]）或 <code>protected:</code> 部分。</p>
</li>
<li><p><strong>示例代码（改为公有后可创建对象）：</strong><br>修改 <code>Outer.h</code>，将 <code>class Inner</code> 移动到 <code>public:</code> 部分。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Outer.h (部分修改)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OUTER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTER_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Outer(<span class="keyword">int</span> val1, <span class="keyword">double</span> val2);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类 [Inner class] 声明在 public 部分</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> &#123;</span> <span class="comment">// 现在是公有 [Public] 的了</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Inner(<span class="keyword">double</span> val);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getDouble</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doSomethingWithOuter</span><span class="params">(Outer* outer_obj)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">accessOuterStatic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> m_inner_val;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var1;</span><br><span class="line">    <span class="keyword">double</span> m_var2;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_outer_static_var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类内部依然可以创建内部类对象</span></span><br><span class="line">    Inner m_inner_obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// OUTER_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code> 文件（现在可以成功编译和运行）：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Outer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 现在可以成功创建公有 [Public] 内部类 [Inner class] 的对象</span></span><br><span class="line">    <span class="comment">// 注意：即使 Inner 是公有的，你仍然需要使用 外部类名::内部类名 的形式来引用它。</span></span><br><span class="line">    <span class="function">Outer::Inner <span class="title">inner_obj_main</span><span class="params">(<span class="number">5.6</span>)</span></span>;</span><br><span class="line">    inner_obj_main.getDouble(); <span class="comment">// 调用其公有方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Outer <span class="title">outer_instance</span><span class="params">(<span class="number">10</span>, <span class="number">20.1</span>)</span></span>;</span><br><span class="line">    outer_instance.doSomething();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过外部类对象，调用内部类方法访问外部类成员</span></span><br><span class="line">    <span class="comment">// 注意：这里 inner_obj_main 并没有关联到 outer_instance，</span></span><br><span class="line">    <span class="comment">// 所以我们不能用 inner_obj_main.doSomethingWithOuter(&amp;outer_instance);</span></span><br><span class="line">    <span class="comment">// 因为 main 函数中创建的 inner_obj_main 是独立的。</span></span><br><span class="line">    <span class="comment">// 如果想演示，可以通过 outer_instance.m_inner_obj.doSomethingWithOuter(&amp;outer_instance);</span></span><br><span class="line">    <span class="comment">// 但 m_inner_obj 是私有的，所以我们只能通过 Outer 的公有方法来调用。</span></span><br><span class="line">    <span class="comment">// 例如，在 Outer::doSomething() 中调用 m_inner_obj.doSomethingWithOuter(this);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 演示内部类访问外部类 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outer_instance.doSomething(); <span class="comment">// doSomething 内部会创建并操作 inner 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>Outer.cpp</code> 中 <code>Outer::doSomething</code> 的修改以展示内部类访问外部类：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... (Outer.cpp 部分)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Outer::doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Outer::doSomething() 被调用."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    m_inner_obj.getDouble();</span><br><span class="line">    <span class="comment">// 在这里调用内部类的方法，并传入当前外部类对象（this指针）</span></span><br><span class="line">    m_inner_obj.doSomethingWithOuter(<span class="keyword">this</span>); <span class="comment">// 内部类访问外部类的私有非静态成员</span></span><br><span class="line">    m_inner_obj.accessOuterStatic(); <span class="comment">// 内部类访问外部类的静态成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>
<p><strong>运行输出（类似）：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Inner对象已创建，值为: 5.6</span><br><span class="line">Inner的成员变量 m_inner_val: 5.6</span><br><span class="line">Outer对象已创建，m_var1: 10, m_var2: 20.1</span><br><span class="line">Outer::doSomething() 被调用.</span><br><span class="line">Inner的成员变量 m_inner_val: 20.1</span><br><span class="line">Inner访问Outer的m_var1: 10</span><br><span class="line">Inner访问Outer的m_var2: 20.1</span><br><span class="line">Inner访问Outer的静态变量 s_outer_static_var: 100</span><br><span class="line">--- 演示内部类访问外部类 ---</span><br><span class="line">Outer::doSomething() 被调用.</span><br><span class="line">Inner的成员变量 m_inner_val: 20.1</span><br><span class="line">Inner访问Outer的m_var1: 10</span><br><span class="line">Inner访问Outer的m_var2: 20.1</span><br><span class="line">Inner访问Outer的静态变量 s_outer_static_var: 100</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="2-2-外部类-Outer-class-对内部类-Inner-class-的访问"><a href="#2-2-外部类-Outer-class-对内部类-Inner-class-的访问" class="headerlink" title="2.2 外部类 [Outer class] 对内部类 [Inner class] 的访问"></a><strong>2.2 外部类 [Outer class] 对内部类 [Inner class] 的访问</strong></h4><ul>
<li><p><strong>核心规则：</strong> 外部类<strong>不</strong>能直接访问<strong>内部类</strong> [Inner class] 的<strong>私有</strong> [Private] 成员变量 [Member variables] 或成员函数 [Member functions]。这遵循了类封装的基本原则。如果需要访问，必须通过<strong>内部类</strong> [Inner class] 提供的<strong>公有</strong> [Public] 接口（如 getter/setter 方法）。</p>
</li>
<li><p><strong>示例代码（外部类尝试访问内部类私有成员 -&gt; 编译错误）：</strong><br>在 <code>Outer.h</code> 的 <code>class Inner</code> 中，假设我们有一个 <code>private double m_inner_val;</code>。<br>如果我们在 <code>Outer::doSomething()</code> 中尝试 <code>std::cout &lt;&lt; m_inner_obj.m_inner_val;</code> 就会导致编译错误。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Outer.h (假设 Inner 类的 private 部分有 m_inner_val)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> m_inner_val; <span class="comment">// 这是私有的</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Outer.cpp (在 Outer::doSomething() 中尝试非法访问)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Outer::doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Outer::doSomething() 被调用."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// m_inner_obj.m_inner_val = 100.0; // 编译错误！'m_inner_val' is private within this context</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "尝试访问内部类私有变量: " &lt;&lt; m_inner_obj.m_inner_val &lt;&lt; std::endl; // 编译错误</span></span><br><span class="line">    m_inner_obj.getDouble(); <span class="comment">// 正确：通过公有 [Public] 方法访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>通过 getter 访问：</strong><br>正确的方式是<strong>内部类</strong> [Inner class] 提供一个<strong>公有</strong> [Public] 的 getter 方法来获取其<strong>私有</strong> [Private] 成员的值。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Outer.h (在 Inner 类中添加公有 [Public] getter)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Inner(<span class="keyword">double</span> val);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getDouble</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getInnerValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_inner_val; &#125; <span class="comment">// 添加 getter 方法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> m_inner_val;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Outer.cpp (在 Outer::doSomething() 中通过 getter 访问)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Outer::doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Outer::doSomething() 被调用."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"通过getter访问Inner的m_inner_val: "</span> &lt;&lt; m_inner_obj.getInnerValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// OK</span></span><br><span class="line">    m_inner_obj.getDouble();</span><br><span class="line">    m_inner_obj.doSomethingWithOuter(<span class="keyword">this</span>);</span><br><span class="line">    m_inner_obj.accessOuterStatic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h4 id="2-3-内部类-Inner-class-对外部类-Outer-class-的访问"><a href="#2-3-内部类-Inner-class-对外部类-Outer-class-的访问" class="headerlink" title="2.3 内部类 [Inner class] 对外部类 [Outer class] 的访问"></a><strong>2.3 内部类 [Inner class] 对外部类 [Outer class] 的访问</strong></h4><ul>
<li><p><strong>核心规则：</strong> 这是嵌套类中一个非常重要的特性。<strong>内部类</strong> [Inner class] <strong>可以访问外部类</strong> [Outer class] <strong>的所有成员</strong>（包括<strong>私有</strong> [Private] 和<strong>保护</strong> <code>protected</code> 成员），无论外部类成员的访问权限如何。</p>
<ul>
<li><strong>访问非静态 [Static] 成员变量 [Member variables]：</strong> 必须通过<strong>外部类</strong> [Outer class] 的<strong>对象实例</strong>（指针或引用）来访问。这是因为非静态成员属于特定的对象实例，内部类对象本身没有这个实例。</li>
<li><strong>访问静态 [Static] 成员变量 [Member variables]：</strong> 可以<strong>直接访问</strong>，无需通过外部类对象实例。因为<strong>静态</strong> [Static] 成员属于类本身，而非特定对象。</li>
</ul>
</li>
<li><p><strong>示例代码（内部类访问外部类私有非静态成员 -&gt; 需要外部类对象）：</strong><br>在 <code>Outer::Inner::doSomethingWithOuter(Outer* outer_obj)</code> 方法中演示。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Outer.cpp (部分)</span></span><br><span class="line"><span class="comment">// 内部类访问外部类私有成员的示例</span></span><br><span class="line"><span class="keyword">void</span> Outer::Inner::doSomethingWithOuter(Outer* outer_obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (outer_obj) &#123;</span><br><span class="line">        <span class="comment">// 内部类可以访问外部类对象的私有成员变量 [Member variables] (通过外部类对象指针/引用)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inner访问Outer的m_var1: "</span> &lt;&lt; outer_obj-&gt;m_var1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// m_var1 是 Outer 的私有成员</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inner访问Outer的m_var2: "</span> &lt;&lt; outer_obj-&gt;m_var2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// m_var2 是 Outer 的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到，<code>m_var1</code> 和 <code>m_var2</code> 尽管是 <code>Outer</code> 的<strong>私有</strong> [Private] 成员，但 <code>Inner</code> 类的方法可以通过 <code>outer_obj</code> 指针轻松访问它们。</p>
</li>
<li><p><strong>示例代码（内部类访问外部类静态成员 -&gt; 直接访问）：</strong><br>在 <code>Outer::Inner::accessOuterStatic()</code> 方法中演示。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Outer.cpp (部分)</span></span><br><span class="line"><span class="comment">// 内部类访问外部类静态成员的示例</span></span><br><span class="line"><span class="keyword">void</span> Outer::Inner::accessOuterStatic() &#123;</span><br><span class="line">    <span class="comment">// 内部类可以直接访问外部类 [Outer class] 的静态 [Static] 成员，无需通过对象实例</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inner访问Outer的静态变量 s_outer_static_var: "</span> &lt;&lt; s_outer_static_var &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// s_outer_static_var 是 Outer 的静态私有成员，但 Inner 可以直接访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里 <code>s_outer_static_var</code> 是 <code>Outer</code> 的<strong>静态私有</strong> [Static private] 成员，<code>Inner</code> 类可以直接使用其名称访问，不需要 <code>Outer::s_outer_static_var</code> 这样的前缀，也不需要 <code>outer_obj-&gt;s_outer_static_var</code>。</p>
</li>
</ul>
<h4 id="2-4-定义内部类-Inner-class-成员函数-Member-functions"><a href="#2-4-定义内部类-Inner-class-成员函数-Member-functions" class="headerlink" title="2.4 定义内部类 [Inner class] 成员函数 [Member functions]"></a><strong>2.4 定义内部类 [Inner class] 成员函数 [Member functions]</strong></h4><ul>
<li><p><strong>核心规则：</strong> 当你在<strong>外部类</strong> [Outer class] 定义之外（通常在 <code>.cpp</code> 实现文件）定义<strong>内部类</strong> [Inner class] 的成员函数 [Member functions] 时，你需要使用<strong>作用域解析运算符</strong> [Scope Resolution Operator] <code>::</code> 来明确指定其所属的类层级。<br>语法格式为：<code>外部类名::内部类名::成员函数名</code></p>
</li>
<li><p><strong>示例代码（定义内部类构造函数 [Constructor]）：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Outer.cpp (部分)</span></span><br><span class="line"><span class="comment">// 内部类构造函数 [Constructor] 的定义需要使用作用域解析运算符 [Scope Resolution Operator]</span></span><br><span class="line"><span class="comment">// 语法: 外部类名::内部类名::成员名</span></span><br><span class="line">Outer::Inner::Inner(<span class="keyword">double</span> val) : m_inner_val(val) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inner对象已创建，值为: "</span> &lt;&lt; m_inner_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Outer::Inner::getDouble() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inner的成员变量 m_inner_val: "</span> &lt;&lt; m_inner_val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他 Inner 成员函数也以类似方式定义</span></span><br></pre></td></tr></table></figure></div>
<p>如果你尝试省略 <code>Outer::</code>，编译器将无法找到 <code>Inner</code> 类，从而导致<strong>编译错误</strong> [Compiler error]。</p>
</li>
</ul>
<h3 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a><strong>3. 代码示例</strong></h3><p>上面所有的讲解都包含了详细的代码示例，你可以将它们组合起来，形成一个完整的项目。</p>
<p><strong>文件结构：</strong></p>
<ul>
<li><code>Outer.h</code>：包含 <code>Outer</code> 类及其嵌套 <code>Inner</code> 类的声明。</li>
<li><code>Outer.cpp</code>：包含 <code>Outer</code> 和 <code>Inner</code> 类成员函数的实现。</li>
<li><code>main.cpp</code>：包含 <code>main</code> 函数，用于测试。</li>
</ul>
<p><strong>完整代码已在 2.1-2.3 节中提供。</strong></p>
<h3 id="4-问答卡片-QA-Flash-Cards"><a href="#4-问答卡片-QA-Flash-Cards" class="headerlink" title="4. 问答卡片 [QA Flash Cards]"></a><strong>4. 问答卡片 [QA Flash Cards]</strong></h3><p>以下是一些关键知识点的问答卡片，帮助你巩固记忆：</p>
<p><strong>Q1: 什么情况下，你无法在 <code>main</code> 函数中直接创建一个</strong>内部类<strong> [Inner class] 的对象？</strong><br><strong>A1:</strong> 当<strong>内部类</strong> [Inner class] 被声明在<strong>外部类</strong> [Outer class] 的 <code>private</code>（<strong>私有</strong> [Private]）部分时。</p>
<p><strong>Q2: </strong>外部类<strong> [Outer class] 可以直接访问</strong>内部类<strong> [Inner class] 的</strong>私有<strong> [Private] 成员变量 [Member variables] 吗？</strong><br><strong>A2:</strong> <strong>不可以</strong>。外部类必须通过内部类提供的<strong>公有</strong> [Public] 接口（如 getter/setter 方法）来访问其私有成员。</p>
<p><strong>Q3: </strong>内部类<strong> [Inner class] 可以访问</strong>外部类<strong> [Outer class] 的</strong>私有<strong> [Private] 成员变量 [Member variables] 吗？如果可以，需要什么条件？</strong><br><strong>A3:</strong> <strong>可以</strong>。<strong>内部类</strong> [Inner class] 可以访问<strong>外部类</strong> [Outer class] 的所有成员（包括<strong>私有</strong> [Private]）。但访问<strong>非静态</strong> [Static] 成员时，需要通过<strong>外部类</strong> [Outer class] 的<strong>对象实例</strong>（指针或引用）。</p>
<p><strong>Q4: </strong>内部类<strong> [Inner class] 如何访问</strong>外部类<strong> [Outer class] 的</strong>静态<strong> [Static] 成员变量 [Member variables]？</strong><br><strong>A4:</strong> <strong>内部类</strong> [Inner class] 可以<strong>直接访问</strong>外部类的<strong>静态</strong> [Static] 成员，无需通过外部类对象实例。</p>
<p><strong>Q5: 在 <code>.cpp</code> 文件中定义</strong>内部类<strong> [Inner class] 的</strong>构造函数<strong> [Constructor] 时，需要注意什么语法？</strong><br><strong>A5:</strong> 需要使用<strong>作用域解析运算符</strong> [Scope Resolution Operator] <code>::</code>，语法为 <code>外部类名::内部类名::构造函数名</code>。例如 <code>Outer::Inner::Inner(double val)</code>。</p>
<h3 id="5-常见误解与错误-Common-Misunderstanding-or-Mistakes"><a href="#5-常见误解与错误-Common-Misunderstanding-or-Mistakes" class="headerlink" title="5. 常见误解与错误 [Common Misunderstanding or Mistakes]"></a><strong>5. 常见误解与错误 [Common Misunderstanding or Mistakes]</strong></h3><ul>
<li><strong>误解1：</strong> 只要内部类是公有的，就可以直接 <code>Inner obj;</code><ul>
<li><strong>纠正：</strong> 即使<strong>内部类</strong> [Inner class] 是<strong>公有</strong> [Public] 的，你仍然需要使用<strong>外部类</strong> [Outer class] 的<strong>作用域</strong> [Scope] 来引用它，即 <code>Outer::Inner obj;</code>。编译器需要知道 <code>Inner</code> 是哪个 <code>Inner</code>。</li>
</ul>
</li>
<li><strong>误解2：</strong> 外部类和内部类之间共享所有成员，可以互相直接访问私有成员。<ul>
<li><strong>纠正：</strong> 这是一个<strong>单向</strong>的关系。<strong>内部类</strong> [Inner class] 可以访问<strong>外部类</strong> [Outer class] 的私有成员，但<strong>外部类</strong> [Outer class] <strong>不能</strong>直接访问<strong>内部类</strong> [Inner class] 的私有成员。</li>
</ul>
</li>
<li><strong>误解3：</strong> 内部类可以随意访问外部类的非静态成员，就像它自己的成员一样。<ul>
<li><strong>纠正：</strong> 访问<strong>外部类</strong> [Outer class] 的<strong>非静态</strong> [Static] 成员时，<strong>内部类</strong> [Inner class] 必须通过<strong>外部类</strong> [Outer class] 的<strong>对象实例</strong>来访问（例如通过传入 <code>this</code> 指针）。只有<strong>静态</strong> [Static] 成员可以直接访问。这是因为非静态成员是与特定对象绑定的。</li>
</ul>
</li>
<li><strong>误解4：</strong> 忘了在 <code>.cpp</code> 文件中为<strong>内部类</strong> [Inner class] 的成员函数 [Member functions] 添加外部类<strong>作用域</strong> [Scope]。<ul>
<li><strong>纠正：</strong> 定义<strong>内部类</strong> [Inner class] 成员函数时，务必使用 <code>Outer::Inner::</code> 这样的前缀，否则会导致<strong>编译错误</strong> [Compiler error]，因为编译器找不到对应的类。</li>
</ul>
</li>
</ul>
<h3 id="6-编程练习-Coding-Exercise"><a href="#6-编程练习-Coding-Exercise" class="headerlink" title="6. 编程练习 [Coding Exercise]"></a><strong>6. 编程练习 [Coding Exercise]</strong></h3><p>好的，现在轮到你来动手了！请完成下面的代码，实现一个简单的<strong>外部类</strong> [Outer class] 和<strong>内部类</strong> [Inner class]，并遵循以下要求：</p>
<ol>
<li>创建一个<strong>外部类</strong> <code>Car</code>。</li>
<li>在 <code>Car</code> 类的 <code>private</code>（<strong>私有</strong> [Private]）部分，声明一个<strong>内部类</strong> <code>Engine</code>。</li>
<li><code>Car</code> 类应该有一个<strong>私有</strong> [Private] <strong>成员变量</strong> [Member variables] <code>m_brand</code> (字符串类型，表示品牌)。</li>
<li><code>Engine</code> 类应该有一个<strong>私有</strong> [Private] <strong>成员变量</strong> [Member variables] <code>m_horsepower</code> (整型，表示马力)。</li>
<li><code>Engine</code> 类应该有一个<strong>公有</strong> [Public] <strong>构造函数</strong> [Constructor]，接收一个 <code>horsepower</code> 参数。</li>
<li><code>Engine</code> 类应该有一个<strong>公有</strong> [Public] 方法 <code>start()</code>，在这个方法中：<ul>
<li>打印 <code>Engine</code> 的 <code>m_horsepower</code>。</li>
<li>尝试访问其所属 <code>Car</code> 对象的 <code>m_brand</code>，并打印出来（你需要传入 <code>Car</code> 对象指针才能做到这一点）。</li>
</ul>
</li>
<li><code>Car</code> 类应该有一个<strong>公有</strong> [Public] <strong>构造函数</strong> [Constructor]，接收 <code>brand</code> 和 <code>horsepower</code> 参数，并在其中创建 <code>Engine</code> 类的对象。</li>
<li><code>Car</code> 类应该有一个<strong>公有</strong> [Public] 方法 <code>drive()</code>，在这个方法中，调用其内部 <code>Engine</code> 对象的 <code>start()</code> 方法，并传入 <code>Car</code> 对象的 <code>this</code> 指针。</li>
</ol>
<p><strong>请在下面的代码块中填写缺失的部分，使得代码能够成功编译并运行，输出预期的结果。</strong></p>
<p><strong><code>Car.h</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 用于字符串类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// TODO 1: 声明Car类的公有 [Public] 构造函数 [Constructor]，接收品牌和马力参数</span></span><br><span class="line">    Car(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; brand, <span class="keyword">int</span> horsepower);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TODO 2: 声明Car类的公有 [Public] 方法 drive()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_brand; <span class="comment">// Car的私有成员变量 [Member variables]</span></span><br><span class="line">    <span class="comment">// TODO 3: 在private部分声明内部类 [Inner class] Engine</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// TODO 4: 声明Engine类的公有 [Public] 构造函数 [Constructor]，接收马力参数</span></span><br><span class="line">        Engine(<span class="keyword">int</span> horsepower);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// TODO 5: 声明Engine类的公有 [Public] 方法 start()，接收一个Car类的指针</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(Car* car_obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> m_horsepower; <span class="comment">// Engine的私有成员变量 [Member variables]</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Engine m_engine; <span class="comment">// Car内部的Engine对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CAR_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>Car.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 6: 定义Car类的构造函数 [Constructor]</span></span><br><span class="line">Car::Car(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; brand, <span class="keyword">int</span> horsepower) </span><br><span class="line">    <span class="comment">// 初始化列表：初始化m_brand，并在构造函数中创建Engine对象</span></span><br><span class="line">    : m_brand(brand), m_engine(horsepower) &#123; <span class="comment">// 注意这里m_engine的初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car对象 '"</span> &lt;&lt; m_brand &lt;&lt; <span class="string">"' (马力: "</span> &lt;&lt; horsepower &lt;&lt; <span class="string">") 已创建."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 7: 定义Car类的drive()方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Car::drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car正在启动..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 调用内部Engine对象的start()方法，并传入当前的Car对象指针</span></span><br><span class="line">    m_engine.start(<span class="keyword">this</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 8: 定义Engine类的构造函数 [Constructor] (注意作用域解析运算符 [Scope Resolution Operator])</span></span><br><span class="line">Car::Engine::Engine(<span class="keyword">int</span> horsepower) : m_horsepower(horsepower) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Engine对象 (马力: "</span> &lt;&lt; m_horsepower &lt;&lt; <span class="string">") 已创建."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 9: 定义Engine类的start()方法 (注意作用域解析运算符 [Scope Resolution Operator])</span></span><br><span class="line"><span class="keyword">void</span> Car::Engine::start(Car* car_obj) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"引擎启动！马力: "</span> &lt;&lt; m_horsepower &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (car_obj) &#123;</span><br><span class="line">        <span class="comment">// 内部类 [Inner class] 访问外部类 [Outer class] 的私有成员变量 [Member variables]</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"这是 "</span> &lt;&lt; car_obj-&gt;m_brand &lt;&lt; <span class="string">" 的引擎."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 访问Car的m_brand</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 10: 在main函数中创建Car对象并调用drive()方法</span></span><br><span class="line">    <span class="function">Car <span class="title">myCar</span><span class="params">(<span class="string">"Tesla"</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line">    myCar.drive();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n程序结束."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<p>请填写上述代码中的 <code>TODO</code> 部分。当你完成并提供解决方案后，我会在下一轮回复中为你评分，给出正确答案和详细解释，并提供进一步的学习建议！</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>// 外部类构造函数 [Constructor]<br>Outer::Outer(int val1, double val2) : m_var1(val1), m_var2(val2), m_inner_obj(val2) {<br>    std::cout &lt;&lt; “Outer对象已创建，m_var1: “ &lt;&lt; m_var1 &lt;&lt; “, m_var2: “ &lt;&lt; m_var2 &lt;&lt; std::endl;<br>}<br>这里为啥m_inner_obj(val2) 直接可以work?而不是m_inner_obj(Inner(val2))</p>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常好的问题！它涉及到 C++ 中类成员初始化列表（[Member Initializer List]）的关键语法和对象构造的原理。</p>
<p>让我们来详细解释一下：</p>
<p>当你在 <code>Outer</code> 类的构造函数中使用 <code>m_inner_obj(val2)</code> 时，你正在使用 C++ 的<strong>成员初始化列表</strong> [Member Initializer List] 来初始化 <code>m_inner_obj</code> 这个成员变量。</p>
<ol>
<li><p><strong><code>m_inner_obj(val2)</code> 的含义 (直接初始化 [Direct Initialization])</strong><br>在成员初始化列表中，使用 <code>成员变量名(参数)</code> 这种语法，表示直接调用该成员变量所属类的<strong>构造函数</strong> [Constructor] 来初始化它。</p>
<ul>
<li>在这里，<code>m_inner_obj</code> 是 <code>Outer</code> 类的一个成员，它的类型是 <code>Inner</code>。</li>
<li><code>val2</code> 是 <code>Outer</code> 构造函数接收的一个 <code>double</code> 类型参数。</li>
<li>所以，<code>m_inner_obj(val2)</code> 告诉编译器：请使用 <code>val2</code> 作为参数，来调用 <code>m_inner_obj</code>（即 <code>Inner</code> 类型对象）的构造函数。</li>
<li>由于 <code>Inner</code> 类有一个构造函数 <code>Inner(double val)</code>，它正好接收一个 <code>double</code> 类型的参数，所以 <code>m_inner_obj(val2)</code> 能够直接匹配并调用 <code>Inner::Inner(double)</code> 这个构造函数，从而正确地构造 <code>m_inner_obj</code>。</li>
</ul>
<p>这种方式被称为<strong>直接初始化</strong> [Direct Initialization]，它在 <code>m_inner_obj</code> 被创建时就地构造，是最<strong>高效</strong>和<strong>推荐</strong>的成员初始化方式。</p>
</li>
<li><p><strong>为什么 <code>m_inner_obj(Inner(val2))</code> 也可以（但通常不推荐）？</strong></p>
<ul>
<li><code>Inner(val2)</code>：这部分代码会首先创建一个<strong>临时</strong>的 <code>Inner</code> 对象。这个临时对象会调用 <code>Inner::Inner(double)</code> 构造函数，并用 <code>val2</code> 进行初始化。</li>
<li><code>m_inner_obj(...)</code>：然后，<code>m_inner_obj</code> 会尝试通过<strong>拷贝构造</strong> [Copy Construction] 或<strong>移动构造</strong> [Move Construction] 的方式，用这个临时对象来初始化自己。这需要 <code>Inner</code> 类有可用的拷贝构造函数（<code>Inner(const Inner&amp;)</code>）或移动构造函数（<code>Inner(Inner&amp;&amp;)</code>）。</li>
<li>在现代 C++ (C++11 及更高版本) 中，编译器通常会执行一种叫做<strong>拷贝消除</strong> [Copy Elision] (或返回值优化 RVO) 的优化，这意味着它可能会避免实际的拷贝或移动操作，直接在 <code>m_inner_obj</code> 的内存位置构造对象，使其行为类似于 <code>m_inner_obj(val2)</code>。</li>
</ul>
<p><strong>但是，尽管它可能工作，这种写法通常不被推荐，原因如下：</strong></p>
<ul>
<li><strong>意图不明确：</strong> <code>m_inner_obj(val2)</code> 更清晰地表达了“使用 <code>val2</code> 参数直接构造 <code>m_inner_obj</code>”的意图。而 <code>m_inner_obj(Inner(val2))</code> 看起来像是先创建一个临时对象，再进行拷贝/移动。</li>
<li><strong>潜在效率问题：</strong> 尽管有拷贝消除 [Copy Elision] 优化，但并不能保证所有编译器在所有情况下都能执行这种优化。如果没有优化，它会引入额外的临时对象创建和拷贝/移动的开销。</li>
<li><strong>要求额外构造函数：</strong> 如果 <code>Inner</code> 没有定义拷贝或移动构造函数（或它们被明确删除），那么 <code>m_inner_obj(Inner(val2))</code> 就会导致编译错误。而 <code>m_inner_obj(val2)</code> 只需要 <code>Inner</code> 有一个接受 <code>double</code> 的构造函数即可。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p><code>m_inner_obj(val2)</code> 直接调用 <code>Inner</code> 类的构造函数来初始化 <code>m_inner_obj</code>，这是 C++ 中初始化类类型成员的<strong>标准、高效且推荐</strong>的方式。</p>
<p><code>m_inner_obj(Inner(val2))</code> 涉及到创建临时对象和随后的拷贝/移动构造，尽管编译器可能进行优化，但语义上不如直接初始化清晰和高效。</p>
<p>所以在你的例子中，<code>m_inner_obj(val2)</code> 可以直接工作，因为 <code>Inner</code> 类有 <code>Inner(double)</code> 这样的构造函数来处理 <code>val2</code> 这个 <code>double</code> 类型的值。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a><a class="post-meta__tags" href="/tags/Language/">Language    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/322%20-%20Different%20Type%20Members/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>322 - Different Type Members</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/323%20-%20cpp%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>323 - cpp静态成员函数</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/262 - constexpr if/" title="262 - constexpr if"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">262 - constexpr if</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/272 - first class/" title="272 - first class"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">272 - first class</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/273 - constructor/" title="273 - constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">273 - constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/275 - getter and setter/" title="275 - getter and setter"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">275 - getter and setter</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/277 - IDE 创建 cpp 类方法/" title="277 - IDE 创建 cpp 类方法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">277 - IDE 创建 cpp 类方法</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/283 - cpp 类对象大小探究/" title="283 - cpp 类对象大小探究"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">283 - cpp 类对象大小探究</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>