<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>323 - cpp静态成员函数 | Bear's dream</title><meta name="description" content="323 - cpp静态成员函数"><meta name="keywords" content="Coding,Cpp,Function,Software,Class"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="323 - cpp静态成员函数"><meta name="twitter:description" content="323 - cpp静态成员函数"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="323 - cpp静态成员函数"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/323%20-%20cpp%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="323 - cpp静态成员函数"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/323%20-%20cpp%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"><link rel="prev" title="325 - 类内成员初始化" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/325%20-%20%E7%B1%BB%E5%86%85%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96/"><link rel="next" title="328 - cpp命名空间" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/328%20-%20cpp%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-静态成员函数"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">C++静态成员函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-静态成员函数-Static-Member-Functions-：类级别的行为"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">C++静态成员函数 (Static Member Functions)：类级别的行为</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#详细讲解：C-静态成员函数"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">详细讲解：C++静态成员函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-什么是-static-成员函数？"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">1. 什么是 static 成员函数？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-如何声明-static-成员函数？"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">2. 如何声明 static 成员函数？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-static-成员函数的核心特性与限制"><span class="toc_mobile_items-number">2.1.3.</span> <span class="toc_mobile_items-text">3. static 成员函数的核心特性与限制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-如何访问非-static-成员变量（通过-static-成员函数）？"><span class="toc_mobile_items-number">2.1.4.</span> <span class="toc_mobile_items-text">4. 如何访问非 static 成员变量（通过 static 成员函数）？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-static-成员变量的初始化"><span class="toc_mobile_items-number">2.1.5.</span> <span class="toc_mobile_items-text">5. static 成员变量的初始化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-如何调用-static-成员函数？"><span class="toc_mobile_items-number">2.1.6.</span> <span class="toc_mobile_items-text">6. 如何调用 static 成员函数？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-总结何时使用-static-成员函数"><span class="toc_mobile_items-number">2.1.7.</span> <span class="toc_mobile_items-text">7. 总结何时使用 static 成员函数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#代码示例"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#QA-闪卡-QA-Flash-Cards"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#常见误解或错误"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">常见误解或错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#编程练习"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">编程练习</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-static-成员函数-vs-Python-staticmethod"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">C++ static 成员函数 vs. Python staticmethod</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-2"><span class="toc_mobile_items-number">2.9.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-2"><span class="toc_mobile_items-number">2.10.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Python-staticmethod-静态方法"><span class="toc_mobile_items-number">2.11.</span> <span class="toc_mobile_items-text">Python staticmethod (静态方法)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Python-classmethod-类方法"><span class="toc_mobile_items-number">2.12.</span> <span class="toc_mobile_items-text">Python classmethod (类方法)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#总结表格"><span class="toc_mobile_items-number">2.13.</span> <span class="toc_mobile_items-text">总结表格</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-3"><span class="toc_mobile_items-number">2.14.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-3"><span class="toc_mobile_items-number">2.15.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-你的解决方案评分与实际答案"><span class="toc_mobile_items-number">2.16.</span> <span class="toc_mobile_items-text">7. 你的解决方案评分与实际答案</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#实际答案与详细解释"><span class="toc_mobile_items-number">2.16.1.</span> <span class="toc_mobile_items-text">实际答案与详细解释</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-进一步学习的建议-Extended-Questions"><span class="toc_mobile_items-number">2.17.</span> <span class="toc_mobile_items-text">8. 进一步学习的建议 (Extended Questions)</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-静态成员函数"><span class="toc-number">1.</span> <span class="toc-text">C++静态成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-静态成员函数-Static-Member-Functions-：类级别的行为"><span class="toc-number">2.</span> <span class="toc-text">C++静态成员函数 (Static Member Functions)：类级别的行为</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#详细讲解：C-静态成员函数"><span class="toc-number">2.1.</span> <span class="toc-text">详细讲解：C++静态成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-什么是-static-成员函数？"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 什么是 static 成员函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-如何声明-static-成员函数？"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 如何声明 static 成员函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-static-成员函数的核心特性与限制"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. static 成员函数的核心特性与限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-如何访问非-static-成员变量（通过-static-成员函数）？"><span class="toc-number">2.1.4.</span> <span class="toc-text">4. 如何访问非 static 成员变量（通过 static 成员函数）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-static-成员变量的初始化"><span class="toc-number">2.1.5.</span> <span class="toc-text">5. static 成员变量的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-如何调用-static-成员函数？"><span class="toc-number">2.1.6.</span> <span class="toc-text">6. 如何调用 static 成员函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-总结何时使用-static-成员函数"><span class="toc-number">2.1.7.</span> <span class="toc-text">7. 总结何时使用 static 成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码示例"><span class="toc-number">2.2.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QA-闪卡-QA-Flash-Cards"><span class="toc-number">2.3.</span> <span class="toc-text">QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见误解或错误"><span class="toc-number">2.4.</span> <span class="toc-text">常见误解或错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编程练习"><span class="toc-number">2.5.</span> <span class="toc-text">编程练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">2.6.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">2.7.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-static-成员函数-vs-Python-staticmethod"><span class="toc-number">2.8.</span> <span class="toc-text">C++ static 成员函数 vs. Python staticmethod</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-2"><span class="toc-number">2.9.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-2"><span class="toc-number">2.10.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-staticmethod-静态方法"><span class="toc-number">2.11.</span> <span class="toc-text">Python staticmethod (静态方法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-classmethod-类方法"><span class="toc-number">2.12.</span> <span class="toc-text">Python classmethod (类方法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结表格"><span class="toc-number">2.13.</span> <span class="toc-text">总结表格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-3"><span class="toc-number">2.14.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-3"><span class="toc-number">2.15.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-你的解决方案评分与实际答案"><span class="toc-number">2.16.</span> <span class="toc-text">7. 你的解决方案评分与实际答案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实际答案与详细解释"><span class="toc-number">2.16.1.</span> <span class="toc-text">实际答案与详细解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-进一步学习的建议-Extended-Questions"><span class="toc-number">2.17.</span> <span class="toc-text">8. 进一步学习的建议 (Extended Questions)</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">323 - cpp静态成员函数</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/323%20-%20cpp%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/323%20-%20cpp%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="C-静态成员函数"><a href="#C-静态成员函数" class="headerlink" title="C++静态成员函数"></a>C++静态成员函数</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about static methods or static member functions.And these are functions that are attached to the class blueprint itself.Let’s look at an example here.We have a class called Point, and it has two sections.We have a public section, we have a private section.And in the public section now we have a static member function.And a function is marked static by putting the static keyword in front of the function declaration here.So the gate point count function or member function is a static method now and it doesn’t belong toany class object.It’s going to be affiliated with the class blueprint itself.And this is going to have one consequence which is really big static member functions don’t have accessto member variables of class objects because try to think about it.If the member function is attached or associated with the class blueprint and we can literally havethousands of class objects, which member variables should the member function access if it belongsto the blueprint?So the compiler solve this problem and the so the compiler is going to see this problem and it is goingto stop you to do any kind of access to the member variables from a static member function.But a static member function can have access to static member variables.So for example, if we look at our static member variable here, which is point count here, we canreturn it from a static member function and this is going to work without a problem.If you want to have access to member variables from a static member function, what you can do is passthe object as a parameter to the member function.Then inside the member function you will be able to use the dot notation to access member variables,but you will have to go through the object name like we are doing here.And this is really all you need to know.Another thing you can see here is that we are able to access private member variables of this objectand the reason is because we are inside a point object.If we’re trying to do this from the outside of the class, we’re going to get a compiler error.And I am going to show you an example in a minute.When we hit Visual Studio code, now that you know this, we’re going to play with this a little morein Visual Studio code.Okay, here we are in our working folder.The current project is Static member functions.We’re going to grab our template files like we always do.We’re going to put them in place and we are going to open this in Visual Studio code by dragging anddropping here.Okay, we have the folder here.Let’s open the main CPP file and we’re going to put in a point class that we’re going to use to playwith this things here.So let’s create a header file for that.We’re going to say point dot h and we’re going to create a CPP file point dot cpp.To do this, I am going to head over to the header file and put in my class for point.It is nothing you haven’t seen.Now we have a point class.It has two sections, a public one and a private one and we have our member variables and we have astatic member variable here.After this, we’re going to head in the CPP file and put in our implementation.And again, it is nothing you haven’t seen so far.And we can close the left sidebar here because we don’t need this anymore.Okay?Now we have a static member variable.We want to set up a static member function to the point class here.So the way we do that, we’re going to use the get point count function here.You mark it static by adding the static keyword in front of the function signature here.And at the moment we do this, you see that we have a problem.The const keyword can’t really be applied to a static member function and the reason is the static memberfunction doesn’t have access to the member variables.So what is the meaning of the const keyword here?Whose purpose is to protect you from changing the member variables of a class?So this doesn’t really make sense.We’re going to take this out and our static member function is going to be working.Now, if we head over in the main CPP file, we can take out what we don’t need here and we’re goingto include the point class.Let’s do that and we can go down here and call the static member function before even a point objectis created.We can print that out.For example, we can say point count and we’re going to say get point count.You see that we have access to this through the colon colon syntax here and we can print that out.Okay.So let’s try and world this with GCC.Let’s see what we get.And we have a compiler error undefined reference to point count.The problem is we didn’t initialize our.Point static member variable.So what we can do here is mark it in line.We can do that.And this is going to allow us to initialize this from the class declaration and this is going to work,I guess.So let’s do that.We’re going to build again.Okay.Now you see, the build is good.We can clear and run.Rooster, We should get a zero.Okay, Point count is zero.But if we go down in the main CPP file and say point P one for example, and print the point count again,this should go up to one because anytime we create an object, we’re going to increment the point countas we have seen before.Let’s show you this in case you have forgotten, we are incrementing m point count in our constructorhere and this is the constructor that is going to be doing the Incrementation here alone.No other constructor is going to do this because other constructors are going to delegate the work tothis constructor.That takes two parameters.Here you see, the one parameter constructor is going to delegate to that.The no parameter constructor is going to delegate to that and the copy constructor is not delegatingto that guy.It is initializing the x member variable alone.But we can delegate.So let’s do that.We’re going to say point and we’re going to say point m x and we’re going to say point m y.This is going to do this is going to initialize our little guy with the data coming from the sourcepoint.But we’re going to be delegating to the two parameter constructor on top here.So I am glad I had a chance to show you this.And let’s use we are using parentheses here, but if you want, you can use curly braces in the placeof this parentheses here.So now this thing is working.If we go to world, we’re going to see that the world is good.Now we should get a point count of one.And you see, the point count is one.Again, we are able to use this syntax because the get point count method is now static inside the pointclass.If we take out the static keyword here, we’re going to get a compiler error.If we try to do something like this, Visual Studio code should give us a few squiggly lines and yousee we have them and if we try to build, we’re going to be told we can’t call this member functionlike this.So what does the error say?Can call member function without an object?So if you are doing things like this, so if the member function is not static, you can’t really callit like we are doing here.If you want to call it, you need to go through an object name.And for example, we can go down to the second guy here and say P one get point count.This is going to work because the member function is public.Let’s world you really need to know all this little nuances about how member functions work in C plusplus.So we’re going to run roster.We’re going to see that the point count is one and this is working.But the syntax on top only works if the member function is static.Let’s go back and make it static again.We’re going to make that static and the next thing I want you to see is that static member functionsdon’t have access to the member variables of the class or the class object.I should be specific.Let’s set up a function and show you that we’re going to say void Printinfo and we’re not going to takeanything in and inside the body of this function.We’re going to print the information about the point.Nothing special here.And if we try to build, let’s do that.We’re going to use GCC.You’re going to see that we have an error.And what is the problem here?We are trying to go through an object.Let’s take out the P because we don’t have that here and we’re going to do this.You’re going to see that the build is going to be good.Okay.So the function is here and it is working.We can use it in the main CPP file.For example, we can say P one print inform and it is going to work.We can comment out everything else we have here.Let’s do that and we’re going to world.We should see information about P one printed out and it’s just going to have zeros n for x and Y becausewe use the default constructor to build this object here.If we run roster, we’re going to see that X is zero and Y is zero.Okay, so this is working.But the moment you mark this function as static, let’s try to do that.We’re going to get a compiler error and you see we have a few squiggly lines because we are not allowedto access member variables of objects from a static member function.And the reason is the member function is now attached to the class blueprint itself.It’s not attached to any class object and you wouldn’t really know whose objects member variable you’regoing to access through this member function here because this member function doesn’t belong to anyobject.So we’re going to get a compiler error here.Let’s build and show you the compiler error and see.What Jake is saying here.We’re going to have point me in static member function and this is not allowed.They are going to tell you this here and we’re going to also see invalid use of member in static memberfunction.So this is invalid.This is not allowed.If you do this, you’re going to get a compiler error.So what do you do?If you really want to print the information about a point object through a static member function?Well, you can pass your point object as a parameter to the function.For example, we can go in here and say const point P, let’s make this a reference because we don’twant copies and then we’re going to say p m X, this is going to work, and then we’re going to sayp m Y because we are going through an object name.This is going to work now.Now it is super clear whose member variables we are accessing and notice that this is working becausethe printer from function is part of the class point here.And notice this is working.We are able to access member variables of this object because we are inside the class point.If we try to do this from the outside, this is not going to work because we’re not allowed to accessprivate member variables of an object from the outside.But let’s try and build and show you that this is working now.We don’t have the problem we had before.And let’s see, in Main we are calling without a parameter.That’s why we have this compiler error.So we can pass P one here and this is going to work.Let’s build and we are going to build successfully.As you see here, we can clear this and run Rooster and we see that we have the information here.Point count is zero.Okay.So if we run Rooster now, we’re going to see that the point information is shown here and this is whatwe want.X is zero, Y is zero, and this is what we expect.Let’s try and change this to, let’s say, six and seven and really make sure this is working.So we’re going to build with GCC.The build is good.We can clear and run Rooster.We’re going to see that we have our member variables here and this is really cool.So now you should note that with a static member function, you don’t have access to the member variablesof the class.You can’t do that because the static member function is really not tied to any object.Another thing you can’t do, as we have seen before, is mark a static member function as const becausethe const keyword here is going to protect you from changing the member variables of the object.But remember, a static member function doesn’t have access to the member variables in the first place.So this is really confusing and weird and doesn’t make sense.So the compiler is going to stop you from doing this and if you do this, you’re going to get a compilererror.Let’s build again and show you this.Okay, we have a compiler error boiled, finished with errors and if you go on top you’re going to seethe problem static member function.Our function here cannot have CV qualifier.So it is a const qualifier because the static member function can’t be const because it doesn’t reallymake sense.And we have the same problem here.So you should note that if you are a member function is static, you can’t make it const because itdoesn’t make sense.Let’s take this out and we’re going to build again and make sure that our thing is working and it isworking.And this is really all I had to share in this lecture showing you how you can use static member functions,use them if your function isn’t really tied to any class object and you want it to belong or be tiedto the class blueprint itself, and if you are a member, function is static, it’s not going to haveany access to member variables of the class.You can’t have this pointer.If you use that, you’re going to get a compiler error.You can’t access the member variables and you can’t really do anything like that directly affects anobject because the static member function doesn’t have an idea of the object in which it is operatingon.It is operating in the context of the class blueprint itself.Okay, so this is really all for this lecture.I hope you found it interesting.We are going to stop here in this one.In the next one, we’re going to learn about nested classes.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，欢迎来到我们的C++学习之旅！作为你的导师，我将尽力用最清晰、最易懂的方式来讲解C++的知识点。</p>
<hr>
<h1 id="C-静态成员函数-Static-Member-Functions-：类级别的行为"><a href="#C-静态成员函数-Static-Member-Functions-：类级别的行为" class="headerlink" title="C++静态成员函数 (Static Member Functions)：类级别的行为"></a>C++静态成员函数 (Static Member Functions)：类级别的行为</h1><p><strong>核心概念速览：</strong> <code>static</code> 成员函数是属于整个 <strong>类</strong> (class) 而不是特定 <strong>对象</strong> (object) 的函数。它们可以访问类的 <code>static</code> 成员，但不能直接访问非 <code>static</code> 的成员变量，也无法拥有 <code>const</code> 限定符。</p>
<hr>
<h2 id="详细讲解：C-静态成员函数"><a href="#详细讲解：C-静态成员函数" class="headerlink" title="详细讲解：C++静态成员函数"></a>详细讲解：C++静态成员函数</h2><p>在C++中，<code>static</code> 成员函数是一个非常重要的概念，它与我们通常理解的成员函数有所不同。让我们一步步深入了解它。</p>
<h3 id="1-什么是-static-成员函数？"><a href="#1-什么是-static-成员函数？" class="headerlink" title="1. 什么是 static 成员函数？"></a>1. 什么是 <code>static</code> 成员函数？</h3><p>想象一下一个建筑蓝图 (class blueprint)。普通的成员函数就像蓝图上描述的，每栋根据蓝图建造的房子 (object) 都有自己独立的房间、厨房等（非静态成员变量），并且有自己的行为（非静态成员函数），比如“打开前门”、“关上窗户”。</p>
<p>而 <code>static</code> 成员函数则不同。它不是属于某一个具体的房子，而是直接属于 <strong>蓝图本身</strong>。这意味着：</p>
<ul>
<li>它不依赖于任何特定的房子被建造出来。</li>
<li>它描述的是与蓝图整体相关的功能，而不是与单个房子相关的行为。</li>
</ul>
<p>在C++中，<code>static</code> 成员函数就是与 <strong>类</strong> (class) 关联，而不是与 <strong>类的对象</strong> (object) 关联的函数。它们是类级别的函数，可以在没有创建任何对象的情况下被调用。</p>
<h3 id="2-如何声明-static-成员函数？"><a href="#2-如何声明-static-成员函数？" class="headerlink" title="2. 如何声明 static 成员函数？"></a>2. 如何声明 <code>static</code> 成员函数？</h3><p>声明一个 <code>static</code> 成员函数非常简单，只需要在函数声明前加上 <code>static</code> 关键字即可：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_point_count</span><span class="params">()</span></span>; <span class="comment">// 这是一个静态成员函数</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_point_count; <span class="comment">// 这是一个静态成员变量</span></span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>在这里，<code>get_point_count</code> 函数被 <code>static</code> 标记，意味着它现在是一个静态成员函数。</p>
<h3 id="3-static-成员函数的核心特性与限制"><a href="#3-static-成员函数的核心特性与限制" class="headerlink" title="3. static 成员函数的核心特性与限制"></a>3. <code>static</code> 成员函数的核心特性与限制</h3><p>理解 <code>static</code> 成员函数的关键在于其“独立性”：</p>
<ul>
<li><strong>没有 <code>this</code> 指针</strong>：每个非 <code>static</code> 成员函数在调用时都会隐式地接收一个指向当前对象的 <code>this</code> 指针。通过这个 <code>this</code> 指针，函数可以访问该对象的非 <code>static</code> 成员。然而，<code>static</code> 成员函数不属于任何特定的对象，所以它们 <strong>没有 <code>this</code> 指针</strong>。</li>
<li><p><strong>无法直接访问非 <code>static</code> 成员变量</strong>：由于没有 <code>this</code> 指针，<code>static</code> 成员函数自然不知道它应该操作哪个对象的非 <code>static</code> 成员变量。如果你尝试在 <code>static</code> 成员函数中直接访问 <code>m_x</code> 或 <code>m_y</code> (非静态成员变量)，编译器会报错。这是因为类可以有成千上万的对象，静态成员函数属于蓝图，它无法知道你想访问的是哪一个对象的 <code>m_x</code>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：静态成员函数尝试直接访问非静态成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_info_error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这将导致编译错误！</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; "X: " &lt;&lt; m_x &lt;&lt; ", Y: " &lt;&lt; m_y &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// 错误：静态成员函数不能直接访问非静态成员 'm_x' / 'm_y'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>可以访问 <code>static</code> 成员变量</strong>：<code>static</code> 成员变量（也称为类变量）是与类本身关联的，它们不属于任何对象，只有一份存储。因此，<code>static</code> 成员函数可以毫无问题地访问 <code>static</code> 成员变量，因为它们也属于类级别。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_point_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_point_count; <span class="comment">// 可以访问静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_point_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>不能用 <code>const</code> 关键字修饰</strong>：<code>const</code> 关键字通常用于成员函数，表示该函数不会修改其所属对象的成员变量（即不会修改 <code>this</code> 指针指向的数据）。由于 <code>static</code> 成员函数不与任何对象绑定，没有 <code>this</code> 指针，也就没有“所属对象”的状态可以被修改或保护。因此，<code>const</code> 关键字对于 <code>static</code> 成员函数来说是毫无意义的，编译器会阻止你这样做。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：静态成员函数不能被 const 修饰</span></span><br><span class="line"><span class="comment">// static int get_point_count() const; // 编译错误！</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<h3 id="4-如何访问非-static-成员变量（通过-static-成员函数）？"><a href="#4-如何访问非-static-成员变量（通过-static-成员函数）？" class="headerlink" title="4. 如何访问非 static 成员变量（通过 static 成员函数）？"></a>4. 如何访问非 <code>static</code> 成员变量（通过 <code>static</code> 成员函数）？</h3><p>尽管 <code>static</code> 成员函数不能直接访问非 <code>static</code> 成员变量，但如果你确实需要通过它来操作特定对象的非 <code>static</code> 数据，你可以将 <strong>对象作为参数传递</strong> 进去。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态成员函数，通过传入 Point 对象的引用来访问其非静态成员</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_point_info</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Info - X: "</span> &lt;&lt; p.m_x &lt;&lt; <span class="string">", Y: "</span> &lt;&lt; p.m_y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>注意：即使 <code>print_point_info</code> 是一个 <code>static</code> 函数，并且 <code>m_x</code> 和 <code>m_y</code> 是 <code>private</code> (私有) 成员，它仍然能够访问 <code>p</code> 对象的 <code>m_x</code> 和 <code>m_y</code>。这是因为 <code>static</code> 成员函数仍然是 <code>Point</code> 类的一部分，类内的所有成员（包括 <code>static</code> 和非 <code>static</code> 的）都可以访问其他成员（包括 <code>private</code> 成员），只要它们是通过正确的对象引用（如 <code>p</code>）来访问的。如果你在类的外部尝试直接 <code>some_object.m_x</code>，那就会报错。</p>
<h3 id="5-static-成员变量的初始化"><a href="#5-static-成员变量的初始化" class="headerlink" title="5. static 成员变量的初始化"></a>5. <code>static</code> 成员变量的初始化</h3><p><code>static</code> 成员变量的存储是独立的，不随对象的创建而分配。它们在程序启动时被初始化，并且只有一份。因此，它们必须在类定义之外进行 <strong>定义和初始化</strong>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 .cpp 文件中</span></span><br><span class="line"><span class="comment">// 必须在类外部定义和初始化静态成员变量</span></span><br><span class="line"><span class="keyword">int</span> Point::m_point_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>
<p>从 C++17 开始，你也可以使用 <code>inline</code> 关键字在类内部直接初始化 <code>static</code> 成员变量，这允许在头文件中进行定义和初始化，避免了在 <code>.cpp</code> 文件中单独定义的步骤：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 .h 文件中 (C++17 及更高版本)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> m_point_count = <span class="number">0</span>; <span class="comment">// 使用 inline 关键字，允许在类内初始化</span></span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="6-如何调用-static-成员函数？"><a href="#6-如何调用-static-成员函数？" class="headerlink" title="6. 如何调用 static 成员函数？"></a>6. 如何调用 <code>static</code> 成员函数？</h3><p>调用 <code>static</code> 成员函数不需要创建类的对象。你可以直接使用 <strong>类名和作用域解析运算符</strong> (<code>::</code>) 来调用它们。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 main 函数中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span> <span class="comment">// 假设 Point 类定义在 Point.h 中</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在创建任何 Point 对象之前就可以调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"当前点对象数量: "</span> &lt;&lt; Point::get_point_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>; <span class="comment">// 创建一个 Point 对象，构造函数会增加 m_point_count</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建 p1 后，点对象数量: "</span> &lt;&lt; Point::get_point_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">30</span>, <span class="number">40</span>)</span></span>; <span class="comment">// 创建第二个 Point 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建 p2 后，点对象数量: "</span> &lt;&lt; Point::get_point_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过对象调用静态函数也是可以的，但不推荐，因为它容易让人误解</span></span><br><span class="line">    <span class="comment">// 以为该函数依赖于对象，实际上它不依赖</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"通过 p1 调用 (不推荐): "</span> &lt;&lt; p1.get_point_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 同样输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用带参数的静态函数来打印特定对象的信息</span></span><br><span class="line">    Point::print_point_info(p1); <span class="comment">// 输出 X: 10, Y: 20</span></span><br><span class="line">    Point::print_point_info(p2); <span class="comment">// 输出 X: 30, Y: 40</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="7-总结何时使用-static-成员函数"><a href="#7-总结何时使用-static-成员函数" class="headerlink" title="7. 总结何时使用 static 成员函数"></a>7. 总结何时使用 <code>static</code> 成员函数</h3><p>当一个函数：</p>
<ul>
<li><strong>不需要访问任何特定对象的非 <code>static</code> 成员变量。</strong></li>
<li><strong>其行为与整个类相关，而不是与类的某个具体对象相关。</strong></li>
<li><strong>可能需要在没有创建任何对象的情况下被调用。</strong></li>
</ul>
<p>那么它就是 <code>static</code> 成员函数的好选择。常见的用途包括：</p>
<ul>
<li>计数类创建了多少个对象（如 <code>get_point_count</code>）。</li>
<li>提供工厂方法（例如 <code>Point::create_point(x, y)</code>）。</li>
<li>执行一些只与类本身相关的实用操作。</li>
</ul>
<hr>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>为了更好地理解 <code>static</code> 成员函数，我们来创建一个完整的 <code>Point</code> 类示例。</p>
<p><strong><code>Point.h</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> POINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Point();</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    Point(<span class="keyword">const</span> Point&amp; source); <span class="comment">// 拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Point();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数：获取点对象的总数</span></span><br><span class="line">    <span class="comment">// 注意：不能是 const</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_point_count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数：打印某个点对象的信息 (需要传入对象)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_point_info</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态成员函数：打印当前点对象的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_self_info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例：试图在静态函数中访问非静态成员</span></span><br><span class="line">    <span class="comment">// static void problematic_static_method() &#123;</span></span><br><span class="line">    <span class="comment">//     // std::cout &lt;&lt; "X: " &lt;&lt; m_x &lt;&lt; ", Y: " &lt;&lt; m_y &lt;&lt; std::endl; // 编译错误！</span></span><br><span class="line">    <span class="comment">//     // 静态成员函数不能直接访问非静态成员变量</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_x; <span class="comment">// 非静态成员变量</span></span><br><span class="line">    <span class="keyword">int</span> m_y; <span class="comment">// 非静态成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员变量：记录点对象的总数</span></span><br><span class="line">    <span class="comment">// C++17 及以后可以直接在这里使用 inline 初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> m_point_count = <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// POINT_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>Point.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不是 C++17 或不使用 inline，则需要在这里定义静态成员变量</span></span><br><span class="line"><span class="comment">// int Point::m_point_count = 0; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">Point::Point() : Point(<span class="number">0</span>, <span class="number">0</span>) &#123; <span class="comment">// 委托给带参数的构造函数</span></span><br><span class="line">    <span class="comment">// 委托构造，m_point_count 会在被委托的构造函数中递增</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的构造函数</span></span><br><span class="line">Point::Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : m_x(x), m_y(y) &#123;</span><br><span class="line">    m_point_count++; <span class="comment">// 每创建一个 Point 对象，计数器增加</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">") Created. Total: "</span> &lt;&lt; m_point_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">Point::Point(<span class="keyword">const</span> Point&amp; source) : m_x(source.m_x), m_y(source.m_y) &#123;</span><br><span class="line">    m_point_count++; <span class="comment">// 拷贝构造也会增加对象计数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point Copied ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">"). Total: "</span> &lt;&lt; m_point_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Point::~Point() &#123;</span><br><span class="line">    m_point_count--; <span class="comment">// 对象销毁时，计数器减少</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">") Destroyed. Total: "</span> &lt;&lt; m_point_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Point::get_point_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_point_count; <span class="comment">// 访问静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员函数，通过传入对象来访问其非静态成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::print_point_info</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Static Print Info - Point X: "</span> &lt;&lt; p.m_x &lt;&lt; <span class="string">", Y: "</span> &lt;&lt; p.m_y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非静态成员函数，打印当前对象的信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::print_self_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Non-Static Print Info - Point X: "</span> &lt;&lt; m_x &lt;&lt; <span class="string">", Y: "</span> &lt;&lt; m_y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 程序开始 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 在创建任何对象之前调用静态成员函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"在创建对象前，当前点对象数量: "</span> &lt;&lt; Point::get_point_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建 Point 对象</span></span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>; <span class="comment">// 调用带参数构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建 p1 后，当前点对象数量: "</span> &lt;&lt; Point::get_point_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Point p2; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建 p2 后，当前点对象数量: "</span> &lt;&lt; Point::get_point_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Point p3 = p1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝 p1 到 p3 后，当前点对象数量: "</span> &lt;&lt; Point::get_point_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通过静态成员函数打印某个对象的信息（传入对象）</span></span><br><span class="line">    Point::print_point_info(p1);</span><br><span class="line">    Point::print_point_info(p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 调用非静态成员函数（需要通过对象）</span></span><br><span class="line">    p1.print_self_info();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 错误示例：尝试直接通过类名调用非静态函数 (会报错)</span></span><br><span class="line">    <span class="comment">// Point::print_self_info(); // 编译错误：无法在没有对象的情况下调用非静态成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 静态函数不能被 const 修饰的例子 (请尝试在 Point.h 中修改 get_point_count 声明，然后编译)</span></span><br><span class="line">    <span class="comment">// static int get_point_count() const; // 编译器会报错：static member function cannot have cv-qualifier</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 程序结束 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>编译和运行：</strong></p>
<p>你需要将这三个文件（<code>Point.h</code>, <code>Point.cpp</code>, <code>main.cpp</code>）放在同一个文件夹中，然后使用C++编译器（如g++）编译：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp Point.cpp -o my_app</span><br><span class="line">./my_app</span><br></pre></td></tr></table></figure></div>
<p>观察输出，你会看到 <code>Point::get_point_count()</code> 如何准确地跟踪对象的创建和销毁。</p>
<hr>
<h2 id="QA-闪卡-QA-Flash-Cards"><a href="#QA-闪卡-QA-Flash-Cards" class="headerlink" title="QA 闪卡 (QA Flash Cards)"></a>QA 闪卡 (QA Flash Cards)</h2><ol>
<li><p><strong>Q:</strong> <code>static</code> 成员函数属于类的哪个部分？<br><strong>A:</strong> 它属于 <strong>类</strong> 本身，而不是类的任何特定 <strong>对象</strong>。</p>
</li>
<li><p><strong>Q:</strong> <code>static</code> 成员函数内部可以访问 <code>static</code> 成员变量吗？<br><strong>A:</strong> <strong>可以</strong>。因为 <code>static</code> 成员变量也属于类级别。</p>
</li>
<li><p><strong>Q:</strong> <code>static</code> 成员函数内部可以访问非 <code>static</code> 成员变量吗？<br><strong>A:</strong> <strong>不可以直接访问</strong>。因为它没有 <code>this</code> 指针，不知道要操作哪个对象的非 <code>static</code> 成员。</p>
</li>
<li><p><strong>Q:</strong> 如何在 <code>main</code> 函数中调用 <code>static</code> 成员函数？<br><strong>A:</strong> 使用 <strong>类名和作用域解析运算符 <code>::</code></strong>，例如 <code>ClassName::staticMethod()</code>。</p>
</li>
<li><p><strong>Q:</strong> <code>static</code> 成员函数可以被 <code>const</code> 关键字修饰吗？为什么？<br><strong>A:</strong> <strong>不可以</strong>。因为 <code>const</code> 关键字用于保证函数不修改其所属对象的成员变量，而 <code>static</code> 成员函数不属于任何对象，没有 <code>this</code> 指针，也就没有“所属对象”的状态可供修改。</p>
</li>
<li><p><strong>Q:</strong> 如果 <code>static</code> 成员函数需要访问某个对象的非 <code>static</code> 成员，该怎么做？<br><strong>A:</strong> 将 <strong>该对象作为参数传递</strong> 给 <code>static</code> 成员函数。</p>
</li>
</ol>
<hr>
<h2 id="常见误解或错误"><a href="#常见误解或错误" class="headerlink" title="常见误解或错误"></a>常见误解或错误</h2><ol>
<li><p><strong>误解1：<code>static</code> 成员函数有 <code>this</code> 指针。</strong></p>
<ul>
<li><strong>纠正：</strong> <code>static</code> 成员函数没有 <code>this</code> 指针。<code>this</code> 指针总是指向当前被调用的非 <code>static</code> 成员函数所属的对象。</li>
</ul>
</li>
<li><p><strong>误解2：可以在 <code>static</code> 成员函数中直接访问非 <code>static</code> 成员变量。</strong></p>
<ul>
<li><strong>纠正：</strong> 这是最常见的错误。由于没有 <code>this</code> 指针，<code>static</code> 成员函数不知道要访问哪个对象的非 <code>static</code> 成员。如果你尝试这样做，编译器会报错。</li>
</ul>
</li>
<li><p><strong>误解3：<code>static</code> 成员函数可以被声明为 <code>const</code>。</strong></p>
<ul>
<li><strong>纠正：</strong> <code>const</code> 成员函数是为了保证不修改对象的状态，而 <code>static</code> 成员函数根本不操作任何对象的状态，所以 <code>const</code> 对它没有意义，会导致编译错误。</li>
</ul>
</li>
<li><p><strong>误解4：<code>static</code> 成员变量不需要在类外定义/初始化。</strong></p>
<ul>
<li><strong>纠正：</strong> 除了 C++17 引入的 <code>inline</code> 关键字允许在类内初始化外，通常 <code>static</code> 成员变量都需要在 <code>.cpp</code> 文件中（类定义之外）进行定义和初始化，否则会遇到链接错误 (undefined reference)。</li>
</ul>
</li>
<li><p><strong>误解5：<code>static</code> 成员函数只能访问 <code>static</code> 成员变量。</strong></p>
<ul>
<li><strong>纠正：</strong> 虽然不能直接访问非 <code>static</code> 成员变量，但如果一个非 <code>static</code> 成员变量所属的对象作为参数传递给 <code>static</code> 函数，那么 <code>static</code> 函数可以通过这个参数访问该对象的 <code>public</code> 或 <code>private</code> 非 <code>static</code> 成员（因为它仍在类的作用域内）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h2><p>现在，是时候让你动手实践了！</p>
<p>请根据我们学到的知识，完善下面的 <code>Car</code> 类。这个 <code>Car</code> 类应该能够：</p>
<ol>
<li>有一个 <code>static</code> 成员变量来追踪创建了多少辆 <code>Car</code> 对象。</li>
<li>有一个 <code>static</code> 成员函数来获取当前 <code>Car</code> 对象的总数。</li>
<li>有一个 <code>static</code> 成员函数，接收一个 <code>Car</code> 对象作为参数，并打印这辆车的 <code>make</code> 和 <code>model</code>。</li>
<li>构造函数和析构函数要正确更新 <code>static</code> 计数器。</li>
</ol>
<p>请在 <code>Car.h</code> 和 <code>Car.cpp</code> 文件中完成 <code>// TODO:</code> 部分的代码。</p>
<p><strong><code>Car.h</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; make, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; model);</span><br><span class="line">    ~Car();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 声明一个静态成员函数来获取当前创建的 Car 对象总数</span></span><br><span class="line">    <span class="comment">// 提示：这个函数不需要参数，返回类型是 int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 声明一个静态成员函数，接收一个 const Car&amp; 参数，并打印该 Car 对象的 make 和 model</span></span><br><span class="line">    <span class="comment">// 提示：这个函数不需要返回类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_make;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_model;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 声明一个静态成员变量来追踪 Car 对象的总数</span></span><br><span class="line">    <span class="comment">// 提示：C++17 及以后可以直接在这里使用 inline 初始化为 0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CAR_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>Car.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Car.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 如果在 Car.h 中没有使用 inline，请在这里定义并初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 类的构造函数</span></span><br><span class="line">Car::Car(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; make, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; model) : m_make(make), m_model(model) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 构造时增加 Car 对象计数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car '"</span> &lt;&lt; m_make &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"' created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 类的析构函数</span></span><br><span class="line">Car::~Car() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 析构时减少 Car 对象计数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car '"</span> &lt;&lt; m_make &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"' destroyed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 实现获取 Car 对象总数的静态成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 实现打印 Car 信息的静态成员函数</span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code> (无需修改，用于测试你的代码)</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Car.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Car 管理程序开始 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在创建任何 Car 对象之前，获取当前 Car 数量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"当前 Car 数量: "</span> &lt;&lt; Car::get_total_cars() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 假设你的静态函数叫 get_total_cars</span></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// 局部作用域，用于测试对象生命周期</span></span><br><span class="line">        <span class="function">Car <span class="title">myCar</span><span class="params">(<span class="string">"Toyota"</span>, <span class="string">"Camry"</span>)</span></span>;</span><br><span class="line">        <span class="function">Car <span class="title">yourCar</span><span class="params">(<span class="string">"Honda"</span>, <span class="string">"CRV"</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建两辆车后，当前 Car 数量: "</span> &lt;&lt; Car::get_total_cars() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用静态函数打印特定 Car 的信息</span></span><br><span class="line">        Car::print_car_details(myCar); <span class="comment">// 假设你的静态函数叫 print_car_details</span></span><br><span class="line">        Car::print_car_details(yourCar);</span><br><span class="line">    &#125; <span class="comment">// myCar 和 yourCar 在这里销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"离开作用域后，当前 Car 数量: "</span> &lt;&lt; Car::get_total_cars() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Car <span class="title">anotherCar</span><span class="params">(<span class="string">"Ford"</span>, <span class="string">"Focus"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建另一辆车后，当前 Car 数量: "</span> &lt;&lt; Car::get_total_cars() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Car::print_car_details(anotherCar);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Car 管理程序结束 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请完成 <code>Car.h</code> 和 <code>Car.cpp</code> 中的 <code>TODO</code> 部分，然后告诉我你的解决方案。</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>回答之前我想问一下， 这个Static function和python的staticmethod有什么区别</p>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常好的问题！提问说明你正在积极思考并尝试关联新知识，这对于学习非常重要。</p>
<p>C++的 <code>static</code> 成员函数 (static member function) 和 Python 的 <code>staticmethod</code> 在概念上确实有相似之处，但它们在语言特性和使用哲学上存在一些关键区别。</p>
<p>让我们来详细比较一下：</p>
<h2 id="C-static-成员函数-vs-Python-staticmethod"><a href="#C-static-成员函数-vs-Python-staticmethod" class="headerlink" title="C++ static 成员函数 vs. Python staticmethod"></a>C++ <code>static</code> 成员函数 vs. Python <code>staticmethod</code></h2><p><strong>核心相似点 (Core Similarities):</strong></p>
<ol>
<li><strong>类级别归属 (Class-level Affiliation):</strong> 两者都与 <strong>类</strong> (class) 本身关联，而不是与类的 <strong>对象</strong> (object / instance) 关联。这意味着你可以在不创建任何对象的情况下直接通过类名来调用它们（C++: <code>ClassName::staticMethod()</code>；Python: <code>ClassName.static_method()</code>）。</li>
<li><strong>不接收隐式实例引用 (No Implicit Instance Reference):</strong><ul>
<li>C++ 的 <code>static</code> 成员函数 <strong>没有 <code>this</code> 指针</strong> (this pointer)。</li>
<li>Python 的 <code>staticmethod</code> 不会自动接收 <code>self</code> 参数（即实例本身）。<br>这是它们能够被称为“静态”的核心原因——它们不操作特定对象的实例数据。</li>
</ul>
</li>
</ol>
<p><strong>关键区别 (Key Differences):</strong></p>
<ol>
<li><p><strong>访问类成员的权限 (Access to Class Members):</strong></p>
<ul>
<li><strong>C++ <code>static</code> 成员函数：</strong><ul>
<li>可以 <strong>直接访问</strong> 类的 <strong><code>static</code> 成员变量</strong> (static member variable) 和 <strong><code>static</code> 成员函数</strong>。因为 <code>static</code> 成员也是类级别的。</li>
<li><strong>不能直接访问</strong> 类的 <strong>非 <code>static</code> 成员变量</strong> (non-static member variable) 或 <strong>非 <code>static</code> 成员函数</strong>。如果你需要在 <code>static</code> 函数中操作非 <code>static</code> 成员，你必须将一个对象作为参数显式地传递给它。</li>
</ul>
</li>
<li><strong>Python <code>staticmethod</code>：</strong><ul>
<li><strong>不能直接访问</strong> 实例属性 (instance attributes)，因为它没有 <code>self</code> 参数。</li>
<li>可以 <strong>直接访问</strong> 类的 <strong>类属性</strong> (class attributes) 和 <strong>其他 <code>staticmethod</code></strong>。</li>
<li>如果需要访问 <strong><code>classmethod</code></strong> (类方法) 或 <strong>普通方法</strong> (regular method)，通常需要显式地通过类名来调用（例如 <code>ClassName.some_classmethod()</code>）。Python 的 <code>classmethod</code> (类方法) 会自动接收 <code>cls</code> (类本身) 作为第一个参数，这使得它能够更方便地访问类属性和调用其他类方法，而 <code>staticmethod</code> 没有这个 <code>cls</code> 参数。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>多态性与继承 (Polymorphism and Inheritance):</strong></p>
<ul>
<li><strong>C++ <code>static</code> 成员函数：</strong><ul>
<li><strong>不能是虚函数 (virtual function)</strong>。C++ 的虚函数机制依赖于 <code>this</code> 指针和虚函数表 (vtable) 来实现运行时多态，而 <code>static</code> 函数没有 <code>this</code> 指针，不参与多态。</li>
<li>如果派生类 (derived class) 定义了一个与基类 (base class) 同名的 <code>static</code> 成员函数，这通常是 <strong>隐藏 (hiding)</strong> 而不是 <strong>覆盖 (overriding)</strong>。调用哪个函数取决于你使用基类名还是派生类名来调用。</li>
</ul>
</li>
<li><strong>Python <code>staticmethod</code>：</strong><ul>
<li>它仍然遵循 Python 的继承规则。派生类会继承基类的 <code>staticmethod</code>。</li>
<li>虽然 <code>staticmethod</code> 不参与实例方法那样的动态调度 (dynamic dispatch)，但它确实是类方法解析顺序 (Method Resolution Order, MRO) 的一部分。在 Python 中，方法查找通常是动态的。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>声明方式 (Declaration Method):</strong></p>
<ul>
<li><strong>C++：</strong> 使用 <code>static</code> 关键字直接放在函数声明前面。</li>
<li><strong>Python：</strong> 使用 <code>@staticmethod</code> 装饰器 (decorator) 放在函数定义上方。</li>
</ul>
</li>
<li><p><strong>哲学/最佳实践 (Philosophy/Best Practice):</strong></p>
<ul>
<li><strong>C++ <code>static</code> 成员函数：</strong> 更常用于与类本身逻辑相关但不需要任何对象状态的功能，例如：<ul>
<li>对象计数器 (<code>Point::get_point_count()</code>)。</li>
<li>工厂方法 (factory method)，用于创建类的实例而不需要现有实例。</li>
<li>一些工具函数，这些函数与类紧密相关，但并不操作类的实例数据。</li>
</ul>
</li>
<li><strong>Python <code>staticmethod</code>：</strong> 哲学上更灵活一些。通常用于：<ul>
<li>纯粹的工具函数，只是为了逻辑组织而放在类内。</li>
<li>当一个函数既不需要访问实例数据 (<code>self</code>) 也不需要访问类数据 (<code>cls</code>) 时。</li>
<li>Python 提供了 <code>classmethod</code> (类方法) 来处理需要访问类自身（例如，创建子类实例或访问类属性）的场景，这在 C++ 中通常由 <code>static</code> 方法结合显式传递类信息来完成。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>总结表格：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">特性 / 方法</th>
<th style="text-align:left">C++ <code>static</code> 成员函数</th>
<th style="text-align:left">Python <code>staticmethod</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>所属</strong></td>
<td style="text-align:left">类</td>
<td style="text-align:left">类</td>
</tr>
<tr>
<td style="text-align:left"><strong>需要对象调用</strong></td>
<td style="text-align:left">否 (<code>ClassName::method()</code>)</td>
<td style="text-align:left">否 (<code>ClassName.method()</code>)</td>
</tr>
<tr>
<td style="text-align:left"><strong><code>this</code> / <code>self</code> 参数</strong></td>
<td style="text-align:left">无 <code>this</code> 指针</td>
<td style="text-align:left">无 <code>self</code> 参数</td>
</tr>
<tr>
<td style="text-align:left"><strong>可直接访问实例数据</strong></td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left"><strong>可直接访问类数据</strong></td>
<td style="text-align:left">可以访问 <code>static</code> 成员变量/函数</td>
<td style="text-align:left">可以访问类属性，其他 <code>staticmethod</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>多态性</strong></td>
<td style="text-align:left">不参与虚函数，派生类隐藏</td>
<td style="text-align:left">参与继承，不参与动态调度</td>
</tr>
<tr>
<td style="text-align:left"><strong>声明方式</strong></td>
<td style="text-align:left"><code>static</code> 关键字</td>
<td style="text-align:left"><code>@staticmethod</code> 装饰器</td>
</tr>
<tr>
<td style="text-align:left"><strong>典型用途</strong></td>
<td style="text-align:left">对象计数，工厂方法，类级别工具函数</td>
<td style="text-align:left">纯工具函数，逻辑组织</td>
</tr>
</tbody>
</table>
</div>
<p>理解了这些区别，你会发现虽然名字相似，但它们在各自语言的类型系统和运行时行为中扮演的角色略有不同。在 C++ 中，<code>static</code> 成员函数提供了非常严格的编译时保证和类型安全，而 Python 的 <code>staticmethod</code> 则体现了其动态、灵活的特性。</p>
<hr>
<h2 id="🧑‍💻-User-2"><a href="#🧑‍💻-User-2" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>classmethod和staticmethod的区别？ python</p>
<hr>
<h2 id="🤖-Assistant-2"><a href="#🤖-Assistant-2" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，既然你问到了 <code>classmethod</code> 和 <code>staticmethod</code> 在 Python 中的区别，这正是理解 Python 类方法设计理念的关键！我们来深入探讨一下。</p>
<p>在 Python 中，<code>staticmethod</code> 和 <code>classmethod</code> 都属于装饰器 (decorators)，用于修改类中方法的行为。它们的主要区别在于它们接收的第一个参数，以及它们因此能够访问的信息。</p>
<h2 id="Python-staticmethod-静态方法"><a href="#Python-staticmethod-静态方法" class="headerlink" title="Python staticmethod (静态方法)"></a>Python <code>staticmethod</code> (静态方法)</h2><p>正如我们之前讨论的，<code>staticmethod</code> 的核心特点是：</p>
<ol>
<li><strong>不接收任何隐式参数 (No Implicit First Argument):</strong> 它既不接收类实例 (<code>self</code>) 作为第一个参数，也不接收类本身 (<code>cls</code>) 作为第一个参数。</li>
<li><strong>行为与普通函数类似 (Behaves like a Regular Function):</strong> 它本质上就是一个定义在类命名空间 (namespace) 下的普通函数。它与类或类的任何实例都没有直接的“绑定”关系。</li>
<li><strong>无法直接访问实例或类数据 (Cannot Directly Access Instance or Class Data):</strong> 因为它没有 <code>self</code> 或 <code>cls</code> 参数，所以它无法直接访问实例的属性 (instance attributes) 或类的属性 (class attributes)。如果你想让它访问这些数据，你必须显式地将它们作为参数传递进去。</li>
</ol>
<p><strong>典型应用场景：</strong></p>
<ul>
<li><strong>纯工具函数 (Utility Functions):</strong> 当一个函数与类有逻辑上的关联，但不需要访问类或实例的任何特定数据时，可以使用 <code>staticmethod</code>。它只是为了代码组织而放在类里面，而不是全局函数。</li>
<li><strong>与其他类或实例无关的辅助计算 (Auxiliary Calculations):</strong> 例如，一个类中可能包含一个用于校验输入的辅助函数，这个校验逻辑与类的状态无关。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    class_attribute = <span class="string">"Hello from class"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, instance_attribute)</span>:</span></span><br><span class="line">        self.instance_attribute = instance_attribute</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_method_example</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="comment"># 无法直接访问 MyClass.class_attribute 或 self.instance_attribute</span></span><br><span class="line">        print(<span class="string">f"静态方法被调用，参数: <span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方式：</span></span><br><span class="line">print(MyClass.static_method_example(<span class="number">5</span>, <span class="number">3</span>)) <span class="comment"># 通过类名调用</span></span><br><span class="line"><span class="comment"># 也可以通过实例调用，但不推荐，因为它容易让人误解</span></span><br><span class="line">obj = MyClass(<span class="string">"instance data"</span>)</span><br><span class="line">print(obj.static_method_example(<span class="number">10</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></div>
<h2 id="Python-classmethod-类方法"><a href="#Python-classmethod-类方法" class="headerlink" title="Python classmethod (类方法)"></a>Python <code>classmethod</code> (类方法)</h2><p><code>classmethod</code> 的核心特点是：</p>
<ol>
<li><strong>接收类本身作为第一个隐式参数 (Receives the Class Itself as First Implicit Argument):</strong> 约定俗成地，这个参数通常命名为 <code>cls</code> (class 的缩写)。</li>
<li><strong>可以访问类属性和调用其他类方法 (Can Access Class Attributes and Call Other Class Methods):</strong> 因为它接收了 <code>cls</code> 参数，所以它可以通过 <code>cls</code> 来访问类的属性 (class attributes) 和调用类的其他方法（包括其他 <code>classmethod</code> 或 <code>staticmethod</code>）。</li>
<li><strong>主要用于创建实例 (Often Used for Alternative Constructors):</strong> 它们常被用作替代构造函数 (alternative constructors)，提供不同的方式来创建类的实例。</li>
</ol>
<p><strong>典型应用场景：</strong></p>
<ul>
<li><strong>工厂方法 (Factory Methods):</strong> 当你需要提供多种方式来创建类的实例时。例如，一个 <code>Date</code> 类可能有一个 <code>from_string</code> 类方法，用于从字符串解析日期并创建 <code>Date</code> 对象。</li>
<li><strong>需要访问类属性的工具函数 (Utility Functions Needing Class Attributes):</strong> 当一个函数需要访问或修改类级别的状态（即类属性）时。</li>
<li><strong>处理继承 (Handling Inheritance):</strong> 当你使用 <code>classmethod</code> 创建实例时，如果子类调用了这个类方法，那么 <code>cls</code> 参数将指向子类，而不是基类，这使得它能够正确地创建子类的实例，这在处理继承时非常有用。</li>
</ul>
<p><strong>示例：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    class_attribute = <span class="string">"Hello from class"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        print(<span class="string">f"MyClass instance created with value: <span class="subst">&#123;self.value&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method_example</span><span class="params">(cls, prefix)</span>:</span></span><br><span class="line">        <span class="comment"># cls 参数就是 MyClass 这个类本身</span></span><br><span class="line">        print(<span class="string">f"类方法被调用。Class Attribute: <span class="subst">&#123;cls.class_attribute&#125;</span>"</span>)</span><br><span class="line">        <span class="comment"># 通过 cls 参数可以创建类的实例</span></span><br><span class="line">        <span class="keyword">return</span> cls(<span class="string">f"<span class="subst">&#123;prefix&#125;</span> - derived value"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_from_string</span><span class="params">(cls, data_string)</span>:</span></span><br><span class="line">        <span class="comment"># 这是一个常见的工厂方法用法</span></span><br><span class="line">        parts = data_string.split(<span class="string">'-'</span>)</span><br><span class="line">        <span class="keyword">if</span> len(parts) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> cls(<span class="string">f"From String: <span class="subst">&#123;parts[<span class="number">0</span>]&#125;</span>_<span class="subst">&#123;parts[<span class="number">1</span>]&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cls(<span class="string">"Default Value"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方式：</span></span><br><span class="line"><span class="comment"># 通过类名调用类方法，并创建实例</span></span><br><span class="line">instance1 = MyClass.class_method_example(<span class="string">"Prefix"</span>)</span><br><span class="line">instance2 = MyClass.create_from_string(<span class="string">"data1-data2"</span>)</span><br><span class="line">instance3 = MyClass.create_from_string(<span class="string">"single_data"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"实例1的值: <span class="subst">&#123;instance1.value&#125;</span>"</span>)</span><br><span class="line">print(<span class="string">f"实例2的值: <span class="subst">&#123;instance2.value&#125;</span>"</span>)</span><br><span class="line">print(<span class="string">f"实例3的值: <span class="subst">&#123;instance3.value&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承中的类方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span><span class="params">(MyClass)</span>:</span></span><br><span class="line">    class_attribute = <span class="string">"Hello from SubClass"</span> <span class="comment"># 子类可以覆盖类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super().__init__(value)</span><br><span class="line">        print(<span class="string">"SubClass instance created!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类调用基类的类方法，cls 会指向 SubClass</span></span><br><span class="line">sub_instance = SubClass.class_method_example(<span class="string">"SubPrefix"</span>)</span><br><span class="line">print(<span class="string">f"子类实例的值: <span class="subst">&#123;sub_instance.value&#125;</span>"</span>)</span><br></pre></td></tr></table></figure></div>
<p>在这个继承的例子中，当 <code>SubClass.class_method_example(&quot;SubPrefix&quot;)</code> 被调用时，<code>cls</code> 参数实际上是 <code>SubClass</code>，所以 <code>cls(f&quot;{prefix} - derived value&quot;)</code> 会创建一个 <code>SubClass</code> 的实例，而不是 <code>MyClass</code> 的实例。这是 <code>classmethod</code> 比 <code>staticmethod</code> 更强大的一个关键点。</p>
<h2 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">特性 / 方法</th>
<th style="text-align:left"><code>staticmethod</code> (静态方法)</th>
<th style="text-align:left"><code>classmethod</code> (类方法)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>第一个参数</strong></td>
<td style="text-align:left">无 (<code>self</code> 或 <code>cls</code>)</td>
<td style="text-align:left"><code>cls</code> (代表类本身)</td>
</tr>
<tr>
<td style="text-align:left"><strong>可访问实例属性</strong></td>
<td style="text-align:left">否 (除非显式传入实例)</td>
<td style="text-align:left">否 (但可以创建实例来访问)</td>
</tr>
<tr>
<td style="text-align:left"><strong>可访问类属性</strong></td>
<td style="text-align:left">否 (除非显式通过 <code>ClassName.attr</code>)</td>
<td style="text-align:left">是 (通过 <code>cls.attribute</code>)</td>
</tr>
<tr>
<td style="text-align:left"><strong>是否能够创建实例</strong></td>
<td style="text-align:left">否 (只能通过 <code>ClassName()</code> 或 <code>cls()</code>)</td>
<td style="text-align:left">是 (通过 <code>cls()</code>)</td>
</tr>
<tr>
<td style="text-align:left"><strong>绑定到</strong></td>
<td style="text-align:left">类，但行为像普通函数</td>
<td style="text-align:left">类</td>
</tr>
<tr>
<td style="text-align:left"><strong>主要用途</strong></td>
<td style="text-align:left">纯工具函数，代码组织</td>
<td style="text-align:left">工厂方法，替代构造函数，操作类属性</td>
</tr>
</tbody>
</table>
</div>
<p><strong>简而言之：</strong></p>
<ul>
<li><strong><code>staticmethod</code></strong>：方法内部 <strong>既不需要访问实例数据，也不需要访问类数据</strong>。它只是一个逻辑上属于这个类的普通函数。</li>
<li><strong><code>classmethod</code></strong>：方法内部 <strong>需要访问类本身</strong>（比如访问类属性，或者根据类的类型创建新的实例）。它接收 <code>cls</code> 参数，可以利用这个参数来处理类相关的事宜。</li>
</ul>
<p>希望这个详细的解释能帮助你彻底理解两者的区别！</p>
<hr>
<h2 id="🧑‍💻-User-3"><a href="#🧑‍💻-User-3" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>answer:</p>
<p>Car.h<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; make, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; model);</span><br><span class="line">    ~Car();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 声明一个静态成员函数来获取当前创建的 Car 对象总数</span></span><br><span class="line">    <span class="comment">// 提示：这个函数不需要参数，返回类型是 int</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_total_cars</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 声明一个静态成员函数，接收一个 const Car&amp; 参数，并打印该 Car 对象的 make 和 model</span></span><br><span class="line">    <span class="comment">// 提示：这个函数不需要返回类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_car_details</span><span class="params">(<span class="keyword">const</span> Car&amp; car)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_make;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_model;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 声明一个静态成员变量来追踪 Car 对象的总数</span></span><br><span class="line">    <span class="comment">// 提示：C++17 及以后可以直接在这里使用 inline 初始化为 0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> num_of_cars = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CAR_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p>Car.cpp<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Car.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 如果在 Car.h 中没有使用 inline，请在这里定义并初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 类的构造函数</span></span><br><span class="line">Car::Car(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; make, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; model) : m_make(make), m_model(model) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 构造时增加 Car 对象计数</span></span><br><span class="line">    num_of_cars++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car '"</span> &lt;&lt; m_make &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"' created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 类的析构函数</span></span><br><span class="line">Car::~Car() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 析构时减少 Car 对象计数</span></span><br><span class="line">    num_of_cars--;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car '"</span> &lt;&lt; m_make &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"' destroyed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 实现获取 Car 对象总数的静态成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Car::get_total_cars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num_of_cars;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 实现打印 Car 信息的静态成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Car::print_car_details</span><span class="params">(<span class="keyword">const</span> Car&amp; car)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"make is "</span> &lt;&lt; car.m_make &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"model is "</span> &lt;&lt; car.m_model &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<hr>
<h2 id="🤖-Assistant-3"><a href="#🤖-Assistant-3" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>太棒了！你的解决方案非常出色！</p>
<h2 id="7-你的解决方案评分与实际答案"><a href="#7-你的解决方案评分与实际答案" class="headerlink" title="7. 你的解决方案评分与实际答案"></a>7. 你的解决方案评分与实际答案</h2><p><strong>评分：</strong> 10/10 分！</p>
<p>你完全正确地完成了所有要求，不仅正确声明并实现了静态成员函数和静态成员变量，而且还巧妙地运用了 C++17 的 <code>inline</code> 关键字来初始化静态成员变量，展现了对 C++ 静态成员机制的深入理解。特别值得称赞的是，你正确地通过传递对象引用来让静态函数访问非静态成员，并且正确地处理了构造函数和析构函数中的计数器增减。</p>
<p>这是你提交的，也是完全正确的代码和详细解释：</p>
<h3 id="实际答案与详细解释"><a href="#实际答案与详细解释" class="headerlink" title="实际答案与详细解释"></a><strong>实际答案与详细解释</strong></h3><p><strong><code>Car.h</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CAR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数：初始化车辆的制造者和型号</span></span><br><span class="line">    <span class="comment">// 参数：make - 制造者，model - 型号</span></span><br><span class="line">    Car(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; make, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; model);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数：在 Car 对象被销毁时调用</span></span><br><span class="line">    ~Car();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数：获取当前创建的 Car 对象总数</span></span><br><span class="line">    <span class="comment">// 属于类本身，不依赖于任何特定对象，因此不需要 'this' 指针，也不能是 const</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_total_cars</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数：打印某个 Car 对象的制造者和型号</span></span><br><span class="line">    <span class="comment">// 由于静态函数不能直接访问非静态成员，所以需要将 Car 对象作为参数传入</span></span><br><span class="line">    <span class="comment">// 参数 'car' 是一个 const 引用，表示函数不会修改传入的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_car_details</span><span class="params">(<span class="keyword">const</span> Car&amp; car)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 非静态成员变量：每辆 Car 对象都有自己独立的 make 和 model</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_make;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_model;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员变量：追踪 Car 对象的总数</span></span><br><span class="line">    <span class="comment">// 属于类本身，所有 Car 对象共享这一个计数器</span></span><br><span class="line">    <span class="comment">// 'inline' 关键字 (C++17) 允许在类定义内部直接初始化静态成员变量</span></span><br><span class="line">    <span class="comment">// 如果没有 'inline' 或者不是 C++17，则需要在 .cpp 文件中单独定义和初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> num_of_cars = <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// CAR_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>Car.cpp</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Car.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果在 Car.h 中没有使用 inline 关键字，则需要在这里定义并初始化静态成员变量。</span></span><br><span class="line"><span class="comment">// 例如：int Car::num_of_cars = 0;</span></span><br><span class="line"><span class="comment">// 但由于你在 .h 文件中使用了 inline，这里就不需要重复定义了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 类的构造函数实现</span></span><br><span class="line">Car::Car(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; make, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; model) : m_make(make), m_model(model) &#123;</span><br><span class="line">    <span class="comment">// 每创建一个 Car 对象，静态计数器 num_of_cars 递增</span></span><br><span class="line">    num_of_cars++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car '"</span> &lt;&lt; m_make &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"' created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 类的析构函数实现</span></span><br><span class="line">Car::~Car() &#123;</span><br><span class="line">    <span class="comment">// 每销毁一个 Car 对象，静态计数器 num_of_cars 递减</span></span><br><span class="line">    num_of_cars--;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car '"</span> &lt;&lt; m_make &lt;&lt; <span class="string">" "</span> &lt;&lt; m_model &lt;&lt; <span class="string">"' destroyed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员函数 get_total_cars 的实现</span></span><br><span class="line"><span class="comment">// 直接返回静态成员变量 num_of_cars 的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Car::get_total_cars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num_of_cars;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员函数 print_car_details 的实现</span></span><br><span class="line"><span class="comment">// 通过传入的 'car' 对象引用来访问其私有非静态成员 m_make 和 m_model</span></span><br><span class="line"><span class="comment">// 即使是 private 成员，只要是在类的作用域内 (包括静态成员函数)，都可以访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Car::print_car_details</span><span class="params">(<span class="keyword">const</span> Car&amp; car)</span> </span>&#123;   </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Make: "</span> &lt;&lt; car.m_make &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Model: "</span> &lt;&lt; car.m_model &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当你使用提供的 <code>main.cpp</code> 编译运行这段代码时，你会看到它完美地工作，精确地计数车辆数量，并正确打印每辆车的详细信息。</p>
<h2 id="8-进一步学习的建议-Extended-Questions"><a href="#8-进一步学习的建议-Extended-Questions" class="headerlink" title="8. 进一步学习的建议 (Extended Questions)"></a>8. 进一步学习的建议 (Extended Questions)</h2><p>你已经很好地掌握了 C++ 中的 <code>static</code> 成员函数和静态成员变量。为了更深入地理解相关概念和实际应用，我建议你进一步探讨以下问题：</p>
<ol>
<li><p><strong><code>static</code> 成员变量的生命周期和存储位置：</strong></p>
<ul>
<li><code>static</code> 成员变量在程序生命周期中何时被初始化？何时被销毁？</li>
<li>它们通常存储在哪里（例如，数据段）？与局部 <code>static</code> 变量的生命周期有何异同？</li>
</ul>
</li>
<li><p><strong><code>static</code> 成员与单例模式 (Singleton Pattern)：</strong></p>
<ul>
<li>了解如何利用 <code>static</code> 成员来实现“单例模式”，即确保一个类在整个程序中只有一个实例。为什么 <code>static</code> 在这里是关键？</li>
<li>研究懒汉式单例 (Lazy Initialization Singleton) 和饿汉式单例 (Eager Initialization Singleton) 的区别。</li>
</ul>
</li>
<li><p><strong><code>static</code> 成员在多线程环境下的注意事项：</strong></p>
<ul>
<li>如果多个线程同时创建或销毁 <code>Car</code> 对象，<code>num_of_cars</code> 计数器可能会出现什么问题（例如，竞态条件 [race condition]）？</li>
<li>如何使用互斥锁 (mutex) 或原子操作 (atomic operations) 来保护 <code>static</code> 计数器，使其在多线程环境下也能正确工作？</li>
</ul>
</li>
<li><p><strong><code>static</code> 局部变量与 <code>static</code> 成员变量的区别：</strong></p>
<ul>
<li>回顾一下在函数内部声明的 <code>static</code> 局部变量的特性。它们与 <code>static</code> 成员变量有何异同？何时应该使用它们？</li>
</ul>
</li>
<li><p><strong><code>static</code> 成员与非成员 <code>static</code> 函数/变量：</strong></p>
<ul>
<li>C++ 中除了类的 <code>static</code> 成员外，还有文件作用域的 <code>static</code> 变量和函数。它们有什么作用？与类 <code>static</code> 成员的 <code>static</code> 关键字含义有何联系和区别？（提示：关于链接性 [linkage]）</li>
</ul>
</li>
</ol>
<p>这些问题将引导你探索 <code>static</code> 关键字更深层次的含义，以及它在 C++ 实际项目开发中的高级应用和潜在挑战。当你准备好讨论这些问题时，我们再一起深入学习！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Function/">Function    </a><a class="post-meta__tags" href="/tags/Software/">Software    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/325%20-%20%E7%B1%BB%E5%86%85%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>325 - 类内成员初始化</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/328%20-%20cpp%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>328 - cpp命名空间</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/Cpp 默认构造函数创建对象/" title="Cpp 默认构造函数创建对象"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">Cpp 默认构造函数创建对象</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/299 - 显式构造函数/" title="299 - 显式构造函数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">299 - 显式构造函数</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/302 - 对象数组复制陷阱/" title="302 - 对象数组复制陷阱"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">302 - 对象数组复制陷阱</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/312 - cpp 友元函数详解/" title="312 - cpp 友元函数详解"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">312 - cpp 友元函数详解</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/return type for lambda function template/" title="return type for lambda function template"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">return type for lambda function template</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/diff between constexpr and define/" title="diff between constexpr and define"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">diff between constexpr and define</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>