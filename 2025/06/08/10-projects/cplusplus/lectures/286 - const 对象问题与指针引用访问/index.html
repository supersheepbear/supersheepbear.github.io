<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>286 - const 对象问题与指针引用访问 | Bear's dream</title><meta name="description" content="286 - const 对象问题与指针引用访问"><meta name="keywords" content="Cpp,Coding,Class,Object,Pointer"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="286 - const 对象问题与指针引用访问"><meta name="twitter:description" content="286 - const 对象问题与指针引用访问"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="286 - const 对象问题与指针引用访问"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/286%20-%20const%20%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="286 - const 对象问题与指针引用访问"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/286%20-%20const%20%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE/"><link rel="prev" title="283 - cpp 类对象大小探究" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/283%20-%20cpp%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E6%8E%A2%E7%A9%B6/"><link rel="next" title="287 - const 对象作为函数参数的注意事项" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/287%20-%20const%20%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">152</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Const-对象问题与指针引用访问"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Const 对象问题与指针引用访问</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-中的-const-对象：美好的初衷与恼人的现实"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">C++ 中的 const 对象：美好的初衷与恼人的现实</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Const-对象问题与指针引用访问"><span class="toc-number">1.</span> <span class="toc-text">Const 对象问题与指针引用访问</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-中的-const-对象：美好的初衷与恼人的现实"><span class="toc-number">2.</span> <span class="toc-text">C++ 中的 const 对象：美好的初衷与恼人的现实</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">286 - const 对象问题与指针引用访问</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/286%20-%20const%20%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/286%20-%20const%20%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Const-对象问题与指针引用访问"><a href="#Const-对象问题与指针引用访问" class="headerlink" title="Const 对象问题与指针引用访问"></a>Const 对象问题与指针引用访问</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about cost objects.Suppose you have a class like this.The class is called Dog, and we have two sections in the class.We have a public section and we have a private section inside the class.We also have a few constructors and we have a destructor.But the important thing we want to look at in this lecture is the setters, which is this block here.And the getters that we have in this class now, we have this class declared.We don’t have the definitions in here because we could move them in a separate file to keep the headerclean.But suppose we created an object of this class and made it const.So we are declaring a dog object and it is made const here and when we make it const I want you to thinkabout what this means.It means that you can’t change any member variable in this object.Essentially, you can’t change the dog name, you can’t change the dog breed, you can’t change thedog age.If you try to do that, you’re going to get a compiler error.In this lecture, we’re going to see some problems that come with declaring your object cost.Then we’re going to see a solution to this in a few lectures ahead.So if we have our object declared here and we tried to set the name to another name, for example,through the call here, you would expect this to fail because this object is cast and we shouldn’t beable to modify any member variable of this object and say to name is going to try and modify the nameof the object.So this is going to give us a compiler error and we expect a compiler error.The problem is going to come if we try to call a function like print information here.And the print function is really trying to read from the dog object.The main purpose of this function is, for example, to read the dog name and print that out, to readthe breed name for the dog and print that out.It’s also going to read the age and print that out.It’s really not going to modify the object.But if we try to call this and compile our program, we’re going to get a compiler error.This is even going to be the case if we try to read using any of the getters we have in the function.This is going to be even the case if we try to read the dog name through any of the getters we havein our class.So, for example, if we say Dog one get name here, we’re going to get a compiler error.So why is this the case?The problem is we have no special way to differentiate between the getters and setters and tell thecompiler that the getters aren’t going to modify the data in the class and that the setters are onlygoing to be able to modify.We don’t really have a way to tell the compiler which methods are going to be modifying the objectsbecause we want our setters to modify the object and tell the compiler that our getters are innocent.They’re not going to try and modify the object in the eyes of the compiler.Our getters could also modify the object.So that’s the problem here, and that’s why we are getting a compiler error.If we try to call any of these methods on a const object.Okay, so we have a problem.And the problem again is that we can’t read data from our const objects, but we’re going to get theprotection from the compiler if we try to call the setter methods.But if we can’t read from our objects, our objects are really going to be useless.We are going to see a solution to this in a few lectures ahead.But first let’s address some thoughts some of you might have about this problem here.Some of you might be saying, What if we try and go through pointers or references and try to modifythe object or try to call our getters and see if things work?Well, I had to break it to you.That’s not going to work either.But let’s analyze this things case by case.Okay, so suppose we are trying to go through a pointer to Non-const and try to see if we can call oursetter or getter functions.So we have our object declared here and we have a pointer to dog.Notice that this is a pointer to Non-const.So this pointer could potentially be used to modify the object it is pointing to.And the moment we assign the address of our cast object to this pointer, we’re going to get a compilererror.The compiler is going to see that this pointer could be used to modify our const dog object.So it’s going to stop us from doing the assignment here.So this is going to fail.This is not going to work.Okay, so our first attempt failed, but what if we try to go through a non-const reference?Let’s see what happens.Again, we have our dog object.We are trying to set up a non-const reference to dog and we try to assign our dog object to this reference.Here again, the compiler is going to see that this reference could be used to modify our cast dog objectand it is going to store.Stop us from doing this assignment.So if we set up this assignment in our code, we’re going to get a compiler error.And the compiler error is going to say we can’t convert from a const.Doug Reference to Doug reference because that’s what we are trying to do here.Okay, so what if we try to go through pointer to cost?Let’s see what happens.We’re going to have our Doug object, which is const and we are going to set up a pointer to const.Doug That’s what we have here and we’re going to assign the address of our object to this pointer.So this is going to work, this is going to compile, but the moment we try to call a setter to ourDoug object, we’re going to get a compiler error.And this is expected because we have no business modifying a const object.But if we try to call an innocent getter function, which is not going to really modify our object,we’re also going to get a compiler error.And this is the same problem we saw before.But I want you to see this in the context of pointers and references here.So this is also not going to work.Okay, so what if we try to go through const references, We’re going to set up our Doug object andwe’re going to set up a const reference here and we’re going to assign our object to this reference.And the moment we try to go through our reference to modify the object, we’re going to get a compilererror, which is what we expect.But you see that if we even call our printing function here, we’re going to get a compiler error thatwe don’t really expect.So this is a problem with const objects and we need to find a solution to this.So we have seen that const objects are really problematic and if you set them up, you’re going to beprotected from changing your objects from the setters.But even your getters, which aren’t really modifying your object, the compiler is going to preventyou from calling them.And this is the problem I really want you to see and keep in your mind.Now that we have really described the problem, it is time we headed over to Visual Studio Code andshow you how this works in practice.Okay, here we are in our working folder.The current project is Const Objects.We’re going to grab our template files and put them in place.Let’s copy this and we’re going to put that in our folder and we are going to open this in Visual Studiocode like we always do.Let’s drag and drop here we have our folder open, let’s open the main CPP file and clean it up a littlebit.The first thing we’re going to do is to create our class that we’re going to be using to learn aboutthe problems you might come across if you use const objects in your C plus plus program.So we’re going to come to the left sidebar here and click on the plus icon, which says New file here.We’re going to create our header file, which is going to be called Doc Dot H, and we’re going to createanother file, which is going to be our CPP file.Let’s close the Open editors menu here because it’s confusing me so we’re going to also create a CPPfile.We’re going to say dot dot CPP and I am going to put in the code for the class because I have it prepared.So let’s paste that in here.I have the code in the header.I am going to go to the doc CPP file here, which is open and I’m going to put in the code that I haveprepared.Let’s go through this class a little bit because I don’t really want to waste your time typing this.We’re going to look at it and we’re going to see how it’s made.Then we’re going to try and use it.We have a class.It’s called Dog.It has a public section and a private section.Notice that our member variables now have been changed to string view because we want to avoid copieswhen we pass parameters to the constructors here.So that’s the reason why we used Stdstring view here.We also have a third member variable which is of unsigned and because the age can’t really be negative,so it makes sense to make this unsigned.And if you go on top here, we also have a few other functions.We have our getters get name, get breed, get age.They are going to be returning our member variables.We have a couple of setters.We have set name, set, breed, set age.They are going to be setting data to our member variables.We also have a utility function which is called principal and it’s going to print information aboutour class.So this is the definition of our class.But in the definition of the class, what we have are the prototypes for the functions.The definitions for the member functions are going to live in dog CPP, and if you go in dog CPP, you’regoing to have an include statement.Here, we’re going to have our constructor, which is going to use the parameters to initialize ourmember variables.We have our getters and all they will do is really return the member variables.One thing you should notice is that we have.The scope resolution operator in front of each function name here.So you see, Doug has a scope resolution operator in front.So this is going to tell the compiler that this function here belongs to the Doug class.That’s what the scope resolution operator here means.We have the same on our getters, so we have our scope resolution.Operator You can see that on get name, get breed and get age.You see that we also have that on our setters.The setters are going to be setting data in our member variables.So we’re going to set name, breed and age and our utility function is just going to print informationabout our class object.It’s just going to print.Doug It’s going to say the memory address where the object lives.It’s going to print the name, the breed and the age, and we’re going to see that on the console.So this is our class.If you don’t want to type it, you can get it from the resource section of this lecture and you canstart using it right away because this is going to take some time.But I do recommend spending some time to type this code.And because this is really how you learn.Another thing I haven’t explained I think is the include guard here.This is going to prevent people from including this twice.So the preprocessor is basically going to come in this file and say, if this thing here is not defined,I am going to define it and then I’m going to include whatever I have in this file here.If this thing is already defined, it’s not going to define this and it’s not going to include whatwe have here.So we have learnt about this before and we are reusing this here.So now that we have this class, let’s try to use it in main.We’re going to go to the main CPP file and we’re going to include our dog class.And we say that by saying quotes and inside the put in the class header file.And now that we have the class included, we can try and use it in the main function.So we’re going to say dog and say dog one and we’re going to pass in the information to use our constructor.We’re going to pass in the name, which is going to be fluffy like always.We’re going to pass in the breed, which is going to be Shefford, and we’re going to pass in the ageof the dog.Now that we have this, we can try and print information about this dog.So we’re going to say dog one and say print info.This is going to call our print function that we have in the class.So if we go back to the class definition we have in Dog dot H, we’re going to see that print info isgoing to print information.But another thing you can do in Visual Studio code is right click on the class and say, Go to definition.When you do that, it’s not going to do that.So this doesn’t work in Visual Studio code, but we can go and find the definition for the functionourselves.So print your form is going to print dog.It’s going to say the address of the object and it’s going to print information about our object.So we’re going to have name, breed and age printed out here, and we’re going to be respectively printingour member variables here.So let’s go back to Main and we’re going to try and build this program with GCC.The build is good.We can bring up a terminal and say Clear and run a rooster.Now you’re going to see that we have the information about our dog object here printed out.We say dog.We say the memory location for this object.And we’re going to say information about this dog, the name, the breed and the age here.All this information is available.We can use our setters.So, for example, we can go in here and say, dog one, set name and change this to me, for example.Why not?And it’s going to be Wire Fox.We’re going to set the name, nothing else.So we’re going to say Milu here and we’re going to print the information again.We’re going to say dog one printable.And if we do that, you see that the program is going to work.Visual Studio Code is not complaining.If we try to compile this program with GCC, you’re going to see that the world is good.And if we run, we’re going to see that our setting has applied to our object.The name is Fluffy, then the name is male.So the set name function here is doing its job.Now, what we really want to see in this lecture is how to work with const objects.So we’re going to change this dog.One object here to be const, let’s do that.And the moment we do that, you’re going to see problems pop up.We change this guy to const here by appending or prepending the const keyword in front.And if we try to build this program, we’re going to pass this through GCC, we’re going to get compilererrors and you see that we have a few squiggly lines here show up.The first problem that we really expect is.When we try to set the name.Because now, because this object is cast, we can’t really change any of its member variables.So if we try to change the name, the breed or the age, we’re going to get a compiler error.And here we have that compiler error.We are trying to change the name of a const object.So we can’t do that.We’re going to get a compiler error.So we’re going to see the message here which says that we have a problem at line nine in our code.If we go to line nine, you see that we are calling Printinfo, but we’re not going to look at thisjust yet and we’re going to see that we have a problem again on line 11, which is what we are interestedin looking at now.But it’s also going to say that we have a problem with our setname function call.Here we have on line 11 and it’s going to say that const Doug as this argument discards the const qualifier.So what’s the error here means is that we are trying to modify our const Doug object through the displayor because the setname function here is going to be using the this pointer to set the member variable.So what I haven’t really explained here is that, for example, if we use the setname function, let’slook at the definition.We say M name equals name param.What the compiler is really going to generate in the background is use the this keyword or the thispointer and it’s going to say this m name, then it’s going to say equals name param.This is what the compiler is going to do.And going through the this pointer, you can really modify this object.So this is what the compiler is saying here.It’s saying that this pointer that you have in your function call is going to discard the const qualifierwe have in the main function.In other words, you can go through the this pointer and modify a const object and we can’t allow youto do that.We’re going to give you a compiler error.We actually have the same problems with our calls to Printinfo because that’s going to do the same thingthrough our function calls.So let’s go back to the definition.You see that we are accessing.M name.M Breed.M age.We are actually not modifying anything in this function, but the compiler doesn’t know that.We know that we are not modifying our function.But what the compiler is going to look at is the signature of the function here.And if you look, there is really nothing telling the compiler that this function couldn’t modify ourobject here.That’s why the compiler is stopping us from doing this altogether.So the compiler is going to look at what we do here.It’s going to change our references to the member variables to this using the this pointer.So it’s going to say this M name, it’s going to say this M breed and it’s going to change this to thisM age.And it’s going to see that we could go through the this pointer and modify stuff about our object,and it’s going to stop us from using this function altogether.On const objects, you have seen that this function was working when the object wasn’t const, but nowit is cost and we could go through the printf function to modify our object.The compiler is going to give us a compiler error here.Hopefully you can understand this and I want you to know that this is the case.So let’s say that this is a compiler error.So this is the problem I want you to see with const objects.If you flag your object as const, you want to be able to modify the object through the setters, butno other function is going to work anymore because the compiler is going to think that you could gothrough those functions to modify your object.So some of you might be saying, What if we try and go through pointers and references which are eitherconst or not cost?Let’s try and see that we’re going to comment this out and we’re going to say direct access here, meaningthat we are going directly through the object name to try and do stuff.We go through the object name and call Printinfo.We’re going to get a compiler error.We go through the direct object, we try to set the name, we’re going to get a compiler error.This is what we mean here by direct access.Okay, so let’s try and go through a pointer to Non-const and see if we can access this function hereand do things with them.We’re going to go down here and set up a pointer.We’re going to say Doug Pointer.It’s a pointer to Non-const, so it’s just going to be a Doug Pointer.We’re going to say Doug TR and we’re going to initialize this with the address of our Doug object.Let’s say that Doug one and at the moment we do that we should get a problem because this is a non-constpointer.We could go through it to modify this object here.And if we even try to compile the code by now, we’re going to get a.Hi there.Okay, we have our compiler error.And what the compiler error is going to say is we are passing a const dog as this argument and thisis going to discard our qualifier.Why is that?We’re not doing that here?This was from before, but if we go down here, we’re going to see a compiler error that says invalidconversion from const dog pointer to dog pointer.So what we have to the right of the assignment here is really a const dog pointer.It is a pointer to cast because we are using a const object here.But what we have on the left of the assignment here is a non const pointer and the compiler is goingto notice that we could go through this pointer and modify this object here.So it’s going to stop us from setting up this pointer altogether.So this is not going to work either.And it is what I wanted you to see.Okay, so a non const pointer is not going to work, but what about a non const reference?Let’s do that and we’re going to set up a non-const reference to our object.We’re going to say dog reference and say dog ref and we’re going to assign dog one and we’re going toget the same behavior.This is a non const reference and we are trying to assign a const reference to a non const reference.If we try to compile the program, let’s do that.We’re going to get the same compiler error and you see binding reference of type dog reference to constdog reference.So this is going to not work.We’re going to get the same compiler error because we could go through this reference and modify thiscast object.The compiler is going to stop us from doing this altogether.Okay, this is not going to work.Let’s comment this out.Okay.Some of you might be saying, what if we change our pointer to cast so we can go down here and say thatlet’s say pointer to const and we’re going to set up a const dog pointer, which is going to be constDog Peter.We can call it like this and we’re going to assign the address of Dog one.And if we do this and compile, the compiler is going to trust this pointer.Now because it is a const pointer.We can’t go through this pointer to modify the object we are pointing to now.So the compiler is going to trust us with this pointer.If we build, you’re going to see that the code is going to work.So this is a good step forward.But if we try to do anything with this pointer, let’s do that.We’re going to say const dog pointer and we’re going to say set name.And we try to set the name to Milu, for example.This is not going to go well because we are trying to go through a const pointer to modify stuff.So this is going to give us a compiler error because we’re not allowed to do that.We can’t go through this pointer and modify our object.We’re going to see that the compiler error is saying const dog as this argument discards the qualifierof const.So we can’t say set name through this pointer because we are pointing to a const object and this isa pointer to cast.So this is expected because this is a pointer to const.We really expect not to be able to go through the pointer to modify the object, but even our gettersare not going to work.So if we say const dog pointer and say get name, for example, this is a getter.It’s really not modifying the object, but the compiler doesn’t know that.It doesn’t know that this function isn’t modifying our object because what really the compiler looksat is the signature of the function.It’s going to look at the gate name, let’s look at that.It’s going to look at this function and it’s going to say, There is nothing telling me that this functioncouldn’t modify our object.So I’m going to stop you from trying to even call that function in the main function here.If you try to call it, I’m going to throw a compiler error.That’s what the compiler is going to say.And if we try to world, let’s do that, we’re going to get a compiler error and it’s going to say thesame thing that this argument that is used in this getName function.And if we go in get name again, the compiler is going to see what we do here and it’s going to changethis to return this name.And it’s going to say you could go through this pointer here and modify this object.So I am going to stop you from doing that.That’s why we have this compiler error pointer to const isn’t also going to work.So what if we use the const reference?We’re going to go down and try to use this.We’re going to say const dog reference and I say const dog ref and we’re going to assign dog one whatwe always do.Now the compiler is going to trust this reference because it is cast.Let’s try and compile and really prove this to see the world is good.But again, if we try and go through this and do anything, we’re going to say.Cast a dark wrath.And I tried to set the name, for example, and we’re going to change the name to Milu.That’s what we want to do.And if we compile, we’re going to get a compiler error.Let’s do that.We’re going to use GCC.You see, we have a compiler error and the compiler error says this argument could be used to modifythe objects.So I want to let you use set name here.That’s the compiler error.And we expect that because we are going through a Const reference and we can’t really go through a constreference to modify the object we are referencing.So this is expected.But what is not expected is not to be able to even read stuff from our const object.So for example, if we say const dog reference and say get name, let’s use this here.We expect this call to work.But if we build, we’re going to really be surprised that it is not working again with the compilererror is going to say const dog.This argument discards the const qualifier because because we could go through the this pointer insidethis function definition and modify our const object here.So I am going to stop you from doing that and I am going to throw a compiler error.This is really what I wanted you to see in this lecture, that when your object is const, you’re goingto be locked away from using your object and it is practically useless because you can’t either readfrom it and you can’t write to it.We’re going to stop here in this lecture and in the next one I am going to show you that you’re goingto have the same problems if you try to use this object as an argument to functions.Then in the following lecture I am going to show you how we can solve this problem.So go ahead and finish up here and meet me in the next lecture.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，C++ 新同学你好！非常欢迎来到 C++ 的世界。今天我们来聊一聊一个非常重要的概念：<code>const</code> 对象 (const objects)。这节课我们会发现，有时候想让一个对象保持不变，反而会遇到一些意想不到的麻烦。别担心，我会一步一步带你弄清楚！</p>
<h1 id="C-中的-const-对象：美好的初衷与恼人的现实"><a href="#C-中的-const-对象：美好的初衷与恼人的现实" class="headerlink" title="C++ 中的 const 对象：美好的初衷与恼人的现实"></a>C++ 中的 <code>const</code> 对象：美好的初衷与恼人的现实</h1><p><strong>简要总结：</strong></p>
<p>当我们把一个对象声明为 <code>const</code> (常量)，意味着我们不希望它的任何成员变量被修改。这在很多情况下是非常有用的，比如确保数据在传递过程中不被意外更改。然而，C++ 编译器在处理 <code>const</code> 对象时，为了保证这种“不变性”，会严格限制我们能对这个对象做什么。令人困惑的是，有时候即使我们只是想读取对象的信息（比如调用一个“获取”方法），编译器也可能会报错。这节课我们就来深入探讨这个问题，并为后续学习解决方案打下基础。</p>
<hr>
<p><strong>详细解释：</strong></p>
<p>我们先来看一个你可能会在编程中用到的例子。想象我们有一个 <code>Dog</code> (狗) 类：</p>
<p><strong>1. <code>Dog</code> 类的设计</strong></p>
<p>这个 <code>Dog</code> 类有它自己的属性（比如名字、品种、年龄）和行为（比如设置名字、获取名字、打印信息）。</p>
<ul>
<li><p><strong>头文件 (<code>dog.h</code>)</strong>: 通常我们会把类的声明放在头文件中。</p>
<ul>
<li><strong>包含守卫 (Include Guards)</strong>:<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOG_H</span></span><br><span class="line"><span class="comment">// ... 类的声明 ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DOG_H</span></span></span><br></pre></td></tr></table></figure></div>
这几行代码叫做“包含守卫”。它们的作用是防止同一个头文件被意外地多次包含到同一个源文件中，那样会导致编译错误。<code>#ifndef DOG_H</code> 检查 <code>DOG_H</code> 这个宏是否还没被定义。如果没定义，<code>#define DOG_H</code> 就会定义它，然后处理中间的代码。如果下次再遇到 <code>#include &quot;dog.h&quot;</code>，由于 <code>DOG_H</code> 已经被定义了，<code>#ifndef</code> 到 <code>#endif</code> 之间的代码就会被跳过。</li>
<li><strong>成员变量 (Member Variables)</strong>:<ul>
<li><code>m_name</code> (名字): 我们使用了 <code>std::string_view</code> 类型。<code>std::string_view</code> (字符串视图) 是一个轻量级的对象，它“指向”一个已存在的字符串数据，但本身不拥有这个数据。这样做的好处是，在传递字符串时可以避免不必要的拷贝，提高效率。</li>
<li><code>m_breed</code> (品种): 同样是 <code>std::string_view</code>。</li>
<li><code>m_age</code> (年龄): 我们使用了 <code>unsigned int</code> (无符号整型)，因为年龄通常不会是负数。<br>这些成员变量通常放在 <code>private</code> (私有)区域，意味着它们只能被类自己的成员函数访问，外部代码不能直接修改它们，这是一种封装 (encapsulation) 的体现。</li>
</ul>
</li>
<li><strong>成员函数 (Member Functions)</strong>:<ul>
<li><strong>构造函数 (Constructors)</strong>: 用于创建和初始化 <code>Dog</code> 对象。</li>
<li><strong>析构函数 (Destructor)</strong>: 在对象生命周期结束时执行清理工作（在这个例子中比较简单，可能为空）。</li>
<li><strong>Setters (设置器)</strong>: 例如 <code>set_name()</code>, <code>set_breed()</code>, <code>set_age()</code>。这些函数用于修改对象的成员变量。</li>
<li><strong>Getters (获取器)</strong>: 例如 <code>get_name()</code>, <code>get_breed()</code>, <code>get_age()</code>。这些函数用于读取对象的成员变量的值。</li>
<li><strong>工具函数 (Utility Functions)</strong>: 例如 <code>print_info()</code>，用于打印狗狗的全部信息。<br>这些成员函数通常放在 <code>public</code> (公共)区域，意味着外部代码可以调用它们。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>源文件 (<code>dog.cpp</code>)</strong>: 通常我们会把类成员函数的具体实现（定义）放在源文件中。</p>
<ul>
<li>在源文件中，你需要 <code>#include &quot;dog.h&quot;</code> 来引入类的声明。</li>
<li><strong>作用域解析运算符 (Scope Resolution Operator) <code>::</code></strong>: 当你在 <code>.cpp</code> 文件中定义成员函数时，你需要告诉编译器这个函数属于哪个类。例如：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 dog.cpp 中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 为了 std::cout</span></span></span><br><span class="line"></span><br><span class="line">Dog::Dog(<span class="built_in">std</span>::string_view name_param, <span class="built_in">std</span>::string_view breed_param, <span class="keyword">unsigned</span> <span class="keyword">int</span> age_param)</span><br><span class="line">    : m_name(name_param), m_breed(breed_param), m_age(age_param) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog 对象被创建了: "</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::string_view <span class="title">Dog::get_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::set_name</span><span class="params">(<span class="built_in">std</span>::string_view new_name)</span> </span>&#123;</span><br><span class="line">    m_name = new_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 其他函数的定义 ...</span></span><br></pre></td></tr></table></figure></div>
这里的 <code>Dog::</code> 就是作用域解析运算符，它表明 <code>Dog(...)</code> 构造函数、<code>get_name()</code> 函数等是 <code>Dog</code> 类的一部分。</li>
</ul>
</li>
</ul>
<p><strong>2. 什么是 <code>const</code> 对象？</strong></p>
<p>现在，假设我们创建了一个 <code>Dog</code> 对象，并且我们希望这个对象一旦创建后就不能被修改。我们可以使用 <code>const</code> 关键字 (keyword) 来声明它：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Dog <span class="title">dog1</span><span class="params">(<span class="string">"小黄"</span>, <span class="string">"中华田园犬"</span>, <span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p>这里的 <code>const</code> 告诉编译器：<code>dog1</code> 是一个常量对象。这意味着 <code>dog1</code> 的任何成员变量（<code>m_name</code>, <code>m_breed</code>, <code>m_age</code>）都不应该被改变。</p>
<p><strong>3. <code>const</code> 对象带来的问题</strong></p>
<ul>
<li><p><strong>调用 Setter (设置器)：</strong><br>如果你试图修改 <code>dog1</code> 的属性，比如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dog1.set_name("小白"); // 尝试修改 const 对象的名字</span></span><br></pre></td></tr></table></figure></div>
<p>编译器会报错！这是符合我们预期的，因为 <code>dog1</code> 是 <code>const</code> 的，我们不希望它被修改。<code>set_name</code> 函数的目的是修改 <code>m_name</code>，这显然违背了 <code>const</code> 对象的初衷。</p>
</li>
<li><p><strong>调用 Getter (获取器) 或其他看似只读的函数：</strong><br>现在麻烦来了。如果我们只是想打印狗狗的信息或者获取它的名字呢？</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dog1.print_info();      // 尝试打印 const 对象的信息</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; dog1.get_name(); // 尝试获取 const 对象的名字</span></span><br></pre></td></tr></table></figure></div>
<p>你可能会惊讶地发现，这两行代码同样会导致<strong>编译错误</strong>！</p>
<p><strong>为什么会这样呢？</strong><br>问题在于，编译器如何判断一个成员函数是否会修改对象？默认情况下，编译器会假设任何普通的成员函数都有可能修改对象的成员变量。它不会去分析函数体内部的具体代码（比如 <code>print_info</code> 只是 <code>std::cout</code>，<code>get_name</code> 只是 <code>return m_name;</code>）。</p>
<p>对于一个非 <code>const</code> 成员函数（比如我们目前定义的 <code>print_info</code> 和 <code>get_name</code>），编译器认为它们内部的 <code>this</code> 指针 (this pointer) 是一个指向非 <code>const</code> 对象的指针 (例如 <code>Dog* this</code>)。当你用一个 <code>const Dog</code> 对象去调用这样一个函数时，相当于要把一个 <code>const Dog*</code> (指向 <code>const</code> 对象的指针) 传递给一个期望 <code>Dog*</code> (指向非 <code>const</code> 对象的指针) 的 <code>this</code> 指针。这种转换会“丢弃 <code>const</code> 限定符”，是不安全的，因为函数内部可能会通过这个非 <code>const</code> 的 <code>this</code> 指针修改对象。因此，编译器为了安全起见，直接禁止了这种调用。</p>
<p>简单来说，<strong>编译器看到 <code>print_info()</code> 和 <code>get_name()</code> 没有被特殊标记为“保证不会修改对象”，所以它就认为这些函数可能会修改对象，因此不允许在 <code>const</code> 对象上调用它们。</strong></p>
</li>
</ul>
<p><strong>4. 尝试通过指针或引用访问 <code>const</code> 对象</strong></p>
<p>有些同学可能会想，能不能通过指针或引用来绕过这个问题呢？我们来试试：</p>
<ul>
<li><p><strong>指向非 <code>const</code> 对象的指针 (Pointer to Non-const):</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Dog <span class="title">dog1</span><span class="params">(<span class="string">"小黄"</span>, <span class="string">"中华田园犬"</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// Dog* ptr_dog = &amp;dog1; // 编译错误！</span></span><br></pre></td></tr></table></figure></div>
<p>这行代码会产生编译错误。为什么？因为 <code>dog1</code> 是 <code>const Dog</code> 类型，所以 <code>&amp;dog1</code> (取地址) 得到的是一个 <code>const Dog*</code> (指向 <code>const Dog</code> 的指针)。你不能把一个 <code>const Dog*</code> 赋值给一个 <code>Dog*</code> (指向非 <code>const Dog</code> 的指针)，因为这样做会丢失 <code>const</code> 限定，使得你可以通过 <code>ptr_dog</code> 来修改 <code>dog1</code> 的内容，这就破坏了 <code>dog1</code> 的常量性。编译器会阻止这种危险行为，错误信息通常是 “invalid conversion from ‘const Dog<em>’ to ‘Dog</em>’”。</p>
</li>
<li><p><strong>非 <code>const</code> 对象的引用 (Reference to Non-const):</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Dog <span class="title">dog1</span><span class="params">(<span class="string">"小黄"</span>, <span class="string">"中华田园犬"</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="comment">// Dog&amp; ref_dog = dog1; // 编译错误！</span></span><br></pre></td></tr></table></figure></div>
<p>同样，这也会编译错误。<code>dog1</code> 是 <code>const Dog</code>，你不能把它绑定到一个非 <code>const</code> 的引用 <code>Dog&amp;</code> 上。原因和指针类似，如果允许这样做，你就可以通过 <code>ref_dog</code> 修改 <code>dog1</code>。错误信息通常是 “binding reference of type ‘Dog&amp;’ to ‘const Dog’ discards qualifiers”。</p>
</li>
<li><p><strong>指向 <code>const</code> 对象的指针 (Pointer to const):</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Dog <span class="title">dog1</span><span class="params">(<span class="string">"小黄"</span>, <span class="string">"中华田园犬"</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> Dog* ptr_const_dog = &amp;dog1; <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure></div>
<p>这个是允许的。<code>ptr_const_dog</code> 是一个指向 <code>const Dog</code> 的指针，这意味着你不能通过 <code>ptr_const_dog</code> 来修改 <code>dog1</code> 所指向的对象。<br>但是，问题依旧：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ptr_const_dog-&gt;set_name("小白"); // 编译错误！ (符合预期，不能通过 const 指针修改)</span></span><br><span class="line"><span class="comment">// ptr_const_dog-&gt;print_info();   // 编译错误！ (和直接调用 dog1.print_info() 一样的问题)</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ptr_const_dog-&gt;get_name(); // 编译错误！ (和直接调用 dog1.get_name() 一样的问题)</span></span><br></pre></td></tr></table></figure></div>
<p>即使我们用了 <code>const</code> 指针，调用那些普通的 getter 或 <code>print_info</code> 仍然失败，因为这些函数本身没有被声明为 <code>const</code> 成员函数。</p>
</li>
<li><p><strong><code>const</code> 对象的引用 (Reference to const):</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Dog <span class="title">dog1</span><span class="params">(<span class="string">"小黄"</span>, <span class="string">"中华田园犬"</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> Dog&amp; ref_const_dog = dog1; <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure></div>
<p>这也是允许的。<code>ref_const_dog</code> 是一个对 <code>const Dog</code> 的引用。<br>同样的问题：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref_const_dog.set_name("小白"); // 编译错误！ (符合预期)</span></span><br><span class="line"><span class="comment">// ref_const_dog.print_info();   // 编译错误！</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ref_const_dog.get_name(); // 编译错误！</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<p><strong>总结一下当前的困境：</strong><br>一旦对象被声明为 <code>const</code>，我们就无法调用那些没有被特殊标记为“安全”（即不会修改对象）的成员函数，即使这些函数实际上只是读取数据。这使得 <code>const</code> 对象在当前情况下几乎“毫无用处”，因为我们既不能写也不能（安全地）读。</p>
<p>别灰心！这个问题是有解决方案的（就是将成员函数声明为 <code>const</code> 成员函数），我们会在接下来的课程中学习。现在，重要的是理解为什么会产生这些编译错误。</p>
<hr>
<p><strong>代码示例：</strong></p>
<p>我们会创建三个文件：<code>dog.h</code> (类声明), <code>dog.cpp</code> (类定义), 和 <code>main.cpp</code> (主程序，使用 <code>Dog</code> 类)。</p>
<p><strong><code>dog.h</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt; // 为了 std::string_view</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    // 为了 std::cout (虽然通常定义在.cpp，但print_info内联的话可能放这里)</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::string_view m_name;</span><br><span class="line">    <span class="built_in">std</span>::string_view m_breed;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="comment">// 一个静态成员，用于演示析构函数（可选）</span></span><br><span class="line">    <span class="comment">// static inline size_t dog_count&#123;&#125;; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Dog(<span class="built_in">std</span>::string_view name_param, <span class="built_in">std</span>::string_view breed_param, <span class="keyword">unsigned</span> <span class="keyword">int</span> age_param);</span><br><span class="line">    Dog(); <span class="comment">// 默认构造函数</span></span><br><span class="line">    ~Dog(); <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">get_name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">get_breed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setters</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="built_in">std</span>::string_view name_param)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_breed</span><span class="params">(<span class="built_in">std</span>::string_view breed_param)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> age_param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工具函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DOG_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>dog.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dog.h"</span> <span class="comment">// 包含类声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数定义</span></span><br><span class="line">Dog::Dog(<span class="built_in">std</span>::string_view name_param, <span class="built_in">std</span>::string_view breed_param, <span class="keyword">unsigned</span> <span class="keyword">int</span> age_param)</span><br><span class="line">    : m_name(name_param), m_breed(breed_param), m_age(age_param) &#123;</span><br><span class="line">    <span class="comment">// dog_count++;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗 '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' 被参数化构造了。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog::Dog() : Dog(<span class="string">"无名氏"</span>, <span class="string">"未知品种"</span>, <span class="number">0</span>) &#123; <span class="comment">// 委托构造</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗 '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' 被默认构造了。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数定义</span></span><br><span class="line">Dog::~Dog() &#123;</span><br><span class="line">    <span class="comment">// dog_count--;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗 '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' 被析构了。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Getters 定义</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::string_view <span class="title">Dog::get_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::string_view <span class="title">Dog::get_breed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_breed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Dog::get_age</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setters 定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::set_name</span><span class="params">(<span class="built_in">std</span>::string_view name_param)</span> </span>&#123;</span><br><span class="line">    m_name = name_param;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗的名字被设置为: "</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::set_breed</span><span class="params">(<span class="built_in">std</span>::string_view breed_param)</span> </span>&#123;</span><br><span class="line">    m_breed = breed_param;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗的品种被设置为: "</span> &lt;&lt; m_breed &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::set_age</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> age_param)</span> </span>&#123;</span><br><span class="line">    m_age = age_param;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗的年龄被设置为: "</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::print_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为了演示 this 指针，我们打印一下对象的地址</span></span><br><span class="line">    <span class="comment">// 在成员函数内部，this 是一个指向调用该函数的对象的指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗信息 (对象地址: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  名字: "</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 编译器会理解为 this-&gt;m_name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  品种: "</span> &lt;&lt; m_breed &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// this-&gt;m_breed</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  年龄: "</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;   <span class="comment">// this-&gt;m_age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>main.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dog.h"</span> <span class="comment">// 包含 Dog 类</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 非 const 对象测试 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Dog <span class="title">dog_non_const</span><span class="params">(<span class="string">"旺财"</span>, <span class="string">"拉布拉多"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    dog_non_const.print_info();</span><br><span class="line">    dog_non_const.set_name(<span class="string">"大黄"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"旺财的新名字: "</span> &lt;&lt; dog_non_const.get_name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    dog_non_const.print_info();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- const 对象测试 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Dog <span class="title">dog_const</span><span class="params">(<span class="string">"常量狗"</span>, <span class="string">"金毛"</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建 const 对象 dog_const"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 尝试调用 setter - 应该编译失败 (符合预期)</span></span><br><span class="line">    <span class="comment">// dog_const.set_name("试图修改"); // 取消注释这行会导致编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尝试调用 getter - 应该编译失败 (这就是问题所在!)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "常量狗的名字: " &lt;&lt; dog_const.get_name() &lt;&lt; std::endl; // 取消注释这行会导致编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 尝试调用 print_info - 应该编译失败 (这也是问题所在!)</span></span><br><span class="line">    <span class="comment">// dog_const.print_info(); // 取消注释这行会导致编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- const 对象与指针/引用测试 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 4. 尝试用非 const 指针指向 const 对象 - 应该编译失败</span></span><br><span class="line">    <span class="comment">// Dog* ptr_non_const_to_const = &amp;dog_const; // 取消注释这行会导致编译错误</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "ptr_non_const_to_const 创建失败 (预期中)" &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 尝试用非 const 引用绑定 const 对象 - 应该编译失败</span></span><br><span class="line">    <span class="comment">// Dog&amp; ref_non_const_to_const = dog_const; // 取消注释这行会导致编译错误</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "ref_non_const_to_const 创建失败 (预期中)" &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 使用 const 指针指向 const 对象 - OK</span></span><br><span class="line">    <span class="keyword">const</span> Dog* ptr_const_to_const = &amp;dog_const;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_const_to_const 创建成功: "</span> &lt;&lt; ptr_const_to_const &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// ptr_const_to_const-&gt;set_name("再次尝试修改"); // 编译错误 (预期中)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "名字: " &lt;&lt; ptr_const_to_const-&gt;get_name() &lt;&lt; std::endl; // 编译错误 (问题依旧)</span></span><br><span class="line">    <span class="comment">// ptr_const_to_const-&gt;print_info(); // 编译错误 (问题依旧)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 使用 const 引用绑定 const 对象 - OK</span></span><br><span class="line">    <span class="keyword">const</span> Dog&amp; ref_const_to_const = dog_const;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref_const_to_const 绑定成功"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// ref_const_to_const.set_name("又双叒叕尝试修改"); // 编译错误 (预期中)</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "名字: " &lt;&lt; ref_const_to_const.get_name() &lt;&lt; std::endl; // 编译错误 (问题依旧)</span></span><br><span class="line">    <span class="comment">// ref_const_to_const.print_info(); // 编译错误 (问题依旧)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123; <span class="comment">// 只是为了让上面的注释行不影响程序正常结束的输出</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n(请取消上面main.cpp中标注为会导致编译错误的行来观察编译器的报错信息)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n程序演示结束。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><strong>编译和运行：</strong><br>你需要一个 C++ 编译器（如 G++）。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp dog.cpp -o main_program -std=c++17</span><br><span class="line">./main_program</span><br></pre></td></tr></table></figure></div><br>当你取消 <code>main.cpp</code> 中那些会导致错误的行的注释时，你会看到编译器报错。仔细阅读编译器的错误信息，它们通常会提示类似 “passing ‘const Dog’ as ‘this’ argument discards qualifiers” 这样的信息。</p>
<hr>
<p><strong>QA 闪卡 (QA Flash Cards):</strong></p>
<ol>
<li><p><strong>Q:</strong> 什么是 <code>const</code> 对象 (const object)？<br><strong>A:</strong> 一个在初始化之后，其成员变量的值不能被修改的对象。它通过 <code>const</code> 关键字声明。</p>
</li>
<li><p><strong>Q:</strong> 为什么在一个 <code>const</code> 对象上调用一个看起来只是读取数据（如 <code>get_name()</code>）的普通成员函数也会导致编译错误？<br><strong>A:</strong> 因为编译器默认情况下无法保证这个普通成员函数不会修改对象内部的数据。它看到的是函数签名 (function signature)，而不是函数体。除非该函数被明确标记为 <code>const</code> 成员函数（我们将在后续课程学习），否则编译器会认为它可能会修改对象，因此禁止在 <code>const</code> 对象上调用。</p>
</li>
<li><p><strong>Q:</strong> 尝试将一个 <code>const</code> 对象的地址赋值给一个非 <code>const</code> 指针 (pointer to non-const) 会发生什么？例如 <code>Dog* ptr = &amp;const_dog_object;</code><br><strong>A:</strong> 会导致编译错误。因为这样做会丢失 <code>const</code> 限定，使得程序可能通过这个非 <code>const</code> 指针修改一个本应是 <code>const</code> 的对象，这是不安全的。</p>
</li>
<li><p><strong>Q:</strong> <code>this</code> 指针 (this pointer) 在 <code>const</code> 对象调用成员函数时扮演了什么角色？<br><strong>A:</strong> 在一个普通的（非 <code>const</code>）成员函数内部，<code>this</code> 指针的类型是 <code>ClassName*</code> (例如 <code>Dog*</code>)。当你在一个 <code>const ClassName</code> (例如 <code>const Dog</code>) 对象上尝试调用这个普通成员函数时，编译器需要将对象的地址（类型为 <code>const ClassName*</code>）传递给 <code>this</code> 指针。从 <code>const ClassName*</code> 到 <code>ClassName*</code> 的转换会“丢弃 <code>const</code> 限定符”，这是一种危险操作，所以编译器会报错。</p>
</li>
</ol>
<hr>
<p><strong>常见误解或新手易犯错误：</strong></p>
<ol>
<li><p><strong>误解：“我的 <code>getter</code> 函数明明只是返回一个成员变量，它肯定不会修改对象，所以它应该能在 <code>const</code> 对象上调用。”</strong></p>
<ul>
<li><strong>纠正：</strong> 编译器并不去分析你函数体内部的逻辑。它只看函数的声明。如果一个成员函数没有在其声明的末尾标记 <code>const</code> (例如 <code>std::string_view get_name() const;</code>)，编译器就认为它是一个可能会修改对象的函数，因此不允许在 <code>const</code> 对象上调用它。</li>
</ul>
</li>
<li><p><strong>错误：认为只要是指针或引用被声明为 <code>const</code>（例如 <code>const Dog* ptr</code>），那么它指向的对象的所有方法都能被安全调用。</strong></p>
<ul>
<li><strong>纠正：</strong> <code>const Dog* ptr</code> 意味着你<em>不能通过 <code>ptr</code> 这个指针来修改</em>它所指向的对象。但是，能否调用对象的某个方法，取决于该方法本身是不是 <code>const</code> 成员函数。如果方法不是 <code>const</code> 成员函数，那么即使通过 <code>const Dog*</code> 指针调用，也会失败。</li>
</ul>
</li>
<li><p><strong>混淆“指向常量的指针/引用”和“常量指针/引用本身”：</strong></p>
<ul>
<li><code>const Dog* p;</code> // p 是一个指针，它指向一个 <code>Dog</code> 对象，这个 <code>Dog</code> 对象通过p来看是常量（不能通过p修改）。p本身可以指向其他<code>Dog</code>对象。</li>
<li><code>Dog* const p;</code> // p 是一个常量指针，p一旦初始化后不能再指向其他对象，但它指向的 <code>Dog</code> 对象可以通过p来修改（如果对象本身不是const）。</li>
<li>本节课主要讨论的是<strong>对象本身是 <code>const</code></strong> (<code>const Dog my_dog;</code>)，或者通过<strong>指向常量的指针/引用</strong> (<code>const Dog* ptr;</code> 或 <code>const Dog&amp; ref;</code>) 来访问对象时遇到的问题。</li>
</ul>
</li>
<li><p><strong>试图用 <code>const_cast</code> 去掉 <code>const</code> 性质来调用非 <code>const</code> 成员函数：</strong></p>
<ul>
<li>虽然 <code>const_cast</code> 可以用来移除变量的 <code>const</code> 限定，但如果原始对象确实是以 <code>const</code> 方式定义的，然后你通过 <code>const_cast</code> 修改了它，这是未定义行为 (undefined behavior)，非常危险，应该避免。我们这里遇到的问题，正确的解决方式是修改类的设计（使用 <code>const</code> 成员函数），而不是试图“欺骗”编译器。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>编码练习：</strong></p>
<p>下面是 <code>dog.h</code> 和 <code>dog.cpp</code> 的代码（和上面示例一样，你可以直接复制使用）。你的任务是补全 <code>main.cpp</code> 中的 <code>// TODO:</code> 部分，并观察编译器的行为。</p>
<p><strong><code>dog.h</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::string_view m_name;</span><br><span class="line">    <span class="built_in">std</span>::string_view m_breed;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">std</span>::string_view name_param, <span class="built_in">std</span>::string_view breed_param, <span class="keyword">unsigned</span> <span class="keyword">int</span> age_param);</span><br><span class="line">    Dog();</span><br><span class="line">    ~Dog();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">get_name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::string_view <span class="title">get_breed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_age</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="built_in">std</span>::string_view name_param)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_breed</span><span class="params">(<span class="built_in">std</span>::string_view breed_param)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> age_param)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DOG_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>dog.cpp</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dog.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">Dog::Dog(<span class="built_in">std</span>::string_view name_param, <span class="built_in">std</span>::string_view breed_param, <span class="keyword">unsigned</span> <span class="keyword">int</span> age_param)</span><br><span class="line">    : m_name(name_param), m_breed(breed_param), m_age(age_param) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗 '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' 被参数化构造了。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog::Dog() : Dog(<span class="string">"无名氏"</span>, <span class="string">"未知品种"</span>, <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗 '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' 被默认构造了。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog::~Dog() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗 '"</span> &lt;&lt; m_name &lt;&lt; <span class="string">"' 被析构了。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::string_view <span class="title">Dog::get_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::string_view <span class="title">Dog::get_breed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_breed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Dog::get_age</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::set_name</span><span class="params">(<span class="built_in">std</span>::string_view name_param)</span> </span>&#123;</span><br><span class="line">    m_name = name_param;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗的名字被设置为: "</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::set_breed</span><span class="params">(<span class="built_in">std</span>::string_view breed_param)</span> </span>&#123;</span><br><span class="line">    m_breed = breed_param;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗的品种被设置为: "</span> &lt;&lt; m_breed &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::set_age</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> age_param)</span> </span>&#123;</span><br><span class="line">    m_age = age_param;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗的年龄被设置为: "</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::print_info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗信息 (对象地址: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  名字: "</span> &lt;&lt; m_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  品种: "</span> &lt;&lt; m_breed &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  年龄: "</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>main.cpp</code> (练习部分)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dog.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Dog <span class="title">my_const_dog</span><span class="params">(<span class="string">"豆豆"</span>, <span class="string">"柯基"</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"创建了一个 const Dog 对象 my_const_dog。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1: 尝试调用 my_const_dog 的 print_info() 方法。</span></span><br><span class="line">    <span class="comment">//         编译一下，看看会发生什么。然后注释掉这行代码。</span></span><br><span class="line">    <span class="comment">// Your code for TODO 1 here:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2: 尝试调用 my_const_dog 的 get_name() 方法，并打印返回的名字。</span></span><br><span class="line">    <span class="comment">//         编译一下，看看会发生什么。然后注释掉这行代码。</span></span><br><span class="line">    <span class="comment">// Your code for TODO 2 here:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 3: 尝试声明一个普通的 Dog 指针 (Dog*), 让它指向 my_const_dog。</span></span><br><span class="line">    <span class="comment">//         例如: Dog* ptr_to_const = &amp;my_const_dog;</span></span><br><span class="line">    <span class="comment">//         编译一下，看看会发生什么。然后注释掉这行代码，并解释为什么会失败。</span></span><br><span class="line">    <span class="comment">// Your code for TODO 3 here:</span></span><br><span class="line">    <span class="comment">// 解释为什么失败:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n练习完成。如果你注释掉了所有导致错误的代码，程序应该能正常编译和运行。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>请你尝试完成 <code>main.cpp</code> 中的 <code>// TODO:</code> 部分，编译并观察结果。然后把你的 <code>main.cpp</code> 代码发给我，我会帮你看看并给出反馈！</p>
<p>我们这节课就先到这里。理解了 <code>const</code> 对象带来的这些问题，下一节课我们就能更好地学习如何解决它们了！加油！</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">main.cpp: In function ‘int main()’:</span><br><span class="line">main.cpp:11:28: error: passing ‘const Dog’ as ‘this’ argument discards qualifiers [-fpermissive]</span><br><span class="line">   11 |     my_const_dog.print_info();</span><br><span class="line">      |     ~~~~~~~~~~~~~~~~~~~~~~~^~</span><br><span class="line">In file included from main.cpp:2:</span><br><span class="line">dog.h:26:10: note:   in call to ‘void Dog::print_info()’</span><br><span class="line">   26 |     void print_info();</span><br><span class="line">      |          ^~~~~~~~~~</span><br><span class="line">main.cpp:17:26: error: passing ‘const Dog’ as ‘this’ argument discards qualifiers [-fpermissive]</span><br><span class="line">   17 |     my_const_dog.get_name();</span><br><span class="line">      |     ~~~~~~~~~~~~~~~~~~~~~^~</span><br><span class="line">dog.h:18:22: note:   in call to ‘std::string_view Dog::get_name()’</span><br><span class="line">   18 |     std::string_view get_name();</span><br><span class="line">      |                      ^~~~~~~~</span><br><span class="line">main.cpp:25:25: error: invalid conversion from ‘const Dog*’ to ‘Dog*’ [-fpermissive]</span><br><span class="line">   25 |     Dog* ptr_to_const &#x3D; &amp;my_const_dog;</span><br><span class="line">      |                         ^~~~~~~~~~~~~</span><br><span class="line">      |                         |</span><br><span class="line">      |                         const Dog*</span><br></pre></td></tr></table></figure></div></div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Object/">Object    </a><a class="post-meta__tags" href="/tags/Pointer/">Pointer    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/283%20-%20cpp%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E6%8E%A2%E7%A9%B6/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>283 - cpp 类对象大小探究</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/287%20-%20const%20%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>287 - const 对象作为函数参数的注意事项</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/Cpp 默认构造函数创建对象/" title="Cpp 默认构造函数创建对象"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">Cpp 默认构造函数创建对象</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/278 - cpp 指针管理类对象示例/" title="278 - cpp 指针管理类对象示例"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">278 - cpp 指针管理类对象示例</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/283 - cpp 类对象大小探究/" title="283 - cpp 类对象大小探究"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">283 - cpp 类对象大小探究</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/304 - 移动构造函数窃取/" title="304 - 移动构造函数窃取"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">304 - 移动构造函数窃取</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/静态成员访问控制/" title="静态成员访问控制"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">静态成员访问控制</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/273 - constructor/" title="273 - constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">273 - constructor</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>