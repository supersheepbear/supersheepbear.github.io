<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>309 - 聚合类型统一初始化 | Bear's dream</title><meta name="description" content="309 - 聚合类型统一初始化"><meta name="keywords" content="Cpp,Coding,Learning,Development,Class"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="309 - 聚合类型统一初始化"><meta name="twitter:description" content="309 - 聚合类型统一初始化"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="309 - 聚合类型统一初始化"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/309%20-%20%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B%E7%BB%9F%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="309 - 聚合类型统一初始化"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/309%20-%20%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B%E7%BB%9F%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96/"><link rel="prev" title="306 -  cpp 初始化列表构造函数详解" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/306%20-%20%20cpp%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><link rel="next" title="319 - Class Const" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/319%20-%20Class%20Const/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#好的，总结非常全面，我将标题设置为：-聚合类型统一初始化"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">好的，总结非常全面，我将标题设置为： 聚合类型统一初始化</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-统一初始化：聚合类型（Aggregate-Types）的奥秘与窄化转换（Narrowing-Conversion）"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">C++统一初始化：聚合类型（Aggregate Types）的奥秘与窄化转换（Narrowing Conversion）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-什么是统一初始化？"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">1. 什么是统一初始化？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-对普通（非聚合）用户定义类（User-Defined-Class）的初始化"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">1.1 对普通（非聚合）用户定义类（User-Defined Class）的初始化</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-深入理解聚合类型（Aggregate-Types）"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">2. 深入理解聚合类型（Aggregate Types）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-针对聚合类型的统一初始化"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">3. 针对聚合类型的统一初始化</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-1-使用花括号-进行初始化-列表初始化-聚合初始化"><span class="toc_mobile_items-number">1.6.1.</span> <span class="toc_mobile_items-text">3.1 使用花括号 {} 进行初始化 (列表初始化 &#x2F; 聚合初始化)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-2-使用圆括号-进行初始化-直接初始化"><span class="toc_mobile_items-number">1.6.2.</span> <span class="toc_mobile_items-text">3.2 使用圆括号 () 进行初始化 (直接初始化)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-常见误解与错误-Common-Misunderstandings-or-Mistakes"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">5. 常见误解与错误 (Common Misunderstandings or Mistakes)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-编程练习-Coding-Exercise"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">6. 编程练习 (Coding Exercise)</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#好的，总结非常全面，我将标题设置为：-聚合类型统一初始化"><span class="toc-number">1.</span> <span class="toc-text">好的，总结非常全面，我将标题设置为： 聚合类型统一初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-统一初始化：聚合类型（Aggregate-Types）的奥秘与窄化转换（Narrowing-Conversion）"><span class="toc-number">1.3.</span> <span class="toc-text">C++统一初始化：聚合类型（Aggregate Types）的奥秘与窄化转换（Narrowing Conversion）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是统一初始化？"><span class="toc-number">1.4.</span> <span class="toc-text">1. 什么是统一初始化？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-对普通（非聚合）用户定义类（User-Defined-Class）的初始化"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.1 对普通（非聚合）用户定义类（User-Defined Class）的初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-深入理解聚合类型（Aggregate-Types）"><span class="toc-number">1.5.</span> <span class="toc-text">2. 深入理解聚合类型（Aggregate Types）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-针对聚合类型的统一初始化"><span class="toc-number">1.6.</span> <span class="toc-text">3. 针对聚合类型的统一初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-使用花括号-进行初始化-列表初始化-聚合初始化"><span class="toc-number">1.6.1.</span> <span class="toc-text">3.1 使用花括号 {} 进行初始化 (列表初始化 &#x2F; 聚合初始化)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-使用圆括号-进行初始化-直接初始化"><span class="toc-number">1.6.2.</span> <span class="toc-text">3.2 使用圆括号 () 进行初始化 (直接初始化)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-QA-闪卡-QA-Flash-Cards"><span class="toc-number">1.7.</span> <span class="toc-text">4. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见误解与错误-Common-Misunderstandings-or-Mistakes"><span class="toc-number">1.8.</span> <span class="toc-text">5. 常见误解与错误 (Common Misunderstandings or Mistakes)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-编程练习-Coding-Exercise"><span class="toc-number">1.9.</span> <span class="toc-text">6. 编程练习 (Coding Exercise)</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">309 - 聚合类型统一初始化</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/309%20-%20%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B%E7%BB%9F%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/309%20-%20%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B%E7%BB%9F%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="好的，总结非常全面，我将标题设置为：-聚合类型统一初始化"><a href="#好的，总结非常全面，我将标题设置为：-聚合类型统一初始化" class="headerlink" title="好的，总结非常全面，我将标题设置为： 聚合类型统一初始化"></a>好的，总结非常全面，我将标题设置为： <strong>聚合类型统一初始化</strong></h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to zoom in on uniform initialization when we are initializing aggregatesand uniform initialization really refers to the fact that we can initialize anything in C plus pluseither using parentheses like this or curly braces.We have mostly seen that we can use the parentheses syntax to set up objects in C plus plus and we couldpass parameters to our object and the C plus plus compiler would see this and call our constructor toset up our object.But we can also use curly braces if we want to do that as part of uniform initialization in C plus plusuniform initialization is something that was introduced in C plus plus 11 and we can still use thatin C plus plus 20.But now we want to see how this works with aggregates.We have seen that we already know about two examples of aggregates so far in this course.We know about struct and we know about array.Here we have an example of a person struct which has two member variables.The first one is an stdstring and the second one is an integer.So we can initialize that using curly braces like this.But it is also possible to initialize our aggregates using the syntax that uses parentheses like this.So these things are going to be mostly similar.But the main difference I have found is that if you initialize with curly braces, you’re not goingto be allowed to do narrowing conversions.And if you use parentheses to initialize your aggregates, you’re going to be allowed to use narrowingconversions.Except for that, I think these two kinds of initializations are the same.It’s going to be a matter of preference, but other than that, these two ways of initializing yourobjects are going to be working exactly in the same way.Now that we know this, we’re going to head over to Visual Studio code and play with this a little more.Okay.Here we are in our working folder.The current project is uniform initialization for aggregates.We’re going to grab our template files pretty quick and we’re going to put them in place.After that, we’re going to open this little guy in Visual Studio code by dragging and dropping here,and this is going to open our folder and we should have our main.cpp file here.Let’s crack it open.And the first thing I want to do is to show you that we can use uniform initialization even for theobjects we build ourselves.So let’s set up a simple class.We’re going to set up a class called Point.It’s going to be having two sections, a public section and a private section.We’re going to have our constructor, which is really simple.It’s going to take two parameters by value.It’s going to be using an initializer list, and you see that we can even use curly braces in our initializerlist.So this is going to work.C plus plus is going to accept this or I should say C plus plus compilers are going to accept this.Once we have initialized our little guys, we’re going to hit the body of the constructor and we’regoing to say that we have called this constructor.What I really want you to see is that we can go down in main and create point objects using uniforminitialization.We’re going to say point P one and you already know that we can pass our parameters, for example,like this and this is going to work.Okay?So let’s make sure we are passing in double parameters or arguments, I should say.And this is going to work.If we print this point, we’re going to see the information.So let’s build and really show you that the compiler is going to accept this and the world is goingto be good.Another thing you should know is that you can use curly braces and the compiler is going to note thatif it sees a syntax like this, it’s going to call your constructor.So let’s build and show you that the constructor is going to be called and it is going to be our constructorhere, which takes two parameters.You see, the world is good.We can clear.And run Rooster.We’re going to see that point constructor is called.Constructor is going to be called regardless of the uniform initialization syntax to use.We can either use curly braces or parentheses.This will work.Let’s say uniform initialization and this can be parentheses or curly braces.Either of these is going to work and it is going to call the constructor that you have in place.But what we really want to look at in this lecture is uniform initialization in the context of aggregates.And we’re going to use a struct and an array to really drive the point home.We’re going to go down and set up another struct, which is going to be a person struct.And suppose inside we’re going to put in some data, we’re going to put in an STD string which is goingto store the name for the person and we’re going to put in an unsigned integer.We’re going to say unsigned int age.And we forgot to put the variable name and we forgot to put the variable name for the stdstring membervariable here.My bad.We’re going to say name and we’re going to say MH here to really be super clear that it is a membervariable.I like to use this syntax and now Visual Studio Code should be happy about this, at least I hope.Let’s build again to really make sure that this is valid syntax.You see, the build is good.We can serve up our struct like this, but what we really want to see is that we can use either curlybraces or parentheses to initialize our aggregate.Let’s go down and do that.We’re going to say that we are trying to use our struct and we’re going to use our curly brace syntaxand we’re going to see what we can achieve with this.So we’re going to set up a person object and we’re going to say person one and we’re going to use Curlybraces.What we’re going to do is pass in the name, let’s say, Daniel, and we’re going to pass in the ageand let’s put in 35.And if we do this, you see that the syntax here is going to work.Let’s try and work to really prove this.Okay, the world is good, but if we try and use, for example, double for the age, let’s see whatwe get.Let’s try and build and see that we see what is wrong here.We’re going to see that we’re going to have a compiler error and you’re going to see that the erroris narrowing conversion from double to unsigned.And the problem is narrowing conversions are not allowed.If you are using uniform initialization and initializing an aggregate with curly braces, this is notsupported.If you do this, you’re going to get a compiler error.The reason has to do with how the compiler varies.This things up behind the curtains.We’re not going to go into those details for now.It’s going to be enough to know that narrowing conversions are not going to work.If you try to use uniform initialization with curlies for your aggregates.Let’s turn this back to 35 and you’re going to see that this is going to be accepted by the compiler.We’re going to go down and look at how we can use parentheses and see if this actually works.So we’re going to say parentheses here and we’re going to comment out the person object we just createdhere and we’re going to create another person object.Let’s do that.We’re going to say person and we’re going to say p two.And we’re going to use parentheses and pass in the same kind of data we’re going to pass in Daniel.Or we can use John.I am tired of Daniel and we can say John is 41 years old.You’re going to see that this is going to be accepted by the compiler.And if we’re trying to build this is going to build, fine, Let’s pass this through GCC and make surethat the world is good and a benefit with parentheses like this is that narrowing conversions are goingto be allowed.So if, for example, we pass in 41.7 for the age, we’re going to see that we’re not going to get anysquiggly line.But even if we build, this is going to build successfully because with parentheses like this, narrowingconversions are going to be allowed if you use this, to initialize your aggregate.So this is really the difference between uniform initialization for aggregates using curlies and parentheses.With curlies, the narrowing conversions are not going to be allowed, but with parentheses narrowingconversions are going to be allowed.Other than this, I think these two ways of initializing your aggregates are really the same.And again, this curlies and parentheses are part of a bigger scheme in C plus plus to do uniform initializationon anything.The idea is that we should be able to use parentheses or curlies to initialize anything in C plus plus.Okay.So we have seen that this syntax is going to work for a struct, which is one example of an aggregatewe know about, but we can also use this for arrays.So for example, if we set up an array for students and say it is an int array and initialize this usingcurlies, we only can use integers inside here because we don’t support narrowing conversions if weuse curly braces.If we do this, you’re going to see that this is going to build fine.Okay.Both is good.But if we change one of these guys to a double, for example, we’re going to have a compiler errorbecause we just put in something that is going to call for a narrowing conversion from double to andthis is going to give us a compiler error because we can’t do narrowing conversion from aggregates ifwe initialize with curly braces.If we want to use narrowing conversions, we can change this to parentheses and this is going to work.And I don’t think I have shown you that we can initialize our array like this, but this is going towork.This is going to initialize your array.But in this case, the 4.7 here is going to be implicitly converted to an eight because this is an arrayof ants.If we build, we’re going to see that the compiler error is going to go away.We are going to build good and this is what we want.This is really all I had to share in this lecture.I hope you found it interesting.For now, we’re going to head over to the next lecture and try to recap what we saw in this chapter.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，C++新手朋友，你好！很高兴能成为你的C++老师。我们将一步步深入学习C++中一个非常实用且重要的特性：统一初始化（<a href="https://en.cppreference.com/w/cpp/language/initialization#Uniform_initialization" target="_blank" rel="external nofollow noopener noreferrer">Uniform Initialization</a>）。</p>
<hr>
<h2 id="C-统一初始化：聚合类型（Aggregate-Types）的奥秘与窄化转换（Narrowing-Conversion）"><a href="#C-统一初始化：聚合类型（Aggregate-Types）的奥秘与窄化转换（Narrowing-Conversion）" class="headerlink" title="C++统一初始化：聚合类型（Aggregate Types）的奥秘与窄化转换（Narrowing Conversion）"></a><strong>C++统一初始化：聚合类型（<a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization" target="_blank" rel="external nofollow noopener noreferrer">Aggregate Types</a>）的奥秘与窄化转换（<a href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Numeric_conversions" target="_blank" rel="external nofollow noopener noreferrer">Narrowing Conversion</a>）</strong></h2><p><strong>简要总结：</strong> 本节课将详细讲解C++11引入的统一初始化语法，特别是针对聚合类型（如结构体和数组）如何使用花括号 <code>{}</code> 和圆括号 <code>()</code> 进行初始化。我们将重点探讨这两种初始化方式在处理窄化转换时的核心区别，并通过代码示例帮助你彻底理解。</p>
<hr>
<h2 id="1-什么是统一初始化？"><a href="#1-什么是统一初始化？" class="headerlink" title="1. 什么是统一初始化？"></a><strong>1. 什么是统一初始化？</strong></h2><p>在C++11标准中，引入了一个叫做“统一初始化”的概念。它的核心思想是：希望C++中所有的初始化操作都能使用一种<strong>统一的语法</strong>来完成。这意味着，无论是初始化基本数据类型、用户定义类、结构体还是数组，我们都可以选择使用两种主要的语法形式：<strong>圆括号 <code>()</code></strong> 或 <strong>花括号 <code>{}</code></strong>。</p>
<ul>
<li><strong>目标：</strong> 提供一种更加一致、清晰且不易出错的初始化方式。</li>
<li><strong>引入时机：</strong> C++11标准引入，并在C++20及后续版本中依然有效。</li>
</ul>
<h3 id="1-1-对普通（非聚合）用户定义类（User-Defined-Class）的初始化"><a href="#1-1-对普通（非聚合）用户定义类（User-Defined-Class）的初始化" class="headerlink" title="1.1 对普通（非聚合）用户定义类（User-Defined Class）的初始化"></a><strong>1.1 对普通（非聚合）用户定义类（<a href="https://en.cppreference.com/w/cpp/language/class" target="_blank" rel="external nofollow noopener noreferrer">User-Defined Class</a>）的初始化</strong></h3><p>首先，让我们看看统一初始化是如何作用于我们自己定义的普通类的。对于一个有构造函数（<a href="https://en.cppreference.com/w/cpp/language/constructor" target="_blank" rel="external nofollow noopener noreferrer">Constructor</a>）的类，<code>()</code> 和 <code>{}</code> 语法都可以用来调用构造函数创建对象。</p>
<p><strong>示例：<code>Point</code> 类</strong></p>
<p>假设我们有一个 <code>Point</code> 类，它有两个 <code>double</code> 类型的成员变量 <code>x</code> 和 <code>y</code>，并有一个接受两个 <code>double</code> 参数的构造函数。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Point类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x;</span><br><span class="line">    <span class="keyword">double</span> m_y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Point(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : m_x(x), m_y(y) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point 构造函数被调用: ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用圆括号 () 进行初始化 (直接初始化)</span></span><br><span class="line">    <span class="comment">// 这种方式会调用匹配的构造函数</span></span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10.1</span>, <span class="number">20.2</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--------------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用花括号 &#123;&#125; 进行初始化 (列表初始化)</span></span><br><span class="line">    <span class="comment">// 这种方式同样会调用匹配的构造函数</span></span><br><span class="line">    Point p2&#123;<span class="number">30.3</span>, <span class="number">40.4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于非聚合类（如Point，因为它有用户定义的构造函数），</span></span><br><span class="line">    <span class="comment">// 无论是使用()还是&#123;&#125;，本质上都是在寻找并调用最匹配的构造函数。</span></span><br><span class="line">    <span class="comment">// 因此，这两种方式对于调用构造函数的效果是相同的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>运行结果：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point 构造函数被调用: (10.1, 20.2)</span><br><span class="line">--------------------</span><br><span class="line">Point 构造函数被调用: (30.3, 40.4)</span><br></pre></td></tr></table></figure></div>
<p>从上面的例子可以看出，对于有构造函数的类，<code>()</code> 和 <code>{}</code> 都可以成功调用构造函数。在这些情况下，它们表现的行为非常相似。</p>
<h2 id="2-深入理解聚合类型（Aggregate-Types）"><a href="#2-深入理解聚合类型（Aggregate-Types）" class="headerlink" title="2. 深入理解聚合类型（Aggregate Types）"></a><strong>2. 深入理解聚合类型（Aggregate Types）</strong></h2><p>在C++中，有些类型被称为“聚合类型”。它们有一些特殊的性质，使得C++编译器可以为它们提供一些默认的初始化行为。</p>
<p><strong>聚合类型的定义：</strong></p>
<p>一个类型是聚合类型，如果它满足以下所有条件：</p>
<ol>
<li><strong>它是一个数组类型</strong>（例如 <code>int arr[]</code>）。</li>
<li><strong>它是一个类类型</strong>（<code>struct</code>、<code>class</code> 或 <code>union</code>），并且：<ul>
<li>没有用户声明的构造函数（<a href="https://en.cppreference.com/w/cpp/language/constructor" target="_blank" rel="external nofollow noopener noreferrer">User-declared constructor</a>）。</li>
<li>没有私有（<a href="https://en.cppreference.com/w/cpp/language/access" target="_blank" rel="external nofollow noopener noreferrer">Private</a>）或保护（<a href="https://en.cppreference.com/w/cpp/language/access" target="_blank" rel="external nofollow noopener noreferrer">Protected</a>）的非静态数据成员（<a href="https://en.cppreference.com/w/cpp/language/class#Member_objects" target="_blank" rel="external nofollow noopener noreferrer">Non-static data member</a>）。</li>
<li>没有基类（<a href="https://en.cppreference.com/w/cpp/language/derived_class" target="_blank" rel="external nofollow noopener noreferrer">Base Class</a>）。</li>
<li>没有虚函数（<a href="https://en.cppreference.com/w/cpp/language/virtual" target="_blank" rel="external nofollow noopener noreferrer">Virtual Function</a>）。</li>
<li>（C++11-C++17还有一些其他限制，C++20放宽了这些限制，例如允许基类和私有/保护非静态数据成员，只要它们是公共的并且没有用户声明的构造函数）。</li>
</ul>
</li>
</ol>
<p><strong>简单来说：</strong> 聚合类型通常就是那些<strong>没有复杂自定义行为</strong>（如自定义构造函数）的“朴素”结构体、类或数组。C++允许我们直接通过提供值的列表来初始化它们的成员。</p>
<p><strong>我们已经见过的聚合类型：</strong></p>
<ul>
<li><strong>结构体（<code>struct</code>）</strong>：如果它没有用户定义的构造函数、没有私有成员等。</li>
<li><strong>数组（<code>array</code>）</strong>：例如 <code>int[]</code>。</li>
</ul>
<h2 id="3-针对聚合类型的统一初始化"><a href="#3-针对聚合类型的统一初始化" class="headerlink" title="3. 针对聚合类型的统一初始化"></a><strong>3. 针对聚合类型的统一初始化</strong></h2><p>现在，我们来重点看看统一初始化在聚合类型上的应用，以及 <code>()</code> 和 <code>{}</code> 在这里表现出的关键区别。</p>
<h3 id="3-1-使用花括号-进行初始化-列表初始化-聚合初始化"><a href="#3-1-使用花括号-进行初始化-列表初始化-聚合初始化" class="headerlink" title="3.1 使用花括号 {} 进行初始化 (列表初始化 / 聚合初始化)"></a><strong>3.1 使用花括号 <code>{}</code> 进行初始化 (列表初始化 / 聚合初始化)</strong></h3><p>当我们使用花括号 <code>{}</code> 来初始化聚合类型时，这种方式被称为<strong>列表初始化</strong>（<a href="https://en.cppreference.com/w/cpp/language/list_initialization" target="_blank" rel="external nofollow noopener noreferrer">List Initialization</a>），对于聚合类型，它也特指<strong>聚合初始化</strong>。</p>
<p><strong>关键规则：列表初始化（和聚合初始化）</strong> <strong>严格禁止</strong> <strong>窄化转换（<a href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Numeric_conversions" target="_blank" rel="external nofollow noopener noreferrer">Narrowing Conversions</a>）</strong>。</p>
<ul>
<li><strong>什么是窄化转换？</strong> 窄化转换指的是将一个值转换为一个<strong>无法完整表示该值所有可能范围</strong>的类型。这通常会导致数据丢失。例如：<ul>
<li><code>double</code> 转换为 <code>int</code> (丢失小数部分)</li>
<li><code>float</code> 转换为 <code>int</code> (丢失小数部分)</li>
<li><code>long</code> 转换为 <code>int</code> (如果 <code>long</code> 的值超出了 <code>int</code> 的范围)</li>
<li><code>int</code> 转换为 <code>short</code> (如果 <code>int</code> 的值超出了 <code>short</code> 的范围)</li>
<li><code>unsigned int</code> 转换为 <code>int</code> (如果 <code>unsigned int</code> 的值超出了 <code>int</code> 的正数范围)</li>
</ul>
</li>
</ul>
<p><strong>示例1：结构体 <code>Person</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 需要包含string头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Person结构体，它是一个聚合类型</span></span><br><span class="line"><span class="comment">// 因为它没有用户定义的构造函数，所有成员都是公开的，没有基类/虚函数等</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> age; <span class="comment">// 无符号整数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 使用花括号 &#123;&#125; 初始化聚合类型 (列表初始化/聚合初始化)</span></span><br><span class="line">    <span class="comment">// 这种方式会逐个成员地初始化</span></span><br><span class="line">    Person p1 = &#123;<span class="string">"Daniel"</span>, <span class="number">35</span>&#125;; <span class="comment">// OK，类型匹配</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Person 1: Name = "</span> &lt;&lt; p1.name &lt;&lt; <span class="string">", Age = "</span> &lt;&lt; p1.age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试进行窄化转换 (double到unsigned int)</span></span><br><span class="line">    <span class="comment">// Person p_error = &#123;"Daniel", 35.7&#125;; // 编译错误！不允许窄化转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译错误信息大致会是：</span></span><br><span class="line">    <span class="comment">// error: narrowing conversion of '3.5700000000000002e+01' from 'double' to 'unsigned int' [-Wnarrowing]</span></span><br><span class="line">    <span class="comment">// 这是因为 35.7 是一个 double 类型，将其赋值给 unsigned int 类型会丢失小数部分，</span></span><br><span class="line">    <span class="comment">// 这是一个窄化转换，而花括号初始化严格禁止这种行为。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>示例2：数组 <code>students</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 使用花括号 &#123;&#125; 初始化数组 (列表初始化/聚合初始化)</span></span><br><span class="line">    <span class="keyword">int</span> students_age[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// OK，类型匹配</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Students Ages: "</span> &lt;&lt; students_age[<span class="number">0</span>] &lt;&lt; <span class="string">", "</span> &lt;&lt; students_age[<span class="number">1</span>] &lt;&lt; <span class="string">", "</span> &lt;&lt; students_age[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试进行窄化转换 (double到int)</span></span><br><span class="line">    <span class="comment">// int students_error[] = &#123;1, 2.5, 3&#125;; // 编译错误！不允许窄化转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样，2.5 是 double 类型，赋值给 int 会丢失小数，是窄化转换，&#123;&#125; 初始化会阻止。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>总结 <code>{}</code> 行为：</strong> 安全第一！它会阻止任何可能导致数据丢失的隐式类型转换，确保你的程序更健壮。</p>
<h3 id="3-2-使用圆括号-进行初始化-直接初始化"><a href="#3-2-使用圆括号-进行初始化-直接初始化" class="headerlink" title="3.2 使用圆括号 () 进行初始化 (直接初始化)"></a><strong>3.2 使用圆括号 <code>()</code> 进行初始化 (直接初始化)</strong></h3><p>当使用圆括号 <code>()</code> 来初始化聚合类型时，这种方式被称为<strong>直接初始化</strong>（<a href="https://en.cppreference.com/w/cpp/language/initialization#Direct_initialization" target="_blank" rel="external nofollow noopener noreferrer">Direct Initialization</a>）。</p>
<p><strong>关键规则：直接初始化通常允许窄化转换</strong>（但可能会发出编译器警告，因为它可能导致数据丢失）。</p>
<p><strong>示例1：结构体 <code>Person</code></strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用圆括号 () 初始化聚合类型 (直接初始化)</span></span><br><span class="line">    <span class="comment">// Person p2("John", 41); </span></span><br><span class="line">    <span class="comment">// 上述语法对于没有构造函数的聚合类型来说，如果编译器将其解释为直接初始化，</span></span><br><span class="line">    <span class="comment">// 并且能够按顺序匹配成员类型，它可能工作。</span></span><br><span class="line">    <span class="comment">// 在C++11及更高版本，对于聚合体，这种语法（`Type obj(arg1, arg2);`）</span></span><br><span class="line">    <span class="comment">// 通常被视为调用一个隐式或合成的构造函数，如果存在，</span></span><br><span class="line">    <span class="comment">// 并且在这种情况下，窄化转换是允许的。</span></span><br><span class="line">    <span class="comment">// 但是，更推荐和明确的聚合初始化语法是使用花括号`&#123;&#125;`。</span></span><br><span class="line">    <span class="comment">// 为了明确展示圆括号允许窄化转换的场景，我们可以考虑更明确的直接初始化或函数式转换。</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 但为了贴合讲座内容，我们假设编译器在这种上下文中允许这种对聚合体的 "伪构造函数" 调用，</span></span><br><span class="line">    <span class="comment">// 并且允许窄化转换。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际更常见和推荐的、明确区分 &#123;&#125; 和 () 行为的场景是：</span></span><br><span class="line">    <span class="comment">// 当类型有一个可以被 &#123;&#125; 或 () 调用的构造函数时。</span></span><br><span class="line">    <span class="comment">// 但由于本讲座聚焦聚合类型，我们根据讲座的意图来演示。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设此处Person的(string, unsigned int)是允许的直接初始化</span></span><br><span class="line">    <span class="comment">// 允许窄化转换</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"John"</span>, <span class="number">41.7</span>)</span></span>; <span class="comment">// OK，41.7会被窄化为41</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Person 2: Name = "</span> &lt;&lt; p2.name &lt;&lt; <span class="string">", Age = "</span> &lt;&lt; p2.age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你会发现这里不会有编译错误，编译器会自动将41.7截断为41。</span></span><br><span class="line">    <span class="comment">// 尽管没有错误，但这种行为通常会伴随数据丢失，所以要小心使用。</span></span><br><span class="line">    <span class="comment">// 很多现代编译器会发出警告，提醒你发生了窄化。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>运行结果：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person 2: Name &#x3D; John, Age &#x3D; 41</span><br></pre></td></tr></table></figure></div>
<p>请注意，<code>41.7</code> 被默默地截断成了 <code>41</code>。</p>
<p><strong>重要澄清：数组和 <code>()</code> 语法</strong></p>
<p>原始讲座中提到 <code>int arr[] = (1, 2, 3);</code> 这样的数组初始化方式允许窄化转换。<strong>这是一个非常容易引起混淆的地方，需要特别注意：</strong></p>
<ul>
<li><strong>C风格数组（<code>int arr[]</code>）的初始化：</strong> 在C++中，C风格的数组（如 <code>int arr[]</code>）<strong>只能</strong>使用花括号 <code>{}</code> 进行列表初始化。<code>()</code> 语法并不适用于C风格数组的这种批量初始化。</li>
<li><code>int arr[] = (1, 2, 3);</code> 这行代码实际上使用了C++的<strong>逗号运算符（<a href="https://en.cppreference.com/w/cpp/language/operator_other#Comma_operator" target="_blank" rel="external nofollow noopener noreferrer">Comma Operator</a>）</strong>。表达式 <code>(1, 2, 3)</code> 的结果是最后一个操作数 <code>3</code>。所以，<code>int arr[] = (1, 2, 3);</code> 等价于 <code>int arr[] = {3};</code>。这意味着你创建了一个只包含一个元素 <code>3</code> 的数组。如果 <code>3</code> 是 <code>double</code> 类型，比如 <code>(1.0, 2.0, 3.0)</code>，那么 <code>int arr[] = (1.0, 2.0, 3.0);</code> 会变成 <code>int arr[] = {3.0};</code>，这里 <code>3.0</code> 到 <code>int</code> 的窄化转换会引发<strong>编译错误</strong>（因为是列表初始化）。</li>
<li><strong>总结：</strong> 对于C风格数组，<strong>只能用 <code>{}</code> 进行初始化</strong>，并且这种初始化方式<strong>严格禁止窄化转换</strong>。讲座中提到的 <code>()</code> 允许数组窄化转换的例子是有误的，或者它指的是其他更复杂的场景（例如 <code>std::array</code> 配合某些特定的构造函数），但对于裸C风格数组，情况并非如此。</li>
</ul>
<p><strong>为了避免混淆，请记住：</strong></p>
<ul>
<li><strong>花括号 <code>{}</code>：</strong> <strong>禁止</strong> 窄化转换。用于列表初始化和聚合初始化。</li>
<li><strong>圆括号 <code>()</code>：</strong> <strong>允许</strong> 窄化转换。主要用于直接初始化（可能调用构造函数）。</li>
</ul>
<p><strong>总结 <code>()</code> 行为：</strong> 更宽松，但有数据丢失风险。它通常允许编译器执行隐式类型转换，即使这些转换是窄化转换。</p>
<h2 id="4-QA-闪卡-QA-Flash-Cards"><a href="#4-QA-闪卡-QA-Flash-Cards" class="headerlink" title="4. QA 闪卡 (QA Flash Cards)"></a><strong>4. QA 闪卡 (QA Flash Cards)</strong></h2><ol>
<li><p><strong>Q1:</strong> C++中统一初始化是为了解决什么问题？它是在哪个C++标准版本中引入的？</p>
<ul>
<li><strong>A1:</strong> 统一初始化是为了提供一种<strong>统一、一致的初始化语法</strong>，减少混乱和潜在错误。它是在 <strong>C++11</strong> 标准中引入的。</li>
</ul>
</li>
<li><p><strong>Q2:</strong> 对于聚合类型（如满足条件的 <code>struct</code> 或 <code>array</code>），使用花括号 <code>{}</code> 和圆括号 <code>()</code> 进行初始化时，它们在处理窄化转换方面有什么核心区别？</p>
<ul>
<li><strong>A2:</strong> 使用 <strong>花括号 <code>{}</code>（列表初始化/聚合初始化）</strong> 严格<strong>禁止</strong>窄化转换。而使用 <strong>圆括号 <code>()</code>（直接初始化）</strong> 通常<strong>允许</strong>窄化转换。</li>
</ul>
</li>
<li><p><strong>Q3:</strong> 请举一个窄化转换的例子。为什么C++会默认禁止使用花括号 <code>{}</code> 进行窄化转换？</p>
<ul>
<li><strong>A3:</strong> 窄化转换的例子是将 <code>double</code> 类型的值 <code>3.14</code> 转换为 <code>int</code> 类型（结果为 <code>3</code>，小数部分丢失）。C++默认禁止 <code>{}</code> 进行窄化转换是为了提高代码的<strong>安全性</strong>和<strong>可靠性</strong>，避免因为隐式的数据丢失而引入潜在的错误。</li>
</ul>
</li>
<li><p><strong>Q4:</strong> 对于一个拥有用户定义构造函数的普通C++类（非聚合类型），使用 <code>()</code> 和 <code>{}</code> 进行初始化有什么区别吗？</p>
<ul>
<li><strong>A4:</strong> 对于拥有用户定义构造函数的普通类，<code>()</code> 和 <code>{}</code> 都可以用来<strong>调用匹配的构造函数</strong>。在大多数情况下，它们的效果是相同的，都旨在找到并调用最合适的构造函数。窄化转换的规则取决于构造函数的参数类型和传入的实参类型，而不是 <code>()</code> 或 <code>{}</code> 本身。</li>
</ul>
</li>
</ol>
<h2 id="5-常见误解与错误-Common-Misunderstandings-or-Mistakes"><a href="#5-常见误解与错误-Common-Misunderstandings-or-Mistakes" class="headerlink" title="5. 常见误解与错误 (Common Misunderstandings or Mistakes)"></a><strong>5. 常见误解与错误 (Common Misunderstandings or Mistakes)</strong></h2><ol>
<li><p><strong>误解1：</strong> 以为 <code>()</code> 和 <code>{}</code> 在任何情况下都完全等效。</p>
<ul>
<li><strong>事实：</strong> 对于聚合类型，它们在处理窄化转换时有本质区别。对于某些非聚合类型，<code>{}</code> 可能会优先调用接受 <code>std::initializer_list</code> 的构造函数，而 <code>()</code> 则不会，这可能导致不同的行为。</li>
</ul>
</li>
<li><p><strong>误解2：</strong> 认为只要是 <code>()</code> 初始化就一定安全，不会有数据丢失。</p>
<ul>
<li><strong>事实：</strong> 虽然 <code>()</code> 允许窄化转换，但这正是其潜在危险之处。它<strong>允许数据丢失</strong>而不会报错。在实际编码中，即使编译器不报错，也应该警惕并避免不必要的窄化转换，或者明确进行类型转换来表达意图。</li>
</ul>
</li>
<li><p><strong>误解3：</strong> 混淆聚合类型和非聚合类型。</p>
<ul>
<li><strong>事实：</strong> 并非所有 <code>struct</code> 都是聚合类型。例如，如果 <code>struct</code> 有用户自定义的构造函数，它就不是聚合类型了。<code>()</code> 和 <code>{}</code> 在聚合类型和非聚合类型上的行为侧重点是不同的。对非聚合类型，它们主要是选择和调用构造函数；对聚合类型，则是直接初始化成员并受窄化转换规则约束。</li>
</ul>
</li>
<li><p><strong>误解4：</strong> 认为C风格数组可以使用 <code>()</code> 进行多元素初始化，并且允许窄化转换。</p>
<ul>
<li><strong>事实：</strong> 如前所述，C风格数组只能使用 <code>{}</code> 进行列表初始化，并且严格禁止窄化转换。<code>int arr[] = (1, 2, 3);</code> 这种写法实际上是利用了逗号运算符，只初始化了一个元素，且该元素仍受 <code>{}</code> 的窄化转换规则约束。</li>
</ul>
</li>
</ol>
<h2 id="6-编程练习-Coding-Exercise"><a href="#6-编程练习-Coding-Exercise" class="headerlink" title="6. 编程练习 (Coding Exercise)"></a><strong>6. 编程练习 (Coding Exercise)</strong></h2><p>为了巩固你对聚合类型统一初始化和窄化转换的理解，请完成以下练习。</p>
<p><strong>目标：</strong> 你需要填写缺失的代码，以实现对一个 <code>Product</code> 结构体和一个 <code>double</code> 数组的初始化，并观察 <code>()</code> 和 <code>{}</code> 在窄化转换方面的不同行为。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义一个聚合类型 Product</span></span><br><span class="line"><span class="comment">// 它有：</span></span><br><span class="line"><span class="comment">// - std::string name</span></span><br><span class="line"><span class="comment">// - int quantity (数量)</span></span><br><span class="line"><span class="comment">// - double price (价格)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Product</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> quantity;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 花括号 &#123;&#125; 初始化 (禁止窄化转换) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用花括号 &#123;&#125; 初始化 Product 对象 p1</span></span><br><span class="line">    <span class="comment">// 确保 quantity 为 5，price 为 99.99</span></span><br><span class="line">    <span class="comment">// （注意：如果尝试在这里对quantity进行窄化转换，例如传入5.5，会发生什么？）</span></span><br><span class="line">    <span class="comment">// Product p1 = &#123; /* <span class="doctag">TODO:</span> 填写代码 */ &#125;; </span></span><br><span class="line">    Product p1 = &#123; <span class="string">"Laptop"</span>, <span class="number">5</span>, <span class="number">99.99</span> &#125;; <span class="comment">// 示例填充</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Product 1: Name = "</span> &lt;&lt; p1.name </span><br><span class="line">              &lt;&lt; <span class="string">", Quantity = "</span> &lt;&lt; p1.quantity </span><br><span class="line">              &lt;&lt; <span class="string">", Price = "</span> &lt;&lt; p1.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 尝试使用花括号 &#123;&#125; 初始化 Product 对象 p2，故意引入窄化转换</span></span><br><span class="line">    <span class="comment">// 例如，将 quantity 赋值为 10.5</span></span><br><span class="line">    <span class="comment">// 预期：这将导致编译错误。请尝试取消注释以下代码，并观察编译器错误。</span></span><br><span class="line">    <span class="comment">// Product p2 = &#123; "Mouse", 10.5, 25.0 &#125;; // <span class="doctag">TODO:</span> 尝试填入代码并观察错误</span></span><br><span class="line">    <span class="comment">// 实际操作时，你需要注释掉这行，因为它会阻止编译成功。</span></span><br><span class="line">    <span class="comment">// Product p2_will_fail_compile = &#123; "Mouse", 10.5, 25.0 &#125;; </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 圆括号 () 初始化 (允许窄化转换) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 使用圆括号 () 初始化 Product 对象 p3</span></span><br><span class="line">    <span class="comment">// 故意引入窄化转换：将 quantity 赋值为 15.7</span></span><br><span class="line">    <span class="comment">// 预期：这将允许窄化转换，15.7 会被截断为 15，不会有编译错误（可能有警告）。</span></span><br><span class="line">    <span class="comment">// Product p3 = ( /* <span class="doctag">TODO:</span> 填写代码 */ ); </span></span><br><span class="line">    <span class="function">Product <span class="title">p3</span><span class="params">(<span class="string">"Keyboard"</span>, <span class="number">15.7</span>, <span class="number">75.50</span>)</span></span>; <span class="comment">// 示例填充</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Product 3: Name = "</span> &lt;&lt; p3.name </span><br><span class="line">              &lt;&lt; <span class="string">", Quantity = "</span> &lt;&lt; p3.quantity </span><br><span class="line">              &lt;&lt; <span class="string">", Price = "</span> &lt;&lt; p3.price &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 数组初始化对比 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 使用花括号 &#123;&#125; 初始化一个 double 数组 (所有元素都是整数值)</span></span><br><span class="line">    <span class="comment">// 预期：正常初始化，没有窄化转换问题。</span></span><br><span class="line">    <span class="comment">// double values1[] = &#123; /* <span class="doctag">TODO:</span> 填写代码 */ &#125;;</span></span><br><span class="line">    <span class="keyword">double</span> values1[] = &#123; <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span> &#125;; <span class="comment">// 示例填充</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Values 1: "</span> &lt;&lt; values1[<span class="number">0</span>] &lt;&lt; <span class="string">", "</span> &lt;&lt; values1[<span class="number">1</span>] &lt;&lt; <span class="string">", "</span> &lt;&lt; values1[<span class="number">2</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 尝试使用花括号 &#123;&#125; 初始化一个 int 数组，其中一个元素是 double 类型（引入窄化转换）</span></span><br><span class="line">    <span class="comment">// 预期：这将导致编译错误。请尝试取消注释以下代码，并观察编译器错误。</span></span><br><span class="line">    <span class="comment">// int values2_will_fail_compile[] = &#123; 1, 2.5, 3 &#125;; // <span class="doctag">TODO:</span> 尝试填入代码并观察错误</span></span><br><span class="line">    <span class="comment">// 实际操作时，你需要注释掉这行。</span></span><br><span class="line">    <span class="comment">// int values2_will_fail_compile[] = &#123; 1, 2.5, 3 &#125;; </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请你将 <code>TODO</code> 部分的代码填写完整。完成之后，我会为你批改答案并给出更深入的建议。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Learning/">Learning    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/306%20-%20%20cpp%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>306 -  cpp 初始化列表构造函数详解</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/319%20-%20Class%20Const/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>319 - Class Const</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/275 - getter and setter/" title="275 - getter and setter"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">275 - getter and setter</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/325 - 类内成员初始化/" title="325 - 类内成员初始化"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">325 - 类内成员初始化</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/272 - first class/" title="272 - first class"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">272 - first class</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/273 - constructor/" title="273 - constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">273 - constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/266 - building concept/" title="266 - building concept"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">266 - building concept</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/277 - IDE 创建 cpp 类方法/" title="277 - IDE 创建 cpp 类方法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">277 - IDE 创建 cpp 类方法</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>