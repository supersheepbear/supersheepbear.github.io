<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>265 - using concept | Bear's dream</title><meta name="description" content="265 - using concept"><meta name="keywords" content="Coding,Cpp,Function,Language,Concepts"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="265 - using concept"><meta name="twitter:description" content="265 - using concept"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="265 - using concept"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/265%20-%20using%20concept/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="265 - using concept"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/265%20-%20using%20concept/"><link rel="prev" title="261 - Type traits" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/261%20-%20Type%20traits/"><link rel="next" title="274 - default constructor" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/274%20-%20default%20constructor/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#265-Using-Concept"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">265 - Using Concept</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-标题与摘要"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">1. 标题与摘要</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-详细解释"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">2. 详细解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-问答卡片-QA-Flash-Cards"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">4. 问答卡片 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-常见误解或错误"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">5. 常见误解或错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-编程练习"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">6. 编程练习</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-练习解答与评价"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">7. 练习解答与评价</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-扩展思考与建议"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">8. 扩展思考与建议</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#265-Using-Concept"><span class="toc-number">1.</span> <span class="toc-text">265 - Using Concept</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-标题与摘要"><span class="toc-number">1.1.</span> <span class="toc-text">1. 标题与摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-详细解释"><span class="toc-number">1.2.</span> <span class="toc-text">2. 详细解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-代码示例"><span class="toc-number">1.3.</span> <span class="toc-text">3. 代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-问答卡片-QA-Flash-Cards"><span class="toc-number">1.4.</span> <span class="toc-text">4. 问答卡片 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见误解或错误"><span class="toc-number">1.5.</span> <span class="toc-text">5. 常见误解或错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-编程练习"><span class="toc-number">1.6.</span> <span class="toc-text">6. 编程练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-练习解答与评价"><span class="toc-number">1.7.</span> <span class="toc-text">7. 练习解答与评价</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-扩展思考与建议"><span class="toc-number">1.8.</span> <span class="toc-text">8. 扩展思考与建议</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">265 - using concept</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/265%20-%20using%20concept/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/265%20-%20using%20concept/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="265-Using-Concept"><a href="#265-Using-Concept" class="headerlink" title="265 - Using Concept"></a>265 - Using Concept</h1><p><a href="https://gemini.google.com/u/2/app/494d211d2d28ff60" target="_blank" rel="external nofollow noopener noreferrer">https://gemini.google.com/u/2/app/494d211d2d28ff60</a></p>
<p>好的，作为你的 C++ 导师，我会用最清晰易懂的方式，带你一步步学习 C++20 中引入的 Concepts (概念)。</p>
<h2 id="1-标题与摘要"><a href="#1-标题与摘要" class="headerlink" title="1. 标题与摘要"></a>1. 标题与摘要</h2><p><strong>标题：</strong> C++20 Concepts 入门：为你的函数模板添加约束</p>
<p><strong>摘要：</strong> 本次讲解我们将学习 C++20 中的 Concepts (概念)。Concepts 是一种机制，允许我们为函数模板 (function template) 添加约束，规定模板参数必须满足的条件（例如，必须是整数、浮点数或某种自定义类型）。如果尝试使用不满足约束的类型调用模板，编译器将在编译时 (compile time) 报错，从而提高代码的健壮性和可读性。</p>
<h2 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h2><p><strong>什么是 Concepts？</strong></p>
<p>想象一下，你写了一个函数模板，比如一个加法函数，你希望它能处理各种数字类型。但有时候，你可能只想让它处理整数，或者只处理有特定行为的类型。在 C++20 之前，实现这种约束比较复杂，通常需要用到 SFINAE (Substitution Failure Is Not An Error) 或者 <code>static_assert</code>。</p>
<p>C++20 引入的 Concepts (概念) 提供了一种更简洁、更直接的方式来表达这些约束。你可以把它看作是对模板参数的“要求”或“合同”。当你定义一个函数模板时，可以指定它的模板参数必须满足某个 Concept。</p>
<p><strong>Concepts 的两大来源：</strong></p>
<ol>
<li><strong>标准库 (standard library) 提供的 Concepts：</strong> C++ 标准库已经为我们预定义了很多常用的 Concepts，可以直接使用。比如用于约束整数类型的 <code>std::integral</code>，约束浮点数类型的 <code>std::floating_point</code> (浮点数类型) 等。本次讲解主要使用这些标准库 Concepts。</li>
<li><strong>自定义 Concepts：</strong> 你也可以根据自己的需求定义新的 Concepts。这部分内容我们将在后续课程中学习。</li>
</ol>
<p><strong>使用 Concepts 的好处：</strong></p>
<ul>
<li><strong>更清晰的编译错误信息：</strong> 当约束不满足时，编译器会直接告诉你哪个 Concept 没有被满足，而不是像 SFINAE 那样产生冗长难懂的错误信息。</li>
<li><strong>将约束写在接口中：</strong> Concepts 直接出现在函数模板的声明中，使得模板的“意图”和“要求”更加明确，提高了代码的可读性。</li>
<li><strong>提高类型安全 (type safety)：</strong> 在编译阶段就能阻止不合适的类型被用于模板，避免了潜在的运行时错误或逻辑错误。</li>
</ul>
<p><strong>如何为函数模板应用 Concepts？（四种语法）</strong></p>
<p>C++20 提供了几种不同的语法来将 Concepts 应用于函数模板：</p>
<p><strong>语法一：模板声明后的 <code>requires</code> 子句 (Clause)</strong></p>
<p>这是最直接的一种方式。在模板参数列表之后，使用 <code>requires</code> 关键字 (keyword)，后跟你的 Concept 和模板参数。</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 包含 Concepts 需要的头文件</span><br><span class="line">#include &lt;concepts&gt; </span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">&#x2F;&#x2F; 在模板参数列表后添加 requires 子句</span><br><span class="line">requires std::integral&lt;T&gt; &#x2F;&#x2F; T 必须满足 std::integral 这个 Concept</span><br><span class="line">auto add(T a, T b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里的 <code>requires std::integral&lt;T&gt;</code> 就表示：只有当调用 <code>add</code> 函数时提供的类型 <code>T</code> 是一个整数类型（如 <code>int</code>, <code>char</code>, <code>short</code>, <code>long</code> 等），这个模板才会被实例化。如果你尝试用 <code>double</code> 或 <code>std::string</code> 来调用它，编译器就会报错。</p>
<ul>
<li><strong>注意:</strong> <code>requires</code> 后面跟的是一个在编译时求值的布尔表达式。这意味着你甚至可以直接使用类型萃取 (Type Traits) 库里的表达式，只要它能在编译时确定结果是 <code>true</code> 或 <code>false</code>。例如：<code>requires std::is_integral_v&lt;T&gt;</code> 也能达到同样的效果。当表达式为 <code>true</code> 时，约束满足；为 <code>false</code> 时，约束不满足，编译失败。</li>
</ul>
<p><strong>语法二：在模板参数列表中直接使用 Concept</strong></p>
<p>你可以直接用 Concept 的名字替换模板参数列表中的 <code>typename</code> 或 <code>class</code>。</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;concepts&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 直接用 Concept std::integral 替代 typename</span><br><span class="line">template &lt;std::integral T&gt; &#x2F;&#x2F; T 必须是整数类型</span><br><span class="line">auto add(T a, T b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这种写法更简洁，意图也非常清晰：<code>T</code> 不仅仅是“任意类型”，而是必须是“满足 <code>std::integral</code> 的类型”。它和语法一的效果是完全一样的。</p>
<p><strong>语法三：结合 <code>auto</code> 参数使用</strong></p>
<p>如果你使用 C++14/17 引入的 <code>auto</code> 作为函数参数类型来简化函数模板的编写（这被称为“简略函数模板”或 “abbreviated function template”），你也可以在 <code>auto</code> 前面加上 Concept 来约束推导出的类型。</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;concepts&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对每个使用 auto 的参数，在其前面加上 Concept</span><br><span class="line">auto add(std::integral auto a, std::integral auto b) &#123; &#x2F;&#x2F; a 和 b 的类型都必须是整数类型</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这表示，编译器在推导 <code>a</code> 和 <code>b</code> 的具体类型时，必须确保推导出的类型满足 <code>std::integral</code> 这个 Concept。</p>
<p><strong>语法四：尾随 <code>requires</code> 子句</strong></p>
<p>你还可以将 <code>requires</code> 子句放在函数参数列表的 <em>后面</em>。</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;concepts&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">auto add(T a, T b) </span><br><span class="line">    requires std::integral&lt;T&gt; &#123; &#x2F;&#x2F; requires 子句放在参数列表之后</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这种语法在某些复杂的情况下可能更灵活，或者在约束依赖于多个模板参数时可读性更好。它和语法一的效果也是一样的。</p>
<p><strong>总结:</strong> 这四种语法提供了灵活性，你可以根据具体情况和个人偏好选择最合适的。核心思想都是一样的：为模板参数添加编译时的约束。</p>
<h2 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h2><p>让我们通过一个完整的例子来看看这些语法如何工作。我们将创建一个 <code>add</code> 函数模板，并使用 <code>std::integral</code> Concept 来约束它只能用于整数类型。</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;concepts&gt; &#x2F;&#x2F; 必须包含 &lt;concepts&gt; 头文件才能使用 Concepts</span><br><span class="line">#include &lt;string&gt;   &#x2F;&#x2F; 只是为了演示非整数类型</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --- 语法一：模板声明后的 requires 子句 ---</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires std::integral&lt;T&gt; &#x2F;&#x2F; T 必须是整数</span><br><span class="line">auto add_syntax1(T a, T b) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;[Syntax 1] &quot;;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --- 语法二：模板参数列表中的 Concept ---</span><br><span class="line">template &lt;std::integral T&gt; &#x2F;&#x2F; T 必须是整数</span><br><span class="line">auto add_syntax2(T a, T b) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;[Syntax 2] &quot;;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --- 语法三：结合 auto 使用 ---</span><br><span class="line">&#x2F;&#x2F; 注意：返回值类型也可以用 Concept auto，或者明确指定，或者让编译器推导</span><br><span class="line">&#x2F;&#x2F; 这里为了简单，我们让编译器推导返回类型</span><br><span class="line">auto add_syntax3(std::integral auto a, std::integral auto b) &#123; </span><br><span class="line">    std::cout &lt;&lt; &quot;[Syntax 3] &quot;;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --- 语法四：尾随 requires 子句 ---</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">auto add_syntax4(T a, T b) </span><br><span class="line">    requires std::integral&lt;T&gt; &#123; &#x2F;&#x2F; T 必须是整数</span><br><span class="line">    std::cout &lt;&lt; &quot;[Syntax 4] &quot;;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i1 &#x3D; 5, i2 &#x3D; 10;</span><br><span class="line">    char c1 &#x3D; &#39;a&#39;, c2 &#x3D; 1; &#x2F;&#x2F; char 也是整数类型</span><br><span class="line">    double d1 &#x3D; 3.14, d2 &#x3D; 2.71;</span><br><span class="line">    &#x2F;&#x2F; std::string s1 &#x3D; &quot;Hello&quot;, s2 &#x3D; &quot; World&quot;; &#x2F;&#x2F; 字符串不是整数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用整数类型调用，这些都应该编译通过</span><br><span class="line">    std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; add_syntax1(i1, i2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;char: &quot; &lt;&lt; add_syntax1(c1, c2) &lt;&lt; std::endl; &#x2F;&#x2F; char 会被提升为 int 进行运算</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; add_syntax2(i1, i2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;char: &quot; &lt;&lt; add_syntax2(c1, c2) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; add_syntax3(i1, i2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;char: &quot; &lt;&lt; add_syntax3(c1, c2) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;int: &quot; &lt;&lt; add_syntax4(i1, i2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;char: &quot; &lt;&lt; add_syntax4(c1, c2) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用 double 类型调用，这些调用会因为不满足 std::integral 约束而导致编译错误</span><br><span class="line">    &#x2F;&#x2F; 取消下面行的注释会导致编译失败</span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; &quot;double: &quot; &lt;&lt; add_syntax1(d1, d2) &lt;&lt; std::endl; </span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; &quot;double: &quot; &lt;&lt; add_syntax2(d1, d2) &lt;&lt; std::endl;</span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; &quot;double: &quot; &lt;&lt; add_syntax3(d1, d2) &lt;&lt; std::endl;</span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; &quot;double: &quot; &lt;&lt; add_syntax4(d1, d2) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 同样，使用 std::string 调用也会失败</span><br><span class="line">    &#x2F;&#x2F; std::cout &lt;&lt; &quot;string: &quot; &lt;&lt; add_syntax1(s1, s2) &lt;&lt; std::endl; &#x2F;&#x2F; 编译错误</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 编译器的错误信息会很清晰，例如（不同编译器略有不同）：</span><br><span class="line">    &#x2F;&#x2F; error: constraints not satisfied for function template &#39;add_syntax1&#39; [with T &#x3D; double]</span><br><span class="line">    &#x2F;&#x2F; note: because &#39;double&#39; does not satisfy concept &#39;integral&#39;</span><br><span class="line">    &#x2F;&#x2F; note: &#39;std::integral&lt;double&gt;&#39; evaluated to false</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>编译和运行:</strong></p>
<p>你需要一个支持 C++20 的编译器（如 GCC 10+ 或 Clang 10+）。编译时需要启用 C++20 标准。</p>
<ul>
<li>使用 GCC: <code>g++ -std=c++20 your_code.cpp -o program</code></li>
<li>使用 Clang: <code>clang++ -std=c++20 your_code.cpp -o program</code></li>
</ul>
<p>当你编译上面的代码（保持 <code>double</code> 调用的注释状态）时，它会成功编译并运行，输出整数和字符相加的结果。如果你取消对 <code>double</code> 类型调用的注释，编译将会失败，并给出类似上面提到的、关于 <code>std::integral</code> 约束不满足的清晰错误信息。</p>
<h2 id="4-问答卡片-QA-Flash-Cards"><a href="#4-问答卡片-QA-Flash-Cards" class="headerlink" title="4. 问答卡片 (QA Flash Cards)"></a>4. 问答卡片 (QA Flash Cards)</h2><ul>
<li><p>问: C++ Concepts 是什么？</p>
<p>  答: C++20 引入的一种机制，用于对函数模板的模板参数施加约束，规定它们必须满足的条件（如类型特性或行为）。</p>
</li>
<li><p>问: 为什么要使用 Concepts？</p>
<p>  答: 提供更清晰的编译错误信息、将约束直接写在函数接口中提高可读性、增强编译时类型安全。</p>
</li>
<li><p>问: 使用标准库 Concepts 需要包含哪个头文件？</p>
<p>  答: #include <concepts></concepts></p>
</li>
<li><p>问: 写出至少两种为函数模板 template <typename t> void func(T arg); 添加 std::integral 约束的语法。</typename></p>
<p>  答:</p>
<ol>
<li><code>template &lt;typename T&gt; requires std::integral&lt;T&gt; void func(T arg);</code></li>
<li><code>template &lt;std::integral T&gt; void func(T arg);</code></li>
<li>(如果用 auto) <code>void func(std::integral auto arg);</code></li>
<li><code>template &lt;typename T&gt; void func(T arg) requires std::integral&lt;T&gt;;</code></li>
</ol>
</li>
</ul>
<h2 id="5-常见误解或错误"><a href="#5-常见误解或错误" class="headerlink" title="5. 常见误解或错误"></a>5. 常见误解或错误</h2><ol>
<li><strong>忘记 <code>#include &lt;concepts&gt;</code>：</strong> 这是最常见的错误。不包含头文件就无法使用标准库定义的 Concepts。</li>
<li><strong>语法混淆：</strong> 对四种语法不熟悉，比如 <code>requires</code> 子句放错位置，或者在 <code>auto</code> 前后错误地使用 Concept。</li>
<li><strong>编译器不支持：</strong> 使用了不支持 C++20 或未启用 C++20 标准的编译器进行编译。</li>
<li><strong>认为 Concepts 是运行时检查：</strong> Concepts 是在编译时 (compile time) 进行检查的，不是在程序运行时。如果编译通过，就意味着约束在编译层面得到了满足。</li>
<li><strong>过度约束：</strong> 有时候可能添加了过于严格的 Concept，导致一些本可以正常工作的类型无法使用模板。需要仔细选择或定义合适的 Concept。</li>
<li><strong>对 Concept 的要求理解不清：</strong> 不清楚某个标准 Concept（如 <code>std::invocable</code>, <code>std::equality_comparable</code>）具体要求类型具备哪些操作或特性，导致使用错误。</li>
</ol>
<h2 id="6-编程练习"><a href="#6-编程练习" class="headerlink" title="6. 编程练习"></a>6. 编程练习</h2><p>假设你有一个函数模板，用于打印任何可以转换为 <code>std::string</code> 的类型的值。请使用 Concepts（选择上面介绍的任意一种语法）来约束模板参数 <code>T</code>，确保只有能隐式转换为 <code>std::string</code> 的类型才能调用这个函数模板。</p>
<p>你需要查找一个合适的标准 Concept 来表达“可以转换为 <code>std::string</code>”。提示：可以在 <code>&lt;concepts&gt;</code> 头文件中查找与转换相关的 Concept。</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;concepts&gt; &#x2F;&#x2F; 确保包含了 concepts 头文件</span><br><span class="line">#include &lt;vector&gt;   &#x2F;&#x2F; 用于测试不兼容类型</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO: 在下面的模板声明中添加合适的 Concept 约束</span><br><span class="line">&#x2F;&#x2F; 要求：类型 T 必须能够隐式转换为 std::string</span><br><span class="line"></span><br><span class="line">&#x2F;* 在这里添加你的 Concept 约束 *&#x2F;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void print_as_string(const T&amp; value) &#123;</span><br><span class="line">    std::string s &#x3D; value; &#x2F;&#x2F; 依赖于 T 到 std::string 的隐式转换</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一个简单的、可以转换为 string 的类</span><br><span class="line">struct MyStringable &#123;</span><br><span class="line">    operator std::string() const &#123; &#x2F;&#x2F; 定义了转换到 std::string 的操作符</span><br><span class="line">        return &quot;MyStringable Object&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    print_as_string(&quot;Hello C++ Concepts!&quot;); &#x2F;&#x2F; const char* 可以转为 string</span><br><span class="line">    print_as_string(std::string(&quot;I am a string.&quot;)); &#x2F;&#x2F; string 本身</span><br><span class="line">    </span><br><span class="line">    MyStringable my_obj;</span><br><span class="line">    print_as_string(my_obj); &#x2F;&#x2F; 自定义类型，可以转为 string</span><br><span class="line"></span><br><span class="line">    int number &#x3D; 123;</span><br><span class="line">    &#x2F;&#x2F; 如果约束正确添加，下面这行应该导致编译错误，因为 int 不能直接转为 std::string</span><br><span class="line">    &#x2F;&#x2F; print_as_string(number); </span><br><span class="line"></span><br><span class="line">    std::vector&lt;int&gt; vec &#x3D; &#123;1, 2, 3&#125;;</span><br><span class="line">     &#x2F;&#x2F; 如果约束正确添加，下面这行也应该导致编译错误</span><br><span class="line">    &#x2F;&#x2F; print_as_string(vec);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请在你认为合适的位置填入 Concept 约束，使得 <code>int</code> 和 <code>std::vector&lt;int&gt;</code> 的调用会导致编译失败，而其他调用可以成功。完成后，请将你修改后的 <code>print_as_string</code> 函数模板定义发给我。</p>
<p>没问题！看来这个练习稍微有点挑战性，这很正常，我们一起来看看答案。</p>
<h2 id="7-练习解答与评价"><a href="#7-练习解答与评价" class="headerlink" title="7. 练习解答与评价"></a>7. 练习解答与评价</h2><p>你没有提供具体的尝试代码，这完全没关系！学习新知识的过程中，遇到困难是很常见的。关键在于理解为什么以及如何解决它。</p>
<p><strong>正确答案：</strong></p>
<p>要约束模板参数 <code>T</code> 必须能隐式转换为 <code>std::string</code>，我们需要使用 C++ 标准库在 <code>&lt;concepts&gt;</code> 头文件中提供的 <code>std::convertible_to</code> Concept。</p>
<p>以下是使用 <strong>语法一 (<code>requires</code> 子句)</strong> 的解决方案：</p>
<p>C++</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;concepts&gt; &#x2F;&#x2F; 确保包含了 concepts 头文件</span><br><span class="line">#include &lt;vector&gt;   &#x2F;&#x2F; 用于测试不兼容类型</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 std::convertible_to Concept 约束 T</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">requires std::convertible_to&lt;T, std::string&gt; &#x2F;&#x2F; 约束：T 必须能隐式转换为 std::string</span><br><span class="line">void print_as_string(const T&amp; value) &#123;</span><br><span class="line">    std::string s &#x3D; value; &#x2F;&#x2F; 依赖于 T 到 std::string 的隐式转换</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; --- 其他代码保持不变 ---</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一个简单的、可以转换为 string 的类</span><br><span class="line">struct MyStringable &#123;</span><br><span class="line">    operator std::string() const &#123; &#x2F;&#x2F; 定义了转换到 std::string 的操作符</span><br><span class="line">        return &quot;MyStringable Object&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    print_as_string(&quot;Hello C++ Concepts!&quot;); &#x2F;&#x2F; const char* 可以转为 string</span><br><span class="line">    print_as_string(std::string(&quot;I am a string.&quot;)); &#x2F;&#x2F; string 本身</span><br><span class="line">    </span><br><span class="line">    MyStringable my_obj;</span><br><span class="line">    print_as_string(my_obj); &#x2F;&#x2F; 自定义类型，可以转为 string</span><br><span class="line"></span><br><span class="line">    int number &#x3D; 123;</span><br><span class="line">    &#x2F;&#x2F; 现在下面这行会导致编译错误，因为 int 不能隐式转为 std::string</span><br><span class="line">    &#x2F;&#x2F; print_as_string(number); </span><br><span class="line"></span><br><span class="line">    std::vector&lt;int&gt; vec &#x3D; &#123;1, 2, 3&#125;;</span><br><span class="line">    &#x2F;&#x2F; 现在下面这行也会导致编译错误</span><br><span class="line">    &#x2F;&#x2F; print_as_string(vec);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释：</strong></p>
<ol>
<li><strong><code>std::convertible_to&lt;From, To&gt;</code>：</strong> 这是标准库提供的一个 Concept，用于检查 <code>From</code> 类型的对象是否可以隐式地转换为 <code>To</code> 类型。在我们的例子中，就是检查类型 <code>T</code> 是否能隐式转换为 <code>std::string</code>。</li>
<li><strong><code>requires std::convertible_to&lt;T, std::string&gt;</code>：</strong> 这行代码是核心。它告诉编译器，只有当模板参数 <code>T</code> 满足“可以隐式转换为 <code>std::string</code>”这个条件时，<code>print_as_string</code> 函数模板才能被实例化。</li>
<li><strong>为什么有效？</strong><ul>
<li><code>const char*</code> (C 风格字符串字面量) 可以隐式转换为 <code>std::string</code>。</li>
<li><code>std::string</code> 自身当然满足条件。</li>
<li><code>MyStringable</code> 类定义了一个 <code>operator std::string()</code>，这使得它可以隐式转换为 <code>std::string</code>。</li>
<li><code>int</code> 和 <code>std::vector&lt;int&gt;</code> 类型没有提供到 <code>std::string</code> 的隐式转换规则，因此它们不满足 <code>std::convertible_to&lt;T, std::string&gt;</code> 这个 Concept，导致编译失败。这正是我们想要的效果！</li>
</ul>
</li>
</ol>
<p><strong>其他语法：</strong></p>
<p>你也可以用其他语法实现相同的约束，例如：</p>
<ul>
<li><strong>语法二:</strong> <code>template &lt;std::convertible_to&lt;std::string&gt; T&gt;</code></li>
<li><strong>语法四:</strong> <code>template &lt;typename T&gt; void print_as_string(const T&amp; value) requires std::convertible_to&lt;T, std::string&gt;</code></li>
</ul>
<p>它们的效果是完全一样的。</p>
<h2 id="8-扩展思考与建议"><a href="#8-扩展思考与建议" class="headerlink" title="8. 扩展思考与建议"></a>8. 扩展思考与建议</h2><p>恭喜你接触了 Concepts 这个强大的 C++20 特性！为了更深入地理解和应用它，你可以尝试思考以下问题或进行探索：</p>
<ol>
<li><strong>尝试其他语法：</strong> 将上面答案中的 <code>requires</code> 子句改成语法二或语法四的形式，亲自验证它们的效果。</li>
<li><strong>探索其他标准 Concepts：</strong><ul>
<li><code>std::same_as&lt;T, U&gt;</code>：检查类型 <code>T</code> 是否与类型 <code>U</code> 完全相同。</li>
<li><code>std::derived_from&lt;Derived, Base&gt;</code>：检查 <code>Derived</code> 是否继承自 <code>Base</code>。</li>
<li><code>std::invocable&lt;Fn, Args...&gt;</code>：检查类型 <code>Fn</code> 的对象是否可以用参数 <code>Args...</code> 来调用（像函数一样）。</li>
<li><code>std::equality_comparable&lt;T&gt;</code>：检查类型 <code>T</code> 的对象是否支持 <code>==</code> 和 <code>!=</code> 操作。</li>
<li><code>std::totally_ordered&lt;T&gt;</code>：检查类型 <code>T</code> 的对象是否支持所有比较操作符 (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>)。</li>
<li>尝试修改 <code>print_as_string</code> 或创建新的模板函数，并使用这些 Concepts 进行约束。</li>
</ul>
</li>
<li><strong>思考 <code>std::convertible_to</code> 的局限性：</strong> 这个 Concept 只检查隐式转换。如果一个类型只能 <em>显式</em> 转换为 <code>std::string</code>（例如，通过 <code>static_cast</code> 或只有一个 <code>explicit</code> 的转换构造函数/操作符），<code>std::convertible_to</code> 会返回 <code>false</code>。思考一下，如果你想允许显式转换，或者想区分隐式和显式转换，该怎么做？（这可能需要自定义 Concept 或其他技术）。</li>
<li><strong>下一步：自定义 Concepts：</strong> 思考一下，标准库 Concepts 可能无法满足所有需求。如果你想定义一个 Concept，要求一个类型必须有一个名为 <code>serialize()</code> 的成员函数，该怎么办？这就是我们接下来要学习的——如何定义你自己的 Concepts！</li>
</ol>
<p>继续努力，多动手实践，你会越来越熟练地掌握 C++ Concepts 的！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Function/">Function    </a><a class="post-meta__tags" href="/tags/Language/">Language    </a><a class="post-meta__tags" href="/tags/Concepts/">Concepts    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/261%20-%20Type%20traits/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>261 - Type traits</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/274%20-%20default%20constructor/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>274 - default constructor</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/268 - Combining concepts/" title="268 - Combining concepts"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">268 - Combining concepts</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/267 - requires clause/" title="267 - requires clause"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">267 - requires clause</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/341 - Linkage Cpp/" title="341 - Linkage Cpp"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">341 - Linkage Cpp</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/return type for lambda function template/" title="return type for lambda function template"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">return type for lambda function template</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/258 - Non type template parameters/" title="258 - Non type template parameters"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">258 - Non type template parameters</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/262 - constexpr if/" title="262 - constexpr if"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">262 - constexpr if</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>