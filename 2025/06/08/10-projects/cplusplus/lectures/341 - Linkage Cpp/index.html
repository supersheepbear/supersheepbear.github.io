<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>341 - Linkage Cpp | Bear's dream</title><meta name="description" content="341 - Linkage Cpp"><meta name="keywords" content="Cpp,Coding,Learning,Function,Language"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="341 - Linkage Cpp"><meta name="twitter:description" content="341 - Linkage Cpp"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="341 - Linkage Cpp"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/341%20-%20Linkage%20Cpp/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="341 - Linkage Cpp"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/341%20-%20Linkage%20Cpp/"><link rel="prev" title="diff between constexpr and define" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/notes/diff%20between%20constexpr%20and%20define/"><link rel="next" title="cpp 全局变量和常量" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/notes/cpp%20%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">178</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">160</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">23</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#341-Linkage-Cpp"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">341 - Linkage Cpp</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-名字的“可见度”：深入理解链接属性（Linkage）"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">C++ 名字的“可见度”：深入理解链接属性（Linkage）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-什么是链接属性？"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">1. 什么是链接属性？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-无链接（No-Linkage）"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">2. 无链接（No Linkage）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-内部链接（Internal-Linkage）"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">3. 内部链接（Internal Linkage）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-外部链接（External-Linkage）"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">4. 外部链接（External Linkage）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-QA-闪卡-QA-Flash-Cards"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">5. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-常见误解与错误"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">6. 常见误解与错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-编程练习：理解链接属性"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">6. 编程练习：理解链接属性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">1.12.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#关于共享-const-值（常量）的最佳实践"><span class="toc_mobile_items-number">1.13.</span> <span class="toc_mobile_items-text">关于共享 const 值（常量）的最佳实践</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#要不要定义成全局变量？"><span class="toc_mobile_items-number">1.14.</span> <span class="toc_mobile_items-text">要不要定义成全局变量？</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#341-Linkage-Cpp"><span class="toc-number">1.</span> <span class="toc-text">341 - Linkage Cpp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-名字的“可见度”：深入理解链接属性（Linkage）"><span class="toc-number">1.3.</span> <span class="toc-text">C++ 名字的“可见度”：深入理解链接属性（Linkage）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是链接属性？"><span class="toc-number">1.4.</span> <span class="toc-text">1. 什么是链接属性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-无链接（No-Linkage）"><span class="toc-number">1.5.</span> <span class="toc-text">2. 无链接（No Linkage）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-内部链接（Internal-Linkage）"><span class="toc-number">1.6.</span> <span class="toc-text">3. 内部链接（Internal Linkage）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-外部链接（External-Linkage）"><span class="toc-number">1.7.</span> <span class="toc-text">4. 外部链接（External Linkage）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-QA-闪卡-QA-Flash-Cards"><span class="toc-number">1.8.</span> <span class="toc-text">5. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-常见误解与错误"><span class="toc-number">1.9.</span> <span class="toc-text">6. 常见误解与错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-编程练习：理解链接属性"><span class="toc-number">1.10.</span> <span class="toc-text">6. 编程练习：理解链接属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">1.11.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">1.12.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于共享-const-值（常量）的最佳实践"><span class="toc-number">1.13.</span> <span class="toc-text">关于共享 const 值（常量）的最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#要不要定义成全局变量？"><span class="toc-number">1.14.</span> <span class="toc-text">要不要定义成全局变量？</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">341 - Linkage Cpp</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/341%20-%20Linkage%20Cpp/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/341%20-%20Linkage%20Cpp/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="341-Linkage-Cpp"><a href="#341-Linkage-Cpp" class="headerlink" title="341 - Linkage Cpp"></a>341 - Linkage Cpp</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture we’re going to learn about linkage and linkage is a property associated with names inyour C plus plus program.We’re going to be exploring this in the context of variable names and function names.And this property is going to control how visible the name is across translation units.Okay, so suppose we have a function here and inside our function we have a variable declared.Inside we have the age variable, the value is six.And the job of this function is to print this out.If you look at this age variable here, it’s really only accessible inside this function.You can’t even access it from the outside of this function here.So we say that this variable, the name for the variable here, this age here, it has no linkage.And what we mean by that is that it really isn’t accessible from anywhere in the global scope of thefile where it is or even in other translation units.So it has no linkage.That’s what we say here.If we look at another example here, we have a variable.For example, it is declared in some file.This is a constant variable and by default, in your C plus plus program, const variables are goingto have internal linkage.What we mean by that is that they can only be accessed or used in the translation unit where they weredeclared and defined.If you try and set up another variable of the same name in another translation unit, you’re not goingto be picking up the name of this variable here.You’re going to be setting up a completely different variable and we’re going to see an example of thisonce we hit Visual Studio code in a minute.But note that constant variables like this have internal linkage by default.And what we mean is that they can only be accessed and used from the translation unit where they weredeclared and defined.So this is another kind of linkage we can have in C plus plus.The first one is null linkage.We can also have internal linkage and it is what we just learned about in this slide here.Another kind of linkage we can have is external linkage.And a good example for this is a global variable which is not const.This is going to have external linkage by default.And what we mean by that is that this variable can be accessed and used in different translation unitsthan the one it was declared and used in.So for example, if this was declared in file one, it is possible to access and use this variable ina separate translation unit.And this is really cool and this is what we mean by external linkage functions.Also default to external linkage in C plus plus you can declare the functions in one translation unitsand use them in a separate translation unit.And we have seen that at multiple occasions.So in C plus plus, we have a lot of options for linkage.We can have no linkage.For example, if a variable is local to a function, we can have internal linkage.And what we mean by that is that this name is not going to be usable or accessible from other translationunits.We can have external linkage.And what we mean by that is that the name can be accessible and used in other translation units, separatefrom the translation units where it was declared and defined.We can also have module linkage, but we don’t have enough tools to really understand this.So in this lecture we’re just going to focus on the three options null linkage, internal and externallinkage.Okay, so let’s recap what we just talked about here.Function.Local variables have no linkage, so they can’t really be accessed even from the outside of the function.If you try to do that, you’re going to get a compiler error cause const global variables have internallinkage by default, so they can only be accessed and used from the translation unit where they weredeclared and Non-const global variables have external linkage.By default they can be used in other translation units.And we’re going to see a few examples of this in a minute.Functions have external linkage and they can be used from the translation units different from the onethey were declared in.Now that you have an idea about what linkage is, again, it is a property associated with names, forexample, variable names, function names, and this property is going to control how visible the nameis across different translation units in your C plus plus program.Now that we know this, we’re going to head over to Visual Studio code and play with this a little more.Okay.So here we are in our working folder.The current project is linkage.We’re going to grab our template files, we’re going to copy them pretty fast and put them in our folderhere.And we are going to open this little guy in Visual Studio code.This is going to give us our main.cpp file.We can clean it up a little bit.And we’re going to close the sidebar here because we don’t need this by now.So the first thing we’re going to look at is no linkage.And the way to set up this example, we’re going to set up a simple function.We’re going to say some function, and inside the function we’re going to set up a variable, call itage and initialize that with a 34, for example.This could work.And what we’re going to do is print this out.We’re going to print the age, but we’re also going to print the address of this age variable.So we’re going to say address of age.We can say that in our C plus plus program.You already know this and we’re going to print the address of age here and we’re going to say Stdendl.And I don’t know why we have this problem here.Why do we have this squiggly lines?We don’t have a pair of parentheses here.That’s the problem.So we can make this work now.And if we’re trying to compile this program, it is going to compile.But before we do that, we’re going to say some function, we’re going to call it, and it is goingto print what we see here.Let’s do that.We’re going to build our program with GCC.And you’re going to see that the world is good.We’re going to bring up a terminal and play with us a little bit.We’re going to run Rooster and we’re going to see our age to be 34.And the address of this variable in memory is what you see right here.But we can separate these guys by putting a space here so that the output is better.Let’s build again.To make sure this is working, we can clear and run Rooster.Now we have the edge here.And the address of this variable is here.It is ending in DBC.But what I want you to see is that the edge variable here is not accessible anywhere outside this functionhere.So, for example, if you try and come in main here and try to print the edge, for example, we’regoing to say edge here.If you try and access this like this, you want to be using this variable here because it isn’t reallyaccessible from the outside.If you’re trying to compile this program, you’re going to see a compiler error that says that edgehere is not declared or defined anywhere.So you’re going to see edge was not declared in this scope, so the compiler doesn’t know what it is.Even if you try and come to the top here and for example, say int H equals 33, for example, whatyou do here is not assigning a value to this edge variable.You are declaring a completely different variable in the global scope of the main function.So the variable we have inside the function and the variable we have on the outside here are different.Let’s try and compile this and see if it works.You’re going to see that the world is good, but if we print the edge, we’re going to see 33, whichis not what we have in our function here.You’re going to see 33.And if we print the address of this, we can do that.We can say edge here.So let’s do that.We’re going to say H, we’re going to put out to the edge and we’re going to put out the address ofthis little guy.We’re going to say address of H and we’re going to do the exact same thing we did in our function here.So if we do this, we will be printing the address of the outside variable here.It won’t be the variable inside our function.So if we do this and say Stdcout.And put a simple separator here so that we can see this fence of the terminal and go down and call somefunction.You can try and guess what we’re going to see.We’re going to see the age printed out.The first one is going to be 33 here and the address is going to be the address of this variable onthe outside.And after our separator here, we’re going to call the function.We’re going to print 34 and we’re going to see a different address.And I am going through this trouble to really try and prove that we can’t access this age variable hereoutside this function.So this guy has no linkage.It can’t be accessed outside this function here.This is what we mean by saying that it has no linkage.Let’s go ahead and run this program so that you can see the output so the world is good.We can clear and run Rooster.We’re going to see first we’re going to see 33.The address is going to be ending in zero 20 and we’re going to see 34 and the address is going to beending in DBC.So they are different variables and the function local variables have no linkage.That’s what we mean here.You can’t access them from the outside of the function.Even in the file where the function was declared and defined and you can’t even access them in a separatefile.For example, if we go here and set up some other file, let’s do that.We’re going to set up some other file dot cpp.If we, for example, set up some function, we’re going to do void.We’re going to call this do something.If we go in and try and print the age and do something like this, for this to work, we need to includeIostream.We’re going to include that.If we do this, we’re going to get a compiler error and the compiler is going to complain that it doesn’tknow what age is because the age we have here can’t really be accessed from anywhere other than withinthis curly braces where this variable is used here and declared.So I hope this is really clear.Let’s try and compile and show you this compiler error we expect from this guy here we’re going to build.Where the JCC and we’re going to see that age was not declared in this scope.The error is coming from some other file dot cpp at line four, and that’s exactly here.So you can’t really do this.Hopefully this drives the point home that function.Local variables have no linkage.Now that we have looked at this, let’s focus on global variables.We’re going to take out this entire thing here because we don’t need this anymore.We’re going to build and make sure the program is compiling correctly.You see, the world is good, so we are good.We’re going to go back in the main CPP file and we’re going to set up a constant variable.We can go down here and actually remove this.Now we have made our point and we don’t want this to confuse us and we’re going to go down and set upa single const variable.We’re going to say const double and it’s going to be called distance.You can call it whatever you want, and we’re going to put in a variable maybe 45.8.Let’s say this is the distance to go somewhere.Okay?So we have this variable here.If we want to use this variable in this translation unit, we can really use it.We can go down and say Stdcout, we’re going to say distance and we’re going to print the distance ofthis variable here.This is going to be important in a minute, and the address of this guy is going to be address of distance.We can close the left sidebar here and make sure this is saying distance.And we’re going to put our new line character using Endl here.And this is going to work.If we build and run this program, we’re going to run the task to build with GCC.The build is going to be good so we can clear and run Rooster.This is going to print our distance.No problem here.The problem is going to come if we want to use this variable in a separate translation unit.So, for example, if we go in our some other file and try to set up something like this, suppose wewant to access this variable from this file here, we can grab the declaration here and the definitionand use that here.For example, we can say const double distance and not put in a value here and hope that inside herewe have this value we have from the main CPP file and this is going to surprise you.Let’s set up a function that is going to print this variable, but it’s going to be printing what wehave in this other translation unit here.So we’re going to say void and we’re going to call this print distance and we’re going to say stdcoutdistance from other file.I think this is going to be descriptive enough, so we’re going to print the distance, but we’re alsogoing to print the address of the variable here.So address of distance is going to be the address of distance, and we’re going to put our new linecharacter.This is going to work.So this is a function declared in some other file or defined.That’s what I should say.So we’re going to come back in main and we’re going to put in a definition for the print distance function.So we’re going to say void print distance.I think it doesn’t take anything.And so we’re going to do this.This is going to do if we go in main and call that function, we’re going to put in a separator.Okay.So let’s try and think about what is going to happen if we run this program.We’re going to print the distance from the variable we have in Main, and we’re going to also call theprint distance function we have in some other file and hope that it’s going to access the distance variablewe have in main because we think this is a declaration for the variable we have in main.So that should bring that in.But what I want you to see is that constant variables have internal linkage by default.So we can’t really access this variable from any other translation unit.If we try to do that like we do here, this is going to be a complete declaration and the definitionof another variable and this is going to initialize this variable to junk.So we’re going to see that junk value printed out here and not what we have in the main function.So the first print out is going to print what we have in main.It’s going to print this value here.It’s going to print its address in memory and the print distance function.It’s going to print some junk value and it’s going to print the address of that junk value.But the addresses are going to be different and the values are also going to be probably different.That’s what we expect here.We’re going to build this with GCC and we’re going to see a problem here.We’re going to see an initialized constant distance.So if you declare a constant, you also have to declare it.So we can’t even do this.And.This is really good.The compiler is helpful here.So in hope to get this to work, we can try and put a pair of braces here to initialize this variableand we’re going to run the test to build with GCC and you’re going to see that the world is good.So if we try to clear and run Rooster, we’re going to see that in Main.We’re going to have our distance here.It’s going to be living at this address.But the value in our some other file is going to be zero because we initialize that to zero and it’sgoing to be a completely different variable because you can’t really access a constant variable or aconstant global variable declared in another file.And we have a constant distance variable here.It has internal linkage.It can only be used from the translation unit where it was declared.This is the message here.So you can’t really do what we are trying to do here.If you do this, this will be a completely separate variable.And we have proven that because we see the addresses to be different here.What we have in Main is living at this address ending in 060.What we have in some other file is living at an address ending in zero, a zero.So they are two completely different variables.We can’t really access this variable from any other translation unit.It has internal linkage.This is what we mean here.Okay.So now that we know about internal linkage, we’re going to learn about external linkage and we’re goingto go down and set up another variable, we are going to say INT and we’re going to call this item count.Why not?And we’re going to put in a value of six.Why not?And because this is a not constant global variable, this thing is going to have external linkage.I really want you to know this.And what this means is that we can access this guy even from other translation units and it’s goingto be the exact same variable.The memory is going to be the same if we print that out.And to really show this, we’re going to go back in some other file and try to access our item count.But to do that, we need to mark this guy as a variable defined in some other translation unit.And to do that, we use the external keyword.We’re going to say extern, we are going to say its type and we’re going to say the name of the variable.We’re going to say item count.And this is going to be a declaration of a variable that was defined in some other translation unit.This is what we mean here.So if, for example, we set up a function to print the item count, we’re going to see that what weare accessing is what we have in the main function here, because this guy has external linkage.It can be accessible and used even from other translation units like some other file here.So let’s go down and do that.We’re going to set up a function.We’re going to say void print item count, and we’re going to put up a parameter list and we’re goingto say stdcout item count from other file, and we’re going to say Stdendl to go to the new line.We should separate these guys a little bit and we’re going to just grab this thing and use this in main.So we’re going to comment out the things we had for the distance, because they should be just confusingus now.And we’re going to put a line to print from the main function.Let’s do that.This is going to print item count that we have in main here.So let’s say that this is from Main and we’re going to put a separator N and then we’re going to setup a declaration for the print item count function.We can go on top here and do that.And if we have this n, we can go down and call the function.So let’s do that.We can say print item count and if we’re build and run this program, we try to think about what we’regoing to get.The first print here is going to print the variable we have in main, which is declared right here.So it’s going to print the item count in Main.It’s going to print the value, which is going to be a six, and it’s going to print the address ofthis variable because this variable is not cost.It has external linkage by default.So it can be accessible even from other translation units like some other file.Here we have it declared.Again, this is not a definition of a variable.It is just a declaration of a variable we have defined in some other translation unit.So what we really have here is a way to access something that we have declared and defined in the mainfunction here.So if we print the item count here, we will be accessing what we have in the main function.So they are going to be the same.The value is going to be the same.And the addresses are going to be the same.That’s what we expect here.Let’s bring this up and we’re going to build the program to make sure we get what we expect.The world is going to be good, so we’re going to clear and run.Rooster You see that the value is the same and the addresses in memory are of the same.So this should really prove that external linkage means that you can access the variable from othertranslation units.And the mechanism we have is to mark the variable as extern.And this is going to mean that it was defined in some other variable, but we can access it and useit even from other translation units like we are doing in this function here.And this is really cool, but this is not just limited to non-const global variables.Even functions have external linkage by default.Okay, so but for function we don’t really need to mark them as external or anything.They have external linkage by default.For example, we had declared and defined the print item function in some other file here, but we areable to access it and use that even from the main CPP file here, which is another translation unit.So functions have external linkage by default and we can go in here and say that, but if you want toreally be explicit, you can go down and say that they are external.You can come and put the external keyword in front.This is not going to hurt anything, but it’s going to be just repeating yourself because they are externalby default.If we try and build the program, you’re going to see that this is going to build and run without aproblem.So the build is good.You can put this external keyword here or you can leave it, but note that functions have external linkageby default.This is really all I wanted you to see in this lecture.Learning about the concept of linkage.It is a property that you associate to your names in your Cplusplus program.That property is going to control how accessible the name is going to be a cross translation unit.And we had a chance to look at three kinds of linkage in this lecture here.We have seen that variables may have a null linkage, for example, local variables to functions.We have seen that some variables have internal linkage, for example, const global variables and wehave seen that some other variables can have external linkage like the item count here.And this should be super clear.We are going to stop here in this lecture and the next one we’re going to zoom in on global externalvariables like we have this guy here.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，各位未来的C++大师们！欢迎来到我们的C++学习之旅。</p>
<hr>
<h2 id="C-名字的“可见度”：深入理解链接属性（Linkage）"><a href="#C-名字的“可见度”：深入理解链接属性（Linkage）" class="headerlink" title="C++ 名字的“可见度”：深入理解链接属性（Linkage）"></a><strong>C++ 名字的“可见度”：深入理解链接属性（Linkage）</strong></h2><p><strong>摘要：</strong> 本节课将带你深入理解C++中“名字”（变量名、函数名等）的<strong>链接属性</strong>（Linkage），它决定了一个名字在不同<strong>翻译单元</strong>（Translation Unit）之间的可见性，以及它是否引用同一个实体。我们将重点探讨无链接（No Linkage）、内部链接（Internal Linkage）和外部链接（External Linkage）这三种类型。</p>
<hr>
<h2 id="1-什么是链接属性？"><a href="#1-什么是链接属性？" class="headerlink" title="1. 什么是链接属性？"></a><strong>1. 什么是链接属性？</strong></h2><p>在C++中，<strong>链接属性</strong>（Linkage）是与你的程序中<strong>名字</strong>（Name），例如变量名、函数名等，关联的一个重要特性。它控制着这些名字在不同的<strong>翻译单元</strong>（Translation Unit）之间如何被看见和使用。理解链接属性对于编写大型、模块化的C++程序至关重要。</p>
<p>首先，我们得清楚什么是“翻译单元”。简单来说，一个<strong>翻译单元</strong>（Translation Unit）通常指一个独立的 <code>.cpp</code> 源文件及其所包含（通过<code>#include</code>）的所有头文件，在经过预处理器处理之后，生成的一个可以直接编译的单一文件。你的整个程序可能由多个这样的翻译单元组成，它们最终会被链接器（Linker）组合起来形成可执行文件。</p>
<p>链接属性就是用来告诉编译器和链接器：这个名字，是只在这个翻译单元里有效，还是可以在其他翻译单元里也能访问到，又或者根本就不能从这个名字以外的地方访问。</p>
<p>C++中的链接属性主要有以下几种类型：</p>
<ul>
<li><strong>无链接（No Linkage）：</strong> 名字只在它被定义的<strong>作用域</strong>（Scope）内可见和使用，无法从其作用域外部访问，更不能在其他翻译单元中访问。</li>
<li><strong>内部链接（Internal Linkage）：</strong> 名字可以在它被定义的那个翻译单元的<strong>全局作用域</strong>（Global Scope）内被访问和使用，但无法从其他翻译单元中访问。每个翻译单元如果定义了同名的内部链接实体，它们都是独立的，互不影响。</li>
<li><strong>外部链接（External Linkage）：</strong> 名字可以在它被定义的翻译单元中被访问，也可以在<strong>其他翻译单元</strong>中被访问和使用。所有引用同一个外部链接名字的地方，都指向内存中的同一个实体。</li>
<li><strong>模块链接（Module Linkage）：</strong> 这是C++20引入的新概念，用于模块（Module），目前我们暂时不深入探讨，先专注于前三种。</li>
</ul>
<p>接下来，我们将通过具体的代码示例来深入理解这三种最常见的链接属性。</p>
<h2 id="2-无链接（No-Linkage）"><a href="#2-无链接（No-Linkage）" class="headerlink" title="2. 无链接（No Linkage）"></a><strong>2. 无链接（No Linkage）</strong></h2><p>当一个名字没有链接属性时，它仅仅在它被声明的<strong>局部作用域</strong>（Local Scope）内可见。这意味着你不能在定义它的函数外部访问它，更不能在其他翻译单元中访问它。</p>
<p><strong>示例：函数内的局部变量</strong></p>
<p>函数内部声明的局部变量，如<code>age</code>，它们只在函数内部的<strong>块作用域</strong>（Block Scope）内有效。一旦函数执行完毕，这些变量通常就会被销毁，并且在函数外部根本无法通过这个名字来访问它们。</p>
<p><strong>main.cpp</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 引入输入输出流库</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们有一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">34</span>; <span class="comment">// 这是一个函数局部变量，它具有“无链接”属性</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"在 someFunction 内部: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"age 的值: "</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"age 的地址: "</span> &lt;&lt; &amp;age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 打印变量的内存地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ------------------------------------------</span></span><br><span class="line">    <span class="comment">// 演示无链接 (No Linkage)</span></span><br><span class="line">    <span class="comment">// ------------------------------------------</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 演示无链接 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 调用 someFunction，内部的 age 变量会被创建并使用</span></span><br><span class="line">    someFunction();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 尝试访问函数外部的局部变量 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 2. 尝试在 main 函数中访问 someFunction 内部的 age 变量</span></span><br><span class="line">    <span class="comment">// 这会导致编译错误，因为 age 只在 someFunction 内部可见。</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "在 main 内部尝试访问 someFunction 的 age: " &lt;&lt; age &lt;&lt; std::endl; </span></span><br><span class="line">    <span class="comment">// ^^^ 如果取消注释这一行，会报错：'age' was not declared in this scope</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 证明即使在同一个文件，不同作用域的同名变量也是独立的</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">33</span>; <span class="comment">// 这是 main 函数自己的局部变量，与 someFunction 里的 age 毫无关系</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"在 main 内部: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main 自己的 age 的值: "</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main 自己的 age 的地址: "</span> &lt;&lt; &amp;age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 打印 main 自己的 age 的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次调用 someFunction，看看它内部的 age 仍然是独立的</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 再次调用 someFunction ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    someFunction(); <span class="comment">// 再次调用，可以看到 someFunction 内部的 age 仍然是 34，且地址可能不同（如果栈分配）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 演示无链接 (跨文件) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 4. 尝试在另一个翻译单元中访问。</span></span><br><span class="line">    <span class="comment">// 假设我们有另一个文件 some_other_file.cpp</span></span><br><span class="line">    <span class="comment">// 里面有一个函数尝试访问 someFunction 里的 age。</span></span><br><span class="line">    <span class="comment">// 这同样会失败。</span></span><br><span class="line">    <span class="comment">// 在这里，我们需要声明 someOtherFunction 的原型，因为它在另一个文件中定义</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>; <span class="comment">// 声明在 some_other_file.cpp 中定义的函数</span></span><br><span class="line">    doSomething(); <span class="comment">// 调用在 some_other_file.cpp 中定义的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>some_other_file.cpp</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试在另一个翻译单元中访问 main.cpp 中 someFunction 里的 age 变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"在 some_other_file.cpp 内部的 doSomething 函数: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// int age_from_main_function = age; // 这将导致编译错误：'age' was not declared in this scope</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"无法直接访问 main.cpp 中 someFunction 里的局部变量 age。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释：</strong><br>当你在<code>main</code>函数中尝试访问<code>someFunction</code>内部的<code>age</code>时，编译器会报错<code>&#39;age&#39; was not declared in this scope</code>（age在此作用域中未声明）。这清楚地表明<code>age</code>只在<code>someFunction</code>的<strong>作用域</strong>内可见。即使你在<code>main</code>函数中声明了一个同名的<code>age</code>变量，它们也是完全独立的实体，位于不同的内存地址，互不干扰。这说明了局部变量的“无链接”特性。</p>
<h2 id="3-内部链接（Internal-Linkage）"><a href="#3-内部链接（Internal-Linkage）" class="headerlink" title="3. 内部链接（Internal Linkage）"></a><strong>3. 内部链接（Internal Linkage）</strong></h2><p>具有内部链接属性的名字，只能在定义它的那个<strong>翻译单元</strong>内部被访问和使用。即使你在另一个翻译单元中声明了一个同名的实体，它们也是完全独立的，互不影响。这就像每个文件都有自己私有的同名副本。</p>
<p><strong>示例：<code>const</code> 全局变量</strong></p>
<p>在C++中，<code>const</code>修饰的<strong>全局变量</strong>（Global Variable）默认具有内部链接属性。</p>
<p><strong>main.cpp</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个 const 全局变量，它默认具有“内部链接”属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> distance = <span class="number">45.8</span>; <span class="comment">// 距离某个地方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明在 some_other_file.cpp 中定义的函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDistance</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 演示内部链接 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"在 main.cpp 内部: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"distance 的值: "</span> &lt;&lt; distance &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"distance 的地址: "</span> &lt;&lt; &amp;distance &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 打印在 main.cpp 中 distance 的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 尝试在另一个翻译单元中访问 distance ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    printDistance(); <span class="comment">// 调用在 some_other_file.cpp 中定义的函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>some_other_file.cpp</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试在另一个翻译单元中“访问” main.cpp 中的 distance。</span></span><br><span class="line"><span class="comment">// 但由于 const 全局变量默认是内部链接，这里实际上是定义了一个全新的、独立的 distance 变量。</span></span><br><span class="line"><span class="comment">// 注意：如果这里不初始化，会报错 "uninitialized const 'distance'"</span></span><br><span class="line"><span class="comment">// 因为它不是声明一个外部变量，而是一个新的定义。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> distance = <span class="number">0.0</span>; <span class="comment">// 在这个文件里定义了一个独立的 const distance 变量，并初始化为 0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDistance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"在 some_other_file.cpp 内部的 printDistance 函数: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"distance (从其他文件) 的值: "</span> &lt;&lt; distance &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"distance (从其他文件) 的地址: "</span> &lt;&lt; &amp;distance &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 打印在 some_other_file.cpp 中 distance 的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释：</strong><br>当你编译并运行这个程序时，你会发现<code>main.cpp</code>中打印的<code>distance</code>值是<code>45.8</code>，地址是某个值；而<code>some_other_file.cpp</code>中打印的<code>distance</code>值是<code>0.0</code>，地址是另一个完全不同的值。这证明了即使它们有相同的名字，由于<code>const</code>全局变量默认的内部链接属性，每个翻译单元都拥有自己独立的<code>distance</code>副本。它们之间没有任何关联。</p>
<p><strong>思考：</strong> 为什么<code>const</code>全局变量默认是内部链接？<br>这是C++语言设计的一个考量。如果<code>const</code>全局变量默认是外部链接，那么当你在多个源文件中<code>#include</code>同一个定义了<code>const</code>全局变量的头文件时，会导致多个翻译单元都定义了同一个外部链接变量，从而违反了C++的<strong>单一定义规则</strong>（One Definition Rule, ODR），链接器会报错。将<code>const</code>全局变量默认设为内部链接，可以避免这个问题，每个翻译单元都会获得一个独立的副本，这通常是期望的行为。</p>
<h2 id="4-外部链接（External-Linkage）"><a href="#4-外部链接（External-Linkage）" class="headerlink" title="4. 外部链接（External Linkage）"></a><strong>4. 外部链接（External Linkage）</strong></h2><p>具有外部链接属性的名字，可以在它被定义的翻译单元中被访问和使用，更重要的是，它也可以在<strong>其他翻译单元</strong>中被访问和使用。所有引用同一个外部链接名字的地方，都指向内存中的同一个实体。这是实现多文件协作和模块化编程的基础。</p>
<p><strong>示例1：非 <code>const</code> 全局变量</strong></p>
<p>非<code>const</code>修饰的<strong>全局变量</strong>默认具有外部链接属性。要在一个翻译单元中使用另一个翻译单元中定义的外部链接变量，你需要使用<code>extern</code>关键字进行<strong>声明</strong>（Declaration），而不是再次进行<strong>定义</strong>（Definition）。</p>
<p><strong>main.cpp</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个非 const 全局变量，它默认具有“外部链接”属性</span></span><br><span class="line"><span class="keyword">int</span> item_count = <span class="number">6</span>; <span class="comment">// 物品数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明在 some_other_file.cpp 中定义的函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printItemCount</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 演示外部链接 (非 const 全局变量) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"在 main.cpp 内部: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"item_count 的值: "</span> &lt;&lt; item_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"item_count 的地址: "</span> &lt;&lt; &amp;item_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 打印在 main.cpp 中 item_count 的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 尝试在另一个翻译单元中访问 item_count ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    printItemCount(); <span class="comment">// 调用在 some_other_file.cpp 中定义的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在 main 中修改 item_count 的值，然后看看 printItemCount 是否会受到影响</span></span><br><span class="line">    item_count = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 在 main.cpp 中修改 item_count 后再次调用 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    printItemCount(); <span class="comment">// 再次调用，item_count 的值应该会反映出修改</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>some_other_file.cpp</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 extern 关键字声明 item_count</span></span><br><span class="line"><span class="comment">// 这告诉编译器：item_count 在其他翻译单元中已经定义了，这里只是声明要使用它。</span></span><br><span class="line"><span class="comment">// 这不是定义一个新的变量，而是引用 main.cpp 中已经存在的那个 item_count。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> item_count; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"在 some_other_file.cpp 内部的 printItemCount 函数: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"item_count (从其他文件) 的值: "</span> &lt;&lt; item_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"item_count (从其他文件) 的地址: "</span> &lt;&lt; &amp;item_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 打印在 some_other_file.cpp 中 item_count 的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释：</strong><br>你会看到<code>main.cpp</code>和<code>some_other_file.cpp</code>中打印的<code>item_count</code>的值和地址都是相同的。这证明了它们访问的是内存中的同一个变量。当<code>main.cpp</code>修改了<code>item_count</code>的值后，<code>some_other_file.cpp</code>中的<code>printItemCount</code>函数也能立即看到这个改变，这正是外部链接的强大之处。</p>
<p><strong>示例2：函数</strong></p>
<p><strong>函数</strong>（Function）默认也具有外部链接属性。这就是为什么你可以在一个 <code>.cpp</code> 文件中定义函数，然后在另一个 <code>.cpp</code> 文件中调用它，只要提供了函数的<strong>声明</strong>（原型）即可。</p>
<p><strong>main.cpp</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明在 some_other_file.cpp 中定义的函数原型</span></span><br><span class="line"><span class="comment">// void doSomething(); // 这个我们前面演示无链接时用过，这里可以继续保留</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printItemCount</span><span class="params">()</span></span>; <span class="comment">// 声明 printItemCount 函数，它在 some_other_file.cpp 中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 演示外部链接 (函数) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 我们已经多次调用了 printItemCount 函数，它是在 some_other_file.cpp 中定义的。</span></span><br><span class="line">    <span class="comment">// 这本身就证明了函数的默认链接属性是外部链接。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"printItemCount 函数是在 some_other_file.cpp 中定义的，但可以在 main.cpp 中调用。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    printItemCount(); <span class="comment">// 再次调用，以示函数可以在不同翻译单元间使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你也可以显式地给函数添加 extern 关键字，但这通常是多余的，因为函数默认就是外部链接。</span></span><br><span class="line">    <span class="comment">// extern void printItemCount(); // 这样写是完全合法的，但通常省略。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>some_other_file.cpp</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> item_count; <span class="comment">// 再次声明 item_count 为外部链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// printItemCount 函数的定义</span></span><br><span class="line"><span class="comment">// 默认情况下，函数是外部链接的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printItemCount</span><span class="params">()</span> </span>&#123; <span class="comment">// 这里的 void 也可以加上 extern，但通常省略</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"在 some_other_file.cpp 内部的 printItemCount 函数 (再次被调用): "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"item_count 的值: "</span> &lt;&lt; item_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"item_count 的地址: "</span> &lt;&lt; &amp;item_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释：</strong><br>我们一直以来都在跨文件调用函数，而没有遇到任何问题，这正是因为C++中的函数默认就具有外部链接属性。这意味着你可以在一个文件（翻译单元）中定义一个函数，然后通过在另一个文件（翻译单元）中提供其<strong>函数原型</strong>（Function Prototype）来调用它。</p>
<h2 id="5-QA-闪卡-QA-Flash-Cards"><a href="#5-QA-闪卡-QA-Flash-Cards" class="headerlink" title="5. QA 闪卡 (QA Flash Cards)"></a><strong>5. QA 闪卡 (QA Flash Cards)</strong></h2><p><strong>问题 (Q):</strong> 什么是 C++ 中的“链接属性”？<br><strong>答案 (A):</strong> 链接属性是与 C++ 程序中的名字（如变量名、函数名）相关联的一个特性，它决定了这些名字在不同<strong>翻译单元</strong>之间如何被看见和使用。</p>
<p><strong>问题 (Q):</strong> 局部变量（如函数内部定义的变量）具有哪种链接属性？它的可见范围是什么？<br><strong>答案 (A):</strong> 局部变量具有<strong>无链接</strong>（No Linkage）属性。它们只在被定义的<strong>作用域</strong>内可见和使用，无法从其作用域外部或其它翻译单元中访问。</p>
<p><strong>问题 (Q):</strong> <code>const</code> 修饰的全局变量默认具有哪种链接属性？这意味着什么？<br><strong>答案 (A):</strong> <code>const</code> 修饰的全局变量默认具有<strong>内部链接</strong>（Internal Linkage）属性。这意味着它只能在定义它的那个<strong>翻译单元</strong>内部被访问和使用。即使在其他翻译单元中定义同名变量，它们也是独立的实体，互不影响。</p>
<p><strong>问题 (Q):</strong> 非 <code>const</code> 修饰的全局变量和函数默认具有哪种链接属性？这意味着什么？<br><strong>答案 (A):</strong> 非 <code>const</code> 修饰的全局变量和函数默认具有<strong>外部链接</strong>（External Linkage）属性。这意味着它们不仅可以在定义它们的翻译单元中访问，也可以在<strong>其他翻译单元</strong>中被访问和使用。所有引用同一个外部链接名字的地方，都指向内存中的同一个实体。</p>
<p><strong>问题 (Q):</strong> 如果我想在文件 <code>B.cpp</code> 中使用文件 <code>A.cpp</code> 中定义的非 <code>const</code> 全局变量 <code>myVar</code>，我应该怎么做？<br><strong>答案 (A):</strong> 在 <code>B.cpp</code> 中，你需要使用 <code>extern</code> 关键字对 <code>myVar</code> 进行<strong>声明</strong>，例如：<code>extern int myVar;</code>。这告诉编译器 <code>myVar</code> 在其他地方已经定义了。</p>
<h2 id="6-常见误解与错误"><a href="#6-常见误解与错误" class="headerlink" title="6. 常见误解与错误"></a><strong>6. 常见误解与错误</strong></h2><ol>
<li><p><strong>误解1：函数内的局部变量可以在文件其他地方访问。</strong></p>
<ul>
<li><strong>错误：</strong> 认为<code>someFunction</code>内部的<code>age</code>可以在<code>main</code>函数中直接使用。</li>
<li><strong>原因：</strong> 局部变量是“无链接”的，它们只存在于其函数或块的作用域内。一旦作用域结束，变量就会销毁。</li>
<li><strong>正确理解：</strong> 局部变量与外部世界是隔离的，只能在定义它们的 <code>{}</code> 内部访问。</li>
</ul>
</li>
<li><p><strong>误解2：<code>const</code> 全局变量可以在不同文件之间共享。</strong></p>
<ul>
<li><strong>错误：</strong> 认为在 <code>main.cpp</code> 定义 <code>const int MY_CONST = 10;</code> 后，可以在 <code>other.cpp</code> 中通过 <code>extern const int MY_CONST;</code> 来访问同一个 <code>MY_CONST</code>。</li>
<li><strong>原因：</strong> <code>const</code> 全局变量默认是“内部链接”。在 <code>other.cpp</code> 中写 <code>const int MY_CONST;</code> 会定义一个完全独立的新的 <code>MY_CONST</code> 变量（需要初始化），而不是引用 <code>main.cpp</code> 中的那个。</li>
<li><strong>正确理解：</strong> 要想在不同文件之间共享一个 <code>const</code> 值，通常有两种方法：<ul>
<li>将其定义为 <code>extern const int MY_CONST = 10;</code> (定义一次，外部链接)。</li>
<li>将其放入头文件，并标记为 <code>inline const int MY_CONST = 10;</code> (C++17)，或者只在头文件声明 <code>extern const int MY_CONST;</code> 然后在某个 <code>.cpp</code> 文件中定义 <code>const int MY_CONST = 10;</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>误解3：<code>extern</code> 关键字是用来定义的。</strong></p>
<ul>
<li><strong>错误：</strong> 在 <code>some_other_file.cpp</code> 中写 <code>extern int item_count = 10;</code> 认为这是在声明并引用 <code>main.cpp</code> 中的 <code>item_count</code>。</li>
<li><strong>原因：</strong> <code>extern</code> 关键字表示“此变量在别处定义”，但如果同时给它赋了初始值，它就变成了<strong>定义</strong>，而不是简单的声明。这意味着你会在 <code>some_other_file.cpp</code> 中创建一个<strong>新的</strong> <code>item_count</code> 变量，与 <code>main.cpp</code> 中的 <code>item_count</code> 冲突（单一定义规则 violation），导致链接错误。</li>
<li><strong>正确理解：</strong> <code>extern</code> 后面跟着的通常只是声明，不带初始化。例如：<code>extern int item_count;</code>。<strong>定义</strong>（Definition）发生在没有<code>extern</code>，或者带有初始化的那一次。</li>
</ul>
</li>
<li><p><strong>误解4：没有理解“翻译单元”的概念。</strong></p>
<ul>
<li><strong>错误：</strong> 认为只要在一个 <code>.cpp</code> 文件里定义了，它就在整个项目里都可见。</li>
<li><strong>原因：</strong> C++ 程序是分模块编译的，每个 <code>.cpp</code> 文件及其包含的头文件构成一个独立的“翻译单元”。链接属性正是用来控制这些翻译单元之间的名字可见性。</li>
<li><strong>正确理解：</strong> 区分<strong>声明</strong>（告诉编译器一个名字存在）和<strong>定义</strong>（分配内存并初始化）。链接属性控制的是如何跨越翻译单元共享或隔离这些声明和定义。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-编程练习：理解链接属性"><a href="#6-编程练习：理解链接属性" class="headerlink" title="6. 编程练习：理解链接属性"></a><strong>6. 编程练习：理解链接属性</strong></h2><p>现在，是时候动手实践了！请完成下面的代码，使其能够正确演示不同链接属性的行为。</p>
<p><strong>任务：</strong></p>
<ol>
<li>创建一个 <code>main.cpp</code> 文件。</li>
<li>创建一个 <code>helper.cpp</code> 文件。</li>
<li>创建一个 <code>helper.h</code> 头文件。</li>
</ol>
<p><strong><code>helper.h</code> 文件内容：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once <span class="comment">// 确保头文件只被包含一次</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 声明一个函数，它将在 helper.cpp 中定义</span></span><br><span class="line"><span class="comment">//    这个函数将尝试访问 helper.cpp 中具有内部链接的变量。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInternalVariable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 声明一个函数，它将在 helper.cpp 中定义</span></span><br><span class="line"><span class="comment">//    这个函数将尝试访问 main.cpp 中具有外部链接的变量。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printExternalVariable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在 helper.h 中声明一个 extern int 变量，表示它将在某个 .cpp 文件中定义</span></span><br><span class="line"><span class="comment">//    <span class="doctag">TODO:</span> 在这里添加 extern int variable_from_main 的声明</span></span><br><span class="line"><span class="comment">// extern int variable_from_main; // 提示：你需要在这里声明它</span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code> 文件内容：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helper.h"</span> <span class="comment">// 包含 helper.h 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义一个函数局部变量（无链接）并在 main 中尝试访问它</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunctionWithLocalVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> local_data = <span class="number">100</span>; <span class="comment">// 局部变量，无链接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myFunctionWithLocalVariable 内部: local_data = "</span> &lt;&lt; local_data &lt;&lt; <span class="string">", 地址: "</span> &lt;&lt; &amp;local_data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义一个 const 全局变量 (内部链接)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> internal_global_const = <span class="number">50</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定义一个非 const 全局变量 (外部链接)</span></span><br><span class="line"><span class="comment">//    <span class="doctag">TODO:</span> 在这里定义一个名为 external_global_variable 的 int 变量，并初始化为 200</span></span><br><span class="line"><span class="comment">// int external_global_variable = 200; // 提示：你需要在这里定义它</span></span><br><span class="line"><span class="keyword">int</span> external_global_variable = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 链接属性演示 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示无链接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 无链接 (局部变量) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    myFunctionWithLocalVariable();</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "在 main 中尝试访问 local_data: " &lt;&lt; local_data &lt;&lt; std::endl; // 这行如果取消注释会报错，验证无链接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示内部链接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 内部链接 (const 全局变量) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main.cpp 内部: internal_global_const = "</span> &lt;&lt; internal_global_const </span><br><span class="line">              &lt;&lt; <span class="string">", 地址: "</span> &lt;&lt; &amp;internal_global_const &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    printInternalVariable(); <span class="comment">// 调用 helper.cpp 中的函数，它将尝试访问它的内部链接变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示外部链接</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 外部链接 (非 const 全局变量和函数) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main.cpp 内部: external_global_variable = "</span> &lt;&lt; external_global_variable </span><br><span class="line">              &lt;&lt; <span class="string">", 地址: "</span> &lt;&lt; &amp;external_global_variable &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    printExternalVariable(); <span class="comment">// 调用 helper.cpp 中的函数，它将访问 external_global_variable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试在 main 中修改 external_global_variable 的值，并再次在 helper.cpp 中打印</span></span><br><span class="line">    external_global_variable = <span class="number">300</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 修改 external_global_variable 后 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main.cpp 内部: external_global_variable = "</span> &lt;&lt; external_global_variable </span><br><span class="line">              &lt;&lt; <span class="string">", 地址: "</span> &lt;&lt; &amp;external_global_variable &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    printExternalVariable(); <span class="comment">// 再次调用，观察值是否同步改变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>helper.cpp</code> 文件内容：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helper.h"</span> <span class="comment">// 包含 helper.h 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在这里重新定义一个名为 internal_global_const 的 const int 变量，并初始化为 77。</span></span><br><span class="line"><span class="comment">//       注意：这应该是一个新的、独立的变量，与 main.cpp 中的同名变量互不影响。</span></span><br><span class="line"><span class="comment">// const int internal_global_const = 77; // 提示：你需要在这里定义它</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> internal_global_const = <span class="number">77</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 声明 main.cpp 中定义的 external_global_variable 为外部链接。</span></span><br><span class="line"><span class="comment">//       注意：这里只是声明，不能初始化。</span></span><br><span class="line"><span class="comment">// extern int external_global_variable; // 提示：你需要在这里声明它</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> external_global_variable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInternalVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"helper.cpp 内部: internal_global_const = "</span> &lt;&lt; internal_global_const </span><br><span class="line">              &lt;&lt; <span class="string">", 地址: "</span> &lt;&lt; &amp;internal_global_const &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printExternalVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"helper.cpp 内部: external_global_variable = "</span> &lt;&lt; external_global_variable </span><br><span class="line">              &lt;&lt; <span class="string">", 地址: "</span> &lt;&lt; &amp;external_global_variable &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>请完成上述代码中标注 <code>TODO:</code> 的部分。完成后，编译并运行你的程序，观察输出，特别是变量的值和地址，以验证你的理解。</strong></p>
<hr>
<p>请在完成上述代码后，将你的解决方案粘贴到回复中。我将为你评分并提供详细的答案和解释。</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>误解2：const 全局变量可以在不同文件之间共享。</p>
<p>错误： 认为在 main.cpp 定义 const int MY_CONST = 10; 后，可以在 other.cpp 中通过 extern const int MY_CONST; 来访问同一个 MY_CONST。<br>原因： const 全局变量默认是“内部链接”。在 other.cpp 中写 const int MY_CONST; 会定义一个完全独立的新的 MY_CONST 变量（需要初始化），而不是引用 main.cpp 中的那个。<br>正确理解： 要想在不同文件之间共享一个 const 值，通常有两种方法：<br>将其定义为 extern const int MY_CONST = 10; (定义一次，外部链接)。<br>将其放入头文件，并标记为 inline const int MY_CONST = 10; (C++17)，或者只在头文件声明 extern const int MY_CONST; 然后在某个 .cpp 文件中定义 const int MY_CONST = 10;。</p>
<p>请问best practice是什么？ 要不要定义成全局变量？</p>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常棒的问题！你不仅关注了技术细节，还深入思考了“最佳实践”和设计原则，这正是成为优秀C++开发者所需要的思维方式。</p>
<p>我们来逐一解答你的问题：</p>
<h2 id="关于共享-const-值（常量）的最佳实践"><a href="#关于共享-const-值（常量）的最佳实践" class="headerlink" title="关于共享 const 值（常量）的最佳实践"></a><strong>关于共享 <code>const</code> 值（常量）的最佳实践</strong></h2><p>正如你所理解的，C++中 <code>const</code> 全局变量默认是<strong>内部链接</strong>（Internal Linkage）。这意味着每个<strong>翻译单元</strong>（Translation Unit）都会有自己的独立副本，如果直接将它放在头文件中，并且该头文件被多个 <code>.cpp</code> 文件包含，这不会导致链接错误，但会导致每个 <code>.cpp</code> 文件都有一个独立的副本，这可能不是你想要的“共享”同一个实体。</p>
<p>为了在多个翻译单元之间真正“共享”同一个 <code>const</code> 值（即它们都引用内存中的同一个实体），C++ 提供了几种最佳实践方法，它们避免了<strong>单一定义规则</strong>（One Definition Rule, ODR）的冲突：</p>
<ol>
<li><p><strong>使用 <code>extern</code> 关键字进行声明（传统的、C++17以前的方法）</strong></p>
<ul>
<li><strong>概念：</strong> 在一个 <code>.cpp</code> 文件中进行<strong>定义</strong>（Definition），然后在头文件中使用 <code>extern</code> 关键字进行<strong>声明</strong>（Declaration）。</li>
<li><strong>示例：</strong><ul>
<li><strong><code>my_constants.h</code></strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> SHARED_MAX_VALUE; <span class="comment">// 声明：告诉编译器 SHARED_MAX_VALUE 存在，但在别处定义</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong><code>my_constants.cpp</code></strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_constants.h"</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SHARED_MAX_VALUE = <span class="number">100</span>; <span class="comment">// 定义：这里分配内存并初始化</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong><code>main.cpp</code></strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_constants.h"</span> <span class="comment">// 包含头文件，即可使用 SHARED_MAX_VALUE</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Max value: "</span> &lt;&lt; SHARED_MAX_VALUE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "Address: " &lt;&lt; &amp;SHARED_MAX_VALUE &lt;&lt; std::endl; // 可以打印地址验证是同一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><strong>优点：</strong> 兼容性好，适用于所有C++标准。</li>
<li><strong>缺点：</strong> 需要在 <code>.h</code> 和 <code>.cpp</code> 两个地方操作，多一个文件。</li>
</ul>
</li>
<li><p><strong>使用 <code>inline</code> 关键字（C++17 及更高版本推荐）</strong></p>
<ul>
<li><strong>概念：</strong> C++17 引入了 <code>inline</code> 变量。当一个变量被标记为 <code>inline</code> 时，它可以在多个翻译单元中被定义，但链接器会确保它们都指向内存中的同一个实体，从而解决了 ODR 问题。对于 <code>const</code> 常量，这是非常优雅和推荐的做法。</li>
<li><strong>示例：</strong><ul>
<li><strong><code>my_constants.h</code></strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 如果需要，也可以包含其他头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">int</span> SHARED_MAX_VALUE = <span class="number">100</span>; <span class="comment">// 在头文件中直接定义并初始化</span></span><br><span class="line"><span class="comment">// 编译器和链接器会确保这是唯一的实体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于更复杂的常量对象，也可以这样：</span></span><br><span class="line"><span class="comment">// inline const std::string APP_NAME = "My Awesome App";</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong><code>main.cpp</code></strong> (或任何其他 <code>.cpp</code> 文件)<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_constants.h"</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Max value: "</span> &lt;&lt; SHARED_MAX_VALUE &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "Address: " &lt;&lt; &amp;SHARED_MAX_VALUE &lt;&lt; std::endl; // 打印地址验证是同一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><strong>优点：</strong> 简单、直观，只需在头文件中定义一次即可，无需额外的 <code>.cpp</code> 文件。通常是对于简单 <code>const</code> 变量的<strong>首选方法</strong>。</li>
<li><strong>缺点：</strong> 需要 C++17 或更高版本。</li>
</ul>
</li>
<li><p><strong>使用 <code>constexpr</code> 关键字（更佳实践，如果值是编译时常量）</strong></p>
<ul>
<li><strong>概念：</strong> <code>constexpr</code> 变量在编译时就确定了值，并且通常会被<strong>内联</strong>（inlined）到使用它的地方，不占用运行时内存。即使它在多个翻译单元中被定义（例如通过头文件），也不会有 ODR 问题，因为编译器会确保它们都是相同的编译时常量。</li>
<li><strong>示例：</strong><ul>
<li><strong><code>my_constants.h</code></strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_ITERATIONS = <span class="number">1000</span>; <span class="comment">// 编译时常量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>; <span class="comment">// 编译时常量</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong><code>main.cpp</code></strong> (或任何其他 <code>.cpp</code> 文件)<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_constants.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Max iterations: "</span> &lt;&lt; MAX_ITERATIONS &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pi: "</span> &lt;&lt; PI &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><strong>优点：</strong> 性能最高，不占用运行时存储，真正实现编译时优化。对于数值型或简单对象常量是<strong>最佳实践</strong>。</li>
<li><strong>缺点：</strong> 只能用于<strong>编译时</strong>（Compile-Time）已知的值。</li>
</ul>
</li>
<li><p><strong>使用 <code>enum class</code> (枚举类)</strong></p>
<ul>
<li><strong>概念：</strong> 对于一组相关的整数常量，<code>enum class</code> 是一个非常好的选择。枚举器的值也是编译时常量，不会有 ODR 问题。</li>
<li><strong>示例：</strong><ul>
<li><strong><code>game_states.h</code></strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">GameState</span> &#123;</span></span><br><span class="line">    MainMenu,</span><br><span class="line">    Playing,</span><br><span class="line">    Paused,</span><br><span class="line">    GameOver</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li><strong><code>main.cpp</code></strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"game_states.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GameState current_state = GameState::Playing;</span><br><span class="line">    <span class="keyword">if</span> (current_state == GameState::Playing) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Game is playing!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><strong>优点：</strong> 编译时常量，类型安全，易于组织相关常量。</li>
<li><strong>缺点：</strong> 仅适用于整数类型（或可转换为整数的类型），主要用于表示一组离散状态。</li>
</ul>
</li>
</ol>
<h2 id="要不要定义成全局变量？"><a href="#要不要定义成全局变量？" class="headerlink" title="要不要定义成全局变量？"></a><strong>要不要定义成全局变量？</strong></h2><p>这是一个更深层次的设计问题，涉及到软件架构和代码质量。</p>
<p><strong>一般原则：尽量避免使用裸露的（non-<code>const</code>）全局变量。</strong></p>
<ul>
<li><strong>全局变量的缺点（特别是可变的全局变量）：</strong><ul>
<li><strong>难以管理状态：</strong> 任何函数都可能修改它，使得代码的行为难以预测和调试。</li>
<li><strong>增加了耦合：</strong> 程序的各个部分都依赖于全局变量，降低了模块的独立性。</li>
<li><strong>测试困难：</strong> 编写单元测试时，需要小心设置和清理全局状态。</li>
<li><strong>命名冲突：</strong> 在大型项目中，全局变量容易导致名字冲突。</li>
<li><strong>线程安全问题：</strong> 在多线程环境中，可变全局变量是常见的竞态条件（Race Condition）来源。</li>
</ul>
</li>
</ul>
<p><strong>那么对于 <code>const</code> 全局变量呢？</strong></p>
<p>对于 <code>const</code> 全局变量，上述的一些缺点（如状态难以管理、线程安全问题）得到了极大的缓解，因为它们的值是不可变的。然而，以下几点仍然需要考虑：</p>
<ul>
<li><strong>命名污染：</strong> <code>const</code> 全局变量仍然会污染全局命名空间，尤其是在没有良好封装的情况下。</li>
<li><strong>并非所有“常量”都适合“全局”：</strong> 很多所谓的“常量”实际上只在一个特定模块、类或函数内部有意义。</li>
<li><strong>依赖性：</strong> 尽管值不变，但如果一个模块广泛依赖于全局常量，它仍然与该常量紧密耦合。</li>
</ul>
<p><strong>最佳实践（对于常量）：</strong></p>
<ol>
<li><p><strong>优先使用 <code>constexpr</code> 或 <code>enum class</code>：</strong> 如果常量的值在编译时已知，并且是基本类型或简单结构，这通常是最好的选择。它们通常不会占用运行时存储，也避免了链接问题。</p>
</li>
<li><p><strong>如果常量与特定类相关，定义为 <code>static const</code> 或 <code>static constexpr</code> 成员：</strong></p>
<ul>
<li><strong>示例：</strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">10</span>; <span class="comment">// C++11/14 需要在 .cpp 中定义: const int MyClass::DEFAULT_SIZE;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">double</span> RATIO = <span class="number">0.5</span>; <span class="comment">// C++11/14 可以在这里初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>优点：</strong> 将常量与它所属的逻辑实体（类）绑定，提高了封装性，避免了全局命名空间污染。</li>
</ul>
</li>
<li><p><strong>如果常量是运行时确定但不可变（如通过配置读取），考虑使用单例模式或依赖注入：</strong></p>
<ul>
<li>这超出了我们目前链接属性的范畴，但要知道，并非所有“不变”的值都适合作为全局常量。有时候，它们是程序启动时从配置文件读取的配置值，一旦读取后不再改变。这种情况下，使用配置类或通过依赖注入（Dependency Injection）传递它们是更好的选择。</li>
</ul>
</li>
<li><p><strong>只有当常量真正是“全局”且“通用”时，才考虑使用 <code>inline const</code> 或 <code>extern const</code> 全局变量：</strong></p>
<ul>
<li>例如，数学常数 <code>PI</code>，物理常数 <code>LIGHT_SPEED</code>，或者程序中真正普遍使用的配置阈值。即使在这种情况下，<code>inline const</code> (C++17) 或 <code>constexpr</code> 通常也优于传统的 <code>extern const</code> 全局变量，因为它们更现代、更简洁。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<ul>
<li><p><strong>对于共享 <code>const</code> 值：</strong></p>
<ul>
<li><strong><code>constexpr</code></strong> 是第一选择，如果常量是编译时已知且适用。</li>
<li><strong><code>inline const</code></strong> (C++17) 是第二选择，如果需要运行时存储但值是固定的，并且希望在头文件中定义。</li>
<li><strong><code>extern const</code></strong> (经典做法) 是第三选择，如果你不能使用 C++17 的 <code>inline</code> 变量，或者常量是复杂的对象且不适合放在头文件中。</li>
<li><strong><code>enum class</code></strong> 适用于组织一组相关的整数常量。</li>
</ul>
</li>
<li><p><strong>对于是否定义为全局变量：</strong></p>
<ul>
<li><strong>一般不推荐</strong>定义可变的（non-<code>const</code>）全局变量。</li>
<li><strong>对于 <code>const</code> 常量：</strong> 优先考虑<strong><code>constexpr</code></strong>、<strong><code>inline const</code></strong>（在头文件中）、<strong>类静态成员常量</strong>。只有当常量确实具有<strong>全局</strong>、<strong>普遍</strong>的意义时，才考虑使用它们作为全局变量，即便如此，也要优先使用现代的 <code>constexpr</code> 或 <code>inline const</code> 方式。</li>
</ul>
</li>
</ul>
<p>希望这个详细的解释能帮助你更好地理解和选择最佳实践！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Learning/">Learning    </a><a class="post-meta__tags" href="/tags/Function/">Function    </a><a class="post-meta__tags" href="/tags/Language/">Language    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/notes/diff%20between%20constexpr%20and%20define/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>diff between constexpr and define</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/notes/cpp%20%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>cpp 全局变量和常量</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/265 - using concept/" title="265 - using concept"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">265 - using concept</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/268 - Combining concepts/" title="268 - Combining concepts"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">268 - Combining concepts</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/260 - Named Template Parameters for Lambdas/" title="260 - Named Template Parameters for Lambdas"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">260 - Named Template Parameters for Lambdas</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/267 - requires clause/" title="267 - requires clause"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">267 - requires clause</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/293 - cpp 结构化绑定语法讲解/" title="293 - cpp 结构化绑定语法讲解"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">293 - cpp 结构化绑定语法讲解</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/c_plus_plus_teacher prompt/" title="c_plus_plus_teacher prompt"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">c_plus_plus_teacher prompt</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>