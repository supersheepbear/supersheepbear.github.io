<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>282 - cpp结构体与类的区别和用法 | Bear's dream</title><meta name="description" content="282 - cpp结构体与类的区别和用法"><meta name="keywords" content="Cpp,Coding,Tutorial,Development,Class"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="282 - cpp结构体与类的区别和用法"><meta name="twitter:description" content="282 - cpp结构体与类的区别和用法"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="282 - cpp结构体与类的区别和用法"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/282%20-%20cpp%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="282 - cpp结构体与类的区别和用法"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/282%20-%20cpp%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/"><link rel="prev" title="276 - Class across multiple files" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/276%20-%20Class%20across%20multiple%20files/"><link rel="next" title="286 - const 对象问题与指针引用访问" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/286%20-%20const%20%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-结构体与类的区别和用法"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">C++结构体与类的区别和用法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#1-标题与概要"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">1. 标题与概要</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2-详细解释"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">2. 详细解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#4-QA-闪卡-Flash-Cards"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">4. QA 闪卡 (Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#5-常见误解或易犯错误"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">5. 常见误解或易犯错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#6-编码练习"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">6. 编码练习</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#include"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">include </span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#7-用户解答评估、参考答案及解释"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">7. 用户解答评估、参考答案及解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#8-建议与扩展问题"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">8. 建议与扩展问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-2"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-2"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-结构体与类的区别和用法"><span class="toc-number">1.</span> <span class="toc-text">C++结构体与类的区别和用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-标题与概要"><span class="toc-number">2.</span> <span class="toc-text">1. 标题与概要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-详细解释"><span class="toc-number">3.</span> <span class="toc-text">2. 详细解释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-代码示例"><span class="toc-number">4.</span> <span class="toc-text">3. 代码示例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-QA-闪卡-Flash-Cards"><span class="toc-number">5.</span> <span class="toc-text">4. QA 闪卡 (Flash Cards)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-常见误解或易犯错误"><span class="toc-number">6.</span> <span class="toc-text">5. 常见误解或易犯错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-编码练习"><span class="toc-number">7.</span> <span class="toc-text">6. 编码练习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">7.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include"><span class="toc-number">8.</span> <span class="toc-text">include </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">8.1.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-用户解答评估、参考答案及解释"><span class="toc-number">9.</span> <span class="toc-text">7. 用户解答评估、参考答案及解释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-建议与扩展问题"><span class="toc-number">10.</span> <span class="toc-text">8. 建议与扩展问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-2"><span class="toc-number">10.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-2"><span class="toc-number">10.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">282 - cpp结构体与类的区别和用法</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/282%20-%20cpp%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/282%20-%20cpp%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="C-结构体与类的区别和用法"><a href="#C-结构体与类的区别和用法" class="headerlink" title="C++结构体与类的区别和用法"></a>C++结构体与类的区别和用法</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture we’re going to learn about the struct keyword, and this is another syntax you can useto create classes in your C plus plus program.We have seen that we can already use the class keyword to create our classes.I have to break it to you that we can also use struct to do the same.So the syntax here is going to create a class called Cat and it’s going to have a member variable calledstring name.The difference between struct and class is that for classes, members are going to be private by default.And when you do something like this and create class objects, you want to be able to access the namehere directly.For example, from the main function.If you do that, you’re going to get a compiler error because class members are private by default.But if you use struct members are going to be public by default and you will have direct access fromthe outside.This is the only difference between class and struct.Otherwise you can use them interchangeably and they are going to do the same things we have been seeingfor classes.They really are the same things.The only difference is that classes are going to have private member variables by default and structwill have public member variables by default.But we can change this default by putting in our own public and private sections inside our class.So for example, here you see that we have changed our dog class to have a public member variable throughthe public keyword here and we can do the same for cat.For example, we can put in a public section and a private section and it’s going to behave like classeswe have been building so far.One common use we have for struct is when we have to set up classes that only have public member variables.For example, you can need to set up a point model in your C plus plus program and you can set up aclass like this.You can say struct point, you’re going to put in the member variables and they are going to be directlyaccessible from the outside.And this is something you will see a lot out there.So this is really all about struct.We’re going to head over to Visual Studio code and play with the studio more.Okay.Here we are in our working folder.The current project is struct.We’re going to grab our template files and we’re going to put them in place.Struct, that’s our project here and we’re going to open this in Visual Studio code.Let’s grab a struct and drag and drop on top of Visual Studio code here.This is going to open our folder.We can open the main.cpp file and clean things up a little bit.Okay.So we’re going to set up a simple class called Dog.We’re going to say class dog, and inside we’re going to have a member variable called Name.It’s going to be an stdstring, let’s say dog name or M name to mean that it is a member variable.This is a syntax you will see a lot in C plus plus out there.So let’s use this.From now on we’re going to say M name and we’re going to have another class.Let’s put a semicolon.We’re going to use a struct to set up another one and it’s going to be called dog.Let’s call this cat and we are going to go inside and set up our member variable.We’re going to say stdstring M name and it’s not going to have anything in.So if we create objects of these classes and try to access them, we’re going to see the fundamentaldifference between struct and dog.Let’s create a dog and we’re going to say dog one and we’re going to create a cat and we’re going tosay cat one.And if we do dog one and try to access the M name member variable, maybe set it to something else.Let’s say Fluffy.We’re going to have a compiler error because members of a class are private by default and we can’treally do this.So we are trying to access something that is private from the outside.We’re going to get a compiler error.Okay, So we have a squiggly line here, but if we try to do the same for Cat, it’s going to go throughbecause cat is a struct and members of struct are public by default.Let’s do that and really show you this.We’re going to say cat one and we’re going to say M name and we’re going to give it a name.And let’s say Johnny, I am making this up.I don’t know if there is any cat named Johnny, but we’re going to use this and you’re going to seethat we don’t have any squiggly line.We’re going to build and see if GCC is going to take this.It’s going to take it.The build is good.We can bring up a terminal and run the program and we’re not going to see anything because we’re notprinting anything from the main function here.But if we want, we can print this name of our cat.We’re going to say Stdcout and say cat one name.And if we build, we’re going to see that.So the build should be good.It is good.We can clear and run Rooster and we have Johnny printed out and this is the name of our cat and thisis really the difference between class and struct.Members of classes are going to be private by.Members of struct are going to be public by default, but we can change this defaults.For example, let’s make everything public.We can do that.No big deal here and we can move this a little bit to the right so that things are aligned nicely andwe can do the same for struct.Okay, so let’s align this.Now, if we do this, we will be able to go in the main function and say dog name and change that andwe’re going to be able to see that if we print that out.So let’s go down and say Stdcout and say dog one name and print that out.And if we build now, we’re going to see the name of our dog printed out.Okay, build is good.We can bring this up and clear a little bit and run Rooster.We’re going to see Fluffy, our dog name and Johnny our cat name.So this is really all about classes and struct.They are the same things, but the only difference is the defaults that come with these things.But the common use we have for struct is when we want to set up a class that only has direct membervariables and we don’t intend to put methods into that class.A good example of this is the struct of points.So suppose we want to model points in our C plus plus program so we can do something like this.And a point is going to have two coordinates x and y.We’re going to say double y, and from this point on we will be able to create point objects and printthem out however we want.So for example, we can go down and say .0.1, and from this point we can go in and say 0.1 and sayX and assign a value to X, Let’s put in a ten and we’re going to go down and say point one Y and we’regoing to give it a value.Let’s put in 55.5.Why not?And we can do whatever we want with this point.For example, we can set up a function which is going to print a point.We can do that, let’s say void print point and we’re going to pass the point by value.Or we can even use references because this is going to be an object const point reference.I think this is going to do and we’re going to go inside and print the information.We’re going to say Stdcout point and we’re going to put the coordinates and we’re going to say X isgoing to be point X and Y is going to be zero point y, y not.And we’re going to put in our closing square bracket and we’re going to say Stdendl to put a newlinecharacter after our print here.Now we can go down and say print point and pass in 0.1.And if we do that, we’re going to build and we’re going to do that through GCC.You see, the build is good.Now if we print, we should see the information about our point and we see point X one, Y 55.5 andwe see point X is ten, Y is 55.5.We can go down and change the information about our points.For example, we can copy this and go down and change X to 40.4 and Y to 2.7.Why not?And if we print the information about our point, we’re going to see that we have new information andwe’re going to print 0.1.And if we build, we’re going to see the new information.So the build is good.We can clear and run.Rooster Now you see new information in our point.So this is really the difference between class and struct.The only difference is going to be in the default and struct is mostly useful if you want to set upclasses that only have public member variables and you don’t really want to use functions or methodsin that class.And we have an example of that here.And if you have a case like that, you will use struct.Your code is going to be much easier to read and understand from the perspective of other C plus plusdevelopers.We are going to stop here in this lecture and the next one we’re going to learn about the size of objects.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，同学你好！很高兴能成为你的C++启蒙老师。今天我们要学习C++中一个非常有用的关键字：<code>struct</code>。别担心，我会一步一步带你了解它，让你轻松掌握！</p>
<hr>
<h1 id="1-标题与概要"><a href="#1-标题与概要" class="headerlink" title="1. 标题与概要"></a>1. 标题与概要</h1><p><strong>标题：</strong> C++ 结构体 (Struct) 完全指南：轻松理解与类 (Class) 的区别与应用</p>
<p><strong>概要：</strong><br>本节课我们将学习C++中的 <code>struct</code> 关键字，它是创建自定义数据类型的一种方式，非常类似于我们之前可能接触过的 <code>class</code> [类]。我们将重点理解 <code>struct</code> 和 <code>class</code> 之间的核心区别——默认的成员访问权限，并探讨 <code>struct</code> 的常见使用场景。</p>
<hr>
<h1 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h1><p>让我们一步一步来揭开 <code>struct</code> 的神秘面纱。</p>
<p><strong>2.1 什么是 <code>struct</code> (结构体)？</strong></p>
<p>在C++中，<code>struct</code>，全称 structure [结构体]，是一种用户定义的复合数据类型。它允许你将不同数据类型的变量组合成一个单一的逻辑单元。想象一下，你要描述一个“点”，一个点有x坐标和y坐标。使用 <code>struct</code>，你就可以创建一个名为 <code>Point</code> 的类型，它内部包含x和y两个成员。</p>
<p><strong>2.2 <code>struct</code> 与 <code>class</code> (类) 的关系</strong></p>
<p>在C++中，<code>struct</code> 和 <code>class</code> 的功能几乎是完全相同的。你用 <code>class</code> 能做的事情，用 <code>struct</code> 基本上也都能做：</p>
<ul>
<li>它们都可以包含数据成员 (member variables [成员变量])。</li>
<li>它们都可以包含成员函数 (member functions [成员函数]，也叫方法 methods [方法])。</li>
<li>它们都可以使用继承 (inheritance [继承])、多态 (polymorphism [多态]) 等面向对象的特性。</li>
</ul>
<p><strong>2.3 核心区别：默认访问权限 (Default Access Specifier)</strong></p>
<p>这是 <code>struct</code> 和 <code>class</code> 之间 <strong>唯一</strong> 的根本区别：</p>
<ul>
<li><strong><code>struct</code></strong>：如果你不明确指定，其所有成员（包括数据成员和成员函数）默认都是 <strong><code>public</code> [公有]</strong> 的。这意味着在结构体外部的代码可以直接访问这些成员。</li>
<li><strong><code>class</code></strong>：如果你不明确指定，其所有成员默认都是 <strong><code>private</code> [私有]</strong> 的。这意味着这些成员只能在类的内部（比如类的成员函数中）被访问，外部代码不能直接访问。</li>
</ul>
<p>让我们来看个例子：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 struct 定义 Cat</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name; <span class="comment">// 默认是 public</span></span><br><span class="line">    <span class="keyword">int</span> m_age;          <span class="comment">// 默认是 public</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">meow</span><span class="params">()</span> </span>&#123;       <span class="comment">// 默认是 public</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" says: Meow!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 class 定义 Dog</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name; <span class="comment">// 默认是 private</span></span><br><span class="line">    <span class="keyword">int</span> m_age;          <span class="comment">// 默认是 private</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 需要显式声明 public 区域</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">        m_name = name; <span class="comment">// 可以在内部访问 private 成员</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" says: Woof!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat myCat;</span><br><span class="line">    myCat.m_name = <span class="string">"Whiskers"</span>; <span class="comment">// 正确！Cat 的 m_name 默认是 public</span></span><br><span class="line">    myCat.meow();             <span class="comment">// 正确！</span></span><br><span class="line"></span><br><span class="line">    Dog myDog;</span><br><span class="line">    <span class="comment">// myDog.m_name = "Buddy"; // 编译错误！Dog 的 m_name 默认是 private</span></span><br><span class="line">    myDog.setName(<span class="string">"Buddy"</span>);   <span class="comment">// 正确！通过 public 的成员函数访问</span></span><br><span class="line">    myDog.bark();             <span class="comment">// 正确！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中：</p>
<ul>
<li>对于 <code>Cat</code> 结构体，我们可以直接在 <code>main</code> 函数中通过 <code>myCat.m_name</code> 来访问和修改它的名字，因为 <code>m_name</code> 默认是 <code>public</code>。</li>
<li>对于 <code>Dog</code> 类，如果我们尝试 <code>myDog.m_name = &quot;Buddy&quot;;</code>，编译器会报错，因为 <code>m_name</code> 默认是 <code>private</code>。我们必须通过一个 <code>public</code> 的成员函数（如 <code>setName</code>）来间接设置名字。</li>
</ul>
<p><strong>2.4 显式指定访问权限</strong></p>
<p>虽然 <code>struct</code> 和 <code>class</code> 有默认的访问权限，但我们随时可以使用 <code>public:</code>，<code>private:</code>，和 <code>protected:</code> (我们稍后会学习 <code>protected</code> [保护]) 这些 <strong>访问修饰符 (access specifiers)</strong> 来明确指定成员的访问级别。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleStruct</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 我想让这个成员是私有的</span></span><br><span class="line">    <span class="keyword">int</span> secretValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">// 这些是公有的</span></span><br><span class="line">    <span class="keyword">int</span> publicValue;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printSecret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Secret: "</span> &lt;&lt; secretValue &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 内部可以访问 private 成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    ExampleStruct() : secretValue(<span class="number">42</span>), publicValue(<span class="number">10</span>) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 我想让这些成员是公有的</span></span><br><span class="line">    <span class="keyword">int</span> publicValue;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    ExampleClass() : publicValue(<span class="number">20</span>), name(<span class="string">"Test"</span>) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>一旦你显式地使用了 <code>public:</code> 或 <code>private:</code>，那么 <code>struct</code> 和 <code>class</code> 在那一部分的行为就完全一样了。比如，一个所有成员都显式声明为 <code>public</code> 的 <code>class</code>，和一个所有成员都显式声明为 <code>public</code> (或者不声明，依赖默认行为) 的 <code>struct</code>，在使用上是没有区别的。</p>
<p><strong>2.5 何时使用 <code>struct</code>？(约定俗成的规范)</strong></p>
<p>尽管 <code>struct</code> 和 <code>class</code> 功能上几乎等同（除了默认访问权限），但在C++社区中，有一个普遍的约定：</p>
<ul>
<li><p><strong>使用 <code>struct</code></strong>：当你定义一个主要目的是<strong>聚合数据 (aggregate data)</strong> 的类型时，特别是当这些数据成员大部分或全部都希望是公有的，并且这个类型主要作为数据的载体，可能没有什么复杂的行为（成员函数很少或很简单）。这种类型通常被称为 <strong>POD (Plain Old Data)</strong> 类型，或者类似POD的类型。</p>
<ul>
<li>例如：一个二维点 <code>Point { double x; double y; }</code>，一个颜色 <code>Color { int r; int g; int b; }</code>。这些类型的核心在于它们所包含的数据，我们通常希望直接访问这些数据。</li>
</ul>
</li>
<li><p><strong>使用 <code>class</code></strong>：当你希望实现更复杂的对象，需要 <strong>封装 (encapsulation [封装])</strong> 时。封装意味着将数据（通常设为 <code>private</code>）和操作这些数据的方法（通常设为 <code>public</code>）捆绑在一起。这有助于数据隐藏，保护数据不被随意修改，确保对象状态的有效性。</p>
<ul>
<li>例如：一个 <code>BankAccount</code> 类，它的余额 <code>balance</code> 应该是 <code>private</code> 的，只能通过 <code>deposit()</code> 和 <code>withdraw()</code> 这样的 <code>public</code> 方法来修改。</li>
</ul>
</li>
</ul>
<p>遵循这个约定，可以让其他C++开发者更容易理解你的代码意图。当他们看到 <code>struct</code>，会倾向于认为这是一个简单的数据容器；看到 <code>class</code>，则会预期它有更复杂的行为和封装。</p>
<p><strong>2.6 历史渊源 (可选了解)</strong></p>
<p>在C语言中，<code>struct</code> 只能包含数据成员，不能有成员函数。C++ 继承了C语言的 <code>struct</code> 并对其进行了扩展，使其具备了和 <code>class</code> 几乎一样的能力，包括成员函数、继承等。引入 <code>class</code> 关键字，并使其默认成员为 <code>private</code>，是为了更好地支持面向对象编程中的封装思想。</p>
<hr>
<h1 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h1><p>让我们通过课程中提到的例子来具体看看 <code>struct</code> 和 <code>class</code> 的行为。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 class 定义 Dog</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    <span class="comment">// 默认是 private</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name; <span class="comment">// 成员变量，m_ 前缀是一种常见的命名约定，表示它是成员(member)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数 (Constructor [构造函数])，用于初始化对象</span></span><br><span class="line">    Dog(<span class="built_in">std</span>::<span class="built_in">string</span> name) : m_name(name) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog "</span> &lt;&lt; m_name &lt;&lt; <span class="string">" created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有成员函数来设置名字 (通常称为 setter)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有成员函数来获取名字 (通常称为 getter)</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// const 表示这个函数不会修改对象的状态</span></span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" says: Woof!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 struct 定义 Cat</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line">    <span class="comment">// 默认是 public</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Cat(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age) : m_name(name), m_age(age) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cat "</span> &lt;&lt; m_name &lt;&lt; <span class="string">" aged "</span> &lt;&lt; m_age &lt;&lt; <span class="string">" created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">meow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" says: Meow!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个常用于 struct 的例子：表示一个二维点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x; <span class="comment">// 默认 public</span></span><br><span class="line">    <span class="keyword">double</span> y; <span class="comment">// 默认 public</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个打印 Point 信息的函数</span></span><br><span class="line"><span class="comment">// 我们通过 const 引用传递 Point 对象，避免不必要的拷贝，同时保证函数不会修改它</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPoint</span><span class="params">(<span class="keyword">const</span> Point&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point(x: "</span> &lt;&lt; p.x &lt;&lt; <span class="string">", y: "</span> &lt;&lt; p.y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Dog 类的演示</span></span><br><span class="line">    <span class="function">Dog <span class="title">dog1</span><span class="params">(<span class="string">"Buddy"</span>)</span></span>;</span><br><span class="line">    <span class="comment">// dog1.m_name = "Lucy"; // 编译错误! m_name 是 private</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog's name: "</span> &lt;&lt; dog1.getName() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    dog1.bark();</span><br><span class="line"></span><br><span class="line">    dog1.setName(<span class="string">"Lucy"</span>); <span class="comment">// 通过公有方法修改</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog's new name: "</span> &lt;&lt; dog1.getName() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    dog1.bark();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- Struct Demo ---\n"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cat 结构体的演示</span></span><br><span class="line">    <span class="function">Cat <span class="title">cat1</span><span class="params">(<span class="string">"Whiskers"</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    cat1.m_name = <span class="string">"Smokey"</span>; <span class="comment">// 正确! m_name 是 public</span></span><br><span class="line">    cat1.m_age = <span class="number">4</span>;         <span class="comment">// 正确! m_age 是 public</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cat's name: "</span> &lt;&lt; cat1.m_name &lt;&lt; <span class="string">", Age: "</span> &lt;&lt; cat1.m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    cat1.meow();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- Point Struct Demo ---\n"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Point 结构体的演示</span></span><br><span class="line">    Point p1;</span><br><span class="line">    p1.x = <span class="number">10.5</span>; <span class="comment">// 直接访问 public 成员</span></span><br><span class="line">    p1.y = <span class="number">20.3</span>;</span><br><span class="line">    printPoint(p1);</span><br><span class="line"></span><br><span class="line">    Point p2 = &#123;<span class="number">5.2</span>, <span class="number">8.7</span>&#125;; <span class="comment">// 使用聚合初始化 (aggregate initialization)</span></span><br><span class="line">    printPoint(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>代码解释：</strong></p>
<ol>
<li><p><strong><code>Dog</code> 类</strong>：</p>
<ul>
<li><code>m_name</code> 是 <code>private</code> 的（因为 <code>class</code> 默认是 <code>private</code>，且没有显式声明为 <code>public</code>）。</li>
<li>我们提供了 <code>public</code> 的构造函数 <code>Dog(std::string name)</code> 来初始化 <code>m_name</code>。</li>
<li>我们提供了 <code>public</code> 的 <code>setName</code> 和 <code>getName</code> 函数来间接访问和修改 <code>m_name</code>。</li>
<li>直接在 <code>main</code> 中访问 <code>dog1.m_name</code> 会导致编译错误。</li>
</ul>
</li>
<li><p><strong><code>Cat</code> 结构体</strong>：</p>
<ul>
<li><code>m_name</code> 和 <code>m_age</code> 都是 <code>public</code> 的（因为 <code>struct</code> 默认是 <code>public</code>）。</li>
<li>我们提供了 <code>public</code> 的构造函数 <code>Cat(std::string name, int age)</code>。</li>
<li>可以直接在 <code>main</code> 中通过 <code>cat1.m_name</code> 和 <code>cat1.m_age</code> 来访问和修改它们。</li>
</ul>
</li>
<li><p><strong><code>Point</code> 结构体</strong>：</p>
<ul>
<li><code>x</code> 和 <code>y</code> 都是 <code>public</code> 的。这是一个典型的数据聚合的例子。</li>
<li><code>printPoint</code> 函数接受一个 <code>Point</code> 对象的常量引用 (<code>const Point&amp;</code>)，并打印其坐标。直接访问 <code>p.x</code> 和 <code>p.y</code> 是允许的。</li>
<li><code>Point p2 = {5.2, 8.7};</code> 这种初始化方式叫做聚合初始化，对于成员都是 <code>public</code> 的 <code>struct</code> (或 <code>class</code>) 非常方便。</li>
</ul>
</li>
</ol>
<p>运行这段代码，你会看到类和结构体成员访问权限的不同以及它们如何被使用。</p>
<hr>
<h1 id="4-QA-闪卡-Flash-Cards"><a href="#4-QA-闪卡-Flash-Cards" class="headerlink" title="4. QA 闪卡 (Flash Cards)"></a>4. QA 闪卡 (Flash Cards)</h1><p><strong>卡片1:</strong><br>Q: C++ 中 <code>struct</code> 和 <code>class</code> 的主要区别是什么？<br>A: 它们之间唯一的根本区别是默认的成员访问权限。<code>struct</code> 的成员默认是 <code>public</code> [公有]，而 <code>class</code> 的成员默认是 <code>private</code> [私有]。</p>
<p><strong>卡片2:</strong><br>Q: <code>struct</code> 成员的默认访问权限是什么？<br>A: <code>public</code> [公有]。</p>
<p><strong>卡片3:</strong><br>Q: <code>class</code> 成员的默认访问权限是什么？<br>A: <code>private</code> [私有]。</p>
<p><strong>卡片4:</strong><br>Q: 我们可以在 <code>struct</code> 中使用 <code>private:</code> 关键字吗？<br>A: 可以。同样，也可以在 <code>class</code> 中使用 <code>public:</code> 关键字。使用这些关键字可以覆盖默认的访问权限。</p>
<p><strong>卡片5:</strong><br>Q: 按照惯例，什么时候更倾向于使用 <code>struct</code>？<br>A: 当定义主要用于数据聚合、成员基本都是公有、行为（方法）较少或较简单的类型时，例如 <code>Point {double x, y;}</code>。</p>
<p><strong>卡片6:</strong><br>Q: <code>struct Point { int x; int y; }; Point p;</code> 如何访问 <code>p</code> 的 <code>x</code> 成员？<br>A: <code>p.x</code> (因为 <code>struct</code> 成员默认是 <code>public</code>)。</p>
<hr>
<h1 id="5-常见误解或易犯错误"><a href="#5-常见误解或易犯错误" class="headerlink" title="5. 常见误解或易犯错误"></a>5. 常见误解或易犯错误</h1><ol>
<li><p><strong>误解：<code>struct</code> 不能有成员函数或私有成员。</strong></p>
<ul>
<li><strong>澄清：</strong> 这是一个常见的误解，尤其对于有C语言背景的人。在C++中，<code>struct</code> 可以拥有成员函数、构造函数、析构函数，也可以有 <code>private</code> 和 <code>protected</code> 成员，就像 <code>class</code> 一样。它们的功能几乎完全相同。</li>
</ul>
</li>
<li><p><strong>忘记定义末尾的分号。</strong></p>
<ul>
<li>无论是 <code>class</code> 还是 <code>struct</code>，在定义的大括号 <code>}</code> 之后都必须有一个分号 <code>;</code>。</li>
<li>错误：<code>struct Point { double x; double y; }</code></li>
<li>正确：<code>struct Point { double x; double y; };</code></li>
</ul>
</li>
<li><p><strong>混淆默认访问权限。</strong></p>
<ul>
<li>在 <code>class</code> 中直接尝试访问未声明为 <code>public</code> 的成员，导致编译错误。</li>
<li>或者，以为 <code>struct</code> 的成员需要像 <code>class</code> 一样通过公有方法访问，实际上可以直接访问（如果未显式声明为 <code>private</code>）。</li>
</ul>
</li>
<li><p><strong>过度使用 <code>struct</code>。</strong></p>
<ul>
<li>虽然 <code>struct</code> 可以做 <code>class</code> 能做的大部分事情，但如果一个类型需要复杂的行为、数据隐藏和封装，按照约定俗成的规范，使用 <code>class</code> 并将数据成员设为 <code>private</code> 会更清晰地表达你的设计意图。</li>
</ul>
</li>
<li><p><strong>认为 <code>struct</code> 比 <code>class</code> “轻量”或性能更高。</strong></p>
<ul>
<li>在C++中，编译后 <code>struct</code> 和 <code>class</code> 在内存布局和性能上没有本质区别。编译器对待它们的方式（一旦访问权限被解析）是一样的。选择哪个主要基于语义和设计意图（即默认的公开性 vs. 默认的私有性）。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="6-编码练习"><a href="#6-编码练习" class="headerlink" title="6. 编码练习"></a>6. 编码练习</h1><p>现在，让我们来动手练习一下！请你完成下面的代码。我们来定义一个表示矩形 (<code>Rectangle</code>) 的结构体，并计算它的面积。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 1: 定义一个名为 Rectangle 的 struct</span></span><br><span class="line"><span class="comment">// 它应该有两个 double 类型的公有成员变量: m_width 和 m_height</span></span><br><span class="line"><span class="comment">// YOUR CODE HERE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 2: 实现一个名为 printRectangleArea 的函数</span></span><br><span class="line"><span class="comment">// 这个函数接收一个 const Rectangle&amp; (常量引用) 作为参数</span></span><br><span class="line"><span class="comment">// 它应该计算并打印出矩形的面积 (面积 = 宽度 * 高度)</span></span><br><span class="line"><span class="comment">// 例如: "Rectangle Area: [面积值]"</span></span><br><span class="line"><span class="comment">// YOUR CODE HERE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 3: 创建一个 Rectangle 对象，名为 rect1</span></span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 4: 设置 rect1 的宽度为 5.0，高度为 8.0</span></span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 5: 调用 printRectangleArea 函数，并传入 rect1</span></span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Rectangle rect2 = &#123;<span class="number">3.0</span>, <span class="number">7.0</span>&#125;; <span class="comment">// 使用聚合初始化</span></span><br><span class="line">    printRectangleArea(rect2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请你尝试填写 <code>// YOUR CODE HERE</code> 部分。完成后，把你的代码发给我，我会帮你检查并给出反馈！加油！</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></iostream></h1><p>// TODO 1: 定义一个名为 Rectangle 的 struct<br>// 它应该有两个 double 类型的公有成员变量: m_width 和 m_height<br>// YOUR CODE HERE<br>struct Rectangle {<br>  double m_width;<br>  double m_height;<br>  Rectangle() = default;<br>  Rectangle(double m_width_param, double m_height_param): m_width(m_width_param), m_height(m_height_param) {}<br>};<br>// TODO 2: 实现一个名为 printRectangleArea 的函数<br>// 这个函数接收一个 const Rectangle&amp; (常量引用) 作为参数<br>// 它应该计算并打印出矩形的面积 (面积 = 宽度 <em> 高度)<br>// 例如: “Rectangle Area: [面积值]”<br>// YOUR CODE HERE<br>void printRectangleArea(const Rectangle&amp; rect) {<br>    std::cout &lt;&lt; “Rectangle Area: “ &lt;&lt; rect.m_width </em> rect.m_height &lt;&lt; std::endl;<br>}</p>
<p>int main() {<br>    // TODO 3: 创建一个 Rectangle 对象，名为 rect1<br>    // YOUR CODE HERE<br>    Rectangle rect1;</p>
<pre><code>// TODO 4: 设置 rect1 的宽度为 5.0，高度为 8.0
// YOUR CODE HERE
rect1.m_width = 5.0;
rect1.m_height = 8.0;

// TODO 5: 调用 printRectangleArea 函数，并传入 rect1
// YOUR CODE HERE
printRectangleArea(rect1);

Rectangle rect2 = {3.0, 7.0}; // 使用聚合初始化
printRectangleArea(rect2);

return 0;
</code></pre><p>}</p>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>太棒了！你很认真地完成了练习，代码写得非常好！让我们一起来看看。</p>
<hr>
<h1 id="7-用户解答评估、参考答案及解释"><a href="#7-用户解答评估、参考答案及解释" class="headerlink" title="7. 用户解答评估、参考答案及解释"></a>7. 用户解答评估、参考答案及解释</h1><p><strong>你的解答评估：</strong></p>
<p><strong>评分：</strong> ★★★★★ (5/5 - 非常优秀！)</p>
<p><strong>整体评价：</strong><br>你的代码非常出色！你准确地完成了所有的 <code>TODO</code> 任务。</p>
<ul>
<li><p><strong>TODO 1 (定义 <code>Rectangle</code> 结构体):</strong> 你正确地定义了 <code>Rectangle</code> 结构体，包含了 <code>double</code> 类型的 <code>m_width</code> 和 <code>m_height</code> 成员。这些成员因为在 <code>struct</code> 中且没有显式访问修饰符，所以默认为 <code>public</code>，这完全符合题目要求。</p>
<ul>
<li><strong>加分点：</strong> 你还主动添加了默认构造函数 <code>Rectangle() = default;</code> 和一个带参数的构造函数 <code>Rectangle(double m_width_param, double m_height_param)</code>。这非常好！这使得 <code>Rectangle</code> 结构体更加灵活和健壮。<ul>
<li><code>Rectangle() = default;</code> 确保了我们可以像 <code>Rectangle rect1;</code> 这样创建对象而无需立即提供初始值。</li>
<li>带参数的构造函数则允许我们像 <code>Rectangle rect3(10.0, 2.0);</code> 这样在创建对象时就初始化其成员。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>TODO 2 (实现 <code>printRectangleArea</code> 函数):</strong> 函数签名 <code>void printRectangleArea(const Rectangle&amp; rect)</code> 非常好，使用了常量引用 (<code>const Rectangle&amp;</code>)，既避免了不必要的对象复制开销，也保证了函数不会意外修改传入的 <code>Rectangle</code> 对象。函数体内的面积计算 <code>rect.m_width * rect.m_height</code> 和输出格式也完全正确。</p>
</li>
<li><p><strong>TODO 3 (创建 <code>Rectangle</code> 对象 <code>rect1</code>):</strong> <code>Rectangle rect1;</code> 正确地创建了一个 <code>Rectangle</code> 对象。因为你定义了默认构造函数，所以这行代码工作得很好。</p>
</li>
<li><p><strong>TODO 4 (设置 <code>rect1</code> 的成员):</strong> <code>rect1.m_width = 5.0;</code> 和 <code>rect1.m_height = 8.0;</code> 正确地通过直接成员访问设置了矩形的宽度和高度，这是因为 <code>struct</code> 成员默认是 <code>public</code> 的。</p>
</li>
<li><p><strong>TODO 5 (调用 <code>printRectangleArea</code>):</strong> <code>printRectangleArea(rect1);</code> 正确地调用了函数并传入了对象。</p>
</li>
</ul>
<p><strong>总结：</strong> 你的代码不仅正确，而且展现了良好的编程习惯（比如添加构造函数和使用常量引用）。为你点赞！</p>
<hr>
<p><strong>参考答案与解释：</strong></p>
<p>你的答案本身已经非常棒了！这里我再提供一个版本，主要是为了展示满足题目基本要求的最简洁写法，并和你添加了构造函数的版本进行对比说明。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 1: 定义一个名为 Rectangle 的 struct</span></span><br><span class="line"><span class="comment">// 它应该有两个 double 类型的公有成员变量: m_width 和 m_height</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> m_width;</span><br><span class="line">    <span class="keyword">double</span> m_height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你的版本中添加的构造函数非常好，让结构体更完整：</span></span><br><span class="line">    <span class="comment">// Rectangle() = default;</span></span><br><span class="line">    <span class="comment">// Rectangle(double w, double h) : m_width(w), m_height(h) &#123;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 2: 实现一个名为 printRectangleArea 的函数</span></span><br><span class="line"><span class="comment">// 这个函数接收一个 const Rectangle&amp; (常量引用) 作为参数</span></span><br><span class="line"><span class="comment">// 它应该计算并打印出矩形的面积 (面积 = 宽度 * 高度)</span></span><br><span class="line"><span class="comment">// 例如: "Rectangle Area: [面积值]"</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printRectangleArea</span><span class="params">(<span class="keyword">const</span> Rectangle&amp; rect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> area = rect.m_width * rect.m_height; <span class="comment">// 直接访问公有成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle Area: "</span> &lt;&lt; area &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 3: 创建一个 Rectangle 对象，名为 rect1</span></span><br><span class="line">    Rectangle rect1; <span class="comment">// 如果没有用户定义的构造函数，这会进行默认初始化（POD类型成员不确定值，但随后被赋值）</span></span><br><span class="line">                     <span class="comment">// 在你的版本中，因为有 Rectangle() = default; 所以这是明确的默认构造</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 4: 设置 rect1 的宽度为 5.0，高度为 8.0</span></span><br><span class="line">    rect1.m_width = <span class="number">5.0</span>;  <span class="comment">// 直接访问公有成员</span></span><br><span class="line">    rect1.m_height = <span class="number">8.0</span>; <span class="comment">// 直接访问公有成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 5: 调用 printRectangleArea 函数，并传入 rect1</span></span><br><span class="line">    printRectangleArea(rect1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Rectangle rect2 = &#123;<span class="number">3.0</span>, <span class="number">7.0</span>&#125;; <span class="comment">// 使用聚合初始化 (aggregate initialization [聚合初始化])</span></span><br><span class="line">                                  <span class="comment">// 这种初始化方式对于成员都是 public 的 struct 或 class 非常方便</span></span><br><span class="line">                                  <span class="comment">// 即使你定义了构造函数，如果它们符合一定规则，聚合初始化仍然可能有效（C++17+）</span></span><br><span class="line">    printRectangleArea(rect2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果你有带参数的构造函数，也可以这样创建：</span></span><br><span class="line">    <span class="comment">// Rectangle rect3(10.0, 2.0); // 需要你定义的 Rectangle(double w, double h)</span></span><br><span class="line">    <span class="comment">// printRectangleArea(rect3);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解释关键点：</strong></p>
<ol>
<li><p><strong><code>struct Rectangle</code> 的定义</strong>：</p>
<ul>
<li>最基本的要求就是包含两个 <code>double</code> 类型的成员 <code>m_width</code> 和 <code>m_height</code>。因为是 <code>struct</code>，它们默认就是 <code>public</code> 的。</li>
<li>你添加的构造函数 (<code>Rectangle() = default;</code> 和 <code>Rectangle(double w, double h)</code>) 是很好的实践，它们：<ul>
<li>提供了更明确的对象初始化方式。</li>
<li>使得类/结构体的意图更清晰。</li>
<li>允许更复杂的初始化逻辑（如果需要的话）。</li>
<li><code>= default</code> 告诉编译器生成一个标准的默认构造函数。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>printRectangleArea</code> 函数</strong>：</p>
<ul>
<li>使用 <code>const Rectangle&amp; rect</code> 是最佳实践，原因之前已经提过（效率和安全）。</li>
<li>直接通过 <code>rect.m_width</code> 和 <code>rect.m_height</code> 访问成员是合法的，因为它们是 <code>public</code> 的。</li>
</ul>
</li>
<li><p><strong><code>main</code> 函数中的对象创建与使用</strong>：</p>
<ul>
<li><code>Rectangle rect1;</code>：<ul>
<li>如果 <code>Rectangle</code> 没有任何用户定义的构造函数（就像我上面参考答案中注释掉构造函数的情况），<code>rect1</code> 会被默认构造。对于像 <code>double</code> 这样的内置类型成员，它们的值在此时是未定义的（除非 <code>rect1</code> 是全局或静态对象）。但紧接着你对它们进行了赋值，所以没问题。</li>
<li>在你的代码中，因为有 <code>Rectangle() = default;</code>，<code>rect1</code> 会被明确地默认构造。</li>
</ul>
</li>
<li><code>rect1.m_width = 5.0; rect1.m_height = 8.0;</code>：直接赋值，简单明了。</li>
<li><code>Rectangle rect2 = {3.0, 7.0};</code>：这是 <strong>聚合初始化 (aggregate initialization)</strong>。它适用于没有用户声明的构造函数（或者在某些情况下，即使有，只要它们符合特定规则）、没有私有或保护的非静态数据成员、没有基类、没有虚函数的类型。你的 <code>Rectangle</code> 定义（即使有构造函数）通常也支持这种初始化，尤其是如果你的构造函数被认为是“非限制性的”。这是初始化简单数据结构体的一种非常简洁的方式。</li>
</ul>
</li>
</ol>
<p>你已经做得很棒了，这些解释主要是为了巩固你对这些概念的理解，并展示一些细微的变化和原因。</p>
<hr>
<h1 id="8-建议与扩展问题"><a href="#8-建议与扩展问题" class="headerlink" title="8. 建议与扩展问题"></a>8. 建议与扩展问题</h1><p>做得非常好！为了帮助你进一步巩固和扩展 <code>struct</code> 及相关概念的知识，这里有一些建议和可以思考的问题：</p>
<ol>
<li><p><strong>成员函数 (Member Functions)</strong>：</p>
<ul>
<li>尝试给 <code>Rectangle</code> 结构体添加一个<strong>成员函数</strong>，比如 <code>double getArea() const;</code>，这个函数直接在结构体内部计算并返回面积。然后在 <code>main</code> 函数中像这样调用它：<code>double area = rect1.getArea(); std::cout &lt;&lt; &quot;Area from member function: &quot; &lt;&lt; area &lt;&lt; std::endl;</code></li>
<li>思考：将计算面积的逻辑放在结构体内部（作为成员函数）和外部（如 <code>printRectangleArea</code> 全局函数）各有什么优缺点？</li>
</ul>
</li>
<li><p><strong>构造函数 (Constructors) 的更多思考</strong>：</p>
<ul>
<li>你已经添加了构造函数，非常好！思考一下：如果 <code>Rectangle</code> 的宽度和高度必须是正数，你会如何在构造函数中处理无效输入（比如负数或零）？（提示：可以抛出异常 (exception [异常])，或者设置一个默认的有效值并打印警告）。</li>
</ul>
</li>
<li><p><strong><code>struct</code> vs <code>class</code> 的选择</strong>：</p>
<ul>
<li>尝试将 <code>Rectangle</code> 改写成一个 <code>class</code>。你需要做什么改动才能让 <code>main</code> 函数中的代码（尤其是成员访问和对象创建）仍然能正常工作？（提示：<code>public</code> 关键字）。</li>
<li>反思一下，对于 <code>Rectangle</code> 这个例子，你觉得使用 <code>struct</code> 还是 <code>class</code> 更能表达其“主要作为数据容器”的意图？</li>
</ul>
</li>
<li><p><strong>封装 (Encapsulation) 的初步接触</strong>：</p>
<ul>
<li>如果我们想让 <code>Rectangle</code> 的 <code>m_width</code> 和 <code>m_height</code> 不能被随意修改，而是只能通过特定的成员函数（比如 <code>setWidth</code>，并且这个函数可以检查宽度是否有效），你会怎么修改 <code>Rectangle</code> 的定义？这时 <code>class</code> 和 <code>private</code> 成员会更有用武之地。</li>
</ul>
</li>
<li><p><strong>返回多个值</strong>：</p>
<ul>
<li><code>struct</code> 常被用来从一个函数返回多个值。想象一个函数需要返回一个点的 x 和 y 坐标，你就可以定义一个 <code>struct Point { int x; int y; };</code> 然后让函数返回一个 <code>Point</code> 对象。你能写一个简单的例子吗？</li>
</ul>
</li>
<li><p><strong><code>struct</code> 的大小 (Size of struct)</strong>：</p>
<ul>
<li>在下一课中，你会学习到 <code>sizeof</code> 操作符。可以提前思考一下，<code>sizeof(Rectangle)</code> 的结果大概会是多少？（提示：它通常是其成员大小的总和，但有时会有内存对齐 (memory alignment [内存对齐]) 的影响）。</li>
</ul>
</li>
</ol>
<p>这些问题有些可能超出了当前课程的范围，但它们是指向未来学习方向的好路标。不要有压力，按照自己的节奏来探索。</p>
<p>你今天表现非常出色！继续保持这种学习的热情和实践的习惯，你会很快掌握C++的！如果你对任何解释或扩展问题有疑问，随时问我。</p>
<hr>
<h2 id="🧑‍💻-User-2"><a href="#🧑‍💻-User-2" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>struct 中是不是完全不能有private关键词</p>
<hr>
<h2 id="🤖-Assistant-2"><a href="#🤖-Assistant-2" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>不，这个理解是<strong>不正确</strong>的。</p>
<p><strong><code>struct</code> 中完全可以使用 <code>private</code> (私有) 关键字，也可以使用 <code>protected</code> (保护) 关键字，就像在 <code>class</code> (类) 中一样。</strong></p>
<p><code>struct</code> 和 <code>class</code> 的<strong>唯一</strong>区别在于它们的<strong>默认访问权限 (default access specifier [默认访问修饰符])</strong>：</p>
<ul>
<li>在 <code>struct</code> 中，如果你不写 <code>public:</code>、<code>private:</code> 或 <code>protected:</code>，那么它之后定义的成员<strong>默认是 <code>public</code> (公有)</strong> 的。</li>
<li>在 <code>class</code> 中，如果你不写 <code>public:</code>、<code>private:</code> 或 <code>protected:</code>，那么它之后定义的成员<strong>默认是 <code>private</code> (私有)</strong> 的。</li>
</ul>
<p>一旦你显式地使用了 <code>public:</code>、<code>private:</code> 或 <code>protected:</code>，那么 <code>struct</code> 和 <code>class</code> 在那一部分的行为就完全一样了。</p>
<p><strong>举个例子：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="comment">// 这个成员默认是 public</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> public_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 从这里开始，下面的成员是 private</span></span><br><span class="line">    <span class="keyword">int</span> student_id;</span><br><span class="line">    <span class="keyword">double</span> gpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 从这里开始，下面的成员又是 public</span></span><br><span class="line">    Student(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> id, <span class="keyword">double</span> gpa_val) &#123;</span><br><span class="line">        public_name = name;</span><br><span class="line">        student_id = id; <span class="comment">// 构造函数可以访问 private 成员</span></span><br><span class="line">        gpa = gpa_val;   <span class="comment">// 构造函数可以访问 private 成员</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student "</span> &lt;&lt; public_name &lt;&lt; <span class="string">" created with ID: "</span> &lt;&lt; student_id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayGPA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 成员函数可以访问 private 成员</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; public_name &lt;&lt; <span class="string">"'s GPA: "</span> &lt;&lt; gpa &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个公有方法来获取通常不希望直接修改的私有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getStudentID</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">"Alice"</span>, <span class="number">101</span>, <span class="number">3.8</span>)</span></span>;</span><br><span class="line">    s1.public_name = <span class="string">"Alicia"</span>; <span class="comment">// 正确，public_name 是公有的</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student's public name: "</span> &lt;&lt; s1.public_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s1.student_id = 102; // 编译错误! student_id 是 private 的</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; s1.gpa; // 编译错误! gpa 是 private 的</span></span><br><span class="line"></span><br><span class="line">    s1.displayGPA(); <span class="comment">// 正确，displayGPA 是公有方法</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Student ID (via getter): "</span> &lt;&lt; s1.getStudentID() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 通过公有方法访问私有数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个 <code>Student</code> 结构体的例子中：</p>
<ul>
<li><code>public_name</code> 因为在任何访问修饰符之前，所以它遵循 <code>struct</code> 的默认规则，是 <code>public</code> 的。</li>
<li><code>student_id</code> 和 <code>gpa</code> 在 <code>private:</code> 关键字之后，所以它们是 <code>private</code> 的，不能在 <code>main</code> 函数中直接访问。</li>
<li>构造函数 <code>Student(...)</code> 和成员函数 <code>displayGPA()</code>、<code>getStudentID()</code> 在 <code>public:</code> 关键字之后（或者在 <code>private:</code> 之前，因为 <code>struct</code> 默认是 <code>public</code>），所以它们是 <code>public</code> 的。这些公有函数可以在内部访问私有成员 <code>student_id</code> 和 <code>gpa</code>。</li>
</ul>
<p><strong>总结一下：</strong></p>
<ul>
<li>你可以自由地在 <code>struct</code> 中使用 <code>public:</code>，<code>private:</code> 和 <code>protected:</code> 来控制成员的访问级别。</li>
<li><code>struct</code> 只是意味着“如果你不指定，我就认为是 <code>public</code> 的”。</li>
<li><code>class</code> 只是意味着“如果你不指定，我就认为是 <code>private</code> 的”。</li>
</ul>
<p>尽管语法上允许，但按照 <strong>约定俗成 (convention [惯例])</strong>，当你的类型主要目的是数据聚合，且大部分成员希望是公有的时候，倾向于使用 <code>struct</code>。如果你的类型需要更强的封装，有很多私有数据和复杂的公共接口，则倾向于使用 <code>class</code>。但这更多的是一种风格和意图表达，而不是C++语言的强制限制。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Tutorial/">Tutorial    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/276%20-%20Class%20across%20multiple%20files/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>276 - Class across multiple files</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/286%20-%20const%20%E5%AF%B9%E8%B1%A1%E9%97%AE%E9%A2%98%E4%B8%8E%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>286 - const 对象问题与指针引用访问</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/318 - inline static variable/" title="318 - inline static variable"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">318 - inline static variable</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/313 - friend of class/" title="313 - friend of class"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">313 - friend of class</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/329 - 跨文件命名空间/" title="329 - 跨文件命名空间"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">329 - 跨文件命名空间</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/317 - cpp 类级别数据/" title="317 - cpp 类级别数据"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">317 - cpp 类级别数据</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/257 - cpp Default template arguments/" title="257 - cpp Default template arguments"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">257 - cpp Default template arguments</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/256 - cpp decltype(auto)/" title="256 - cpp decltype(auto)"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">256 - cpp decltype(auto)</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>