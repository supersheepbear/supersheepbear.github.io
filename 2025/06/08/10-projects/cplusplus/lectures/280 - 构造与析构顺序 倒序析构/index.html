<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>280 - 构造与析构顺序 倒序析构 | Bear's dream</title><meta name="description" content="280 - 构造与析构顺序 倒序析构"><meta name="keywords" content="Cpp,Coding,Class,Constructor,Destructor"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="280 - 构造与析构顺序 倒序析构"><meta name="twitter:description" content="280 - 构造与析构顺序 倒序析构"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="280 - 构造与析构顺序 倒序析构"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/280%20-%20%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F%20%E5%80%92%E5%BA%8F%E6%9E%90%E6%9E%84/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="280 - 构造与析构顺序 倒序析构"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/280%20-%20%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F%20%E5%80%92%E5%BA%8F%E6%9E%90%E6%9E%84/"><link rel="prev" title="276 - Class across multiple files" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/276%20-%20Class%20across%20multiple%20files/"><link rel="next" title="283 - cpp 类对象大小探究" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/283%20-%20cpp%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E6%8E%A2%E7%A9%B6/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">178</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">160</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">23</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#构造与析构顺序-倒序析构"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">构造与析构顺序 倒序析构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-标题和概要"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">1. 标题和概要</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-详细解释"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">2. 详细解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-代码示例"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">3. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-Q-amp-A-闪卡-Flash-Cards"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">4. Q&amp;A 闪卡 (Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-常见误解或易犯错误"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">5. 常见误解或易犯错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-编码练习"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">6. 编码练习</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#构造与析构顺序-倒序析构"><span class="toc-number">1.</span> <span class="toc-text">构造与析构顺序 倒序析构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-标题和概要"><span class="toc-number">1.3.</span> <span class="toc-text">1. 标题和概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-详细解释"><span class="toc-number">1.4.</span> <span class="toc-text">2. 详细解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-代码示例"><span class="toc-number">1.5.</span> <span class="toc-text">3. 代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Q-amp-A-闪卡-Flash-Cards"><span class="toc-number">1.6.</span> <span class="toc-text">4. Q&amp;A 闪卡 (Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见误解或易犯错误"><span class="toc-number">1.7.</span> <span class="toc-text">5. 常见误解或易犯错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-编码练习"><span class="toc-number">1.8.</span> <span class="toc-text">6. 编码练习</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">280 - 构造与析构顺序 倒序析构</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/280%20-%20%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F%20%E5%80%92%E5%BA%8F%E6%9E%90%E6%9E%84/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/280%20-%20%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F%20%E5%80%92%E5%BA%8F%E6%9E%90%E6%9E%84/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="构造与析构顺序-倒序析构"><a href="#构造与析构顺序-倒序析构" class="headerlink" title="构造与析构顺序 倒序析构"></a>构造与析构顺序 倒序析构</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, I want you to raise your awareness on the order in which constructors and destructorsare called.Suppose we have a class which is dog here and we have the constructor which is doing its thing in thebody here, and we have the destructor which is releasing our memory and printing something out.So suppose we have created a few objects of this class here and they have different names and they havethe same breed and different ages as you see here.And if we run this code in Main, what do you think we’ll see printed from the constructors and Destructors,If you ask me and I was learning about C plus plus, I would say that the constructors are going tobe called in order.Doug one.Doug two.Doug three.Doug four They are going to be constructed in this order and the destructors would be called in thesame order.But this is not true.The Destructors are going to be called in the reverse order, as you see on the right here.So we’re going to call this constructor for Doug.to be called in reverse order.So the object that was constructed last is going to be destroyed first, as you see here.And the object that was constructed first is going to be destroyed last.And the compiler follows this order to make it easy for it to do things.We can’t really get into those details, but for now, we’re going to head over to Visual Studio Codeand play with us a little more.Okay.Here we are in our working folder.The current project is order of constructor and Destructor Calls here.We’re going to grab our template project pretty quick and we’re going to put them in place.The files, I mean, and we’re going to open this in Visual Studio code like we have been doing allalong.This is going to open up our folder.We can close the left sidebar here and let’s clean up our main function.We are going to bring in the class for Dog from the last lecture.This is exactly what we had there.No change.And we’re going to include the Stringview library for this to work.So we’re going to include Stringview here.And once we do this, we’re going to head over in the main function and set up a few objects of thedog class here.But before we go there, notice that we have a few stdcout statements in our constructor and destructorand we want to see the order in which they are called.So we’re going to set up four objects of our dog.We’re going to say Dog Dog one and we’re going to say the name to be Dog one and it’s going to be ashepherd and it’s going to be, for example, two years old.Why not?We should say dog here.And we are going to copy this four times here and we’re going to call this dog two.The other is going to be Dog three and this is going to be Dog four.And we’re going to say the same thing here, Dog two, three and four.The names are what is really important because we’re going to see them printed out here.But if you want, you can change the ages.Let’s make this a three.Let’s make this a five.Let’s make this a one.Why not for dog four.And now we’re going to run our program.If we run it, we’re going to see the constructors called in the order Dog one dog, two doggy, threedog four.And the Destructors are going to be called in the reverse order Dog four all the way to dog one.Let’s build and show you that this is actually the case.So the build is good.We can bring up a terminal and really run this.Let’s clear and run roster.You’re going to see that dog constructor called for a dog one all the way to dog four And now we havethe dog a destructor called from doggy four all the way to dog one and the compiler is going to enforcethis order for calling constructors and destructors because it makes it easy for it to manage the memoryof objects.For example, if Dog One has been around for a long time and it has because it’s going to be aroundbefore a dog one if you delete dog one after dog four here, there might be other objects that dependon dog one.So that’s why the object that was created last is deleted first, because chances for other objectsto depend on that last object are really slim and you can delete it without any problem.But the object that was created first might have other dependencies and you’re going to be deletingdependent objects first before you delete that object.I think this is the logic the compiler follows to really enforce this order here and you need to beaware of that and make sure that.Any time in your C plus plus application.This is working to your advantage.This is really all I had to share in this lecture.I hope you found it interesting.We are going to stop here in this one and the next one we’re going to learn about the this pointer.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，没问题！非常乐意帮助你学习 C++。C++ 是一门功能强大且应用广泛的编程语言，掌握好它的基础对于后续的学习至关重要。</p>
<p>今天我们将专注于一个非常基础但又极其重要的概念：<strong>构造函数 (Constructor) 和析构函数 (Destructor) 的调用顺序</strong>。</p>
<hr>
<h2 id="1-标题和概要"><a href="#1-标题和概要" class="headerlink" title="1. 标题和概要"></a>1. 标题和概要</h2><p><strong>标题：</strong> C++ 探秘：构造函数与析构函数的生命周期之舞</p>
<p><strong>概要：</strong> 本节课将深入探讨当创建和销毁多个 C++ 对象时，它们的构造函数和析构函数是如何以及为何以特定的顺序被调用的。简单来说，构造函数会按照对象定义的顺序被调用，而析构函数的调用顺序则与之相反（最后构造的对象最先被析构）。</p>
<hr>
<h2 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h2><p>让我们一步一步来理解这个过程。</p>
<p><strong>a. 什么是构造函数 (Constructor) 和析构函数 (Destructor)？</strong></p>
<ul>
<li><strong>构造函数 (Constructor)</strong>：它是一个特殊的成员函数 (member function)，在创建类的对象时自动被调用。它的主要任务是初始化对象的数据成员 (data members)。构造函数的名称与类名完全相同，并且没有返回类型 (return type)。</li>
<li><strong>析构函数 (Destructor)</strong>：它也是一个特殊的成员函数，在对象的生命周期结束时（例如，对象离开其作用域 (scope) 或被 <code>delete</code> 操作符删除时）自动被调用。它的主要任务是执行一些清理工作，比如释放对象在构造时或在其生命周期中分配的资源 (resources)（如动态分配的内存、打开的文件句柄等）。析构函数的名称是在类名前加上一个波浪号 <code>~</code>，它也没有返回类型，也不接受任何参数 (arguments)。</li>
</ul>
<p><strong>b. 对象创建与构造函数的调用顺序</strong></p>
<p>当你在一个作用域（比如 <code>main</code> 函数内部）中定义多个对象时，它们的构造函数会严格按照它们在代码中出现的顺序被调用。</p>
<p>比如，你写下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dog <span class="title">dog1</span><span class="params">(<span class="string">"Buddy"</span>, <span class="string">"Shepherd"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Dog <span class="title">dog2</span><span class="params">(<span class="string">"Lucy"</span>, <span class="string">"Retriever"</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">Dog <span class="title">dog3</span><span class="params">(<span class="string">"Max"</span>, <span class="string">"Poodle"</span>, <span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure></div><br>那么：</p>
<ol>
<li><code>dog1</code> 的构造函数首先被调用。</li>
<li>然后，<code>dog2</code> 的构造函数被调用。</li>
<li>最后，<code>dog3</code> 的构造函数被调用。</li>
</ol>
<p>这非常直观，就像排队一样，先来的先服务。</p>
<p><strong>c. 对象销毁与析构函数的调用顺序——关键点！</strong></p>
<p>这里是初学者容易混淆的地方。与构造函数不同，<strong>析构函数的调用顺序与构造函数的调用顺序相反</strong>。这意味着最后被构造的对象，其析构函数将最先被调用。</p>
<p>对于上面 <code>dog1</code>, <code>dog2</code>, <code>dog3</code> 的例子：</p>
<ol>
<li>当它们的作用域结束时（例如 <code>main</code> 函数执行完毕），<code>dog3</code> 的析构函数首先被调用（因为它是最后一个构造的）。</li>
<li>然后，<code>dog2</code> 的析构函数被调用。</li>
<li>最后，<code>dog1</code> 的析构函数被调用（因为它是第一个构造的）。</li>
</ol>
<p>这种顺序通常被称为 <strong>LIFO (Last-In, First-Out)</strong>，即“后进先出”。你可以把它想象成一叠盘子：你最后放上去的盘子，会是你第一个拿下来的。</p>
<p><strong>d. 为什么是这样的顺序？</strong></p>
<p>编译器 (compiler) 强制执行这种析构顺序是有重要原因的，主要与<strong>资源管理和依赖关系 (dependencies)</strong> 有关：</p>
<ol>
<li><strong>依赖性安全</strong>：想象一下，如果对象 <code>A</code> 的构造依赖于对象 <code>B</code> 的某些状态或资源。如果 <code>B</code> 比 <code>A</code> 先构造，那么当 <code>A</code> 构造时，<code>B</code> 是可用的。按照 LIFO 原则销毁时，<code>A</code> 会比 <code>B</code> 先销毁。这就确保了当 <code>A</code> 的析构函数执行时，它所依赖的 <code>B</code> 对象仍然是存活和有效的。如果先销毁 <code>B</code>，那么 <code>A</code> 的析构函数可能会尝试访问一个已经被销毁的对象，导致未定义行为 (undefined behavior) 或程序崩溃。</li>
<li><strong>资源清理的逻辑性</strong>：通常，后创建的对象可能依赖于先创建的对象所管理的资源。例如，一个对象可能打开了一个文件，而另一个后创建的对象向这个文件写入数据。在销毁时，先关闭并释放写入数据的对象所持有的资源，然后再关闭文件本身，是更合乎逻辑的清理顺序。</li>
<li><strong>栈内存管理 (Stack Memory Management)</strong>：对于在栈 (stack) 上创建的局部对象 (local objects)，这种LIFO的析构顺序与栈的内存分配和回收方式天然吻合。栈本身就是一个LIFO的数据结构。当函数调用结束，栈上的局部变量会以它们声明顺序的逆序被弹出（销毁）。</li>
</ol>
<p><strong>e. 作用域 (Scope) 的影响</strong></p>
<p>对象的生命周期与它们所在的作用域紧密相关。当执行流程离开一个作用域时，在该作用域内声明的所有局部对象的析构函数都会被（以逆序）调用。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">outer_dog</span><span class="params">(<span class="string">"Outer"</span>, <span class="string">"Labrador"</span>, <span class="number">4</span>)</span></span>; <span class="comment">// outer_dog 构造</span></span><br><span class="line">    &#123; <span class="comment">// 进入新的内部作用域</span></span><br><span class="line">        <span class="function">Dog <span class="title">inner_dog1</span><span class="params">(<span class="string">"Inner1"</span>, <span class="string">"Beagle"</span>, <span class="number">1</span>)</span></span>; <span class="comment">// inner_dog1 构造</span></span><br><span class="line">        <span class="function">Dog <span class="title">inner_dog2</span><span class="params">(<span class="string">"Inner2"</span>, <span class="string">"Beagle"</span>, <span class="number">2</span>)</span></span>; <span class="comment">// inner_dog2 构造</span></span><br><span class="line">    &#125; <span class="comment">// 离开内部作用域</span></span><br><span class="line">      <span class="comment">// 此时，inner_dog2 的析构函数先调用</span></span><br><span class="line">      <span class="comment">// 然后，inner_dog1 的析构函数调用</span></span><br><span class="line">    <span class="comment">// ... 更多代码 ...</span></span><br><span class="line">&#125; <span class="comment">// 离开 someFunction 的作用域</span></span><br><span class="line">  <span class="comment">// 此时，outer_dog 的析构函数调用</span></span><br></pre></td></tr></table></figure></div>
<p>理解这个顺序对于编写健壮且无内存泄漏的 C++ 程序至关重要，尤其是在处理需要手动管理资源（如动态内存、文件句柄、网络连接等）的类时。</p>
<hr>
<h2 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h2><p>让我们使用原始内容中提到的 <code>Dog</code> 类来进行演示。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt; // 为了使用 std::string_view</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 类的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> breed;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Dog(<span class="built_in">std</span>::string_view name_param, <span class="built_in">std</span>::string_view breed_param, <span class="keyword">int</span> age_param) &#123;</span><br><span class="line">        name = name_param;</span><br><span class="line">        breed = breed_param;</span><br><span class="line">        age = age_param;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗构造函数被调用，名字是: "</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Dog() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗析构函数被调用，名字是: "</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 在实际应用中，这里可能包含释放动态分配的内存等操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// const 成员函数，因为它不修改对象状态</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗狗信息 - 名字: "</span> &lt;&lt; name &lt;&lt; <span class="string">", 品种: "</span> &lt;&lt; breed &lt;&lt; <span class="string">", 年龄: "</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 程序开始 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Dog <span class="title">dog1</span><span class="params">(<span class="string">"小黑"</span>, <span class="string">"中华田园犬"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">dog2</span><span class="params">(<span class="string">"旺财"</span>, <span class="string">"金毛"</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">dog3</span><span class="params">(<span class="string">"小白"</span>, <span class="string">"萨摩耶"</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">dog4</span><span class="params">(<span class="string">"豆豆"</span>, <span class="string">"泰迪"</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 所有狗狗对象已创建 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 程序即将结束，对象将开始析构 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// main 函数结束，dog4, dog3, dog2, dog1 将依次析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>预期输出：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--- 程序开始 ---</span><br><span class="line">狗狗构造函数被调用，名字是: 小黑</span><br><span class="line">狗狗构造函数被调用，名字是: 旺财</span><br><span class="line">狗狗构造函数被调用，名字是: 小白</span><br><span class="line">狗狗构造函数被调用，名字是: 豆豆</span><br><span class="line"></span><br><span class="line">--- 所有狗狗对象已创建 ---</span><br><span class="line">--- 程序即将结束，对象将开始析构 ---</span><br><span class="line">狗狗析构函数被调用，名字是: 豆豆</span><br><span class="line">狗狗析构函数被调用，名字是: 小白</span><br><span class="line">狗狗析构函数被调用，名字是: 旺财</span><br><span class="line">狗狗析构函数被调用，名字是: 小黑</span><br></pre></td></tr></table></figure></div>
<p><strong>代码解释：</strong></p>
<ol>
<li>我们包含了 <code>&lt;iostream&gt;</code> 用于输出，<code>&lt;string&gt;</code> 用于字符串，<code>&lt;string_view&gt;</code> 是一个轻量级的字符串引用类型。</li>
<li><code>Dog</code> 类有一个构造函数，它接受狗狗的名字、品种和年龄，并在构造时打印一条消息。</li>
<li><code>Dog</code> 类有一个析构函数 <code>~Dog()</code>，它在对象销毁时打印一条消息。</li>
<li>在 <code>main</code> 函数中，我们按顺序创建了 <code>dog1</code>, <code>dog2</code>, <code>dog3</code>, <code>dog4</code> 四个 <code>Dog</code> 对象。</li>
<li>你会观察到，构造函数的消息严格按照 <code>dog1</code> 到 <code>dog4</code> 的顺序打印。</li>
<li>当 <code>main</code> 函数执行到 <code>return 0;</code> 并准备退出时，这些局部对象的生命周期结束了。由于它们是在栈上分配的，它们会按照其构造顺序的<strong>相反顺序</strong>被销毁。</li>
<li>因此，析构函数的消息会按照 <code>dog4</code> -&gt; <code>dog3</code> -&gt; <code>dog2</code> -&gt; <code>dog1</code> 的顺序打印。</li>
</ol>
<hr>
<h2 id="4-Q-amp-A-闪卡-Flash-Cards"><a href="#4-Q-amp-A-闪卡-Flash-Cards" class="headerlink" title="4. Q&amp;A 闪卡 (Flash Cards)"></a>4. Q&amp;A 闪卡 (Flash Cards)</h2><p><strong>闪卡 1:</strong></p>
<ul>
<li><strong>问：</strong> 当在同一个作用域内定义多个对象时，它们的构造函数按什么顺序调用？</li>
<li><strong>答：</strong> 按照它们在代码中被定义的顺序调用。</li>
</ul>
<p><strong>闪卡 2:</strong></p>
<ul>
<li><strong>问：</strong> 当在同一个作用域内定义多个对象时，它们的析构函数按什么顺序调用？</li>
<li><strong>答：</strong> 按照它们构造顺序的<strong>相反</strong>顺序调用（即，最后构造的最先析构，LIFO）。</li>
</ul>
<p><strong>闪卡 3:</strong></p>
<ul>
<li><strong>问：</strong> 为什么析构函数要以与构造函数相反的顺序调用？</li>
<li><strong>答：</strong>主要是为了安全地管理对象间的依赖关系和正确地释放资源。确保一个对象在析构时，它所依赖的其他对象仍然是有效的。</li>
</ul>
<p><strong>闪卡 4:</strong></p>
<ul>
<li><strong>问：</strong> “LIFO” 在对象生命周期管理中代表什么？</li>
<li><strong>答：</strong> Last-In, First-Out (后进先出)。用于描述栈上对象的析构顺序。</li>
</ul>
<hr>
<h2 id="5-常见误解或易犯错误"><a href="#5-常见误解或易犯错误" class="headerlink" title="5. 常见误解或易犯错误"></a>5. 常见误解或易犯错误</h2><ol>
<li><strong>误认为析构顺序与构造顺序相同</strong>：这是最常见的误解。很多初学者会直观地认为既然是按 A, B, C 的顺序构造的，那么也应该按 A, B, C 的顺序析构。务必记住是相反的！</li>
<li><strong>忽略作用域</strong>：对象的生命周期严格受其作用域限制。内部作用域的对象会比外部作用域的对象先析构（如果它们都到达了各自作用域的末尾）。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误理解示例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">d1</span><span class="params">(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125; <span class="comment">// d1 在此析构</span></span><br><span class="line"><span class="function">Dog <span class="title">d2</span><span class="params">(<span class="string">"C"</span>, <span class="string">"D"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">// 有人可能错误地认为 d2 会先于 d1 析构，因为 d2 后声明。</span></span><br><span class="line"><span class="comment">// 但实际上 d1 的作用域先结束。</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>对于动态分配的对象 (heap objects)</strong>：通过 <code>new</code> 创建的对象，其析构函数的调用时机取决于何时对其调用 <code>delete</code>。如果程序员手动 <code>delete</code> 的顺序与 LIFO 原则不符（比如先 <code>delete</code> 了早创建的对象，而后创建的对象依赖它），则可能引发问题。本课主要讨论的是栈上的自动对象 (automatic objects)，它们的析构是自动的。</li>
<li><strong>析构函数中的异常</strong>：通常不建议让析构函数抛出异常 (exceptions)。如果一个析构函数在栈展开 (stack unwinding) 过程中（例如，因为另一个异常）被调用，并且它自己又抛出了异常，这可能导致程序终止 (<code>std::terminate</code>)。</li>
<li><strong>忘记了基类和成员对象的析构顺序</strong>：<ul>
<li>对于派生类 (derived class) 对象，首先执行派生类的析构函数体，然后按照成员对象在类中声明的逆序调用成员对象的析构函数，最后按照继承链的逆序调用基类 (base class) 的析构函数。</li>
<li>构造顺序则是：基类构造函数 -&gt; 成员对象（按声明顺序）构造函数 -&gt; 派生类构造函数体。</li>
<li>这虽然超出了当前讨论的核心，但与“逆序析构”的原则是一致的。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-编码练习"><a href="#6-编码练习" class="headerlink" title="6. 编码练习"></a>6. 编码练习</h2><p>现在，这里有一个小练习。我们有一个 <code>Resource</code> 类，它在构造和析构时会打印信息。请你创建几个 <code>Resource</code> 对象，并预测它们的构造和析构顺序。然后，在 <code>main</code> 函数的注释中填写你预测的输出。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Resource(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; n) : name(n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource '"</span> &lt;&lt; name &lt;&lt; <span class="string">"' is being constructed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Resource() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Resource '"</span> &lt;&lt; name &lt;&lt; <span class="string">"' is being destructed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Program Start ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">resA</span><span class="params">(<span class="string">"Alpha"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    &#123; <span class="comment">// Inner scope starts</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Entering Inner Scope ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="function">Resource <span class="title">resB</span><span class="params">(<span class="string">"Bravo"</span>)</span></span>;</span><br><span class="line">        <span class="function">Resource <span class="title">resC</span><span class="params">(<span class="string">"Charlie"</span>)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Leaving Inner Scope ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="comment">// Inner scope ends</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">resD</span><span class="params">(<span class="string">"Delta"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- Program End ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">请在下方预测并填写完整的输出：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--- Program Start ---</span></span><br><span class="line"><span class="comment">Resource 'Alpha' is being constructed.</span></span><br><span class="line"><span class="comment">--- Entering Inner Scope ---</span></span><br><span class="line"><span class="comment">// TODO 1: 填写 resB 构造时的输出</span></span><br><span class="line"><span class="comment">// TODO 2: 填写 resC 构造时的输出</span></span><br><span class="line"><span class="comment">--- Leaving Inner Scope ---</span></span><br><span class="line"><span class="comment">// TODO 3: 填写 resC 析构时的输出</span></span><br><span class="line"><span class="comment">// TODO 4: 填写 resB 析构时的输出</span></span><br><span class="line"><span class="comment">Resource 'Delta' is being constructed.</span></span><br><span class="line"><span class="comment">--- Program End ---</span></span><br><span class="line"><span class="comment">// TODO 5: 填写 resD 析构时的输出</span></span><br><span class="line"><span class="comment">// TODO 6: 填写 resA 析构时的输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>
<p>请你仔细思考，并尝试填写 <code>// TODO</code> 部分的注释。等你完成后，把你的答案发给我，我会帮你检查并给出反馈！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Constructor/">Constructor    </a><a class="post-meta__tags" href="/tags/Destructor/">Destructor    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/276%20-%20Class%20across%20multiple%20files/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>276 - Class across multiple files</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/283%20-%20cpp%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E6%8E%A2%E7%A9%B6/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>283 - cpp 类对象大小探究</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/273 - constructor/" title="273 - constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">273 - constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/274 - default constructor/" title="274 - default constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">274 - default constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/296 - 构造函数默认参数/" title="296 - 构造函数默认参数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">296 - 构造函数默认参数</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/297 - 构造函数初始化列表/" title="297 - 构造函数初始化列表"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">297 - 构造函数初始化列表</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/300 - cpp构造函数委托/" title="300 - cpp构造函数委托"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">300 - cpp构造函数委托</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/305 - 已删除构造 函数使用/" title="305 - 已删除构造 函数使用"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">305 - 已删除构造 函数使用</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>