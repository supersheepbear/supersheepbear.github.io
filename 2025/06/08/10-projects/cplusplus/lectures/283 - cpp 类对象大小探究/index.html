<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>283 - cpp 类对象大小探究 | Bear's dream</title><meta name="description" content="283 - cpp 类对象大小探究"><meta name="keywords" content="Cpp,Coding,Development,Class,Object"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="283 - cpp 类对象大小探究"><meta name="twitter:description" content="283 - cpp 类对象大小探究"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="283 - cpp 类对象大小探究"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/283%20-%20cpp%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E6%8E%A2%E7%A9%B6/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="283 - cpp 类对象大小探究"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/283%20-%20cpp%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E6%8E%A2%E7%A9%B6/"><link rel="prev" title="279 - cpp析构函数：对象销毁时的内存释放" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/279%20-%20cpp%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/"><link rel="next" title="280 - 构造与析构顺序 倒序析构" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/280%20-%20%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F%20%E5%80%92%E5%BA%8F%E6%9E%90%E6%9E%84/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-类对象大小探究"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">C++ 类对象大小探究</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-类对象的大小：深入理解-sizeof"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">C++ 类对象的大小：深入理解 sizeof</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-类对象大小探究"><span class="toc-number">1.</span> <span class="toc-text">C++ 类对象大小探究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-类对象的大小：深入理解-sizeof"><span class="toc-number">1.3.</span> <span class="toc-text">C++ 类对象的大小：深入理解 sizeof</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">283 - cpp 类对象大小探究</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/283%20-%20cpp%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E6%8E%A2%E7%A9%B6/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/283%20-%20cpp%20%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E6%8E%A2%E7%A9%B6/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="C-类对象大小探究"><a href="#C-类对象大小探究" class="headerlink" title="C++ 类对象大小探究"></a>C++ 类对象大小探究</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about sizes of class objects and try to think about it.What are we going to see if we try to print the size of our class here called Wrapper?Inside, we have two member variables which are of int type and we have a member variable which is ofstdstring type.What do you think we’ll see when we print the size of this wrapper object here, try to think aboutit.So what c plus plus does, it’s going to only account for the size of your member variables.So it’s going to add the sizes of these guys in memory.So we know an INT is going to take four bytes in memory.So we’re going to have eight bytes for these two aunts and we’re going to have an unspecified amountof memory for a string because a string is internally implemented as a class and it stores its dataas const called pointers.So we have really a pointer, and the size of an object doesn’t really account for things you are referringto using pointers.It may count to the size of the pointer itself, but it’s not going to count what is pointed to.And in the case of string, for example, we really want to know the range of things that we are pointingto.So we’re not going to have correct information with Stdstring here.But in general, the size of the object is going to be the sum of the sizes of its member variables.The functions are not going to be counted then the functions are just helper functions that live somewherein memory, but they’re not going to be accounted for in the size of your object.Another reason you might think functions are not accounted for in the size of the object is that reallyfunctions are affiliated with the class itself.Functions are not affiliated with class objects.The class is going to be the blueprint from which we’re going to generate thousands of objects if wewant.But the functions or the methods are going to be associated to the blueprint itself.So it really wouldn’t make sense to associate the size of those functions in memory to class objects.Now that you have this idea, let’s head over to Visual Studio code and play with this a little more.Okay.We have said that the size is mostly going to be the sum of the sizes for the member variables, butthis is not always correct because of a phenomenon we called boundary alignment.Boundary alignment is a thing most compilers do when they have member variables of different types andmember variables that have the size of four bytes in memory are going to be stored at memory locationsthat are multiples of four.And because of this phenomenon, we might have gaps between our memory.If we have variables, for example, that are of two bytes in memory and four bytes in memory, andwe’re going to have gaps inside and the size of the object is going to be slightly off the sum we mightdo for the sizes of our object.I realize this may be confusing.We’re going to head over to Visual Studio code and we’re going to see a few examples.Okay.Here we are in our working folder.The current project is size of class Objects.We’re going to grab our template files pretty quick and we’re going to put them in place and we’re goingto open our project in Visual Studio code.By dragging and dropping here we have our main CPP file.We can close the left sidebar and we can clean the main function here.We’re going to set up a simple class.Let’s call this dog.Why not?We have been using dog.So let’s use this again.We’re going to put our closing semicolon.We’re going to put a public section and it’s going to just contain a constructor and we’re going tosay dog and we’re going to use the default and we’re going to put in a private section.And in here we’re going to put in a size T and say, this is the leg count of a dog.Why not?Let’s say we are modeling this.Okay?So now we have our dog class in place.We can create objects of this dog class.We’re going to say dog dog one.And if we do this, we are interested in knowing the size of our dog class here.So we are going to say stdcout size of dog and say that.And fingers crossed we’re going to see the size of our dog object here and try to guess what we’re goingto get in the slides.We have seen that the size is mostly going to be the sum of the size of the member variables.And let’s print the size of size T here because size T is our only member variable.So I think it’s going to be helpful to see its size printed out.So we’re going to have some context.If we do that, we’re going to say size of size T and we’re going to save that and we’re going to buildthis program.Let’s do that.We’re going to pass this through.JC You see, the bolt is good and we’re going to bring up a terminal and run this, see what happens.Okay, We see size of size.T is eight and the size of our dark object is eight.And this is really cool because we see that the size of our class object is really the size of our membervariables that we have in here.Let’s set up another member variable and really show you this.So we’re going to have arm count.Okay, so we are just messing with this to learn.I don’t aim for this class here to make some sense practically.We just want to see how the member variables affect the size of our class object.Now we have two member variables and we’re going to try and build.We’re going to use JC to do that and we’re going to clear and run Rooster Now you see that size of dogis 16 and this is really proven that the size of an object is only accounting for the sizes of the membervariables.It’s not going to count the functions that we have here.So if, for example, we had a function that says principal and we have another one that says do something,this is not going to change the size of our object because functions aren’t accounted for in the sizeof our object here.So let’s build and really show you this The world is good.We can clear and run Rooster.We see that we have the same sizes.The size of dog is 16, the size of size, T is eight.We can even use object names here.For example, we are using the class itself, but we can use dog one here and we’re going to get thesame information.Let’s go out and we’re going to clear and run Rooster and you see that we have the same size.So if we change this thing to put in a pointer, we’re going to see something else.Let’s put in an end pointer and let’s say page like we have been doing all along and see what we get.And we know that the size of a pointer on my system, let’s print that out so that we have no doubt.Let’s for example say size of end pointer is going to be size of end pointer.Okay, let’s build.We’re going to pass this through JK and the world is going to be good.We can clear and run Rooster We’re going to see that we have 24 because we have two member variablesthat are going to be eight bytes in memory of size.T They are of type size T and we have a pointer which is going to have a size of eight in memory, butwe don’t care what this pointer is pointing to.If for example, this pointer is pointing to something really large, we don’t care.We’re just going to account for the end pointer here.And this is really phenomenal because if, for example, we tried to set up an stdstring object andby now you should know that Stdstring itself is implemented as a class in C plus plus.So it’s really a class and we can print its size.So let’s set up a string object here.We’re going to say STD string and we’re going to say name and we’re going to initialize this with HelloWorld.Okay, we’re going to see something really strange here.So if we print the size of name here, we’re going to say size of name and we’re going to print that.Let’s see what we get.We’re going to run and we’re going to see the world is good and I can clear and run Rooster.We’re going to see that size of name is 32.Let’s change the text inside our string and see that we change accordingly, because this can reallybe confusing.Let’s say I am the king of the universe.Why not?And we’re going to build again.Let’s see what we get.Fingers crossed this is going to blow your mind.You see, we have the same size for name even if we are changing the text in here.So what is really happening?The string is storing our text here as const char pointer and what we have is a pointer inside and whatwe probably have inside is a member variable, which is a pointer like we have here.So what we will be accounting for in the string class is the size of the pointer, but it’s not thesize of what is pointed to.Okay, so the car pointer may be pointing to thousands of characters in memory, but as long as thecompiler is concerned, it’s just going to use the pointer member variable and it’s going to accountfor it in the size of your object.Hopefully you can understand why the size of our string object is going to be the same regardless ofhow large is the string.And this is really something you need to understand.Otherwise this is going to throw you off as you design your C plus plus applications.And this is really all I had to share in this lecture.The size of your object is mostly going to be determined by the.A member variables you have and the size is going to be the sum of the sizes of your member variables.We are going to stop here in this lecture and the next one, we’re going to try and recap what we sawin this chapter.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，C++ 新同学你好！很高兴能成为你的 C++ 导师。我们会用最有效的方法一步步学习。</p>
<h2 id="C-类对象的大小：深入理解-sizeof"><a href="#C-类对象的大小：深入理解-sizeof" class="headerlink" title="C++ 类对象的大小：深入理解 sizeof"></a>C++ 类对象的大小：深入理解 <code>sizeof</code></h2><p><strong>本节概要：</strong><br>我们将探讨 C++ 中类 (class) 对象所占内存大小是如何确定的。核心思想是，对象的大小主要由其成员变量 (member variables) 决定，而成员函数 (member functions) 通常不计入单个对象的大小。我们还会讨论像 <code>std::string</code> 这样的特殊情况以及一个叫做内存对齐 (memory alignment) 的重要概念。</p>
<hr>
<p><strong>详细解释：</strong></p>
<ol>
<li><p><strong><code>sizeof</code> 运算符 (operator)：</strong><br>在 C++ 中，<code>sizeof</code> 是一个一元运算符，它返回一个类型或一个变量在内存中占用的字节 (bytes) 数。这对于理解数据如何在内存中存储至关重要。</p>
</li>
<li><p><strong>类对象大小的基本原则：成员变量的总和</strong></p>
<ul>
<li>当你创建一个类的对象时，编译器 (compiler) 会为该对象的成员变量分配内存。</li>
<li>最直接的理解是，一个对象的大小约等于其所有成员变量大小的总和。</li>
<li>例如，如果一个类有两个 <code>int</code> 类型的成员变量，而一个 <code>int</code> 在你的系统上占用 4 个字节，那么这个对象的大小至少是 4 + 4 = 8 个字节。</li>
</ul>
</li>
<li><p><strong>成员函数不计入对象大小：</strong></p>
<ul>
<li>类的成员函数（或称方法 (methods)）定义了对象可以执行的操作。然而，这些函数的代码本身并不存储在每个对象实例中。</li>
<li>可以把类想象成一个蓝图 (blueprint)，而对象是根据这个蓝图建造的房子。蓝图上描述了房子的功能（相当于成员函数），但这些描述本身并不增加每栋房子占用的土地面积。</li>
<li>函数的代码存储在内存中的一个地方（通常是代码段），所有该类的对象共享这些代码。当调用一个对象的成员函数时，程序会跳转到该代码位置执行，并隐式地传递一个指向该对象的指针 (pointer) (通常称为 <code>this</code> 指针)，以便函数知道要操作哪个对象的数据。</li>
<li>因此，无论类有多少成员函数，或者函数多么复杂，它们都不会增加类对象本身的大小。</li>
</ul>
</li>
<li><p><strong>指针成员变量和 <code>std::string</code> 的特殊性：</strong></p>
<ul>
<li><strong>指针成员：</strong> 如果类有一个指针成员变量，例如 <code>int* p_age;</code>，那么 <code>sizeof</code> 计算的是这个指针变量本身的大小（在 64 位系统上通常是 8 字节，32 位系统上是 4 字节），而不是它所指向的数据的大小。指针指向的内存可能很大，也可能很小，或者甚至可能没有指向任何有效的内存（空指针），但这与指针变量本身的大小无关。</li>
<li><strong><code>std::string</code>：</strong> <code>std::string</code> 是 C++ 标准库中一个非常常用的类，用于处理文本。理解 <code>sizeof(std::string)</code> 的行为很重要：<ul>
<li><code>std::string</code> 内部通常会使用指针来管理实际的字符数据，这些数据存储在堆 (heap) 内存上。</li>
<li>所以，<code>sizeof(std::string)</code> 返回的是 <code>std::string</code> 对象本身管理结构的大小（可能包含指向字符数据的指针、当前字符串长度、已分配容量等成员），而不是它所存储的文本的实际长度。</li>
<li>这意味着，无论 <code>std::string</code> 对象存储 “Hello”还是 “Hello World, this is a very long string”，<code>sizeof(std::string)</code> 的结果通常是相同的（在同一个编译器和平台下）。这是因为它只计算了管理这些字符所需的固定大小的内部成员。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>内存对齐 (Memory Alignment)：</strong></p>
<ul>
<li>虽然我们说对象大小约等于成员变量大小之和，但实际情况可能因为“内存对齐”而略有不同。</li>
<li>为了提高 CPU 访问内存的效率，编译器通常会将变量放置在特定的内存地址上，这些地址是某个数（通常是变量大小或特定值如 4 或 8）的倍数。</li>
<li><strong>为什么需要对齐？</strong> CPU 读取未对齐的数据可能需要多次内存访问，或者在某些架构上直接引发硬件异常。对齐访问通常更快。</li>
<li><strong>填充字节 (Padding Bytes)：</strong> 为了实现对齐，编译器可能会在成员变量之间或在对象的末尾插入一些未使用的字节，称为填充字节。</li>
<li><strong>影响：</strong> 由于填充字节的存在，一个对象的实际大小可能会大于其所有成员变量大小的简单总和。</li>
<li>例如，一个类有如下成员：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;     <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">int</span> b;      <span class="comment">// 4 bytes</span></span><br><span class="line">    short c;    <span class="comment">// 2 bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
简单相加是 1 + 4 + 2 = 7 字节。但实际大小可能是：<ul>
<li><code>char a;</code> (1 byte)</li>
<li>编译器可能填充 3 个字节，使接下来的 <code>int b</code> 从一个能被 4 整除的地址开始。</li>
<li><code>int b;</code> (4 bytes)</li>
<li><code>short c;</code> (2 bytes)</li>
<li>对象总大小也可能需要对齐到某个边界（例如 4 或 8 字节的倍数），所以末尾可能还会填充 2 个字节。</li>
<li>因此，这个 <code>Example</code> 对象的大小可能是 1 (a) + 3 (padding) + 4 (b) + 2 (c) + 2 (padding) = 12 字节，而不是 7 字节。具体取决于编译器和目标平台。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>代码示例：</strong></p>
<p>让我们通过代码来验证这些概念。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; // 包含 std::string 所需的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的 Dog 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数 (Constructor) - 使用默认的</span></span><br><span class="line">    Dog() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog's leg count: "</span> &lt;&lt; leg_count_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog's arm count: "</span> &lt;&lt; arm_count_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (p_age_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog's age: "</span> &lt;&lt; *p_age_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog's name: "</span> &lt;&lt; name_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p_age_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p_age_ = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// 在堆上分配内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        *p_age_ = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">        name_ = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数 (Destructor) - 用于释放动态分配的内存</span></span><br><span class="line">    ~Dog() &#123;</span><br><span class="line">        <span class="keyword">delete</span> p_age_; <span class="comment">// 释放 p_age_ 指向的内存</span></span><br><span class="line">        p_age_ = <span class="literal">nullptr</span>; <span class="comment">// 好习惯，防止悬挂指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">size_t</span> leg_count_ &#123;<span class="number">4</span>&#125;;      <span class="comment">// size_t 通常是无符号长整型</span></span><br><span class="line">    <span class="keyword">size_t</span> arm_count_ &#123;<span class="number">0</span>&#125;;      <span class="comment">// 初始值</span></span><br><span class="line">    <span class="keyword">int</span>* p_age_ &#123;<span class="literal">nullptr</span>&#125;;      <span class="comment">// 指向年龄的指针，初始为空指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name_ &#123;<span class="string">"Buddy"</span>&#125;; <span class="comment">// std::string 对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于演示内存对齐的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlignmentDemo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="comment">// 编译器可能会在这里插入填充字节</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 编译器可能会在这里插入填充字节</span></span><br><span class="line">    short s;</span><br><span class="line">    <span class="comment">// 编译器可能会在这里为整个对象末尾插入填充字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyClass</span> &#123;</span>&#125;; <span class="comment">// 空类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 基本类型大小 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(char): "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(short): "</span> &lt;&lt; <span class="keyword">sizeof</span>(short) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(int): "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(long): "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(long long): "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(float): "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(double): "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(size_t): "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(int*): "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>*) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(std::string): "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">std</span>::<span class="built_in">string</span>) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- Dog 类对象大小 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Dog dog1;</span><br><span class="line">    dog1.set_age(<span class="number">5</span>);</span><br><span class="line">    dog1.set_name(<span class="string">"Rex"</span>);</span><br><span class="line"></span><br><span class="line">    Dog dog2;</span><br><span class="line">    dog2.set_age(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// dog2 使用默认名字 "Buddy"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 Dog 类本身的大小 (通过类型)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Dog) class: "</span> &lt;&lt; <span class="keyword">sizeof</span>(Dog) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 打印 Dog 对象的大小 (通过对象实例)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(dog1) object: "</span> &lt;&lt; <span class="keyword">sizeof</span>(dog1) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解释：</span></span><br><span class="line">    <span class="comment">// Dog 包含:</span></span><br><span class="line">    <span class="comment">// 1. size_t leg_count_  (假设 8 字节)</span></span><br><span class="line">    <span class="comment">// 2. size_t arm_count_  (假设 8 字节)</span></span><br><span class="line">    <span class="comment">// 3. int* p_age_        (假设 8 字节)</span></span><br><span class="line">    <span class="comment">// 4. std::string name_   (假设 32 字节，具体值取决于标准库实现)</span></span><br><span class="line">    <span class="comment">// 理论上不考虑对齐的简单相加: 8 + 8 + 8 + 32 = 56 字节。</span></span><br><span class="line">    <span class="comment">// 实际大小可能会因对齐而略有不同，但通常会接近这个值，或者是这个值的某个对齐后的倍数。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- std::string 行为 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s1 = <span class="string">"short"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s2 = <span class="string">"this is a much longer string"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(s1) (\""</span> &lt;&lt; s1 &lt;&lt; <span class="string">"\"): "</span> &lt;&lt; <span class="keyword">sizeof</span>(s1) &lt;&lt; <span class="string">" byte(s), length: "</span> &lt;&lt; s1.length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(s2) (\""</span> &lt;&lt; s2 &lt;&lt; <span class="string">"\"): "</span> &lt;&lt; <span class="keyword">sizeof</span>(s2) &lt;&lt; <span class="string">" byte(s), length: "</span> &lt;&lt; s2.length() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 注意：sizeof(s1) 和 sizeof(s2) 的值是相同的，尽管它们存储的字符串长度不同。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 内存对齐演示 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(AlignmentDemo): "</span> &lt;&lt; <span class="keyword">sizeof</span>(AlignmentDemo) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// AlignmentDemo 包含 char (1), int (4), short (2). 总共 1+4+2 = 7 字节。</span></span><br><span class="line">    <span class="comment">// 实际大小可能是 12 字节：</span></span><br><span class="line">    <span class="comment">// char c1;      // 1 byte</span></span><br><span class="line">    <span class="comment">// padding;       // 3 bytes (为了让 int i 对齐到 4 字节边界)</span></span><br><span class="line">    <span class="comment">// int i;         // 4 bytes</span></span><br><span class="line">    <span class="comment">// short s;       // 2 bytes</span></span><br><span class="line">    <span class="comment">// padding;       // 2 bytes (为了让整个结构体大小是对齐值(如4或8)的倍数，这里假设是4，所以1+3+4+2 = 10，需要补2到12)</span></span><br><span class="line">    <span class="comment">// 具体填充策略取决于编译器。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 空类大小 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(EmptyClass): "</span> &lt;&lt; <span class="keyword">sizeof</span>(EmptyClass) &lt;&lt; <span class="string">" byte(s)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// C++ 标准规定，空类的大小不能为 0。通常是 1 字节。</span></span><br><span class="line">    <span class="comment">// 这是为了确保空类的不同对象在内存中有不同的地址。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>预期输出分析 (不同系统和编译器可能会略有差异，尤其是 <code>sizeof(std::string)</code> 和对齐后的类大小)：</strong></p>
<ul>
<li>基本类型大小会显示你系统上这些类型的标准大小。</li>
<li><code>sizeof(Dog)</code> 会是其成员 <code>size_t</code> (通常8字节), <code>size_t</code> (8字节), <code>int*</code> (通常8字节), 和 <code>std::string</code> (例如，GCC libstdc++ 中可能是32字节) 的总和，并考虑内存对齐。所以可能是 8+8+8+32 = 56，或者因为对齐而稍大。</li>
<li><code>sizeof(s1)</code> 和 <code>sizeof(s2)</code> 会相同，即使字符串内容长度不同。</li>
<li><code>sizeof(AlignmentDemo)</code> 很可能不是 <code>1+4+2 = 7</code> 字节，而是由于对齐，例如 12 字节。</li>
<li><code>sizeof(EmptyClass)</code> 通常是 1 字节。</li>
</ul>
<hr>
<p><strong>QA 闪卡 (Flash Cards):</strong></p>
<ol>
<li><strong>Q:</strong> 计算一个变量或类型在内存中占用多少字节的 C++ 运算符是什么？<br><strong>A:</strong> <code>sizeof</code> 运算符。</li>
<li><strong>Q:</strong> 类对象的大小主要由什么决定？<br><strong>A:</strong> 主要由其成员变量 (member variables) 的大小总和决定（可能受内存对齐影响）。</li>
<li><strong>Q:</strong> 类的成员函数 (member functions) 会增加该类每个对象实例的大小吗？为什么？<br><strong>A:</strong> 不会。成员函数的代码存储在内存中的一个共享位置，不复制到每个对象中。</li>
<li><strong>Q:</strong> 如果一个类有一个 <code>int* ptr;</code> 成员，<code>sizeof</code> 这个对象时，<code>ptr</code> 贡献的大小是多少？<br><strong>A:</strong> 指针 <code>ptr</code> 本身的大小（例如，64位系统上是8字节），而不是它所指向的 <code>int</code> 数据的大小。</li>
<li><strong>Q:</strong> <code>sizeof(std::string)</code> 返回的是字符串中字符的数量吗？<br><strong>A:</strong> 不是。它返回 <code>std::string</code> 对象内部管理结构的大小，这个大小通常是固定的，与字符串内容的长度无关。</li>
<li><strong>Q:</strong> 什么是内存对齐 (memory alignment)？它如何影响对象的大小？<br><strong>A:</strong> 编译器为了提高 CPU 访问效率，会将成员变量存放在特定地址（通常是其大小的倍数）。这可能导致在成员间或对象末尾添加填充字节 (padding bytes)，使得对象的实际大小大于成员大小的简单总和。</li>
<li><strong>Q:</strong> 一个没有任何成员变量的空类 (empty class)，其大小是多少？<br><strong>A:</strong> 通常是 1 字节。C++ 标准不允许对象大小为0，以保证不同对象有不同地址。</li>
</ol>
<hr>
<p><strong>常见误解或易犯错误：</strong></p>
<ol>
<li><strong>混淆 <code>sizeof(std::string)</code> 和 <code>myString.length()</code>：</strong><ul>
<li><strong>错误：</strong> 认为 <code>sizeof(std::string)</code> 会告诉你字符串里有多少个字符。</li>
<li><strong>正确：</strong> <code>sizeof(std::string)</code> 是 <code>std::string</code> 这个管理类本身的大小。要获取字符数，应该使用 <code>.length()</code> 或 <code>.size()</code> 成员函数。</li>
</ul>
</li>
<li><strong>忽略内存对齐：</strong><ul>
<li><strong>错误：</strong> 简单地将所有成员变量的大小相加，就认为这是对象的最终大小。</li>
<li><strong>正确：</strong> 最终大小可能因为内存对齐而变大。</li>
</ul>
</li>
<li><strong>认为成员函数会增加对象大小：</strong><ul>
<li><strong>错误：</strong> 定义了很多成员函数，担心对象会变得非常庞大。</li>
<li><strong>正确：</strong> 成员函数不影响单个对象的大小。</li>
</ul>
</li>
<li><strong>对指针成员的 <code>sizeof</code> 理解错误：</strong><ul>
<li><strong>错误：</strong> <code>MyClass { char* name; };</code> 认为 <code>sizeof(MyClass)</code> 会包括 <code>name</code> 指向的字符串的长度。</li>
<li><strong>正确：</strong> <code>sizeof(MyClass)</code> 只包括指针 <code>name</code> 本身的大小。</li>
</ul>
</li>
<li><strong>在运行时动态改变大小：</strong><ul>
<li><strong>错误：</strong> 认为 <code>sizeof(MyObject)</code> 的值会随着对象内部动态分配内存（如 <code>std::vector</code> 添加元素）而改变。</li>
<li><strong>正确：</strong> <code>sizeof</code> 是一个编译时（或接近编译时）确定的值，它给出的是对象本身固定结构的大小，不包括它可能管理的、在堆上动态分配的内存区域。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>编码练习：</strong></p>
<p>下面有一个 <code>Gadget</code> 类。请你思考一下，并尝试填写代码来打印出 <code>Gadget</code> 对象的大小。然后编译并运行，看看你的预测是否准确。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gadget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> id_char;       <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="comment">// 编译器可能会在这里插入填充 (padding)</span></span><br><span class="line">    <span class="keyword">int</span> item_code;      <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="comment">// 编译器可能会在这里插入填充</span></span><br><span class="line">    short version;      <span class="comment">// 2 bytes</span></span><br><span class="line">    <span class="comment">// 编译器可能会在这里插入填充</span></span><br><span class="line">    <span class="keyword">bool</span> is_enabled;    <span class="comment">// 1 byte (在某些实现中bool可能占用更多，但通常是1)</span></span><br><span class="line">    <span class="comment">// 编译器可能会在对象末尾插入填充，以使整个对象的大小是某个值的倍数 (例如4或8)</span></span><br><span class="line"></span><br><span class="line">    Gadget(<span class="keyword">char</span> id, <span class="keyword">int</span> code, short v, <span class="keyword">bool</span> enabled)</span><br><span class="line">        : id_char(id), item_code(code), version(v), is_enabled(enabled) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display_details</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ID Char: "</span> &lt;&lt; id_char</span><br><span class="line">                  &lt;&lt; <span class="string">", Item Code: "</span> &lt;&lt; item_code</span><br><span class="line">                  &lt;&lt; <span class="string">", Version: "</span> &lt;&lt; version</span><br><span class="line">                  &lt;&lt; <span class="string">", Enabled: "</span> &lt;&lt; (is_enabled ? <span class="string">"true"</span> : <span class="string">"false"</span>)</span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Gadget <span class="title">my_gadget</span><span class="params">(<span class="string">'A'</span>, <span class="number">101</span>, <span class="number">2</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    my_gadget.display_details();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预测一下 my_gadget 的大小会是多少？</span></span><br><span class="line">    <span class="comment">// 成员大小总和: sizeof(char) + sizeof(int) + sizeof(short) + sizeof(bool)</span></span><br><span class="line">    <span class="comment">// = 1 + 4 + 2 + 1 = 8 bytes.</span></span><br><span class="line">    <span class="comment">// 但由于内存对齐，实际大小可能是多少呢？</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size_of_gadget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在这里填写代码，计算 my_gadget 对象的大小，并将其存储在 size_of_gadget 变量中。</span></span><br><span class="line">    <span class="comment">// 然后打印出这个大小。</span></span><br><span class="line">    <span class="comment">// ----------- 在下面填空 -----------</span></span><br><span class="line">    <span class="comment">// size_of_gadget = ... ;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "Size of my_gadget: " &lt;&lt; ... &lt;&lt; " bytes" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// ---------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请你尝试填写 <code>TODO</code> 部分的代码，然后我会根据你的答案给出评分和解释。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Object/">Object    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/279%20-%20cpp%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9A%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>279 - cpp析构函数：对象销毁时的内存释放</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/280%20-%20%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F%20%E5%80%92%E5%BA%8F%E6%9E%90%E6%9E%84/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>280 - 构造与析构顺序 倒序析构</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/272 - first class/" title="272 - first class"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">272 - first class</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/273 - constructor/" title="273 - constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">273 - constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/275 - getter and setter/" title="275 - getter and setter"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">275 - getter and setter</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/277 - IDE 创建 cpp 类方法/" title="277 - IDE 创建 cpp 类方法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">277 - IDE 创建 cpp 类方法</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/278 - cpp 指针管理类对象示例/" title="278 - cpp 指针管理类对象示例"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">278 - cpp 指针管理类对象示例</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/276 - Class across multiple files/" title="276 - Class across multiple files"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">276 - Class across multiple files</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>