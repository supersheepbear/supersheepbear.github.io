<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>313 - friend of class | Bear's dream</title><meta name="description" content="313 - friend of class"><meta name="keywords" content="Cpp,Coding,Tutorial,Development,Class"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="313 - friend of class"><meta name="twitter:description" content="313 - friend of class"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="313 - friend of class"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/313%20-%20friend%20of%20class/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="313 - friend of class"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/313%20-%20friend%20of%20class/"><link rel="prev" title="312 - cpp 友元函数详解" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/312%20-%20cpp%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><link rel="next" title="318 - inline static variable" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/318%20-%20inline%20static%20variable/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">152</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#313-Friend-of-Class"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">313 - Friend of Class</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-友元类：打破封装的特殊权限"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">C++友元类：打破封装的特殊权限</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-友元类详解"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">1. 友元类详解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-为什么我们需要友元类？"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">1.1 为什么我们需要友元类？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-什么是友元类？"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">1.2 什么是友元类？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-如何声明友元类？"><span class="toc_mobile_items-number">1.4.3.</span> <span class="toc_mobile_items-text">1.3 如何声明友元类？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-4-友元类的工作原理和重要特性"><span class="toc_mobile_items-number">1.4.4.</span> <span class="toc_mobile_items-text">1.4 友元类的工作原理和重要特性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-5-何时使用友元类？"><span class="toc_mobile_items-number">1.4.5.</span> <span class="toc_mobile_items-text">1.5 何时使用友元类？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-详细代码示例"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">2. 详细代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-QA-闪卡-QA-Flash-Cards"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">3. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-常见误解或错误"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">4. 常见误解或错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-编程练习"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">5. 编程练习</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#友元类编程练习：解决方案评估与讲解"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">友元类编程练习：解决方案评估与讲解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-你的解决方案评估"><span class="toc_mobile_items-number">1.12.</span> <span class="toc_mobile_items-text">1. 你的解决方案评估</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-正确答案及解释"><span class="toc_mobile_items-number">1.13.</span> <span class="toc_mobile_items-text">2. 正确答案及解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-建议和扩展问题"><span class="toc_mobile_items-number">1.14.</span> <span class="toc_mobile_items-text">3. 建议和扩展问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-2"><span class="toc_mobile_items-number">1.15.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-2"><span class="toc_mobile_items-number">1.16.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-进一步的调查问题"><span class="toc_mobile_items-number">1.17.</span> <span class="toc_mobile_items-text">8. 进一步的调查问题</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#313-Friend-of-Class"><span class="toc-number">1.</span> <span class="toc-text">313 - Friend of Class</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-友元类：打破封装的特殊权限"><span class="toc-number">1.3.</span> <span class="toc-text">C++友元类：打破封装的特殊权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-友元类详解"><span class="toc-number">1.4.</span> <span class="toc-text">1. 友元类详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-为什么我们需要友元类？"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.1 为什么我们需要友元类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-什么是友元类？"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.2 什么是友元类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-如何声明友元类？"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.3 如何声明友元类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-友元类的工作原理和重要特性"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.4 友元类的工作原理和重要特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-何时使用友元类？"><span class="toc-number">1.4.5.</span> <span class="toc-text">1.5 何时使用友元类？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-详细代码示例"><span class="toc-number">1.5.</span> <span class="toc-text">2. 详细代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-QA-闪卡-QA-Flash-Cards"><span class="toc-number">1.6.</span> <span class="toc-text">3. QA 闪卡 (QA Flash Cards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-常见误解或错误"><span class="toc-number">1.7.</span> <span class="toc-text">4. 常见误解或错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-编程练习"><span class="toc-number">1.8.</span> <span class="toc-text">5. 编程练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">1.9.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">1.10.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#友元类编程练习：解决方案评估与讲解"><span class="toc-number">1.11.</span> <span class="toc-text">友元类编程练习：解决方案评估与讲解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-你的解决方案评估"><span class="toc-number">1.12.</span> <span class="toc-text">1. 你的解决方案评估</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-正确答案及解释"><span class="toc-number">1.13.</span> <span class="toc-text">2. 正确答案及解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-建议和扩展问题"><span class="toc-number">1.14.</span> <span class="toc-text">3. 建议和扩展问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-2"><span class="toc-number">1.15.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-2"><span class="toc-number">1.16.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-进一步的调查问题"><span class="toc-number">1.17.</span> <span class="toc-text">8. 进一步的调查问题</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">313 - friend of class</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/313%20-%20friend%20of%20class/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/313%20-%20friend%20of%20class/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="313-Friend-of-Class"><a href="#313-Friend-of-Class" class="headerlink" title="313 - Friend of Class"></a>313 - Friend of Class</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about friend classes and friend classes are a facility.We have to give external classes access to our own member variables.And let’s look at a simple example to really drive this home.If you look here, we have our good old dog class.It has a public section and a private section, and we have our valuable member variables that externalclasses want to access.If you look down here, we have another class which is called Cat, and it has a function which takesa dog parameter by reference.And inside the function we want to access private members of our dog object directly through the dotoperator like this.And suppose this is that is really important for the problem that you are trying to solve with C plusplus by default, if you try to do this, you’re going to get a compiler error because you really aretrying to access private parts of a dog object from the outside of a dog class.So we’re going to get a compiler error.If you want this to work, you can go in and mark these members as public.But we have seen that this is really bad design.You don’t want to do that.The option we have is to give the cat class access to our own private member variables in here by markingthe class cat as our own friend.And we can do that through the syntax.You see here, we say friend class and then we specify the class.We want to be our friend.The moment we put this declaration and the class is going to become our friend and it has access toany member variable in our class, be it private or public.And you have to be sure that this is what you want because as we have seen in the last lecture, yourfriends are going to have all access to your private member variables and they can read from them,they can even modify them.So make sure this is really what you want.So just like for friend functions, friend classes are not really members, so they don’t have directaccess to the this pointer, for example.They are really not member functions.They are external things that have access to our own things, but they can’t access the member variablesdirectly to have access.They have to go through an object name like dog here.So for example, if we went into this function and tried to access dog age directly, that wouldn’twork because they really are not members and they don’t have access to the this pointer.So this is really all I want to share with you.In terms of friend classes.Let’s head over to Visual Studio code and play with this a little more.Okay.Here we are in our working folder.The current project is Friend classes.We’re going to grab our template files like we always do.We’re going to put them in place and we’re going to open this in Visual Studio code by dragging anddropping here, this is going to open our folder.We’re going to close the left sidebar here and we’re going to clean up a little bit and we are goingto use the dog from the last lecture as a starting point.So here is our class.It has a few private member variables, name and age, and we don’t want this friend functions herebecause they don’t make sense for what we want to do now.Now let’s go down and set up another class, which is going to be a cat class.Let’s do that.We’re going to say class cat and we’re going to have a function which is going to live in the publicsection and we’re going to say print dog info.It’s going to not return anything and we’re going to take our dog by const reference.So let’s do that.Let’s say D here and we are basically going to do the same thing we did in the last lecture.We’re going to print information about the dog object, so we’re going to say Stdcout dog and we’regoing to say the name of the dog d m name.We want to access the name directly.Let’s do that.And we’re going to put a comma and say age and we’re going to say D m age.We’re going to put our square bracket and we’re going to put a new line character and we want this towork.But you see that we have a squiggly line and this is really bad.We don’t want this.We want to have direct access here.But because we are doing this from the outside, you notice that this function is the member functionand because it is a member function and it is just trying to print stuff, let’s mark it as const becausewe don’t want it to modify the member variables and let’s make this class a little complete by givingit a private member variable and give our cat a name also.So let’s say stdstring m name, but it is from a cat class, so make sure you know this.So let’s put a colon here and you see we have a problem here and we want to solve.We have seen that we can use friend functions and these are going to be better than coming in here andmarking this thing as public.Because if we do this, this is going to solve the problem.Anybody will have access to our member variables.From the outside, you see that the squiggly line goes away.But again, this is bad design because anybody from the outside is going to have access to our own membervariables and this is going to leak our own implementation details to the outside.This is bad.We want our member variables to be private.So to give our cat class access, we can mark it as a friend, and the syntax to do that is ridiculouslysimple.Again, we say friend class and then we say the class name.And at the moment we do that, you see the squiggly lines go away and we can go down and create catobjects and do anything we want with them.We can’t really pass the name for our cat, so if we pass them, they are just going to have an emptystring as the name, but we don’t really care.So let’s go down and do that.We’re going to say Cat Cat one and we can then create an object of our dog.We’re going to say Dog Dog one and we’re going to give it a name Fluffy, and they are going to be twoyears old.And then we can say Cat one and say Print dog info and pass our dog here.It’s going to be passed by reference.And if we do this, we’re going to print the information and it is going to be what we want.So let’s build.You’re going to see that the world is good.If we clear and run Rooster, we’re going to see our information here.So there are a few things you really need to know.Even if the cat class has access to our own private member variables, it really isn’t a member.For example, it doesn’t have access to the this pointer.If we try and come in and use the this pointer inside this function, that will be the this pointerof the cat object.It won’t be the this pointer of the dog object that we passed here as a parameter.You really need to know this because of this reason we can’t have direct access to the age of the dog.For example, if we try to do that, we’re going to have a compiler error.Let’s go in and try to print the age directly.Let’s say M Age, and at the moment we do that, we’re going to get a compiler error because Cat doesn’thave a member called M Age and we can’t really have direct access to the dog class because we’re notinside the dog class.Even if we try to use the this pointer, the this pointer we have is for the cat object we are in.If we try to print stuff from here, for example, if we are printing here and trying to access thethis pointer, we will be using the this pointer of the cat object.It won’t be the this pointer of the dog object that was passed to us as a parameter.You really need to know this.If for example we change this to be M name, we will be accessing the name of the cat.It won’t be the name of the dog here.So let’s change this to M name.You’re going to see that it’s going to work, but it won’t be the name for the dog again.It will be the name for the cat object because we have a member variable named M name here.If we take this out, we’re going to see that this is going to give us an error because Cat now doesn’thave a member variable named M name.So you need to know this inside friend classes.We don’t have direct access to member variables of the class that we have befriended.If we want to have access to the member variables, we have to go through an object.So even if we have access to the member variables, the access is still limited to some level.It’s not full access like regular member variables of the class that we have befriended.So you really need to know this.And another thing I want to point out is that just because Cat is now a friend of dog doesn’t mean Dogis a friend of cat.What do I mean?Because of this friendship we have set up here, we don’t have access to private members of Cat.Another thing worth pointing out is that just because we have this friendship here, setting up Catas a friend of dog doesn’t mean a dog is a friend of cat.So friendship is not reciprocal.So you really need to know that if you want dog to be a friend of cat, you have to go inside the catclass and really set this up.But we’re not going to do that here.And I think this is really all I had to share in this lecture.If you need this kind of setup, this is how you can do it.You can set up a friend class and it’s going to have access to your private member variables and youcan use that however you want.We are going to stop here in this lecture.The next one we’re going to try and recap.What we saw in this chapter.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，我们来开始学习C++中一个非常有用的概念：<strong>友元类（Friend Classes）</strong>。</p>
<hr>
<h2 id="C-友元类：打破封装的特殊权限"><a href="#C-友元类：打破封装的特殊权限" class="headerlink" title="C++友元类：打破封装的特殊权限"></a><strong>C++友元类：打破封装的特殊权限</strong></h2><p><strong>摘要：</strong> 本课程将深入探讨C++中的友元类，它是一种赋予外部类访问我们自身私有（private）或保护（protected）成员变量的机制。我们将通过详细的解释和代码示例，理解友元类的声明、工作原理、使用场景、以及需要注意的关键点和常见误解。</p>
<hr>
<h2 id="1-友元类详解"><a href="#1-友元类详解" class="headerlink" title="1. 友元类详解"></a><strong>1. 友元类详解</strong></h2><p>在C++中，我们一直强调面向对象编程的一个核心原则是<strong>封装（Encapsulation）</strong>。这意味着类的内部实现细节，特别是它的成员变量，通常应该被隐藏起来，不直接暴露给外部。我们使用 <code>private</code> 或 <code>protected</code> 关键字来限制对这些成员的访问，以确保数据安全性和代码的健壮性。</p>
<p>然而，在某些特定的场景下，我们可能需要允许一个<strong>特定</strong>的外部类能够直接访问我们类的私有或保护成员。这时，<strong>友元类（Friend Class）</strong>就派上用场了。</p>
<h3 id="1-1-为什么我们需要友元类？"><a href="#1-1-为什么我们需要友元类？" class="headerlink" title="1.1 为什么我们需要友元类？"></a><strong>1.1 为什么我们需要友元类？</strong></h3><p>想象一下，你有一个 <code>Dog</code> 类，它有一些私有的成员变量，比如 <code>m_name</code>（名字）和 <code>m_age</code>（年龄）。你希望这些数据只能通过 <code>Dog</code> 类自己的公共方法来访问和修改，以保护它们不被随意篡改。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age) : m_name(name), m_age(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设没有公共的getter或setter，或者只允许通过特定操作访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>现在，你又有一个 <code>Cat</code> 类，它的一个成员函数 <code>print_dog_info</code> 需要打印一个 <code>Dog</code> 对象的详细信息，包括它的名字和年龄。如果 <code>m_name</code> 和 <code>m_age</code> 是 <code>private</code> 的，那么 <code>Cat</code> 类的 <code>print_dog_info</code> 函数是<strong>无法直接访问</strong> <code>dog_obj.m_name</code> 和 <code>dog_obj.m_age</code> 的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_dog_info</span><span class="params">(<span class="keyword">const</span> Dog&amp; d)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ❌ 编译错误：m_name 和 m_age 是私有的！</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; "Dog Name: " &lt;&lt; d.m_name &lt;&lt; ", Age: " &lt;&lt; d.m_age &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong>问题所在：</strong><br>默认情况下，从 <code>Dog</code> 类外部访问其私有成员会导致编译错误。<br>你可以通过以下方法来解决这个问题，但它们都有各自的缺点：</p>
<ol>
<li><strong>将私有成员改为 <code>public</code>：</strong> 比如把 <code>m_name</code> 和 <code>m_age</code> 声明为 <code>public</code>。<ul>
<li><strong>缺点：</strong> 这完全破坏了封装性，任何外部代码都可以直接访问和修改这些成员，这是一种非常糟糕的设计，因为这会暴露类的内部实现细节，使类更容易被错误使用，并且难以维护。</li>
</ul>
</li>
<li><strong>为私有成员提供公共的 <code>getter</code> 方法：</strong> 为 <code>m_name</code> 和 <code>m_age</code> 提供公共的 <code>getName()</code> 和 <code>getAge()</code> 方法。<ul>
<li><strong>缺点：</strong> 这种方法通常是好的设计，但在某些特定场景下，如果一个类需要对另一个类的内部数据进行深层操作（例如，一个序列化器需要完全重构对象状态），提供大量的 <code>getter</code> 可能不够灵活，或者 <code>setter</code> 会带来安全隐患，而友元提供了一种更紧密耦合但受控的访问方式。</li>
</ul>
</li>
</ol>
<p>为了在<strong>不破坏封装性</strong>的前提下，允许<strong>特定</strong>的外部类访问我们的私有成员，C++引入了友元机制。</p>
<h3 id="1-2-什么是友元类？"><a href="#1-2-什么是友元类？" class="headerlink" title="1.2 什么是友元类？"></a><strong>1.2 什么是友元类？</strong></h3><p>友元类是一种特殊机制，它允许一个类（友元类）访问另一个类（被授予友元权限的类）的私有（<code>private</code>）和保护（<code>protected</code>）成员，就像它是这个类的成员一样。</p>
<p>简单来说，就是“我信任你，所以你可以看到我的秘密。”</p>
<h3 id="1-3-如何声明友元类？"><a href="#1-3-如何声明友元类？" class="headerlink" title="1.3 如何声明友元类？"></a><strong>1.3 如何声明友元类？</strong></h3><p>在C++中，你通过在<strong>被授予友元权限的类</strong>的定义中，使用 <code>friend</code> 关键字来声明一个友元类。</p>
<p><strong>语法：</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeingBefriendedClass</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span>;</span> <span class="comment">// 在这里声明友元类</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></p>
<p><strong>示例：</strong><br>在我们的 <code>Dog</code> 类中，为了让 <code>Cat</code> 类能够访问它的私有成员，我们需要在 <code>Dog</code> 类内部声明 <code>Cat</code> 为其友元：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Dog 类的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age) : m_name(name), m_age(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⭐ 核心：在 Dog 类中声明 Cat 为其友元类</span></span><br><span class="line">    <span class="comment">// 友元声明可以放在类的任何部分（public, private, protected），效果都一样。</span></span><br><span class="line">    <span class="comment">// 但通常为了清晰起见，习惯放在 public 或顶部。</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Cat 类的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Cat 的成员函数现在可以访问 Dog 的私有成员了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_dog_info</span><span class="params">(<span class="keyword">const</span> Dog&amp; d)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗的名字: "</span> &lt;&lt; d.m_name &lt;&lt; <span class="string">", 年龄: "</span> &lt;&lt; d.m_age &lt;&lt; <span class="string">" 岁"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假设 Cat 也有自己的成员</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_cat_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>一旦 <code>Cat</code> 被声明为 <code>Dog</code> 的友元类，<code>Cat</code> 类的<strong>所有成员函数</strong>都可以直接访问 <code>Dog</code> 对象的私有和保护成员。</p>
<h3 id="1-4-友元类的工作原理和重要特性"><a href="#1-4-友元类的工作原理和重要特性" class="headerlink" title="1.4 友元类的工作原理和重要特性"></a><strong>1.4 友元类的工作原理和重要特性</strong></h3><ol>
<li><strong>访问权限：</strong> 友元类可以访问被授予友元权限的类的<strong>所有成员</strong>，包括 <code>private</code>、<code>protected</code> 和 <code>public</code> 成员。</li>
<li><strong>友元不是成员：</strong> 这是非常重要的一点！友元类仅仅是获得了访问权限，它<strong>不是</strong>被授予友元权限的类的一个成员。<ul>
<li>这意味着友元类的对象<strong>不拥有</strong>被授予友元权限的类的 <code>this</code> 指针。</li>
<li>因此，友元类的成员函数不能直接通过 <code>this</code> 访问被授予友元权限的类的成员（例如，在 <code>Cat::print_dog_info</code> 中，你不能直接写 <code>m_name</code> 来访问 <code>Dog</code> 的 <code>m_name</code>）。你必须通过一个<strong>对象实例</strong>来访问这些成员，比如 <code>d.m_name</code>。</li>
</ul>
</li>
<li><strong>友元关系不具传递性（Transitivity）：</strong> 如果类A是类B的友元，类B是类C的友元，这<strong>不意味着</strong>类A是类C的友元。友元关系是明确声明的，不会自动传递。</li>
<li><strong>友元关系不具对称性/非互惠性（Reciprocal）：</strong> 如果类A是类B的友元，这<strong>不意味着</strong>类B也是类A的友元。友元关系是单向的。如果需要双向友元，你需要在两个类中都进行友元声明。</li>
<li><strong>前向声明（Forward Declaration）：</strong> 如果友元类在被授予友元权限的类声明时尚未完全定义，你可能需要使用<strong>前向声明（Forward Declaration）</strong>来告诉编译器这个类的存在。例如：<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>;</span> <span class="comment">// 前向声明 Cat 类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age) : m_name(name), m_age(age) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span>;</span> <span class="comment">// 现在编译器知道 Cat 是一个类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_dog_info</span><span class="params">(<span class="keyword">const</span> Dog&amp; d)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗的名字: "</span> &lt;&lt; d.m_name &lt;&lt; <span class="string">", 年龄: "</span> &lt;&lt; d.m_age &lt;&lt; <span class="string">" 岁"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<h3 id="1-5-何时使用友元类？"><a href="#1-5-何时使用友元类？" class="headerlink" title="1.5 何时使用友元类？"></a><strong>1.5 何时使用友元类？</strong></h3><p>友元机制打破了封装，因此应该<strong>谨慎使用</strong>。它通常用于以下情况：</p>
<ul>
<li><strong>紧密耦合的工具类/助手类：</strong> 当一个辅助类或工具类需要对另一个类的内部实现有非常深层次的了解和操作时。例如，一个调试器或序列化器可能需要直接访问对象的私有状态。</li>
<li><strong>运算符重载（Operator Overloading）：</strong> 特别是当二元运算符（如 <code>&lt;&lt;</code> 或 <code>&gt;&gt;</code> 用于流操作）的左操作数不是类本身时，友元函数或友元类（如果是一组相关的操作）是必要的。例如 <code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const MyClass&amp; obj)</code>。</li>
<li><strong>设计模式：</strong> 在某些设计模式中，友元关系可能被用来实现特定的访问控制。</li>
</ul>
<h2 id="2-详细代码示例"><a href="#2-详细代码示例" class="headerlink" title="2. 详细代码示例"></a><strong>2. 详细代码示例</strong></h2><p>我们将基于你提供的描述，创建一个完整的 <code>Dog</code> 和 <code>Cat</code> 类的示例。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 包含输入输出流库</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;   // 包含字符串库</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 前向声明 ---</span></span><br><span class="line"><span class="comment">// 提前告知编译器 Cat 是一个类，因为 Dog 在声明其为友元时，Cat 类尚未完全定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Dog 类定义 ---</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_name; <span class="comment">// 狗的名字 (私有成员)</span></span><br><span class="line">    <span class="keyword">int</span> m_age;          <span class="comment">// 狗的年龄 (私有成员)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Dog(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">int</span> age) : m_name(name), m_age(age) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog 对象 ["</span> &lt;&lt; m_name &lt;&lt; <span class="string">", "</span> &lt;&lt; m_age &lt;&lt; <span class="string">"] 被创建。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⭐ 声明 Cat 类是 Dog 类的友元</span></span><br><span class="line">    <span class="comment">// 这意味着 Cat 类的所有成员函数都可以访问 Dog 对象的私有和保护成员。</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设有一些公共方法，但不直接暴露私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_name &lt;&lt; <span class="string">" 说：汪汪！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Cat 类定义 ---</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_cat_name; <span class="comment">// 猫的名字 (Cat 自己的私有成员)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Cat(<span class="built_in">std</span>::<span class="built_in">string</span> name) : m_cat_name(name) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cat 对象 ["</span> &lt;&lt; m_cat_name &lt;&lt; <span class="string">"] 被创建。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cat 类的成员函数，用于打印 Dog 对象的信息</span></span><br><span class="line">    <span class="comment">// 注意：这个函数被标记为 const，因为它不会修改 Cat 对象的成员。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_dog_info</span><span class="params">(<span class="keyword">const</span> Dog&amp; d)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- "</span> &lt;&lt; m_cat_name &lt;&lt; <span class="string">" 正在查看 Dog 信息 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// ⭐ 因为 Cat 是 Dog 的友元，所以这里可以直接访问 Dog 对象的私有成员</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗的名字 (来自Cat访问): "</span> &lt;&lt; d.m_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"狗的年龄 (来自Cat访问): "</span> &lt;&lt; d.m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ❌ 常见错误/误解：友元类不能直接访问被友元类的成员，它没有被友元类的 this 指针。</span></span><br><span class="line">        <span class="comment">// 如果这里尝试访问 Dog 的 m_age 或 m_name，会是 Cat 自己的成员，而不是 Dog 的。</span></span><br><span class="line">        <span class="comment">// 例如：</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; "尝试直接访问 Dog 的 m_age (错误示例): " &lt;&lt; m_age &lt;&lt; std::endl; // 编译错误：Cat 没有名为 m_age 的成员</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以访问 Cat 自己的成员</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"查看者 (Cat) 的名字: "</span> &lt;&lt; m_cat_name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 主函数 ---</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 Dog 对象</span></span><br><span class="line">    <span class="function">Dog <span class="title">dog1</span><span class="params">(<span class="string">"Fluffy"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    dog1.bark();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 Cat 对象</span></span><br><span class="line">    <span class="function">Cat <span class="title">cat1</span><span class="params">(<span class="string">"Tom"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cat 对象调用其成员函数来打印 Dog 对象的信息</span></span><br><span class="line">    <span class="comment">// 此时，print_dog_info 可以访问 dog1 的私有成员 m_name 和 m_age</span></span><br><span class="line">    cat1.print_dog_info(dog1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示非互惠性：Dog 对象不能访问 Cat 的私有成员 m_cat_name (即使 Cat 是 Dog 的友元)</span></span><br><span class="line">    <span class="comment">// ❌ 下面的代码会产生编译错误，因为 Dog 不是 Cat 的友元</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "Dog 的名字 (尝试访问 Cat 的私有成员): " &lt;&lt; cat1.m_cat_name &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>运行结果：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Dog 对象 [Fluffy, 2] 被创建。</span><br><span class="line">Fluffy 说：汪汪！</span><br><span class="line"></span><br><span class="line">Cat 对象 [Tom] 被创建。</span><br><span class="line"></span><br><span class="line">--- Tom 正在查看 Dog 信息 ---</span><br><span class="line">狗的名字 (来自Cat访问): Fluffy</span><br><span class="line">狗的年龄 (来自Cat访问): 2</span><br><span class="line">查看者 (Cat) 的名字: Tom</span><br><span class="line">---------------------------------</span><br></pre></td></tr></table></figure></div>
<p><strong>代码解释：</strong></p>
<ul>
<li>我们首先<strong>前向声明</strong>了 <code>Cat</code> 类，因为 <code>Dog</code> 类在定义 <code>Cat</code> 为友元时，需要知道 <code>Cat</code> 是一个类型。</li>
<li>在 <code>Dog</code> 类的定义内部，我们使用了 <code>friend class Cat;</code> 来声明 <code>Cat</code> 是 <code>Dog</code> 的友元。</li>
<li><code>Dog</code> 类的 <code>m_name</code> 和 <code>m_age</code> 是 <code>private</code> 的。</li>
<li>在 <code>Cat</code> 类的 <code>print_dog_info</code> 成员函数中，我们通过传入的 <code>Dog</code> 对象 <code>d</code>，可以直接访问 <code>d.m_name</code> 和 <code>d.m_age</code>，尽管它们是 <code>Dog</code> 的私有成员。这就是友元类的作用。</li>
<li>我们也展示了尝试直接访问 <code>m_age</code> 会报错，因为 <code>Cat</code> 类本身没有 <code>m_age</code> 这个成员，它必须通过 <code>Dog</code> 对象的引用来访问。</li>
<li>最后，我们通过注释掉的错误代码演示了友元关系的非互惠性：<code>Dog</code> 是 <code>Cat</code> 的友元，不代表 <code>Cat</code> 是 <code>Dog</code> 的友元，所以 <code>Dog</code> 无法访问 <code>Cat</code> 的私有成员。</li>
</ul>
<h2 id="3-QA-闪卡-QA-Flash-Cards"><a href="#3-QA-闪卡-QA-Flash-Cards" class="headerlink" title="3. QA 闪卡 (QA Flash Cards)"></a><strong>3. QA 闪卡 (QA Flash Cards)</strong></h2><ol>
<li><strong>问：什么是友元类（Friend Class）？</strong><ul>
<li><strong>答：</strong> 友元类是一种C++机制，允许一个类（友元类）访问另一个类（被友元类）的私有（<code>private</code>）和保护（<code>protected</code>）成员。</li>
</ul>
</li>
<li><strong>问：为什么我们需要友元类？</strong><ul>
<li><strong>答：</strong> 在需要特定外部类访问本类私有或保护成员，但又不想破坏封装性（即不想将这些成员设为 <code>public</code>）时使用。</li>
</ul>
</li>
<li><strong>问：如何在C++中声明一个友元类？</strong><ul>
<li><strong>答：</strong> 在被授予友元权限的类定义内部，使用 <code>friend class ClassName;</code> 语法进行声明。例如：<code>class MyClass { friend class HelperClass; };</code></li>
</ul>
</li>
<li><strong>问：友元类对被友元类的成员拥有什么样的访问权限？</strong><ul>
<li><strong>答：</strong> 友元类可以访问被友元类的所有成员，包括 <code>private</code>、<code>protected</code> 和 <code>public</code> 成员。</li>
</ul>
</li>
<li><strong>问：友元类是其被友元类的成员吗？它可以直接访问 <code>this</code> 指针吗？</strong><ul>
<li><strong>答：</strong> 不是。友元类不是被友元类的成员。因此，它没有被友元类的 <code>this</code> 指针，不能直接通过 <code>this</code> 访问被友元类的成员。它必须通过一个被友元类的<strong>对象实例</strong>来访问其成员。</li>
</ul>
</li>
<li><strong>问：友元关系是互惠的（reciprocal）吗？</strong><ul>
<li><strong>答：</strong> 不是。友元关系是单向的。如果类A是类B的友元，这不意味着类B也是类A的友元。你需要明确声明双向友元关系（如果需要的话）。</li>
</ul>
</li>
<li><strong>问：友元关系是可传递的（transitive）吗？</strong><ul>
<li><strong>答：</strong> 不是。友元关系不可传递。如果A是B的友元，B是C的友元，这不意味着A是C的友元。</li>
</ul>
</li>
</ol>
<h2 id="4-常见误解或错误"><a href="#4-常见误解或错误" class="headerlink" title="4. 常见误解或错误"></a><strong>4. 常见误解或错误</strong></h2><ol>
<li><strong>误解：友元类是被友元类的一部分或子类。</strong><ul>
<li><strong>纠正：</strong> 友元类与被友元类之间没有继承关系，也不是其内部成员。它们是两个独立的类，友元关系仅仅是授予了访问权限。</li>
</ul>
</li>
<li><strong>错误：在友元类中直接使用被友元类的私有成员名（不通过对象）。</strong><ul>
<li><strong>示例错误：</strong> 在 <code>Cat::print_dog_info</code> 中写 <code>std::cout &lt;&lt; m_age;</code> 而不是 <code>std::cout &lt;&lt; d.m_age;</code></li>
<li><strong>纠正：</strong> 友元类没有被友元类的 <code>this</code> 指针。因此，所有对被友元类私有成员的访问都必须通过一个有效的被友元类<strong>对象</strong>（或引用、指针）来完成。</li>
</ul>
</li>
<li><strong>误解：友元关系是双向的（互惠的）。</strong><ul>
<li><strong>纠正：</strong> 这是最常见的误解之一。友元关系是单向的。如果你希望两个类都能访问对方的私有成员，你需要在<strong>两个类中都</strong>声明对方为友元。</li>
</ul>
</li>
<li><strong>误解：过度使用友元。</strong><ul>
<li><strong>纠正：</strong> 友元机制打破了封装，应该谨慎使用。频繁使用友元可能导致代码紧密耦合，难以维护和扩展。优先考虑公共接口（<code>public</code> 方法），只有当公共接口无法满足需求，且友元是合理且必要的解决方案时才使用。</li>
</ul>
</li>
<li><strong>误解：友元声明的位置影响其作用。</strong><ul>
<li><strong>纠正：</strong> 友元声明（<code>friend class ClassName;</code>）可以放在类的 <code>public</code>、<code>private</code> 或 <code>protected</code> 部分，这并不会改变其作用。友元关系是授予访问权限，与访问限定符无关。通常为了代码可读性，将其放在 <code>public</code> 部分或类的顶部。</li>
</ul>
</li>
</ol>
<h2 id="5-编程练习"><a href="#5-编程练习" class="headerlink" title="5. 编程练习"></a><strong>5. 编程练习</strong></h2><p>现在，是时候让你动手实践一下了！</p>
<p><strong>场景：</strong><br>你正在为一家汽车修理店开发一个系统。<br>有一个 <code>Car</code> 类，它有一些私有成员，例如 <code>m_fuel_level</code>（油量）和 <code>m_engine_status</code>（引擎状态）。<br>你还有一个 <code>Mechanic</code> 类，它的 <code>diagnose_car</code> 方法需要检查 <code>Car</code> 对象的这些私有属性来进行诊断。</p>
<p><strong>任务：</strong><br>请修改下面的代码，在 <code>Car</code> 类中添加必要的友元声明，使得 <code>Mechanic</code> 类的 <code>diagnose_car</code> 方法可以成功访问 <code>Car</code> 类的私有成员 <code>m_fuel_level</code> 和 <code>m_engine_status</code>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请在这里添加 Mechanic 类的前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_model;</span><br><span class="line">    <span class="keyword">int</span> m_fuel_level;    <span class="comment">// 油量 (私有)</span></span><br><span class="line">    <span class="keyword">bool</span> m_engine_status; <span class="comment">// 引擎是否正常 (私有)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car(<span class="built_in">std</span>::<span class="built_in">string</span> model, <span class="keyword">int</span> fuel, <span class="keyword">bool</span> engine_ok)</span><br><span class="line">        : m_model(model), m_fuel_level(fuel), m_engine_status(engine_ok) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car ["</span> &lt;&lt; m_model &lt;&lt; <span class="string">"] created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⭐ 在这里添加友元声明，让 Mechanic 类成为 Car 类的友元</span></span><br><span class="line">    <span class="comment">// 你的代码从这里开始 &gt;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;&lt;&lt; 你的代码到这里结束</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mechanic 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mechanic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mechanic(<span class="built_in">std</span>::<span class="built_in">string</span> name) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Mechanic ["</span> &lt;&lt; name &lt;&lt; <span class="string">"] ready."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 诊断汽车的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">diagnose_car</span><span class="params">(<span class="keyword">const</span> Car&amp; car_obj)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 机械师开始诊断汽车 ("</span> &lt;&lt; car_obj.m_model &lt;&lt; <span class="string">") ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 尝试访问 Car 对象的私有成员</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"油量: "</span> &lt;&lt; car_obj.m_fuel_level &lt;&lt; <span class="string">"%"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"引擎状态: "</span> &lt;&lt; (car_obj.m_engine_status ? <span class="string">"正常"</span> : <span class="string">"故障"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (car_obj.m_fuel_level &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"建议加油！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!car_obj.m_engine_status) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"引擎需要维修！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 诊断结束 ---\n"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">myCar</span><span class="params">(<span class="string">"Tesla Model S"</span>, <span class="number">75</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">Car <span class="title">brokenCar</span><span class="params">(<span class="string">"Ford Focus"</span>, <span class="number">10</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mechanic <span class="title">bob</span><span class="params">(<span class="string">"Bob"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    bob.diagnose_car(myCar);</span><br><span class="line">    bob.diagnose_car(brokenCar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请在上面的代码中补全缺失的部分，使其能够正常编译并运行。完成之后，我会为你评分并提供正确答案和进一步的建议。</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请在这里添加 Mechanic 类的前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_model;</span><br><span class="line">    <span class="keyword">int</span> m_fuel_level;    <span class="comment">// 油量 (私有)</span></span><br><span class="line">    <span class="keyword">bool</span> m_engine_status; <span class="comment">// 引擎是否正常 (私有)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car(<span class="built_in">std</span>::<span class="built_in">string</span> model, <span class="keyword">int</span> fuel, <span class="keyword">bool</span> engine_ok)</span><br><span class="line">        : m_model(model), m_fuel_level(fuel), m_engine_status(engine_ok) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car ["</span> &lt;&lt; m_model &lt;&lt; <span class="string">"] created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⭐ 在这里添加友元声明，让 Mechanic 类成为 Car 类的友元</span></span><br><span class="line">    <span class="comment">// 你的代码从这里开始 &gt;&gt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Mechanic</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;&lt;&lt; 你的代码到这里结束</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mechanic 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mechanic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mechanic(<span class="built_in">std</span>::<span class="built_in">string</span> name) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Mechanic ["</span> &lt;&lt; name &lt;&lt; <span class="string">"] ready."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 诊断汽车的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">diagnose_car</span><span class="params">(<span class="keyword">const</span> Car&amp; car_obj)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 机械师开始诊断汽车 ("</span> &lt;&lt; car_obj.m_model &lt;&lt; <span class="string">") ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 尝试访问 Car 对象的私有成员</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"油量: "</span> &lt;&lt; car_obj.m_fuel_level &lt;&lt; <span class="string">"%"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"引擎状态: "</span> &lt;&lt; (car_obj.m_engine_status ? <span class="string">"正常"</span> : <span class="string">"故障"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (car_obj.m_fuel_level &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"建议加油！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!car_obj.m_engine_status) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"引擎需要维修！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 诊断结束 ---\n"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">myCar</span><span class="params">(<span class="string">"Tesla Model S"</span>, <span class="number">75</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">Car <span class="title">brokenCar</span><span class="params">(<span class="string">"Ford Focus"</span>, <span class="number">10</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mechanic <span class="title">bob</span><span class="params">(<span class="string">"Bob"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    bob.diagnose_car(myCar);</span><br><span class="line">    bob.diagnose_car(brokenCar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，我来为你评估一下你的解决方案，并提供详细的反馈和建议。</p>
<hr>
<h2 id="友元类编程练习：解决方案评估与讲解"><a href="#友元类编程练习：解决方案评估与讲解" class="headerlink" title="友元类编程练习：解决方案评估与讲解"></a><strong>友元类编程练习：解决方案评估与讲解</strong></h2><p><strong>得分：4/5</strong></p>
<p>你的解决方案非常接近正确答案，并且抓住了友元类的核心用法！</p>
<hr>
<h2 id="1-你的解决方案评估"><a href="#1-你的解决方案评估" class="headerlink" title="1. 你的解决方案评估"></a><strong>1. 你的解决方案评估</strong></h2><p>你成功地在 <code>Car</code> 类中添加了 <code>friend class Mechanic;</code> 声明，使得 <code>Mechanic</code> 类能够访问 <code>Car</code> 的私有成员。这正是友元类机制的核心所在。</p>
<p><strong>然而，你遗漏了一个关键点：</strong> 对 <code>Mechanic</code> 类进行<strong>前向声明（Forward Declaration）</strong>。</p>
<p>当你在 <code>Car</code> 类中声明 <code>friend class Mechanic;</code> 时，编译器需要知道 <code>Mechanic</code> 是一个“类”类型。虽然 <code>Mechanic</code> 类稍后会被完整定义，但在 <code>Car</code> 类的定义处，编译器如果在此之前没有看到 <code>Mechanic</code> 的任何声明，它会报错，因为它不知道 <code>Mechanic</code> 到底是个什么东西（是类、函数还是变量？）。</p>
<p>所以，在 <code>Car</code> 类定义之前，需要先 <code>class Mechanic;</code> 告诉编译器：“嘿，<code>Mechanic</code> 是一个类，你后面会看到它的完整定义。”</p>
<hr>
<h2 id="2-正确答案及解释"><a href="#2-正确答案及解释" class="headerlink" title="2. 正确答案及解释"></a><strong>2. 正确答案及解释</strong></h2><p>以下是完整的正确代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ⭐ 正确答案：在这里添加 Mechanic 类的前向声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mechanic</span>;</span> <span class="comment">// 告诉编译器 Mechanic 是一个类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Car 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_model;</span><br><span class="line">    <span class="keyword">int</span> m_fuel_level;    <span class="comment">// 油量 (私有)</span></span><br><span class="line">    <span class="keyword">bool</span> m_engine_status; <span class="comment">// 引擎是否正常 (私有)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Car(<span class="built_in">std</span>::<span class="built_in">string</span> model, <span class="keyword">int</span> fuel, <span class="keyword">bool</span> engine_ok)</span><br><span class="line">        : m_model(model), m_fuel_level(fuel), m_engine_status(engine_ok) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Car ["</span> &lt;&lt; m_model &lt;&lt; <span class="string">"] created."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⭐ 正确答案：在这里添加友元声明，让 Mechanic 类成为 Car 类的友元</span></span><br><span class="line">    <span class="comment">// 你的代码从这里开始 &gt;&gt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Mechanic</span>;</span> <span class="comment">// 声明 Mechanic 类是 Car 的友元</span></span><br><span class="line">    <span class="comment">// &lt;&lt;&lt; 你的代码到这里结束</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mechanic 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mechanic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mechanic(<span class="built_in">std</span>::<span class="built_in">string</span> name) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Mechanic ["</span> &lt;&lt; name &lt;&lt; <span class="string">"] ready."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 诊断汽车的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">diagnose_car</span><span class="params">(<span class="keyword">const</span> Car&amp; car_obj)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 机械师开始诊断汽车 ("</span> &lt;&lt; car_obj.m_model &lt;&lt; <span class="string">") ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 尝试访问 Car 对象的私有成员</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"油量: "</span> &lt;&lt; car_obj.m_fuel_level &lt;&lt; <span class="string">"%"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 成功访问</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"引擎状态: "</span> &lt;&lt; (car_obj.m_engine_status ? <span class="string">"正常"</span> : <span class="string">"故障"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 成功访问</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (car_obj.m_fuel_level &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"建议加油！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!car_obj.m_engine_status) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"引擎需要维修！"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 诊断结束 ---\n"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">myCar</span><span class="params">(<span class="string">"Tesla Model S"</span>, <span class="number">75</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">Car <span class="title">brokenCar</span><span class="params">(<span class="string">"Ford Focus"</span>, <span class="number">10</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mechanic <span class="title">bob</span><span class="params">(<span class="string">"Bob"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    bob.diagnose_car(myCar);</span><br><span class="line">    bob.diagnose_car(brokenCar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>详细解释：</strong></p>
<ol>
<li><strong><code>class Mechanic;</code> (前向声明)</strong>：<ul>
<li>在 <code>Car</code> 类定义之前，我们添加了 <code>class Mechanic;</code>。这被称为<strong>前向声明（Forward Declaration）</strong>。</li>
<li>它的作用是告诉编译器，<code>Mechanic</code> 是一个类类型，但此时不需要知道它的完整定义（例如它有哪些成员函数或变量）。这对于解决循环依赖或当一个类只需要知道另一个类的存在但不需要其完整细节时非常有用。</li>
<li>在本例中，<code>Car</code> 类中的 <code>friend class Mechanic;</code> 声明仅仅需要知道 <code>Mechanic</code> 是一个类，因此前向声明足够了。</li>
</ul>
</li>
<li><strong><code>friend class Mechanic;</code> (友元声明)</strong>：<ul>
<li>这行代码在 <code>Car</code> 类的内部，明确地声明 <code>Mechanic</code> 类是 <code>Car</code> 类的友元。</li>
<li>一旦声明，<code>Mechanic</code> 类的所有成员函数（例如 <code>diagnose_car</code>）就获得了访问 <code>Car</code> 对象的私有成员 (<code>m_fuel_level</code>, <code>m_engine_status</code>) 的权限。</li>
<li>请注意，友元声明的位置（在 <code>public</code>, <code>private</code>, <code>protected</code> 区域）对友元权限没有任何影响。通常，为了清晰和约定俗成，我们将其放在 <code>public</code> 区域或类的最开始。</li>
</ul>
</li>
<li><strong><code>Mechanic::diagnose_car(const Car&amp; car_obj)</code> 函数内部</strong>：<ul>
<li>由于 <code>Mechanic</code> 现在是 <code>Car</code> 的友元，<code>diagnose_car</code> 函数可以直接通过传入的 <code>Car</code> 对象引用 <code>car_obj</code> 来访问 <code>car_obj.m_fuel_level</code> 和 <code>car_obj.m_engine_status</code>。</li>
<li>如果 <code>Mechanic</code> 不是 <code>Car</code> 的友元，或者 <code>m_fuel_level</code> 和 <code>m_engine_status</code> 是 <code>private</code> 的，那么这两行访问将导致编译错误。</li>
</ul>
</li>
</ol>
<p>当你运行这段代码时，你会看到它成功编译并输出预期的诊断信息，证明 <code>Mechanic</code> 确实访问了 <code>Car</code> 的私有成员。</p>
<hr>
<h2 id="3-建议和扩展问题"><a href="#3-建议和扩展问题" class="headerlink" title="3. 建议和扩展问题"></a><strong>3. 建议和扩展问题</strong></h2><p>你对友元类的基本概念和用法掌握得很好。为了更深入地理解和应用，我建议你进一步思考以下问题：</p>
<ol>
<li><strong>友元函数与友元类：</strong><ul>
<li>除了友元类，C++还有<strong>友元函数（Friend Functions）</strong>。它们有什么区别？在什么情况下你会选择使用友元函数而不是友元类？</li>
<li>思考：一个非成员函数可以被声明为某个类的友元吗？如果是，语法是怎样的？</li>
</ul>
</li>
<li><strong>友元的粒度控制：</strong><ul>
<li>友元类赋予了对目标类所有私有/保护成员的完全访问权限。如果你只想让一个外部类的<strong>某个特定函数</strong>访问你的私有成员，而不是整个类，该如何实现？（提示：考虑友元函数）</li>
</ul>
</li>
<li><strong>友元的利弊：</strong><ul>
<li>请列举友元机制的<strong>优点</strong>和<strong>缺点</strong>。你认为在实际项目中，使用友元机制时需要注意哪些方面？</li>
<li>友元是否总是“打破封装”的坏事？有没有一些设计模式或场景下，友元是“必要之恶”甚至是一种优雅的解决方案？</li>
</ul>
</li>
<li><strong>实际案例思考：</strong><ul>
<li>除了本例中的“诊断工具”和“序列化器”之外，你还能想到哪些C++标准库中或常见的实际应用场景，可能会用到友元机制？例如，<code>std::ostream</code> 的 <code>operator&lt;&lt;</code> 重载函数通常是如何实现的？</li>
</ul>
</li>
<li><strong>替代方案：</strong><ul>
<li>如果不用友元类，还有哪些其他方法可以实现类似的功能（即让外部代码获取私有成员信息）？比较它们的优缺点，比如公共的 <code>getter</code> 方法。</li>
<li>在面向对象设计中，通常会更倾向于使用哪种方式来共享数据？为什么？</li>
</ul>
</li>
</ol>
<p>希望这些问题能帮助你更全面、深入地理解C++中的友元机制！</p>
<hr>
<h2 id="🧑‍💻-User-2"><a href="#🧑‍💻-User-2" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>为什么我没前向声明还是编译过了？</p>
<hr>
<h2 id="🤖-Assistant-2"><a href="#🤖-Assistant-2" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>这是一个非常好的问题！你的观察非常敏锐，并且触及到了C++标准中一个有趣的细节。</p>
<p>你没有添加 <code>class Mechanic;</code> 这行前向声明，但代码仍然编译通过了，这是因为：</p>
<p><strong>在C++标准中，当你在一个类的 <code>friend class OtherClass;</code> 友元声明中首次提到 <code>OtherClass</code> 时，如果 <code>OtherClass</code> 在此之前从未被声明过，那么这个 <code>friend</code> 声明本身就</strong>隐含地（implicitly）<strong>起到了</strong>前向声明（Forward Declaration）<strong>的作用。</strong></p>
<p>也就是说，这行代码：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Mechanic</span>;</span></span><br></pre></td></tr></table></figure></div><br>实际上等同于：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mechanic</span>;</span> <span class="comment">// 隐含的前向声明</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Mechanic</span>;</span> <span class="comment">// 友元声明</span></span><br></pre></td></tr></table></figure></div></p>
<p><strong>为什么会这样？</strong></p>
<p>这是C++标准为了方便性而允许的一种特殊语法。它简化了当你声明一个友元类时，如果该友元类尚未被定义，你不需要额外写一行 <code>class MyFriendClass;</code>。</p>
<p><strong>但是，请注意以下几点：</strong></p>
<ol>
<li><p><strong>仅限于 <code>friend class</code> 声明：</strong> 这种隐含的前向声明只发生在 <code>friend class ClassName;</code> 这种形式的友元声明中。如果你在其他地方（比如，作为成员变量类型、函数参数类型或返回类型）使用一个尚未被完整定义的类，你仍然需要显式地进行前向声明。</p>
<p><strong>错误示例 (没有显式前向声明的情况下)：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设没有 class Mechanic;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    Mechanic* my_mechanic; <span class="comment">// ❌ 编译错误：Mechanic 类型未知</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Mechanic</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，<code>Mechanic* my_mechanic;</code> 这行就会报错，因为它不是 <code>friend class</code> 声明，编译器需要知道 <code>Mechanic</code> 是一个类类型才能声明指针。</p>
</li>
<li><p><strong>良好的编程习惯：</strong> 尽管编译器允许这种隐含的前向声明，但在实际项目中，显式地写出 <code>class Mechanic;</code> 仍然是一个<strong>更好的编程习惯</strong>。</p>
<ul>
<li><strong>可读性：</strong> 它让代码意图更清晰，一眼就能看出 <code>Mechanic</code> 是一个类。</li>
<li><strong>避免混淆：</strong> 可以避免潜在的混淆，尤其是在更复杂的代码库中，当一个类名可能被误解为其他实体时。</li>
<li><strong>通用性：</strong> 保持了代码的一致性，无论你在哪里首次使用一个尚未完整定义的类，都习惯性地进行前向声明。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>你的代码能够编译通过，是因为C++标准允许 <code>friend class SomeClass;</code> 在 <code>SomeClass</code> 未被声明时，兼具前向声明的功能。</p>
<p>但是，为了代码的清晰度和可维护性，特别是作为C++初学者，我仍然强烈建议你养成<strong>显式进行前向声明</strong>的好习惯，就像我在正确答案中展示的那样。</p>
<hr>
<h2 id="8-进一步的调查问题"><a href="#8-进一步的调查问题" class="headerlink" title="8. 进一步的调查问题"></a><strong>8. 进一步的调查问题</strong></h2><p>既然你对这个细节产生了疑问，说明你已经开始深入思考C++的编译过程了，非常好！以下是一些可以进一步调查的问题，帮助你理解更多：</p>
<ol>
<li><strong>编译过程中的类型信息：</strong><ul>
<li>编译器在处理C++代码时，是如何逐步收集和理解类型信息的？“声明”和“定义”对于编译器意味着什么？</li>
<li>为什么函数声明（<code>void func();</code>）不需要知道函数体的实现，而类成员变量（<code>MyClass obj;</code>）却需要知道 <code>MyClass</code> 的完整定义？</li>
</ul>
</li>
<li><strong>友元声明的特殊性：</strong><ul>
<li>为什么标准会允许 <code>friend class</code> 这种特殊的隐含前向声明，而不是对所有类型引用都要求显式前向声明？这种设计决策背后的原因可能是什么？</li>
</ul>
</li>
<li><strong>循环依赖问题：</strong><ul>
<li>在两个类需要相互引用对方的私有成员，或者相互作为成员变量时，前向声明是如何解决<strong>循环依赖（Circular Dependencies）</strong>问题的？请举一个简短的例子说明。</li>
</ul>
</li>
<li><strong><code>#include</code> 与前向声明：</strong><ul>
<li>什么时候应该使用 <code>#include</code> 来包含头文件，什么时候只需要使用前向声明？它们的优缺点分别是什么？</li>
<li>包含头文件对编译时间有什么影响？前向声明如何帮助优化编译时间？</li>
</ul>
</li>
<li><strong>C++标准演变：</strong><ul>
<li>这种关于 <code>friend class</code> 隐含前向声明的规则在C++的不同标准版本中是否有过变化？（例如，C++98、C++11、C++17等）这可能需要查阅C++标准的文档或权威的C++资源。</li>
</ul>
</li>
</ol>
<p>通过思考和查阅这些问题，你将对C++的编译模型、类型系统以及如何编写更高效、更健壮的代码有更深刻的理解。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Tutorial/">Tutorial    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/312%20-%20cpp%20%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>312 - cpp 友元函数详解</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/318%20-%20inline%20static%20variable/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>318 - inline static variable</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/282 - cpp结构体与类的区别和用法/" title="282 - cpp结构体与类的区别和用法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">282 - cpp结构体与类的区别和用法</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/318 - inline static variable/" title="318 - inline static variable"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">318 - inline static variable</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/329 - 跨文件命名空间/" title="329 - 跨文件命名空间"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">329 - 跨文件命名空间</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/317 - cpp 类级别数据/" title="317 - cpp 类级别数据"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">317 - cpp 类级别数据</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/diff between constexpr and define/" title="diff between constexpr and define"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">diff between constexpr and define</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/静态成员访问控制/" title="静态成员访问控制"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">静态成员访问控制</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>