<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>333 - 匿名命名空间文件私有 | Bear's dream</title><meta name="description" content="333 - 匿名命名空间文件私有"><meta name="keywords" content="Coding,Cpp,Tutorial,Development,Developer"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="333 - 匿名命名空间文件私有"><meta name="twitter:description" content="333 - 匿名命名空间文件私有"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="333 - 匿名命名空间文件私有"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/333%20-%20%E5%8C%BF%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6%E7%A7%81%E6%9C%89/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="333 - 匿名命名空间文件私有"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/333%20-%20%E5%8C%BF%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6%E7%A7%81%E6%9C%89/"><link rel="prev" title="329 - 跨文件命名空间" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/329%20-%20%E8%B7%A8%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"><link rel="next" title="332 - cpp using声明命名空间冲突" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/332%20-%20cpp%20using%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%86%B2%E7%AA%81/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#333-匿名命名空间文件私有"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">333 - 匿名命名空间文件私有</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#深入理解C-匿名命名空间：文件私有化的利器"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">深入理解C++匿名命名空间：文件私有化的利器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-什么是匿名命名空间？"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">1. 什么是匿名命名空间？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-编译器如何处理匿名命名空间？"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">2. 编译器如何处理匿名命名空间？</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-1-内部命名生成-Internal-Name-Generation"><span class="toc_mobile_items-number">1.3.2.1.</span> <span class="toc_mobile_items-text">2.1 内部命名生成 (Internal Name Generation)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-2-作用域限制：内部链接-Internal-Linkage"><span class="toc_mobile_items-number">1.3.2.2.</span> <span class="toc_mobile_items-text">2.2 作用域限制：内部链接 (Internal Linkage)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-3-同一翻译单元内的多个匿名命名空间块"><span class="toc_mobile_items-number">1.3.2.3.</span> <span class="toc_mobile_items-text">2.3 同一翻译单元内的多个匿名命名空间块</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-为什么使用匿名命名空间？及其与-static-关键字的联系"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">3. 为什么使用匿名命名空间？及其与 static 关键字的联系</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#3-1-替代-static-关键字实现内部链接"><span class="toc_mobile_items-number">1.3.3.1.</span> <span class="toc_mobile_items-text">3.1 替代 static 关键字实现内部链接</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#3-2-避免污染全局命名空间-Avoiding-Global-Namespace-Pollution"><span class="toc_mobile_items-number">1.3.3.2.</span> <span class="toc_mobile_items-text">3.2 避免污染全局命名空间 (Avoiding Global Namespace Pollution)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-代码示例"><span class="toc_mobile_items-number">1.3.4.</span> <span class="toc_mobile_items-text">4. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-QA-闪卡-Flash-Cards"><span class="toc_mobile_items-number">1.3.5.</span> <span class="toc_mobile_items-text">5. QA 闪卡 (Flash Cards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-常见误解与错误-Common-Misunderstandings-or-Mistakes"><span class="toc_mobile_items-number">1.3.6.</span> <span class="toc_mobile_items-text">6. 常见误解与错误 (Common Misunderstandings or Mistakes)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-编程练习-Coding-Exercise"><span class="toc_mobile_items-number">1.3.7.</span> <span class="toc_mobile_items-text">7. 编程练习 (Coding Exercise)</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#333-匿名命名空间文件私有"><span class="toc-number">1.</span> <span class="toc-text">333 - 匿名命名空间文件私有</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深入理解C-匿名命名空间：文件私有化的利器"><span class="toc-number">1.3.</span> <span class="toc-text">深入理解C++匿名命名空间：文件私有化的利器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-什么是匿名命名空间？"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 什么是匿名命名空间？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-编译器如何处理匿名命名空间？"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 编译器如何处理匿名命名空间？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-内部命名生成-Internal-Name-Generation"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">2.1 内部命名生成 (Internal Name Generation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-作用域限制：内部链接-Internal-Linkage"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2.2 作用域限制：内部链接 (Internal Linkage)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-同一翻译单元内的多个匿名命名空间块"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">2.3 同一翻译单元内的多个匿名命名空间块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-为什么使用匿名命名空间？及其与-static-关键字的联系"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 为什么使用匿名命名空间？及其与 static 关键字的联系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-替代-static-关键字实现内部链接"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.1 替代 static 关键字实现内部链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-避免污染全局命名空间-Avoiding-Global-Namespace-Pollution"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.2 避免污染全局命名空间 (Avoiding Global Namespace Pollution)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-代码示例"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-QA-闪卡-Flash-Cards"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. QA 闪卡 (Flash Cards)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-常见误解与错误-Common-Misunderstandings-or-Mistakes"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 常见误解与错误 (Common Misunderstandings or Mistakes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-编程练习-Coding-Exercise"><span class="toc-number">1.3.7.</span> <span class="toc-text">7. 编程练习 (Coding Exercise)</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">333 - 匿名命名空间文件私有</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/333%20-%20%E5%8C%BF%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6%E7%A7%81%E6%9C%89/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/333%20-%20%E5%8C%BF%E5%90%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6%E7%A7%81%E6%9C%89/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="333-匿名命名空间文件私有"><a href="#333-匿名命名空间文件私有" class="headerlink" title="333 - 匿名命名空间文件私有"></a>333 - 匿名命名空间文件私有</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about anonymous namespaces.And these are namespaces that don’t have explicit names in our code.And here is a simple example of how you can do that.You just say namespace.You say the curly braces here, but you don’t specify the name for the namespace.And the things we have inside our namespace here are going to be accessible without specifying the namespacename.As you see here, for example, we can call this add function here and we’re going to have access tothis.If you have multiple declarations for an anonymous namespace like we have here, for example, we haveone on top and we have another below the main function.These are not going to be separate namespaces.They are going to be the same namespace.But what we have below is just going to be an extension of the namespace we have on top here.So note that they are not going to be different namespaces and because they are basically the same namespace,we have a declaration on top and we have a definition for our add function in the namespace below here.But anonymous namespaces have a few things you need to be aware of and we’re going to look at them here.The first is that when the compiler sees an anonymous namespace declared in your code, it is goingto generate an internal name for your namespace.So what is going to happen is basically something like this in file one dot cpp we have a namespacewhich is anonymous in file two.We also have an anonymous namespace.What the compiler is going to do behind the scenes is to generate names for these namespaces.So for example, for file one here, we might have a namespace like this.For file two, we might have a namespace like this, but one thing you should know is that you don’thave access to these names here.These are for use by the compiler and a direct consequence of this is that anonymous namespaces canonly be used in the translation units where they are declared.Or to say this.In other words, things you declare in an anonymous namespaces are only going to be usable in the translationunit where they were declared, and you should really know this.And we’re going to see an example of this in a minute when we hit Visual Studio code.But you should really keep this clear in your mind.Okay.The generated unique namespace name is not accessible to you, the developer, so you can’t use thatname.It is for use by the compiler and there can only be one anonymous namespace for a single translationunit.If you set up multiple anonymous namespaces blocks, they just be extensions for the first one.And we have talked about this.Anonymous namespaces in different translation units are completely separate and the compiler is justgoing to generate different namespaces for these guys.And because you don’t have access to the compiler generated namespace, the things you declare insidethe namespace are only going to be accessible in the translation unit where they were declared.This is what we just said, but I really want you to keep this in mind.Okay?We have seen the syntax to declare anonymous namespaces and we know that names inside an anonymous namespaceare only going to be reachable and usable from the translation unit where they were declared.And it is time we headed over to Visual Studio Code and played with us a little more.Okay, here we are in our working folder.The current project is Anonymous Namespaces.We’re going to grab our template files, we’re going to put them in place.Let’s do that.And we’re going to open this little guy in Visual Studio code by dragging and dropping here, and we’regoing to have our main.cpp file.We can close the left sidebar.We don’t need that anymore.And we’re going to play a little bit.We’re going to set up another function, double add.It’s going to add up two parameters, double A and double B, and this function is going to live insidean anonymous namespace.So we’re going to say namespace and we’re not going to specify the name for this namespace.We’re just going to say namespace here.I think we can bring this guy to the top.That’s what I like and we’re going to bring this inside our namespace here and this is the syntax foran anonymous namespace.You say namespace, you don’t specify the name and you put your curly braces and you put whatever youwant to put inside your namespace.Here.In this case, we are putting in the declaration for our Add function.We can also put the definition of this little guy below the main function and it is going to live insidethe namespace here.But this is going to be a definition.So we’re going to put a.A pair of curly braces and we’re going to return A plus B, because that’s what we want to do here.Now, how do we call this function?We know it is living inside the namespace.The compiler is going to generate a name for this namespace, but we don’t have access to that name.To call this function.All we have to do is say Add, let’s do double result equals Add and say 10.1 and 20.2.We can do that and we’re going to see what we get from the compiler.Let’s put a semicolon there and we can print the result out.We can say Stdcout result and we’re going to say result here.Okay, so what do we get?Let’s try and build this program we’re going to build successfully.We can clear and run Rooster by bringing up a terminal here.Let’s bring up a terminal and we’re going to clear and run Rooster.We’re going to see that the result is going to be what we expect, 30.4.So what this is really doing, it’s making this function behave as if it was declared in the globalnamespace because we are able to call it like this.So but that magic is going to be done by the compiler to make this function accessible here.But one thing you should know is that once you declare inside, anonymous namespaces like this are onlygoing to be usable in the translation unit where they were declared.And that’s really important to bring this point home.I am going to add another translation unit, maybe called this some other file.Why not?And it’s going to be a CPP file and we’re going to set up an anonymous namespace with a definition forthis function here.We can copy this and comment this out.To take this out of the main CPP file and we’re going to paste that little guy here.And we note that when the compiler sees a call to this function, it is going to see a declaration insidethis namespace.So this is going to compile.But once we hit the link stage, the linker is going to look for the definition of this function.It’s going to look in this translation unit.It’s not going to find it.It’s going to look in this translation unit, it’s going to see this Add function.This is a definition, but this definition is only accessible from the translation unit where it isdefined.And this happens to be a separate translation unit.So the compiler is not going to find this.This is only usable in some other file translation unit.So this is not going to work and we are going to get a linker error.Let’s try and build this because I want you to see this.We’re going to run the task to build with GCC and the world should fail.You’re going to see build finished with errors and we have an undefined reference to add double, whichis living in an anonymous namespace.So you really should see this.And this is a problem.This should prove that things that you declare inside anonymous namespaces are only usable and accessiblefrom the translation unit where they were declared.The function we have here is only usable in this translation unit.If we go down here and, for example, say void, do something and we go inside and call, add and specifyone and two, for example.So if this function was declared in the main function like we did before, this should work just finebecause now we are trying to use this function from the translation unit where it was declared and definedhere.If we do this, you’re going to see that this is going to work.Let’s build again to make sure this works.We have no typo.This is building successfully.We can clear and run Rooster and this is working just fine.This is really all I had to share in this lecture, showing you the syntax you can use to set up anonymousnamespaces.Please note that the compiler is going to generate a name for this namespaces, but the name is notgoing to be accessible to you in your code.A direct consequence of that is that things you declare inside your anonymous namespace are going tobe only usable and reachable from the translation unit where you declare them and they are going tobe accessible because the compiler is going to do some magic and make them feel like they were declaredin the global namespace.And we can access these names directly without using a namespace prefix like we have been doing before.We are going to stop here in this lecture and the next one we’re going to learn about nesting.Namespaces.Go ahead and finish up here and meet me there.、</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，欢迎来到C++学习之旅！作为您的C++专业开发导师，我将尽我所能，用最清晰、最易懂的方式，带您深入了解C++中一个非常重要的概念——<strong>匿名命名空间 (Anonymous Namespaces)</strong>。</p>
<hr>
<h2 id="深入理解C-匿名命名空间：文件私有化的利器"><a href="#深入理解C-匿名命名空间：文件私有化的利器" class="headerlink" title="深入理解C++匿名命名空间：文件私有化的利器"></a><strong>深入理解C++匿名命名空间：文件私有化的利器</strong></h2><p><strong>核心总结：</strong> 本节课将详细介绍C++中<strong>匿名命名空间 (Anonymous Namespaces)</strong> 的定义、语法、工作原理及其核心特性——<strong>文件内作用域 (translation unit scope)</strong>。我们将理解它为何是实现<strong>内部链接 (internal linkage)</strong> 的现代C++方式，并探讨它与传统<code>static</code>关键字的区别与联系，以及如何避免常见的误解和错误。</p>
<hr>
<h3 id="1-什么是匿名命名空间？"><a href="#1-什么是匿名命名空间？" class="headerlink" title="1. 什么是匿名命名空间？"></a><strong>1. 什么是匿名命名空间？</strong></h3><p>匿名命名空间，顾名思义，就是<strong>没有显式名字 (explicit names)</strong> 的命名空间。它的语法非常简单，就像一个普通的命名空间声明，只是在<code>namespace</code>关键字后面没有跟着任何名字：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// 这就是一个匿名命名空间</span></span><br><span class="line">    <span class="comment">// 在这里声明或定义你的变量、函数、类等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>作用：</strong> 匿名命名空间的主要作用是将其内部声明或定义的所有实体（如变量、函数、类、枚举等）的作用域限制在当前的<strong>翻译单元 (translation unit)</strong> 内。一个翻译单元通常指一个<code>.cpp</code>源文件及其通过<code>#include</code>指令包含的所有头文件经过预处理后的结果。</p>
<p><strong>访问方式：</strong> 有趣的是，虽然它没有名字，但您可以在当前翻译单元内直接访问其内部的成员，不需要使用任何命名空间前缀。这使得它们看起来像是位于<strong>全局命名空间 (global namespace)</strong> 中，但实际上，它们的作用域被严格限制在当前文件内部。</p>
<h3 id="2-编译器如何处理匿名命名空间？"><a href="#2-编译器如何处理匿名命名空间？" class="headerlink" title="2. 编译器如何处理匿名命名空间？"></a><strong>2. 编译器如何处理匿名命名空间？</strong></h3><p>理解匿名命名空间的关键在于理解编译器在幕后是如何处理它们的。</p>
<h4 id="2-1-内部命名生成-Internal-Name-Generation"><a href="#2-1-内部命名生成-Internal-Name-Generation" class="headerlink" title="2.1 内部命名生成 (Internal Name Generation)"></a><strong>2.1 内部命名生成 (Internal Name Generation)</strong></h4><p>当<strong>编译器 (compiler)</strong> 遇到一个匿名命名空间时，它会为这个命名空间生成一个<strong>唯一 (unique)</strong> 的、对开发者<strong>不可访问 (inaccessible)</strong> 的内部名字。例如，如果您的<code>file1.cpp</code>中有一个匿名命名空间，编译器可能会在内部将其视为一个名为<code>__unique_id_for_file1</code>的命名空间。而<code>file2.cpp</code>中的匿名命名空间则会得到另一个完全不同的内部名字，比如<code>__unique_id_for_file2</code>。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 file1.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// 编译器内部可能处理为：namespace __some_unique_id_123A_ &#123; ... &#125;</span></span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper_func</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 file2.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// 编译器内部可能处理为：namespace __another_unique_id_456B_ &#123; ... &#125;</span></span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">// 这个 counter 和 file1.cpp 里的 counter 是完全独立的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper_func</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 这个 helper_func 和 file1.cpp 里的 helper_func 也是完全独立的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>关键点：</strong> 您无法在代码中直接使用这些编译器生成的内部名字。</p>
<h4 id="2-2-作用域限制：内部链接-Internal-Linkage"><a href="#2-2-作用域限制：内部链接-Internal-Linkage" class="headerlink" title="2.2 作用域限制：内部链接 (Internal Linkage)"></a><strong>2.2 作用域限制：内部链接 (Internal Linkage)</strong></h4><p>由于编译器为每个翻译单元中的匿名命名空间生成了独有的、不可访问的内部名字，这就导致了匿名命名空间中声明的实体具有<strong>内部链接 (internal linkage)</strong>。</p>
<p><strong>内部链接意味着什么？</strong></p>
<ul>
<li><strong>私有化：</strong> 这些实体只在它们被定义和声明的那个翻译单元内是可见和可用的。</li>
<li><strong>隔离性：</strong> 它们不会被<strong>链接器 (linker)</strong> 在多个翻译单元之间共享。即使不同文件有同名的函数或变量，只要它们在各自的匿名命名空间内，就不会产生冲突，因为链接器会将它们视为完全不同的实体（因为它们属于不同的内部命名空间）。</li>
</ul>
<p>这是匿名命名空间与普通命名空间最本质的区别。普通命名空间中的实体默认具有外部链接，可以被其他翻译单元访问（只要声明可见）。</p>
<h4 id="2-3-同一翻译单元内的多个匿名命名空间块"><a href="#2-3-同一翻译单元内的多个匿名命名空间块" class="headerlink" title="2.3 同一翻译单元内的多个匿名命名空间块"></a><strong>2.3 同一翻译单元内的多个匿名命名空间块</strong></h4><p>在一个翻译单元（<code>.cpp</code>文件）内部，您可以声明多个匿名命名空间块。需要注意的是，<strong>这些块并不会创建多个独立的匿名命名空间</strong>。相反，它们都是对<strong>同一个</strong>、由编译器为该翻译单元生成的那个匿名命名空间的<strong>扩展 (extension)</strong>。</p>
<p>这意味着，您可以在第一个匿名命名空间块中声明一个函数，然后在同一个文件中的另一个匿名命名空间块中为它提供<strong>定义 (definition)</strong>，就像操作普通命名空间一样：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// 第一个匿名命名空间块</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span></span>; <span class="comment">// 声明 (declaration)</span></span><br><span class="line">    <span class="keyword">int</span> file_private_data = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... main 函数或其他代码 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// 第二个匿名命名空间块 (是前一个的扩展)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123; <span class="comment">// 定义</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Doing something and accessing private data: "</span> &lt;&lt; file_private_data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="3-为什么使用匿名命名空间？及其与-static-关键字的联系"><a href="#3-为什么使用匿名命名空间？及其与-static-关键字的联系" class="headerlink" title="3. 为什么使用匿名命名空间？及其与 static 关键字的联系"></a><strong>3. 为什么使用匿名命名空间？及其与 <code>static</code> 关键字的联系</strong></h3><p>匿名命名空间是现代C++中非常推荐的特性，主要用于实现以下目标：</p>
<h4 id="3-1-替代-static-关键字实现内部链接"><a href="#3-1-替代-static-关键字实现内部链接" class="headerlink" title="3.1 替代 static 关键字实现内部链接"></a><strong>3.1 替代 <code>static</code> 关键字实现内部链接</strong></h4><p>在C++11之前，为了让一个全局变量或函数只在当前文件可见（即具有内部链接），我们通常会使用<code>static</code>关键字：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old_style_module.cpp</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_global_counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s_private_helper</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></div>
<p>然而，<code>static</code>关键字在C++中有多种含义（例如，用于类成员、局部变量、全局/文件作用域），这有时会引起混淆。</p>
<p><strong>匿名命名空间是C++标准推荐的替代方案</strong>，它更清晰地表达了“这个实体只在当前翻译单元内可见”的意图，并且可以应用于更广泛的实体类型（包括类、枚举等）。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modern_module.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> file_private_counter = <span class="number">0</span>; <span class="comment">// 具有内部链接的变量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">file_private_helper</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 具有内部链接的函数</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FilePrivateClass</span> &#123;</span> <span class="comment">/* ... */</span> &#125;; <span class="comment">// 具有内部链接的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>使用匿名命名空间的好处是：</p>
<ul>
<li><strong>语义清晰：</strong> 明确表达了文件私有化的意图。</li>
<li><strong>避免名称冲突：</strong> 即使其他翻译单元定义了同名的全局变量或函数，也不会发生冲突。</li>
<li><strong>可应用于所有实体：</strong> 不仅限于变量和函数，还可以用于类、结构体、枚举等。</li>
</ul>
<h4 id="3-2-避免污染全局命名空间-Avoiding-Global-Namespace-Pollution"><a href="#3-2-避免污染全局命名空间-Avoiding-Global-Namespace-Pollution" class="headerlink" title="3.2 避免污染全局命名空间 (Avoiding Global Namespace Pollution)"></a><strong>3.2 避免污染全局命名空间 (Avoiding Global Namespace Pollution)</strong></h4><p>尽管匿名命名空间中的内容可以直接访问，看起来像是在<strong>全局命名空间 (global namespace)</strong> 中，但从链接的角度看，它们是被隔离的。这有助于保持全局命名空间的整洁，减少名称冲突的可能性。</p>
<h3 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a><strong>4. 代码示例</strong></h3><p>让我们通过代码示例来具体理解匿名命名空间的使用和特性。</p>
<p><strong>项目结构：</strong></p>
<ul>
<li><code>main.cpp</code></li>
<li><code>some_other_file.cpp</code></li>
</ul>
<p><strong><code>main.cpp</code> 文件：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名命名空间块 1：包含 Add 函数的声明</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>; <span class="comment">// 声明 Add 函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> MODULE_NAME = <span class="string">"MainModule"</span>; <span class="comment">// 声明一个文件私有常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"模块名称: "</span> &lt;&lt; MODULE_NAME &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 可以直接访问 MODULE_NAME</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接调用 Add 函数，无需命名空间前缀</span></span><br><span class="line">    <span class="keyword">double</span> result = Add(<span class="number">10.1</span>, <span class="number">20.2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Add(10.1, 20.2) = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试调用 some_other_file.cpp 中的 do_something</span></span><br><span class="line">    <span class="comment">// 理论上 do_something 应该在 some_other_file.cpp 中调用其内部的 Add</span></span><br><span class="line">    <span class="comment">// 这里我们无法直接调用 some_other_file.cpp 内部的 Add 函数</span></span><br><span class="line">    <span class="comment">// 但可以尝试声明一个外部函数（如果 some_other_file.cpp 暴露了它）</span></span><br><span class="line">    <span class="comment">// extern void call_add_from_other_file(); // 假设 some_other_file.cpp 有一个这个函数</span></span><br><span class="line">    <span class="comment">// call_add_from_other_file(); // 如果 some_other_file.cpp 提供了这个，我们可以调用它来间接触发</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名命名空间块 2：为 Add 函数提供定义</span></span><br><span class="line"><span class="comment">// 这是对上面匿名命名空间的扩展</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123; <span class="comment">// 定义 Add 函数</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><code>some_other_file.cpp</code> 文件：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some_other_file.cpp 的匿名命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123; <span class="comment">// 这个 Add 和 main.cpp 中的 Add 是完全独立的</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"在 some_other_file.cpp 的匿名命名空间中调用 Add 函数."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b + <span class="number">1.0</span>; <span class="comment">// 加一个 1.0 以示区别</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_something_internal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"在 some_other_file.cpp 内部调用 Add(1, 2): "</span>;</span><br><span class="line">        <span class="keyword">double</span> res = Add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 成功调用本文件匿名命名空间中的 Add</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数是外部可见的，它会调用当前文件内部的匿名命名空间成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_add_from_other_file</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"从 some_other_file.cpp 的外部可见函数中调用 do_something_internal()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    do_something_internal(); <span class="comment">// 可以在本文件内访问匿名命名空间中的 do_something_internal</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：如果 main.cpp 尝试直接调用 some_other_file.cpp 里的 Add 函数（例如通过 extern double Add(double, double);）</span></span><br><span class="line"><span class="comment">// 链接器会报错，因为 some_other_file.cpp 里的 Add 具有内部链接，无法被外部链接。</span></span><br></pre></td></tr></table></figure></div>
<p><strong>编译和链接演示：</strong></p>
<ol>
<li><p><strong>单独编译 <code>main.cpp</code> 和 <code>some_other_file.cpp</code>：</strong></p>
<ul>
<li><code>g++ -c main.cpp -o main.o</code></li>
<li><code>g++ -c some_other_file.cpp -o some_other_file.o</code></li>
<li>这两个命令都会成功，因为各自文件内的匿名命名空间使用是合法的。</li>
</ul>
</li>
<li><p><strong>链接所有<code>.o</code>文件：</strong></p>
<ul>
<li><code>g++ main.o some_other_file.o -o my_program</code></li>
<li>这也会成功，因为 <code>main.cpp</code> 里的 <code>Add</code> 和 <code>some_other_file.cpp</code> 里的 <code>Add</code> 即使同名，在链接阶段也是两个独立的符号，不会冲突。</li>
</ul>
</li>
<li><p><strong>运行 <code>my_program</code>：</strong></p>
<ul>
<li>您会看到 <code>main.cpp</code> 打印出 <code>Add(10.1, 20.2) = 30.3</code>。</li>
<li>如果您在 <code>main.cpp</code> 中取消 <code>extern void call_add_from_other_file();</code> 的注释并调用它，您将看到 <code>some_other_file.cpp</code> 内部的 <code>Add</code> 被调用，并打印出 <code>在 some_other_file.cpp 的匿名命名空间中调用 Add 函数. 3.0</code>。</li>
</ul>
</li>
</ol>
<p><strong>尝试制造链接错误（关键点）：</strong></p>
<ul>
<li><strong>假设：</strong> 我们想在 <code>main.cpp</code> 中直接使用 <code>some_other_file.cpp</code> 中的 <code>Add</code> 函数。</li>
<li><strong>修改 <code>main.cpp</code> (错误尝试):</strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们想访问 some_other_file.cpp 中的 Add</span></span><br><span class="line"><span class="comment">// extern double Add(double a, double b); // 错误的尝试！</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// double result = Add(1.0, 2.0); // 编译会通过，但链接会失败！</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><strong>结果：</strong> 编译阶段可能不会报错（因为有<code>extern</code>声明，编译器认为链接器会找到）。但在<strong>链接 (link)</strong> 阶段，<strong>链接器会报“未定义引用 (undefined reference)”错误</strong>，因为它在外部符号表中找不到名为<code>Add</code>的函数（<code>some_other_file.cpp</code>中的<code>Add</code>被封装在它自己的内部命名空间中，不具有外部链接）。</li>
</ul>
<p>这有力地证明了匿名命名空间中的内容确实只在声明它们的翻译单元内是可见和可用的。</p>
<h3 id="5-QA-闪卡-Flash-Cards"><a href="#5-QA-闪卡-Flash-Cards" class="headerlink" title="5. QA 闪卡 (Flash Cards)"></a><strong>5. QA 闪卡 (Flash Cards)</strong></h3><p>为了帮助您巩固理解，这里有一些问答闪卡：</p>
<p><strong>Q1:</strong> 匿名命名空间有什么作用？<br><strong>A1:</strong> 它将其中声明的实体（变量、函数、类等）的作用域限制在当前<strong>翻译单元 (translation unit)</strong> 内，实现文件私有化，避免名称冲突，并作为<code>static</code>关键字的现代替代方案。</p>
<p><strong>Q2:</strong> 匿名命名空间中的内容可以在其他<code>.cpp</code>文件里使用吗？<br><strong>A2:</strong> <strong>不能</strong>。匿名命名空间中的内容只在声明它们的那个<strong>翻译单元 (translation unit)</strong> 内可见和可用，它们具有<strong>内部链接 (internal linkage)</strong>。</p>
<p><strong>Q3:</strong> 编译器如何处理匿名命名空间？<br><strong>A3:</strong> 编译器会为每个匿名命名空间生成一个<strong>唯一 (unique)</strong> 的、对开发者<strong>不可访问 (inaccessible)</strong> 的内部名字。</p>
<p><strong>Q4:</strong> <code>static</code>全局函数和匿名命名空间中的函数有什么区别？<br><strong>A4:</strong> 两者都实现了<strong>内部链接 (internal linkage)</strong>，使函数只在当前翻译单元内可见。但匿名命名空间是C++标准更推荐的方式，它语义更清晰，可应用于更多类型的实体（变量、类、枚举等），并且避免了<code>static</code>关键字的多重含义可能引起的混淆。</p>
<p><strong>Q5:</strong> 在同一个<code>.cpp</code>文件里写了两个<code>namespace { ... }</code>块，它们是两个独立的命名空间吗？<br><strong>A5:</strong> <strong>不是</strong>。它们都是对<strong>同一个</strong>、由编译器为该翻译单元生成的那个匿名命名空间的<strong>扩展 (extension)</strong>。</p>
<h3 id="6-常见误解与错误-Common-Misunderstandings-or-Mistakes"><a href="#6-常见误解与错误-Common-Misunderstandings-or-Mistakes" class="headerlink" title="6. 常见误解与错误 (Common Misunderstandings or Mistakes)"></a><strong>6. 常见误解与错误 (Common Misunderstandings or Mistakes)</strong></h3><p>学习匿名命名空间时，新手常犯以下错误或存在误解：</p>
<ol>
<li><p><strong>误解1：匿名命名空间中的内容是全局可见的。</strong></p>
<ul>
<li><strong>纠正：</strong> 虽然它们可以直接访问而无需前缀，但它们并非真正意义上的“全局可见”。它们的作用域严格限制在当前<strong>翻译单元 (translation unit)</strong> 内部，不具备外部链接。在其他翻译单元中无法直接访问。</li>
</ul>
</li>
<li><p><strong>误解2：可以在头文件 (<code>.h</code>) 中使用匿名命名空间。</strong></p>
<ul>
<li><strong>纠正：</strong> <strong>强烈不推荐</strong>在头文件中使用匿名命名空间！如果一个头文件包含匿名命名空间，那么每个包含（<code>#include</code>）这个头文件的<code>.cpp</code>文件，都会得到这个匿名命名空间的一个<strong>独一无二的副本</strong>。这会导致：<ul>
<li><strong>违反单一性原则 (ODR Violation)：</strong> 如果匿名命名空间中包含变量，每个<code>.cpp</code>文件都会有一个该变量的独立副本，这可能导致意想不到的行为，甚至内存浪费。</li>
<li><strong>语义不清：</strong> 匿名命名空间旨在实现文件私有化，而头文件通常用于共享声明。在头文件中使用它会混淆意图。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>误解3：匿名命名空间和普通命名空间一样，可以通过<code>using namespace</code>或者<code>qualified name</code>跨文件访问。</strong></p>
<ul>
<li><strong>纠正：</strong> 不能。由于匿名命名空间中的实体具有<strong>内部链接 (internal linkage)</strong>，它们在链接阶段对其他翻译单元是不可见的。即使您尝试通过某种方式（如<code>extern</code>声明）引用它们，链接器也会报“未定义引用”错误。</li>
</ul>
</li>
<li><p><strong>误解4：匿名命名空间是用来隐藏实现细节的。</strong></p>
<ul>
<li><strong>纠正：</strong> 匿名命名空间的主要目的是限制实体在当前<strong>翻译单元 (translation unit)</strong> 内的可见性，而不是为了隐藏模块间的实现细节（那是通过头文件/源文件分离、PIMPL等技术实现的）。它更多是为了防止内部使用的辅助函数或变量与外部同名实体发生冲突。</li>
</ul>
</li>
<li><p><strong>误解5：<code>static</code>和匿名命名空间完全等价。</strong></p>
<ul>
<li><strong>纠正：</strong> 在实现<strong>内部链接 (internal linkage)</strong> 这一点上，它们是等价的。但匿名命名空间是C++标准推荐的更现代、更通用的方式，可以应用于类、结构体、枚举等，语义更清晰，也避免了<code>static</code>关键字在C++中的多重含义。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="7-编程练习-Coding-Exercise"><a href="#7-编程练习-Coding-Exercise" class="headerlink" title="7. 编程练习 (Coding Exercise)"></a><strong>7. 编程练习 (Coding Exercise)</strong></h3><p>为了帮助您巩固对匿名命名空间的理解，请完成以下练习。</p>
<p><strong>场景：</strong> 您正在开发一个简单的日志记录器（Logger）。其中有一个辅助函数 <code>format_log_message</code>，它只在 <code>Logger.cpp</code> 内部被 <code>Logger</code> 类的方法使用，不希望被其他文件直接访问。</p>
<p><strong>任务：</strong><br>请您在 <code>Logger.cpp</code> 文件中，将 <code>format_log_message</code> 函数放入一个匿名命名空间中，并确保 <code>Logger</code> 类能够正确地使用它。</p>
<p><strong>文件：<code>Logger.h</code></strong> (请勿修改此文件)</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Logger(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; component_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录一条信息日志</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logInfo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录一条错误日志</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logError</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_componentName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><strong>文件：<code>Logger.cpp</code></strong> (请填写 <code>TODO</code> 部分的代码)</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;   // For std::time and std::localtime</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; // For std::put_time</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在这里开始您的代码填写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 将 format_log_message 函数放入一个匿名命名空间中</span></span><br><span class="line"><span class="comment">//    这个函数接收一个日志级别（"INFO" 或 "ERROR"）和消息内容，返回格式化后的字符串。</span></span><br><span class="line"><span class="comment">//    例如，它应该返回类似 "[YYYY-MM-DD HH:MM:SS] [INFO] [ComponentName] Your message"</span></span><br><span class="line"><span class="comment">//    提示：您可以使用 std::put_time 来格式化时间。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// namespace &#123;</span></span><br><span class="line"><span class="comment">//     std::string format_log_message(const std::string&amp; level, const std::string&amp; component_name, const std::string&amp; message) &#123;</span></span><br><span class="line"><span class="comment">//         // 实现您的格式化逻辑</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在这里结束您的代码填写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger 类的实现</span></span><br><span class="line">Logger::Logger(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; component_name)</span><br><span class="line">    : m_componentName(component_name) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::logInfo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用匿名命名空间中的 format_log_message 函数</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 调用 format_log_message 并打印结果</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; format_log_message("INFO", m_componentName, message) &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Logger::logError</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用匿名命名空间中的 format_log_message 函数</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 调用 format_log_message 并打印结果</span></span><br><span class="line">    <span class="comment">// std::cerr &lt;&lt; format_log_message("ERROR", m_componentName, message) &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>文件：<code>main.cpp</code></strong> (用于测试您的Logger，请勿修改)</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Logger <span class="title">appLogger</span><span class="params">(<span class="string">"MyApp"</span>)</span></span>;</span><br><span class="line">    appLogger.logInfo(<span class="string">"Application started successfully."</span>);</span><br><span class="line">    appLogger.logError(<span class="string">"Failed to load configuration file!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试直接调用 format_log_message (这将导致链接错误，验证匿名命名空间的作用)</span></span><br><span class="line">    <span class="comment">// std::string test_message = format_log_message("TEST", "Global", "This should fail at link time!");</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请在 <code>Logger.cpp</code> 中完成 <code>TODO</code> 部分的代码。完成后，您可以尝试编译 <code>main.cpp</code> 和 <code>Logger.cpp</code>，看看它是否能正常工作。</p>
<p>当您完成练习后，请将您的解决方案（<code>Logger.cpp</code> 的 <code>TODO</code> 部分）发送给我，我将为您评分并提供详细的解答和进一步的建议！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Tutorial/">Tutorial    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a><a class="post-meta__tags" href="/tags/Developer/">Developer    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/329%20-%20%E8%B7%A8%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>329 - 跨文件命名空间</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/332%20-%20cpp%20using%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%86%B2%E7%AA%81/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>332 - cpp using声明命名空间冲突</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/256 - cpp decltype(auto)/" title="256 - cpp decltype(auto)"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">256 - cpp decltype(auto)</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/330 - cpp 默认全局命名空间与作用域运算符/" title="330 - cpp 默认全局命名空间与作用域运算符"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">330 - cpp 默认全局命名空间与作用域运算符</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/331 - cpp内置命名空间/" title="331 - cpp内置命名空间"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">331 - cpp内置命名空间</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/334 - cpp Nested/" title="334 - cpp Nested"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">334 - cpp Nested</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/262 - constexpr if/" title="262 - constexpr if"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">262 - constexpr if</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/257 - cpp Default template arguments/" title="257 - cpp Default template arguments"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">257 - cpp Default template arguments</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>