<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>301 - 拷贝构造函数深拷贝 | Bear's dream</title><meta name="description" content="301 - 拷贝构造函数深拷贝"><meta name="keywords" content="Cpp,Function,Class,Object,Programming"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="301 - 拷贝构造函数深拷贝"><meta name="twitter:description" content="301 - 拷贝构造函数深拷贝"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="301 - 拷贝构造函数深拷贝"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/301%20-%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="301 - 拷贝构造函数深拷贝"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/301%20-%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D/"><link rel="prev" title="281 - cpp this 指针详解与应用" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/281%20-%20cpp%20this%20%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/"><link rel="next" title="321 - 类内变量自引用" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/321%20-%20%E7%B1%BB%E5%86%85%E5%8F%98%E9%87%8F%E8%87%AA%E5%BC%95%E7%94%A8/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#拷贝构造函数深拷贝"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">拷贝构造函数深拷贝</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C-拷贝构造函数-Copy-Constructor-深入解析：从浅拷贝到深拷贝"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">C++ 拷贝构造函数 (Copy Constructor) 深入解析：从浅拷贝到深拷贝</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-详细解释"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">1. 详细解释</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-什么是拷贝构造函数？"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">1.1 什么是拷贝构造函数？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-我们的示例：Person-类"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">1.2 我们的示例：Person 类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-默认拷贝构造函数和浅拷贝-Shallow-Copy-问题"><span class="toc_mobile_items-number">2.1.3.</span> <span class="toc_mobile_items-text">1.3 默认拷贝构造函数和浅拷贝 (Shallow Copy) 问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-4-自定义拷贝构造函数"><span class="toc_mobile_items-number">2.1.4.</span> <span class="toc_mobile_items-text">1.4 自定义拷贝构造函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-5-实现深拷贝的步骤"><span class="toc_mobile_items-number">2.1.5.</span> <span class="toc_mobile_items-text">1.5 实现深拷贝的步骤</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-6-拷贝构造函数和构造函数委托-Constructor-Delegation"><span class="toc_mobile_items-number">2.1.6.</span> <span class="toc_mobile_items-text">1.6 拷贝构造函数和构造函数委托 (Constructor Delegation)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-7-何时调用拷贝构造函数？"><span class="toc_mobile_items-number">2.1.7.</span> <span class="toc_mobile_items-text">1.7 何时调用拷贝构造函数？</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-8-拷贝构造函数-Vs-赋值运算符-Assignment-Operator"><span class="toc_mobile_items-number">2.1.8.</span> <span class="toc_mobile_items-text">1.8 拷贝构造函数 Vs 赋值运算符 (Assignment Operator)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-9-析构函数的重要性"><span class="toc_mobile_items-number">2.1.9.</span> <span class="toc_mobile_items-text">1.9 析构函数的重要性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-代码示例"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">2. 代码示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-QA-闪卡"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">3. QA 闪卡</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-常见误解或易犯错误"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">4. 常见误解或易犯错误</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-编码练习"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">5. 编码练习</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-评价你的解答与正确答案解析"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">7. 评价你的解答与正确答案解析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#评价你的解答"><span class="toc_mobile_items-number">2.8.1.</span> <span class="toc_mobile_items-text">评价你的解答</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#参考答案与进一步解释"><span class="toc_mobile_items-number">2.8.2.</span> <span class="toc_mobile_items-text">参考答案与进一步解释</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-建议与扩展问题"><span class="toc_mobile_items-number">2.9.</span> <span class="toc_mobile_items-text">8. 建议与扩展问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-2"><span class="toc_mobile_items-number">2.10.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-2"><span class="toc_mobile_items-number">2.11.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#拷贝构造函数深拷贝"><span class="toc-number">1.</span> <span class="toc-text">拷贝构造函数深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-拷贝构造函数-Copy-Constructor-深入解析：从浅拷贝到深拷贝"><span class="toc-number">2.</span> <span class="toc-text">C++ 拷贝构造函数 (Copy Constructor) 深入解析：从浅拷贝到深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-详细解释"><span class="toc-number">2.1.</span> <span class="toc-text">1. 详细解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-什么是拷贝构造函数？"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 什么是拷贝构造函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-我们的示例：Person-类"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 我们的示例：Person 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-默认拷贝构造函数和浅拷贝-Shallow-Copy-问题"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 默认拷贝构造函数和浅拷贝 (Shallow Copy) 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-自定义拷贝构造函数"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 自定义拷贝构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-实现深拷贝的步骤"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.5 实现深拷贝的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-拷贝构造函数和构造函数委托-Constructor-Delegation"><span class="toc-number">2.1.6.</span> <span class="toc-text">1.6 拷贝构造函数和构造函数委托 (Constructor Delegation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-何时调用拷贝构造函数？"><span class="toc-number">2.1.7.</span> <span class="toc-text">1.7 何时调用拷贝构造函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-拷贝构造函数-Vs-赋值运算符-Assignment-Operator"><span class="toc-number">2.1.8.</span> <span class="toc-text">1.8 拷贝构造函数 Vs 赋值运算符 (Assignment Operator)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-析构函数的重要性"><span class="toc-number">2.1.9.</span> <span class="toc-text">1.9 析构函数的重要性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-代码示例"><span class="toc-number">2.2.</span> <span class="toc-text">2. 代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-QA-闪卡"><span class="toc-number">2.3.</span> <span class="toc-text">3. QA 闪卡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-常见误解或易犯错误"><span class="toc-number">2.4.</span> <span class="toc-text">4. 常见误解或易犯错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-编码练习"><span class="toc-number">2.5.</span> <span class="toc-text">5. 编码练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">2.6.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">2.7.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-评价你的解答与正确答案解析"><span class="toc-number">2.8.</span> <span class="toc-text">7. 评价你的解答与正确答案解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#评价你的解答"><span class="toc-number">2.8.1.</span> <span class="toc-text">评价你的解答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考答案与进一步解释"><span class="toc-number">2.8.2.</span> <span class="toc-text">参考答案与进一步解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-建议与扩展问题"><span class="toc-number">2.9.</span> <span class="toc-text">8. 建议与扩展问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-2"><span class="toc-number">2.10.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-2"><span class="toc-number">2.11.</span> <span class="toc-text">🤖 Assistant</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">301 - 拷贝构造函数深拷贝</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/301%20-%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/301%20-%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="拷贝构造函数深拷贝"><a href="#拷贝构造函数深拷贝" class="headerlink" title="拷贝构造函数深拷贝"></a>拷贝构造函数深拷贝</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture we’re going to learn about copy constructors, and these are constructors that are calledby the compiler to make copies.If you try to construct a class object from another class object.To really learn about this, we’re going to use a person class.We’re going to set up a person class.It’s going to have two sections.We’re going to have a private section and we’re going to have a public section.The private section is going to have a few member variables.We’re going to have the last name, which is modeled as an stdstring.We’re going to have the first name and we’re going to have the age and the public section.We’re going to have a few constructors.We have the default constructor, which is not going to do anything.It’s just going to initialize the member variables.However, they were declared, so the name is going to be empty.The first name is going to be empty and the last name is going to be empty and the age is just goingto be a null pointer because the age is modeled as a pointer here.And this is by purpose because there are a few things I want you to see about copy constructors downhere.We have a few other constructors.We have one that only takes the last name, one that takes two parameters, the last name and the firstname, and another that takes all the other parameters, which is going to initialize all our membervariables here.We also have a utility function which is going to print information about a person object.It’s going to print the memory address where the object lives, and then we’re going to have the lastname, the first name the age, and we can even print the address here.We can print information about our person object here.This is the point.Okay.Now that we know about our class, let’s talk about copies.We have a person object here.We’re going to set them up and put this information here.The last name is going to be John.The first name is going to be snow and the age is going to be 25.And we can print information about this person, but we can create a copy of this person using the syntaxhere.And C plus plus is going to understand this so we can say person.Person two And we want to create a person two from person one here.And if we do this, this is going to work, but it’s not going to probably do what you expect becausethis is going to copy the member variables one by one from person one to person two.So here is a simple illustration.We have a person one, and we want to create a copy of person one in another person which is calledperson two or P two here.So what this is going to do is do a member wise copy.So it’s going to take the last name in person one and copy that in person.Two, we’re going to have a situation like this.It’s going to take the first name in person one and copy that in person.Two, we’re going to have a situation like this and then it’s going to copy the age from person onein person two But remember, the age is a pointer.It’s going to copy the address that is contained in this pointer and put that in person.Two here.And this is going to give us a few problems as we are about to see in the next slides.And copying pointers directly like this is really going to give us problems.Let’s explore this a little more.Here.We have a simple example where we have our person one and person two here and the person two is a copyof person one, as you see through the syntax here.So after we have our two persons created, suppose we want to set the age of person one.We do that through a set age setter that we have in person, which is going to set the age.And after that, if we print the information, we’re going to see that the age for person two was alsochanged because what we really copied is a pointer and the set age is going to dereference the pointerand change what is inside and the change in person.One is also going to be in person.Two So you need to be aware of this.This is a problem and C plus plus is going to introduce this problem by default because C plus plusis going to copy member variables one by one by default, and it’s going to really even copy pointers.So C plus plus does things this way because it generates a default copy constructor for you.And this is a constructor that is going to be used to do the copy we do here.So the syntax we use here is going to call a copy constructor.And in this case we don’t have a copy constructor in person.So the compiler is going to generate a copy constructor and use that.But that generated copy constructor is going to be doing member wise copy from person one to persontwo and it is going to blindly copy the pointer for the age member variable.This is the source of all the problems we have down here of also having the age for person two modifiedthrough changing the age of person one.Hopefully you see the problem here.Okay, so we have a problem here.How do we solve that?The first step is to.Try and see the problem and really prove this, for example, through the debugger.And right now we are using a constructor that is generated by the compiler.So we can’t really set a breakpoint there or really put any stdcout statement to see what is happening.But not to worry.It is possible to set our own copy constructor and use that to see information.We can even go further and disable the default behavior of even copying pointers and really customizeit however we want.So we’re going to do that.Here is our first attempt at setting up a copy constructor and we’re going to set it up like this.We’re going to set up a constructor which is called Person.This is part of the person class because of this scope resolution operator here.And then we’re going to pass a parameter which is another person by const because we don’t really wantto modify it.We want to read from it.But notice that we are passing this by value.You need to save this.And then in our initializer list, we’re basically going to be copying from the source person to ourperson object that we are building here.So the last name is going to be initialized with the last name from the source person.The first name is going to be initialized with the first name from the source person and the age isgoing to be initialized with the age from the source person.Here we are basically copying member wise.We are doing the same thing the compiler has done for us.So but this is going to be problematic because if you look here we are passing by value and this syntaxis not allowed to be used in C plus plus.The problem is this could lead to an endless chain of copy constructor calls.So why is this?Remember to create an object, we say something like this, we say person P two and use P one to buildour person two object.So when the compiler sees a call like this, it will know that it needs to call a copy constructor.And when it calls the copy constructor, it’s going to see our copy constructor here.But it’s going to see that something is passed by value.And to pass by value you need to call the copy constructor.But the copy constructor itself is taking something by value, so we’re going to keep trying to callthe copy constructor and this is going to be an endless chain of calls to the copy constructor and thisis going to end nowhere.So the designers of C plus plus saw this problem and they disallowed this syntax here to try and setup a copy constructor using an object that you pass by value here.So this is not going to work.If you do this, you’re going to get a compiler error.What if we try and pass by reference?Okay, so the first attempt here is really bad.It’s not going to work.If you’re trying to use it, you’re going to get a compiler error.But we can try and pass by reference and that’s what we have here.We are passing our person source person by reference here and it is by const reference because we don’treally want to modify it and we are doing the same thing we did in the last attempt in our initializerlist here.Last name is going to be initialized with the last name of the source person.First name is going to be initialized with the first name of first person here or source person I shouldsay.And the age is going to be initialized with the age of source person here.This is going to do what the C plus plus compiler does.By default, it is doing member wise copy and we are blindly copying the age member variable here andit is a pointer.So we’re going to take the pointer address contained in source and just copy that in destination here,which is this age member variable here.And this is going to also be bad because we just copy the pointer.And if we modify one person’s age, the change is going to be seen in the other person’s age.And we don’t really want that.Okay, so this is bad also, but it’s not as bad as the first attempt, but this is still bad.We need to do better.What we need to do really is to not blindly copy pointers, but set up a new memory address in our newperson object and just copy the value from the source object.And that’s what we are doing here.So we are copying the last name and the first name as we did in the last two attempts.But notice what we do for the age member variable inside.We’re going to set up a new memory location and we’re going to use the data from the source object toinitialize this new memory location.And this is going to do what we want.It is not going to do a blind copy of the pointer.It is going to set up a new memory location in our new person object, and then we’re going to use thedata in the source object.And this is good.And if we try to change the person one here, the changes are not.Going to leak into person two and this is going to be good.Okay, so this is what you should do.If you want to set up a copy constructor, you should pass your parameter by const reference as we dohere.And if you have any pointer member variables, you shouldn’t really blindly copy them.You should set up a new memory location in your destination object and then initialize that with thedata from the source object, which is what we are doing here.We are dereferencing the pointer from the source object and we are grabbing the data inside and usingthat to initialize our age pointer here.And this is really good.Okay, so this is one way we have to set up a copy constructor and it is going to work, but it is alsopossible to delegate the work on another constructor.And the last lecture we have learnt about constructor delegation.We can use that with copy constructors and we can do something like this.This is a copy constructor.It is going to take its parameter by const reference here, but notice that we are delegating the workto another constructor, which is going to take three parameters.So this constructor is going to use the data from our source object and we’re going to initialize thelast name here.We’re going to initialize the first name here and notice that we are dereferencing the pointer and passingthat data to our other constructor because that other constructor is going to set up a new memory locationand use this data here.Okay, so this is how you can delegate the construction from your copy constructor to another constructorthat is going to do the heavy lifting for you.I realize all this can really be confusing, so we are going to head over to Visual Studio code anddo this step by step so that you can really see, okay, here we are in our working folder.The current project is copy constructors.We’re going to grab our template files and use those.We’re going to paste those in and we are going to open this in Visual Studio code.Let’s do that by dragging and dropping here.This is going to open our folder and we need our person class that we can use to really learn aboutcopy constructors.We’re going to set up a header file which is going to be person dot H, and we’re going to set up anotherfile, which is going to be person dot CPP and we’re going to put this in place.I am going to put in the code I have prepared before so that we can really be fast with these things.This is really a simple class.It is called person.We have our member variables, we have a private section and a public section.The private section is going to contain our member variables and we’re going to have our constructorshere, which are going to be used to construct objects of person.We have a destructor, we have a few setters, we have a few getters, and we have a utility functionwhich is going to print information about our person object.Here.I am also going to put in the implementation for our person class and then I am going to try and explainit a little bit.So we have a few member variables.Last name and first name are modeled as STD strings and the age is modeled as a pointer because I wantyou to see problems that might come up if you set up copy constructors and you have pointer member variables.So we really need this.So the constructors are really going to do nothing special.We have a one parameter constructor which is going to delegate the work to another constructor, whichis going to take two parameters.The two parameter constructor is also going to delegate the work to a three parameter constructor,and the three parameter constructor is going to construct our object using this initializer list here.Notice that the three parameter constructor is going to set up a new memory location because if youremember the age is a pointer, so we need to allocate memory to storing the data.So that’s what we do in the constructor here.We’re going to say New Ant and we’re going to store in the data that is coming from the age parameterhere and we’re going to set up our object like this.The problem with this is that it is really using strings by copy and this is bad.So we should fix this either by using a const string references or using string views.I am going to use strings that we pass by reference here.So let’s fix this pretty quick.We’re going to say const string by reference, by reference we should say, and we’re going to say conststring by reference here and const string by reference.Let’s do this and let’s do that here as well.I think we have one left here.Let’s do that const string reference and we could use these parameters in our constructors here.So let’s go back in the CPP file and apply the same changes.We’re going to say const string reference here.You see we have a few squiggly lines, let’s say const string reference.We’re going to fix this class a little bit because string.Reference here.Let’s do this.You don’t have to do this.You can just grab the file that will be attached to the resource section of this lecture, and you canuse this class as is here.So let’s say const here and we’re going to say const string reference, let’s do that and const STDstring and we’re going to pass that by reference here and we have our class.So again, we have three member variables and one is a pointer and we have to make sure that the constructorsthat we use allocate new memory to be able to store data in this pointer here.This is what is really important for this class.So now that we have the class, we can head over in the main function and really use it.We’re going to bring up the sidebar here and head over in the main function and we’re going to includeour person class.So let’s include person.You see that we have this available in the main CPP file here.We’re going to take out what we don’t need and then we’re going to set up a person object.We’re going to say person P one and we’re going to put in John and the first name is going to be snowand the age is going to be 25.I think this is what we used in the slides.So let’s use this and we can print information about this person.Let’s do this and we’re going to build and see this printed out on the console.We can close this guy here.We don’t need this for now.You see, the world is good.We can bring up a terminal to really play with us and we’re going to run Rooster.We’re going to see that we have a person object living at this memory location.The last name is John.The first name is Snow.The age is 25, and the member variable for the age is living at this address here.This is the information we get from our print function, which is living in our header file.Let’s look at it and really see this.So it’s going to print this information here and it’s going to print the value we have in the age pointer.And it’s also going to print the memory location for this pointer here.And we do that by directly printing the pointer.Again, remember the age member variable here is a pointer.And this is key for what we are trying to do in this lecture here.So let’s try and create a copy.We’re going to go down here and create a new person.Person two We can say p two here, and the syntax to create a person object from another person is passingit as a parameter.So we’re going to pass P one here and this is going to do what we want.This is going to copy data from person one and use that to create a new person object, which is goingto be P two here.And if we try to print P two, we’re going to say print info.Let’s see what we get.The first thing you should notice here is that the syntax here is working because of some heavy liftingthat the compiler is going to do.For us to allow for this syntax here to work.Let’s build and really save this.We’re going to build with GCC, we’re going to see that the world is good.We can clear and run Rooster.Now we’re going to see that person.One last name is John.First name is age Address.Memory is here and you see that we have the same information in person to person two is going to liveat a different address because it is a separate variable.But what we have inside the last name is John.The first name is Snow.The age is 25.But you see that the address for the age member variable is the same.So it was copied over.So suppose we have three slots and these two person objects, we have one for the last name, we haveanother for the first name and we have another for the age.And we have the same things for person two here.So let’s put three slots here and what the compiler is going to do.If we set up a syntax like this, it’s going to do blind copy of the member variable.So it’s going to have what we have in the last name member variable and it’s going to copy that in theperson to object eight.It’s going to copy what we have in the last name and it’s going to paste that into the person to object.It’s going to copy what we have in the age member variable and it’s going to paste that into the agemember variable of person two But remember, the age is modeled as a pointer in our class.And what this is going to do, it’s going to copy the memory location, which is contained in personone, and it’s going to paste that into person two.And that’s what we see here.We see the memory address in person one For the age member variable.It’s the same as we have in person two So this is going to cause a few problems.So for example, if we try and modify person one, the changes are going to be seen even in person.Two for the age.So for example, let’s modify the age for person one, we’re going to set age and we’re going to setthe age to 30, for example, and then we’re going to print information for person one.And.Person two After that we’re going to say P one Printinfo and we’re going to say P two Printinfo.Here, if we do this, we’re going to see that the age for these two persons is the same.Even if we really change the age for person one.Let’s put a little separator here so that we can see this on the terminal.We’re going to put a few dashes.Think this is going to do and we’re going to build this.The bold is going to be good.And if we run this, let’s clear and run Rooster, we’re going to see that the age for person one andperson to have changed to 30 because if we call set age, it is going to dereference the pointer andchange the value inside.The thing is we have the same memory addresses in these two persons object and if you change eitherof these guys, the changes are going to be reflected in both of them.Let’s look at how we change the age in person.I don’t think we really looked at this in detail.Okay, so this is our set age method and you’re going to see that in the body.We’re going to be dereferencing the age pointer and assigning a value to it.And if we do this in main and change the age for one object and they happen to contain the same address,the changes are going to be reflected in both of them.And this is not what we want.What we would want if we copied a person object like this is for person two not to be affected by thechanges we do in person.One And the reason for this problem is because the compiler is doing blind memberwise copy.Again, it is copying the last name in person.Two It is copying the first name we have in person one in person two And it is copying what we havein the age member variable in person two And we have the same memory addresses here.So we need to fix this.But before I show you how to fix this, we should also show you how to see these things in the debugger.So, for example, let’s set up a breakpoint on line 14 here and we can use a debugger to see thesethings instead of printing them out using the print function here so we can run our debugger.We’re going to build our program.The build is good.We’re going to give control to the debugger.We’re going to hit this breakpoint here.And now we have our two person objects as locals in the main function here.So we can, for example, see the last name.Let’s expand that a plus here and let’s expand this a little bit.And you’re going to see that the data in here is John.For the last name.We can see the first name.We’re going to see that if we expand data.Plus here, we’re going to see that the last name is snow.We can go down and look at the age.You see that it is a pointer.Okay.So let’s go down to P two.We’re going to see that we have the same information in last name and first name.But look at the age pointer here.It contains the same address both for person one and person two.If you want to see the data inside, you can dereference the pointer and see the data inside.You can see that through the debugger.And this proves that we really are doing a member wise copy and we are just copying the pointer andthis is going to be problematic.If we modify one object, the changes are going to be seen in the other object.What we really need to do is to set up a new memory location in person two and use that to contain ourdata that we pass from person one.So we’re going to be able to do that if we set up our own copy constructor.So let’s head over in the person class and set up a copy constructor.One attempt one might want to do to set up a copy constructor is to do something like this.They might come and say Person, let’s say copy constructor.They might say person and then pass another person by value, let’s say person.If I can type that and we’re going to call this source P for source person and you see that we havea squiggly line, but let’s go on and really finish this up.And then what you might do is go in your implementation file because that’s where we have the implementationsfor our person class.You might say person and say person, we can pass what we had in the header file.And then what you might do is initialize your member variables from what you have from the source personhere.So we’re going to put in a body and then we’re going to put our initializer list on the next line.I think that’s going to be better.So we’re going to say M last name is it called M Last name.Let’s see and see.It is called Last Name, so let’s use that here.I don’t want to go back and change that.We’re going to say last name.It’s going to be initialized with what is coming from the source person.So we’re going to say source P and get last name.We have a function to give that and then we’re going to initialize the first name.It’s going to be using whatever comes from source.P So we’re going to get last name.We’re going to do that and then we’re going to put a comma and initialize the member variable, andwe’re going to use whatever comes from source person and we’re going to get age and use that to initializeour member variable.You see that this is really not working.And the reason is what we talked about in the slides.If you try to set up a copy constructor that passes parameter by value, this is going to cause a chainof endless copy constructor calls because the copy constructor is going to want to call a copy constructorto set up a copy and this is going to be bad.C plus plus designer saw that and they disallowed this kind of syntax here.So this syntax is not going to work.So let’s comment this out because some people are going to try and set up something like this.And let’s say that this is bad and say potential for endless copy constructor calls.Okay, So we said that here.Let’s close this a little bit because we need some more breathing space so we can bring this back.Okay.Now that we know that the syntax here is not going to work, we’re going to set up another one, whichis going to do member wise copy and we’re going to set it up like this.We’re going to pass by reference, so we’re going to say person and we’re going to pass our parameterby const reference.So we’re going to say const person reference and say source P here.This is going to be our source person.We’re going to head over in the CPP file and reuse what we had done before.We can copy this and we’re going to put in our copy constructor, which is going to pass by referenceand do member wise copy.So let’s say that here we’re going to do member wise copy and we need to call these guys as functionshere.This is what the squiggly lines here are about.I think this is the same problem we had with our bad constructor here.So let’s go back and comment this out because I want you to see the problem the compiler is going toshow you and we are going to uncomment this.Sorry for this and we are going to comment out the member wise copy constructor here and we’re goingto uncomment this, but we’re going to see that we get a squiggly line because this is not allowed syntaxin C plus plus.So let’s change this to do a call to the getter function.Okay, so our getters are called properly, but this is still not allowed.If we try to build our program, we’re going to get a compiler error that is going to say that thisis a syntax that is not allowed.The compiler error is not going to be really understandable.It’s going to say invalid constructor.You probably meant const person by reference.You see the error here.This is a syntax that is not allowed and if you’re trying to use it, you’re going to get a compilererror because it could lead to an endless chain of copy constructor calls.So we’re going to comment this out again because we have seen the compiler error.Let’s do that.Let’s head over in the header file and comment this out again and we are going to go down and uncommentour member wise copy constructor.We’re going to do this here and now we have a constructor that seems to work.If we try to build with this constructor in place, let’s see what we get.We’re going to build with GCC first.You see that we have errors and what do we mean by this compiler error?Okay, so what do we have here?Let’s go back and this is not really commented out.Let’s comment this out and we’re going to build again.Now you see that the build is good and we have a constructor that is going to simulate the behaviorwe had with the constructor that was generated for us by the compiler.Because remember, before we set up our own constructors, the compiler was generating a copy constructorfor us.And what the compiler generated was doing exactly what we see here.Member Wise copy.It was taking the last name from the source object and pasting that into our member variable for thelast name.It was taking the first name from our source object and pasting that into our first name and it wastaking the age and pasting that into our age member variable.And remember the age is a pointer and that was the source of our problems because we had two objectsfor the person class that were pointing to the same age memory location and this is really bad.And now that I look at this, I notice that we didn’t use the first name here.We used the last name, We can fix this.We’re going to say get first name.This is going to do what we want.But still we’re going to see the same problems we saw when we use the constructor that was generatedby the compiler.But we can prove that our constructor here is being called by the compiler.Let’s do that.We’re going to say Stdcout.I think we can say that and we’re going to say copy constructor called.We’re going to see that our copy constructor is being used by the compiler.If I can type endl here.So this is good.Let’s try and build and see what we get in our output.The world is going to be good.We can clear and run Rooster and we are going to see that our copy constructor is called and the personobject, which we created as P2 here, is going to have the same information we have in the first personobject.The last name is going to be John.The first name is going to be Snow.The age is going to be 25, but we blindly copied the memory address and the age pointer and pastedthat in our person object, which is P2 here.And this is going to lead to the problem we see here.If we change the age from person one, the change is even going to be seen in person.Two And this is not what we want.So we need to fix this problem.And to fix this we need to avoid blindly copying the pointer for the member variable for age.Here, we need to set up a new memory location and use that to store the information in our copy object.So we’re going to change the copy constructor we have here.We’re going to comment it out and do things right.So what we’re going to do is comment this out and we’re going to set up another one which is going tocopy properly.We’re going to say don’t blindly copy the pointer and we’re going to set up a copy constructor, whichis going to do that.We’re going to say person and we’re going to take a person object by const reference because this isthe syntax that C plus plus expects.What did we do?Const person by reference and we’re going to say Source P, This is going to be our person and we’regoing to go in the CPP file and comment out what we had here because we don’t want this, but I wantyou to keep this as a reference and you need to know that this is really bad.It’s not going to do what you want.And this is also bad because this is not supported.Let’s say that this is really bad.Okay?I think this is expressing the level to which this is really bad.So let’s go down and set up a constructor that is going to work, a copy constructor, I mean, andwe’re going to say don’t blindly copy pointers.So we’re going to grab the constructor we had, which had a problem and we’re going to modify it a littlebit and not blindly copy the pointer.So for the age remember variable, we don’t want to directly copy the pointer here.What we want to do is allocate new memory and we can do that in our initializer list here so we cansay new and, and this is going to dynamically allocate space on the heap.And what we store in here is what we get if we dereference the pointer we get from the source objectand we can use this syntax here to do that.So if we do this, we want to be blindly copying the pointer.We will be setting up a completely new memory location to store the data in our copy object.So now that we have this and we’re going to try and build and really show you this, we’re going tobuild with GCC first, we need to prove that this is going to work.So you see, the syntax is really working.The build is good.We can clear now and run Rooster Now we’re going to see that P one is going to live at this addressthat ends in D30P2 is going to live at this address that ends in C zero and the age member variablefor p one is going to live at an address that ends in 2D0 and the age for the second person object isgoing to live at a different address that ends in 320.So we are doing things right here.We are using a completely new memory location to store the age for a person two And this is what wewant.If we look at the output after we modify person one and change the age to 30, person one is going tohave the age of 30 and the person two is going to have the age of 25.And this is really what we want.We have a copy constructor which is doing what we want.It is not doing blind copies of member variables and this is what we want.This is how you can set up a copy constructor so you now know how to set up a copy constructor.But I want you to know that we can reuse the constructor we have on top here.If you look, this constructor already knows how to allocate new memory for the parameter that you giveit.So for the strings it’s going to do a copy.Last name is going to be the last name that we pass in the parameter here.But for the age, it is going to make a new memory location and it is going to store age parameter nso we can really reuse it and avoid setting up a copy constructor that is doing all the heavy job hereso we can comment it out and use delegated constructors.We can do that.So we’re going to say that here delegate from the copy constructor.And the way to do that we’re going to have the same syntax we had, but we’re not going to initializethe variables ourselves.So let’s copy this and.Adapt this because I don’t want to retype all this.So what we’re going to do is take out all the initialization we’re doing here and we’re going to delegatethe construction from the copy construction to the construction we have on top here.So we’re going to call that what we’re going to do is say person and we’re going to give it the parametersor the arguments we should say.So we’re going to give it the last name, we’re going to say source person, get last name.We can do that.And it is a function we should call it.We’re going to give it the first name, we’re going to say source person and we’re going to get thefirst name.Let’s do that.And it is a function we should call it.Then we’re going to give it the age.How do we get the age?We’re going to dereference the pointer that comes from get age and we’re going to say source person,get age now, not first name, it’s get age.We’re going to get the pointer and then we’re going to dereference that and pass the data to the otherconstructor that we have on top.So we still have a squiggly line here.I don’t know why.Maybe Cplusplus is confused.So what do we have here?Let’s check this a little bit.We need to see.We have source beget last name source beget first name and we are dereferencing the pointer here andpassing the data.And I think we need another set of parentheses.Let’s see if that’s what we need.Yes, we need another parentheses in here.And then the Visual Studio code is going to accept this.So try to take a moment and really understand what we are doing here.The copy constructor is set up using the syntax that Cplusplus accepts, but we’re not going to initializeour member variables ourselves like we did in the last copy constructor that we did.We’re not going to do any memory allocation ourselves.We’re going to delegate all that heavy work to the constructor that we already have, which is constructingour objects here.And this is going to work.It is going to do what we want.Let’s go back to the main function and build our program.We’re going to see that the world is good.We can clear and run Rooster.We’re going to see that we have the exact same output.We have the data copied from person one.We have the last name.We have the first name, we have the age.And if we change person one, as we do here in person one, we’re going to have the age to be 30.But person two is not going to be affected.And this is really good.This is what you should do, this is how you should set up your copy constructors.Okay, so this is really how you can set up your copy constructors in C plus plus.And I don’t think I really told you if you set up your own copy constructor C plus plus is no longergoing to set up a copy constructor for you.It is going to call your copy constructor and the copy constructors are another set of functions thatthe C plus plus compiler can generate for you if you don’t have them in and they are needed.We have seen that the C plus plus compiler can also generate constructors for you.It can also generate destructors if you don’t have any destructors and but it can also generate a copyconstructor as we have seen in this lecture.So you should really know that and we should make sure that in our destructor we are releasing the memorythat we allocated in our constructor.So let’s really check that out.We’re going to go in person.CP And look, we don’t have a destructor in place here.We have a destructor which is going to release the memory and this is really good.We have to make sure that we are not leaking any memory here.So this is really all we set out to do in this lecture.I hope you found it interesting.Again, remember the syntax to set up a copy constructor and remember to not do blind copies, especiallyif you have member variables that are pointers like our age.Here.We are going to stop here in this lecture and the next one we’re going to see that if you store elementsin an array, the compiler is actually going to make copies.And that’s really interesting and we’re going to see that in the next lecture.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，没问题！我们现在开始学习 C++ 中一个非常重要的概念：拷贝构造函数。</p>
<h1 id="C-拷贝构造函数-Copy-Constructor-深入解析：从浅拷贝到深拷贝"><a href="#C-拷贝构造函数-Copy-Constructor-深入解析：从浅拷贝到深拷贝" class="headerlink" title="C++ 拷贝构造函数 (Copy Constructor) 深入解析：从浅拷贝到深拷贝"></a>C++ 拷贝构造函数 (Copy Constructor) 深入解析：从浅拷贝到深拷贝</h1><p><strong>摘要：</strong> 本教程将带你深入理解 C++ 中的拷贝构造函数 (Copy Constructor)，解释其工作原理、何时被调用，以及如何正确实现它以避免常见的浅拷贝问题，特别是处理指针成员时。我们将通过一个 <code>Person</code> 类的例子，一步步展示从默认拷贝构造函数的问题到自定义深拷贝构造函数的实现方法。</p>
<hr>
<h2 id="1-详细解释"><a href="#1-详细解释" class="headerlink" title="1. 详细解释"></a>1. 详细解释</h2><h3 id="1-1-什么是拷贝构造函数？"><a href="#1-1-什么是拷贝构造函数？" class="headerlink" title="1.1 什么是拷贝构造函数？"></a>1.1 什么是拷贝构造函数？</h3><p>拷贝构造函数是一种特殊的<strong>构造函数 (constructor)</strong>。它的作用是在使用一个<strong>已存在的、同类型的对象 (object)</strong> 来<strong>初始化 (initialize)</strong> 一个新的对象时被调用。简单来说，就是当你想要“复制”一个对象来创建一个全新的对象副本时，拷贝构造函数就会登场。</p>
<p>例如，如果你有一个 <code>Person</code> 类的对象 <code>p1</code>，然后你这样写：<br><code>Person p2 = p1;</code><br>或者<br><code>Person p2(p1);</code><br>编译器 (compiler) 就会尝试调用 <code>Person</code> 类的拷贝构造函数来创建 <code>p2</code>。</p>
<h3 id="1-2-我们的示例：Person-类"><a href="#1-2-我们的示例：Person-类" class="headerlink" title="1.2 我们的示例：Person 类"></a>1.2 我们的示例：<code>Person</code> 类</h3><p>为了更好地理解拷贝构造函数，我们将使用一个 <code>Person</code> 类。这个类包含以下信息：</p>
<ul>
<li><strong>私有成员 (private members):</strong><ul>
<li><code>lastName</code> (姓): <code>std::string</code> 类型</li>
<li><code>firstName</code> (名): <code>std::string</code> 类型</li>
<li><code>age</code> (年龄): <code>int*</code> 类型 (一个指向整数的<strong>指针 (pointer)</strong>)。这里特意使用指针是为了演示拷贝构造函数中可能出现的问题和解决方案。</li>
</ul>
</li>
<li><strong>公有成员 (public members):</strong><ul>
<li>多个构造函数，包括一个默认构造函数 (default constructor) 和带参数的构造函数。</li>
<li>一个析构函数 (destructor)，用于释放动态分配的内存。</li>
<li>一个工具函数 <code>print_info()</code>，用于打印对象的信息。</li>
<li>一些 <code>setter</code> 和 <code>getter</code> 方法（用于设置和获取成员变量的值）。</li>
</ul>
</li>
</ul>
<p><strong>关键点：</strong> <code>age</code> 成员是一个指针。在构造函数中，我们会为它动态分配内存来存储实际的年龄值。例如：<br><code>age = new int(actual_age_value);</code></p>
<h3 id="1-3-默认拷贝构造函数和浅拷贝-Shallow-Copy-问题"><a href="#1-3-默认拷贝构造函数和浅拷贝-Shallow-Copy-问题" class="headerlink" title="1.3 默认拷贝构造函数和浅拷贝 (Shallow Copy) 问题"></a>1.3 默认拷贝构造函数和浅拷贝 (Shallow Copy) 问题</h3><p>如果我们没有为 <code>Person</code> 类显式定义一个拷贝构造函数，C++ 编译器会自动为我们生成一个。这个默认的拷贝构造函数执行的是<strong>成员逐一拷贝 (member-wise copy)</strong>。</p>
<ul>
<li>对于 <code>std::string</code> 类型的 <code>lastName</code> 和 <code>firstName</code>，成员逐一拷贝会创建字符串内容的副本，这通常是我们想要的。</li>
<li><strong>但是，对于指针成员 <code>age</code></strong>，成员逐一拷贝仅仅复制指针的地址值，而不是指针所指向的内存中的数据。这就导致了所谓的<strong>浅拷贝 (shallow copy)</strong>。</li>
</ul>
<p><strong>图解浅拷贝：</strong><br>假设我们有 <code>Person p1;</code>，它的 <code>age</code> 指针指向内存地址 <code>0x1000</code>，该地址存着年龄值 <code>25</code>。<br>当我们执行 <code>Person p2 = p1;</code> 时，如果使用的是默认的（或错误的自定义）拷贝构造函数：</p>
<ul>
<li><code>p2.lastName</code> 会得到 <code>p1.lastName</code> 的副本。</li>
<li><code>p2.firstName</code> 会得到 <code>p1.firstName</code> 的副本。</li>
<li><code>p2.age</code> 会得到 <code>p1.age</code> 的副本，也就是说，<code>p2.age</code> 也将指向内存地址 <code>0x1000</code>。</li>
</ul>
<p><strong>浅拷贝带来的问题：</strong></p>
<ol>
<li><strong>数据修改联动：</strong> 由于 <code>p1.age</code> 和 <code>p2.age</code> 指向同一块内存，如果通过 <code>p1</code> 修改了年龄（例如，<code>p1.set_age(30)</code>，这会解引用 <code>p1.age</code> 指针并修改 <code>0x1000</code> 处的值），那么 <code>p2</code> 的年龄也会“莫名其妙”地变成 <code>30</code>，反之亦然。这通常不是我们期望的行为，我们希望副本是独立的。</li>
<li><strong>悬挂指针和重复释放 (Dangling Pointer and Double Free):</strong> 当 <code>p1</code> 和 <code>p2</code> 的生命周期结束时，它们的析构函数都会尝试 <code>delete age;</code>。第一次 <code>delete</code> 会释放 <code>0x1000</code> 处的内存。当第二个对象的析构函数再次尝试 <code>delete</code> 同一个已经被释放的地址时，会导致程序崩溃（重复释放）。即使不崩溃，其中一个对象销毁后，另一个对象的 <code>age</code> 指针就成了悬挂指针，指向了无效内存。</li>
</ol>
<h3 id="1-4-自定义拷贝构造函数"><a href="#1-4-自定义拷贝构造函数" class="headerlink" title="1.4 自定义拷贝构造函数"></a>1.4 自定义拷贝构造函数</h3><p>为了解决浅拷贝的问题，我们需要自定义拷贝构造函数，并为指针成员实现<strong>深拷贝 (deep copy)</strong>。深拷贝意味着为新对象的指针成员分配一块新的内存，并将原对象指针所指向的数据复制到这块新内存中。</p>
<p>拷贝构造函数的典型声明格式如下：<br><code>ClassName(const ClassName&amp; other_object);</code></p>
<ul>
<li><code>ClassName</code> 是你的类名。</li>
<li>参数是 <code>const ClassName&amp; other_object</code>：<ul>
<li><code>const</code>: 表示我们不会在拷贝构造函数中修改源对象 <code>other_object</code>。这是一个好习惯。</li>
<li><code>&amp;</code>: 表示通过<strong>引用 (reference)</strong> 传递。这非常重要！</li>
</ul>
</li>
</ul>
<p><strong>为什么必须通过引用传递？</strong><br>如果我们尝试这样定义拷贝构造函数：<code>Person(Person other_person);</code> (按值传递)<br>当调用这个拷贝构造函数时，为了将实参传递给形参 <code>other_person</code>，需要先复制一份实参。但如何复制呢？又需要调用拷贝构造函数！这就形成了一个无限递归的调用链，最终导致栈溢出。因此，C++ 编译器禁止拷贝构造函数的参数按值传递，它必须是引用。</p>
<h3 id="1-5-实现深拷贝的步骤"><a href="#1-5-实现深拷贝的步骤" class="headerlink" title="1.5 实现深拷贝的步骤"></a>1.5 实现深拷贝的步骤</h3><p>在我们的 <code>Person</code> 类的拷贝构造函数中：</p>
<ol>
<li>对于非指针成员 (<code>lastName</code>, <code>firstName</code>)，可以直接复制：<br><code>lastName = other_person.lastName;</code><br><code>firstName = other_person.firstName;</code></li>
<li>对于指针成员 <code>age</code>，需要执行深拷贝：<ul>
<li>首先，为新对象的 <code>age</code> 指针分配新的内存：<code>age = new int;</code></li>
<li>然后，将源对象 <code>other_person.age</code> 所指向的<em>值</em>复制到这块新内存中：<code>*age = *(other_person.age);</code></li>
<li><strong>注意：</strong> 在解引用 <code>other_person.age</code> 之前，最好检查它是否为 <code>nullptr</code>，以避免解引用空指针。在示例代码中，我们假设它总是在主构造函数中被正确初始化。</li>
</ul>
</li>
</ol>
<p>更简洁的写法（通常在构造函数的初始化列表中完成）：<br><code>age = new int(*(other_person.m_age));</code> // 假设源对象的age指针名为m_age</p>
<h3 id="1-6-拷贝构造函数和构造函数委托-Constructor-Delegation"><a href="#1-6-拷贝构造函数和构造函数委托-Constructor-Delegation" class="headerlink" title="1.6 拷贝构造函数和构造函数委托 (Constructor Delegation)"></a>1.6 拷贝构造函数和构造函数委托 (Constructor Delegation)</h3><p>如果你的类中已经有一个构造函数（比如一个接收所有成员值的构造函数）正确地处理了所有成员的初始化（包括为指针成员分配新内存），那么你可以在拷贝构造函数中使用<strong>构造函数委托 (constructor delegation)</strong> 来避免重复代码。</p>
<p>例如，假设 <code>Person</code> 有一个构造函数：<br><code>Person(const std::string&amp; ln, const std::string&amp; fn, int val_age)</code><br>它内部会做 <code>this-&gt;age = new int(val_age);</code></p>
<p>那么拷贝构造函数可以这样写：<br><code>Person(const Person&amp; other) : Person(other.lastName, other.firstName, *(other.age)) {</code><br><code>// 委托给上面的构造函数，它会负责 new int(*(other.age))</code><br><code>std::cout &lt;&lt; &quot;拷贝构造函数 (委托版本) 被调用!&quot; &lt;&lt; std::endl;</code><br><code>}</code><br>这里，<code>*(other.age)</code> 解引用源对象的 <code>age</code> 指针，获取其指向的整数值，然后将这个值传递给目标构造函数，目标构造函数会为新对象的 <code>age</code> 指针 <code>new</code> 一块新内存并存入这个值。</p>
<h3 id="1-7-何时调用拷贝构造函数？"><a href="#1-7-何时调用拷贝构造函数？" class="headerlink" title="1.7 何时调用拷贝构造函数？"></a>1.7 何时调用拷贝构造函数？</h3><p>拷贝构造函数主要在以下几种情况下被调用：</p>
<ol>
<li><strong>显式或隐式初始化：</strong><br><code>Person p2 = p1;</code> // 隐式调用 (等号在这里是初始化，不是赋值)<br><code>Person p2(p1);</code> // 显式调用</li>
<li><strong>函数按值传参：</strong> 当一个对象作为参数按值传递给一个函数时，会创建该对象的一个副本。<br><code>void some_function(Person p);</code><br><code>Person my_person;</code><br><code>some_function(my_person); // Person的拷贝构造函数被调用以创建p</code></li>
<li><strong>函数按值返回：</strong> 当一个函数按值返回一个对象时，可能会（取决于编译器优化，如RVO/NRVO）调用拷贝构造函数。<br><code>Person create_person() {</code><br><code>Person temp(&quot;Doe&quot;, &quot;John&quot;, 30);</code><br><code>return temp; // 可能调用拷贝构造函数</code><br><code>}</code><br><code>Person new_p = create_person();</code></li>
</ol>
<h3 id="1-8-拷贝构造函数-Vs-赋值运算符-Assignment-Operator"><a href="#1-8-拷贝构造函数-Vs-赋值运算符-Assignment-Operator" class="headerlink" title="1.8 拷贝构造函数 Vs 赋值运算符 (Assignment Operator)"></a>1.8 拷贝构造函数 Vs 赋值运算符 (Assignment Operator)</h3><p>需要区分拷贝构造函数和<strong>拷贝赋值运算符 (copy assignment operator)</strong>。</p>
<ul>
<li><p><strong>拷贝构造函数：</strong> 用于从一个已存在的对象 <em>创建并初始化</em> 一个 <em>新</em> 对象。<br><code>Person p1(&quot;Snow&quot;, &quot;John&quot;, 25);</code><br><code>Person p2 = p1;  // 调用拷贝构造函数</code><br><code>Person p3(p1);   // 调用拷贝构造函数</code></p>
</li>
<li><p><strong>拷贝赋值运算符：</strong> 用于将一个已存在的对象的值赋给 <em>另一个已存在的</em> 对象。<br><code>Person p1(&quot;Snow&quot;, &quot;John&quot;, 25);</code><br><code>Person p2; // 调用默认构造函数 (或者其他构造函数)</code><br><code>p2 = p1;  // 调用拷贝赋值运算符 (operator=)</code></p>
</li>
</ul>
<p>拷贝赋值运算符也需要处理深拷贝问题，并且通常会更复杂一些（比如需要检查自赋值，先释放旧资源再分配新资源）。这是另一个话题，但与拷贝构造函数密切相关。</p>
<h3 id="1-9-析构函数的重要性"><a href="#1-9-析构函数的重要性" class="headerlink" title="1.9 析构函数的重要性"></a>1.9 析构函数的重要性</h3><p>当类中动态分配了资源（如 <code>new int</code> 为 <code>age</code>），必须提供一个<strong>析构函数 (destructor)</strong> 来释放在对象生命周期结束时分配的内存，以避免<strong>内存泄漏 (memory leak)</strong>。<br>对于 <code>Person</code> 类，析构函数应该像这样：<br><code>~Person() {</code><br><code>delete age; // 释放动态分配的内存</code><br><code>age = nullptr; // 好习惯：将指针设为nullptr，防止悬挂指针</code><br><code>std::cout &lt;&lt; &quot;析构函数为 &quot; &lt;&lt; lastName &lt;&lt; &quot; 调用&quot; &lt;&lt; std::endl;</code><br><code>}</code></p>
<p>如果你提供了自定义的拷贝构造函数（尤其是涉及到动态内存管理时），几乎总是意味着你也需要提供自定义的析构函数和自定义的拷贝赋值运算符。这通常被称为 <strong>“Rule of Three” (三法则)</strong> (在C++11及以后，由于移动语义的引入，扩展为 “Rule of Five” 或 “Rule of Zero”)。</p>
<hr>
<h2 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h2><p>下面是一个完整的 <code>Person</code> 类示例，包括正确的拷贝构造函数（使用委托）和析构函数。</p>
<p><strong><code>person.h</code> (头文件)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PERSON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lastName;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> firstName;</span><br><span class="line">    <span class="keyword">int</span>* age; <span class="comment">// 指针成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 带所有参数的构造函数 (主要构造逻辑)</span></span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; ln, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fn, <span class="keyword">int</span> val_age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数 (委托给主要构造函数)</span></span><br><span class="line">    Person();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数 (委托给主要构造函数，实现深拷贝)</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person&amp; other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Person();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter for age</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> new_age)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter for age value</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_age_value</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Utility function to print info</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PERSON_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>person.cpp</code> (实现文件)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带所有参数的构造函数 (主要构造逻辑)</span></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; ln, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fn, <span class="keyword">int</span> val_age)</span><br><span class="line">    : lastName(ln), firstName(fn) &#123;</span><br><span class="line">    age = <span class="keyword">new</span> <span class="keyword">int</span>(val_age); <span class="comment">// 为 age 分配新内存并初始化</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"构造函数 (带参) 为 "</span> &lt;&lt; lastName &lt;&lt; <span class="string">" 调用, 年龄指针: "</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数 (委托给主要构造函数)</span></span><br><span class="line">Person::Person() : Person(<span class="string">"N/A"</span>, <span class="string">"N/A"</span>, <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"默认构造函数为 "</span> &lt;&lt; lastName &lt;&lt; <span class="string">" 调用"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数 (委托给主要构造函数，实现深拷贝)</span></span><br><span class="line">Person::Person(<span class="keyword">const</span> Person&amp; other)</span><br><span class="line">    : Person(other.lastName, other.firstName, *(other.age)) &#123; <span class="comment">// 委托</span></span><br><span class="line">    <span class="comment">// *(other.age) 获取源对象年龄值</span></span><br><span class="line">    <span class="comment">// 主要构造函数会负责 new int(...)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数为 "</span> &lt;&lt; lastName &lt;&lt; <span class="string">" (从 "</span> &lt;&lt; other.lastName &lt;&lt; <span class="string">") 复制, 新年龄指针: "</span> &lt;&lt; age &lt;&lt; <span class="string">", 源年龄指针: "</span> &lt;&lt; other.age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Person::~Person() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数为 "</span> &lt;&lt; lastName &lt;&lt; <span class="string">" 调用, 准备释放年龄指针: "</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> age;      <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    age = <span class="literal">nullptr</span>;   <span class="comment">// 好习惯</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setter for age</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::set_age</span><span class="params">(<span class="keyword">int</span> new_age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age) &#123;</span><br><span class="line">        *age = new_age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Getter for age value</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::get_age_value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (age ? *age : <span class="number">-1</span>); <span class="comment">// 如果age有效则返回值，否则返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Utility function to print info</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Person Info: [Address: "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Last Name: "</span> &lt;&lt; lastName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  First Name: "</span> &lt;&lt; firstName &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (age) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Age: "</span> &lt;&lt; *age &lt;&lt; <span class="string">" (value stored at address: "</span> &lt;&lt; age &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Age: N/A (pointer is null)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-------------------------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>main.cpp</code> (主程序，用于测试)</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"person.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demonstrate_shallow_copy_problem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 演示浅拷贝问题 (如果拷贝构造函数实现错误) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 假设有一个错误的拷贝构造函数实现 (仅用于演示概念)</span></span><br><span class="line">    <span class="comment">// class BadPerson &#123; public: std::string name; int* age_ptr;</span></span><br><span class="line">    <span class="comment">// BadPerson(std::string n, int a) : name(n), age_ptr(new int(a)) &#123;&#125;</span></span><br><span class="line">    <span class="comment">// BadPerson(const BadPerson&amp; other) : name(other.name), age_ptr(other.age_ptr) &#123;&#125; // 浅拷贝</span></span><br><span class="line">    <span class="comment">// ~BadPerson() &#123; delete age_ptr; &#125; &#125;;</span></span><br><span class="line">    <span class="comment">// BadPerson bp1("Bad", 20);</span></span><br><span class="line">    <span class="comment">// BadPerson bp2 = bp1; // bp1.age_ptr 和 bp2.age_ptr 指向相同地址</span></span><br><span class="line">    <span class="comment">// *(bp1.age_ptr) = 22; // bp2的年龄也会变成22</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; "bp2 age: " &lt;&lt; *(bp2.age_ptr) &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// 此处bp1和bp2析构时会double free，导致崩溃</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"这个场景用文字描述：如果 Person p1 和 Person p2 的 age 指针指向同一内存，"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"修改 p1 的年龄会影响 p2，且析构时会重复释放内存导致程序崩溃。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 创建 p1 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Snow"</span>, <span class="string">"John"</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">    p1.print_info();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 使用 p1 创建 p2 (调用拷贝构造函数) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Person p2 = p1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    p2.print_info();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 修改 p1 的年龄 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p1.set_age(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 修改后:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p1.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2 (应该不受影响):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    p2.print_info(); <span class="comment">// p2的年龄应该还是25，因为是深拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- 使用 p1 创建 p3 (另一种调用拷贝构造函数的方式) ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>;</span><br><span class="line">    p3.print_info();</span><br><span class="line"></span><br><span class="line">    demonstrate_shallow_copy_problem();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n--- main函数结束，对象将按p3, p2, p1的逆序析构 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><strong>编译和运行：</strong><br>你可以将 <code>person.h</code>, <code>person.cpp</code>, <code>main.cpp</code> 保存到同一个目录下，然后使用 C++ 编译器（如 g++）编译：<br><code>g++ main.cpp person.cpp -o copy_constructor_test -std=c++11</code><br>然后运行：<br><code>./copy_constructor_test</code></p>
<p>你会从输出中看到构造函数、拷贝构造函数和析构函数被调用的时机，以及 <code>p1</code> 和 <code>p2</code> 的 <code>age</code> 指针指向了不同的内存地址，修改 <code>p1</code> 的年龄不会影响 <code>p2</code>。</p>
<hr>
<h2 id="3-QA-闪卡"><a href="#3-QA-闪卡" class="headerlink" title="3. QA 闪卡"></a>3. QA 闪卡</h2><ol>
<li><p><strong>Q: 什么是拷贝构造函数 (Copy Constructor)？它在什么时候被调用？</strong><br>A: 拷贝构造函数是一种特殊的构造函数，用于通过一个已存在的同类对象来初始化一个新对象。调用时机：1. <code>ClassName obj2 = obj1;</code> 或 <code>ClassName obj2(obj1);</code> 初始化。2. 函数按值传递对象参数。3. 函数按值返回对象。</p>
</li>
<li><p><strong>Q: 什么是浅拷贝 (Shallow Copy)？它对指针成员有什么问题？</strong><br>A: 浅拷贝是指在复制对象时，只复制成员变量的值。对于指针成员，只复制指针的地址，而不是指针指向的数据。问题：多个对象可能共享同一块内存，修改一个会影响另一个；对象析构时可能导致重复释放内存或悬挂指针。</p>
</li>
<li><p><strong>Q: 什么是深拷贝 (Deep Copy)？如何为指针成员实现深拷贝？</strong><br>A: 深拷贝是指在复制对象时，如果遇到指针成员，会为新对象的指针成员分配新的内存，并将原对象指针指向的数据复制到新分配的内存中。实现：在新对象的拷贝构造函数中，为指针成员 <code>new</code> 一块内存，然后解引用原对象的指针，将数据拷贝过来。</p>
</li>
<li><p><strong>Q: 为什么拷贝构造函数的参数通常声明为 <code>const ClassName&amp;</code>？</strong><br>A: <code>const</code> 是为了确保不修改源对象。<code>&amp;</code> (引用) 是为了避免无限递归调用拷贝构造函数（如果按值传递，传递过程本身就需要拷贝）。</p>
</li>
<li><p><strong>Q: 如果类中有动态分配的内存（如使用了 <code>new</code>），拷贝构造函数和析构函数 (Destructor) 需要注意什么？</strong><br>A: 拷贝构造函数需要实现深拷贝，为新对象分配独立的内存资源。析构函数需要在对象销毁时使用 <code>delete</code> (或 <code>delete[]</code>) 释放动态分配的内存，以防止内存泄漏。</p>
</li>
</ol>
<hr>
<h2 id="4-常见误解或易犯错误"><a href="#4-常见误解或易犯错误" class="headerlink" title="4. 常见误解或易犯错误"></a>4. 常见误解或易犯错误</h2><ol>
<li><strong>忘记自定义拷贝构造函数：</strong> 当类中有指针成员，并且你依赖编译器生成的默认拷贝构造函数时，会导致浅拷贝问题。</li>
<li><strong>自定义了拷贝构造函数但仍是浅拷贝：</strong> 比如写了 <code>age = other.age;</code>（对于指针 <code>age</code>），这仍然是浅拷贝。正确的是 <code>age = new int(*(other.age));</code>。</li>
<li><strong>拷贝构造函数参数按值传递：</strong> <code>Person(Person other);</code> 这是不允许的，会导致编译错误，因为它会引发无限递归。必须是引用 <code>Person(const Person&amp; other);</code>。</li>
<li><strong>忘记析构函数：</strong> 如果在构造函数或拷贝构造函数中用 <code>new</code> 分配了内存，但没有在析构函数中用 <code>delete</code> 释放，会导致内存泄漏。</li>
<li><strong>混淆拷贝初始化和赋值：</strong><ul>
<li><code>Person p2 = p1;</code> // 初始化，调用拷贝构造函数。</li>
<li><code>Person p2; p2 = p1;</code> // <code>p2 = p1;</code> 是赋值，调用拷贝赋值运算符 (<code>operator=</code>)，不是拷贝构造函数。</li>
</ul>
</li>
<li><strong>拷贝构造函数中忘记拷贝所有成员：</strong> 确保拷贝构造函数处理了类的所有成员变量，尤其是后来新添加的成员。</li>
<li><strong>在深拷贝指针前未检查源指针是否为 <code>nullptr</code>:</strong> 如果源对象的指针可能是 <code>nullptr</code>，直接解引用 <code>*(other.age)</code> 会导致程序崩溃。应先检查：<code>if (other.age) { age = new int(*(other.age)); } else { age = nullptr; }</code>。在我们的例子中，主构造函数保证了 <code>age</code> 被初始化，所以简化了处理。</li>
</ol>
<hr>
<h2 id="5-编码练习"><a href="#5-编码练习" class="headerlink" title="5. 编码练习"></a>5. 编码练习</h2><p>现在，轮到你来实践了！下面是一个 <code>Book</code> 类，它有一个动态分配的字符数组成员 <code>title</code>。请你为它补全拷贝构造函数的实现，确保进行深拷贝。</p>
<p><strong><code>book.h</code></strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOOK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // For strcpy, strlen</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* title; <span class="comment">// 动态分配的书名</span></span><br><span class="line">    <span class="keyword">int</span> pages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Book(<span class="keyword">const</span> <span class="keyword">char</span>* t, <span class="keyword">int</span> p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数 (需要你来实现)</span></span><br><span class="line">    Book(<span class="keyword">const</span> Book&amp; other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Book();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_title</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* new_title)</span></span>; <span class="comment">// 一个修改title的方法，用于测试深拷贝</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// BOOK_H</span></span></span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>book.cpp</code></strong> (你需要填充拷贝构造函数部分)<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"book.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Book::Book(<span class="keyword">const</span> <span class="keyword">char</span>* t, <span class="keyword">int</span> p) : pages(p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(t) + <span class="number">1</span>]; <span class="comment">// +1 for null terminator</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(title, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        title[<span class="number">0</span>] = <span class="string">'\0'</span>; <span class="comment">// Empty string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book '"</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"' constructed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数 (<span class="doctag">TODO:</span> 请你来实现这里的深拷贝逻辑)</span></span><br><span class="line">Book::Book(<span class="keyword">const</span> Book&amp; other) : pages(other.pages) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book copy constructor invoked for creating a copy of '"</span> &lt;&lt; (other.title ? other.title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"'."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// --- 开始你的代码 ---</span></span><br><span class="line">    <span class="keyword">if</span> (other.title) &#123;</span><br><span class="line">        <span class="comment">// 1. 为 this-&gt;title 分配足够的内存 (包括末尾的 '\0')</span></span><br><span class="line">        <span class="comment">// title = new char[...];</span></span><br><span class="line">        <span class="comment">// 2. 使用 std::strcpy 将 other.title 的内容复制到 this-&gt;title</span></span><br><span class="line">        <span class="comment">// std::strcpy(title, other.title);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// title = new char[1];</span></span><br><span class="line">        <span class="comment">// title[0] = '\0';</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --- 结束你的代码 ---</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book '"</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"' (copy) constructed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Book::~Book() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book '"</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"' destructed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] title; <span class="comment">// 使用 delete[] 因为 title 是用 new char[] 分配的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Book::display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Title: "</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">", Pages: "</span> &lt;&lt; pages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Book::set_title</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* new_title)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] title; <span class="comment">// 删除旧标题</span></span><br><span class="line">    <span class="keyword">if</span> (new_title) &#123;</span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(new_title) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(title, new_title);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        title[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book title changed to '"</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"'."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong><code>main_exercise.cpp</code></strong> (用于测试你的实现)<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"book.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating originalBook..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Book <span class="title">originalBook</span><span class="params">(<span class="string">"The Lord of the Rings"</span>, <span class="number">1200</span>)</span></span>;</span><br><span class="line">    originalBook.display();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating copiedBook from originalBook..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Book copiedBook = originalBook; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    copiedBook.display();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Changing title of originalBook..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    originalBook.set_title(<span class="string">"The Hobbit"</span>);</span><br><span class="line">    originalBook.display();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"CopiedBook's title (should remain unchanged if deep copy worked):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    copiedBook.display(); <span class="comment">// 如果是深拷贝，copiedBook的标题不应改变</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating anotherCopiedBook from originalBook..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Book <span class="title">anotherCopiedBook</span><span class="params">(originalBook)</span></span>; <span class="comment">// 再次调用拷贝构造函数</span></span><br><span class="line">    anotherCopiedBook.display();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Program ending. Destructors will be called."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>请你将 <code>book.cpp</code> 中拷贝构造函数 <code>Book::Book(const Book&amp; other)</code> 的 <code>// --- 开始你的代码 ---</code> 和 <code>// --- 结束你的代码 ---</code> 之间的部分补充完整。完成后，将 <code>book.h</code>, <code>book.cpp</code>, <code>main_exercise.cpp</code> 放在一起编译运行，看看结果是否符合预期（修改 <code>originalBook</code> 的标题不应影响 <code>copiedBook</code>）。</p>
<p>当你完成后，请将你修改后的 <code>Book::Book(const Book&amp; other)</code> 函数的完整代码发给我，我会帮你检查。</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"book.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Book::Book(<span class="keyword">const</span> <span class="keyword">char</span>* t, <span class="keyword">int</span> p) : pages(p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(t) + <span class="number">1</span>]; <span class="comment">// +1 for null terminator</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(title, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        title[<span class="number">0</span>] = <span class="string">'\0'</span>; <span class="comment">// Empty string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book '"</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"' constructed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数 (<span class="doctag">TODO:</span> 请你来实现这里的深拷贝逻辑)</span></span><br><span class="line">Book::Book(<span class="keyword">const</span> Book&amp; other) : pages(other.pages) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book copy constructor invoked for creating a copy of '"</span> &lt;&lt; (other.title ? other.title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"'."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// --- 开始你的代码 ---</span></span><br><span class="line">    <span class="keyword">if</span> (other.title) &#123;</span><br><span class="line">        <span class="comment">// 1. 为 this-&gt;title 分配足够的内存 (包括末尾的 '\0')</span></span><br><span class="line">        <span class="comment">// title = new char[...];</span></span><br><span class="line">        <span class="comment">// 2. 使用 std::strcpy 将 other.title 的内容复制到 this-&gt;title</span></span><br><span class="line">        <span class="comment">// std::strcpy(title, other.title);</span></span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(other.title) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(title, other.title);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        title[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --- 结束你的代码 ---</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book '"</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"' (copy) constructed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">Book::~Book() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book '"</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"' destructed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] title; <span class="comment">// 使用 delete[] 因为 title 是用 new char[] 分配的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Book::display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Title: "</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">", Pages: "</span> &lt;&lt; pages &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Book::set_title</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* new_title)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] title; <span class="comment">// 删除旧标题</span></span><br><span class="line">    <span class="keyword">if</span> (new_title) &#123;</span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(new_title) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(title, new_title);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        title[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book title changed to '"</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"'."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>非常好！你对 <code>Book</code> 类拷贝构造函数的实现非常出色！</p>
<hr>
<h2 id="7-评价你的解答与正确答案解析"><a href="#7-评价你的解答与正确答案解析" class="headerlink" title="7. 评价你的解答与正确答案解析"></a>7. 评价你的解答与正确答案解析</h2><h3 id="评价你的解答"><a href="#评价你的解答" class="headerlink" title="评价你的解答"></a>评价你的解答</h3><p><strong>评分：5/5 (优秀)</strong></p>
<p>你的代码成功地实现了 <code>Book</code> 类拷贝构造函数的深拷贝逻辑。</p>
<p><strong>做得好的地方：</strong></p>
<ol>
<li><strong>正确深拷贝：</strong> 你为新对象的 <code>title</code> 指针分配了新的内存空间，并使用 <code>std::strcpy</code> 复制了源对象 <code>title</code> 的内容。这是深拷贝的核心。</li>
<li><strong>处理 <code>nullptr</code>：</strong> 你正确地检查了 <code>other.title</code> 是否为 <code>nullptr</code>。如果源 <code>title</code> 是 <code>nullptr</code>（或指向空字符串，虽然题目中的构造函数会确保它至少指向 <code>\0</code>），你的代码会为新对象的 <code>title</code> 分配内存并将其初始化为一个空字符串 (<code>\0</code>)。这是一个安全且合理的处理方式。</li>
<li><strong>成员初始化列表：</strong> 你使用了成员初始化列表 <code>pages(other.pages)</code> 来复制 <code>pages</code> 成员，这是推荐的做法。</li>
</ol>
<p>你的实现是完全正确的，并且能够通过 <code>main_exercise.cpp</code> 中的测试，即修改一个对象的 <code>title</code> 不会影响其副本的 <code>title</code>。</p>
<h3 id="参考答案与进一步解释"><a href="#参考答案与进一步解释" class="headerlink" title="参考答案与进一步解释"></a>参考答案与进一步解释</h3><p>你的实现本身就是一种正确的答案。下面我们再回顾一下关键点，并展示一个使用<strong>构造函数委托 (constructor delegation)</strong> 的替代版本，它可以帮助减少代码重复（如果适用的话）。</p>
<p><strong>你的正确实现（再次强调）：</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">Book::Book(<span class="keyword">const</span> Book&amp; other) : pages(other.pages) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book copy constructor invoked for creating a copy of '"</span> &lt;&lt; (other.title ? other.title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"'."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (other.title) &#123;</span><br><span class="line">        <span class="comment">// 1. 为 this-&gt;title 分配足够的内存 (包括末尾的 '\0')</span></span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(other.title) + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 2. 使用 std::strcpy 将 other.title 的内容复制到 this-&gt;title</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(title, other.title);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 other.title 是 nullptr (尽管我们的构造函数会避免这种情况，但防御性编程是好的)</span></span><br><span class="line">        <span class="comment">// 或者如果 other.title 就是一个空字符串指针</span></span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        title[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book '"</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"' (copy) constructed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p><strong>解释关键步骤：</strong></p>
<ol>
<li><code>pages(other.pages)</code>：对于像 <code>int</code> 这样的简单数据类型，直接在成员初始化列表中复制其值即可。</li>
<li><code>if (other.title)</code>：检查源对象的 <code>title</code> 是否有效。这是一个好习惯，尽管在当前 <code>Book</code> 类的构造函数中，<code>title</code> 总是被初始化（要么指向一个有效的字符串，要么指向一个只包含 <code>\0</code> 的空字符串）。</li>
<li><code>title = new char[std::strlen(other.title) + 1];</code>：这是深拷贝的核心。为新对象的 <code>title</code> 分配一块全新的内存。内存的大小是源字符串的长度加上1（为了存储末尾的空终止符 <code>\0</code>）。</li>
<li><code>std::strcpy(title, other.title);</code>：将源字符串的内容复制到新分配的内存中。</li>
<li><code>else</code> 分支：如果 <code>other.title</code> 是 <code>nullptr</code> (或逻辑上为空)，为新 <code>title</code> 创建一个表示空字符串的有效指针。</li>
</ol>
<p><strong>使用构造函数委托的替代版本：</strong><br>如果你的主构造函数已经妥善处理了 <code>title</code> 的分配和复制逻辑（就像我们的 <code>Book(const char* t, int p)</code> 一样），你可以使用构造函数委托来简化拷贝构造函数，避免代码重复：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数 (使用构造函数委托的版本)</span></span><br><span class="line">Book::Book(<span class="keyword">const</span> Book&amp; other)</span><br><span class="line">    : Book(other.title, other.pages) &#123; <span class="comment">// 将工作委托给 Book(const char* t, int p)</span></span><br><span class="line">    <span class="comment">// Book(const char* t, int p) 构造函数会处理 title 的 new 和 strcpy，</span></span><br><span class="line">    <span class="comment">// 以及 pages 的初始化。</span></span><br><span class="line">    <span class="comment">// 它也会处理 other.title 为 nullptr 或空字符串的情况。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book copy constructor (delegating version) invoked for creating a copy of '"</span> &lt;&lt; (other.title ? other.title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"'."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 注意：这里我们不需要再显式地操作 this-&gt;title 或 this-&gt;pages，</span></span><br><span class="line">    <span class="comment">// 因为委托的构造函数已经完成了这些工作。</span></span><br><span class="line">    <span class="comment">// 这条额外的 cout 只是为了演示。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个版本更简洁，因为它重用了已有的构造逻辑。主构造函数 <code>Book(const char* t, int p)</code> 的实现如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Book::Book(<span class="keyword">const</span> <span class="keyword">char</span>* t, <span class="keyword">int</span> p) : pages(p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">std</span>::<span class="built_in">strlen</span>(t) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">strcpy</span>(title, t);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        title = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        title[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book '"</span> &lt;&lt; (title ? title : <span class="string">"N/A"</span>) &lt;&lt; <span class="string">"' constructed (by main constructor)."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>当拷贝构造函数 <code>Book(other.title, other.pages)</code> 被调用时，它实际上是调用了 <code>Book::Book(const char* t, int p)</code>，并将 <code>other.title</code> 作为 <code>t</code> 传递，<code>other.pages</code> 作为 <code>p</code> 传递。主构造函数内的逻辑会为新对象正确地分配和复制 <code>title</code>。</p>
<p><strong>编译并运行你的代码的结果应如下所示（部分输出）：</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Creating originalBook...</span><br><span class="line">Book &#39;The Lord of the Rings&#39; constructed.</span><br><span class="line">Title: The Lord of the Rings, Pages: 1200</span><br><span class="line"></span><br><span class="line">Creating copiedBook from originalBook...</span><br><span class="line">Book copy constructor invoked for creating a copy of &#39;The Lord of the Rings&#39;.</span><br><span class="line">Book &#39;The Lord of the Rings&#39; (copy) constructed.</span><br><span class="line">Title: The Lord of the Rings, Pages: 1200</span><br><span class="line"></span><br><span class="line">Changing title of originalBook...</span><br><span class="line">Book title changed to &#39;The Hobbit&#39;.</span><br><span class="line">Title: The Hobbit, Pages: 1200</span><br><span class="line">CopiedBook&#39;s title (should remain unchanged if deep copy worked):</span><br><span class="line">Title: The Lord of the Rings, Pages: 1200 &#x2F;&#x2F; &lt;- 关键：copiedBook的标题未改变</span><br><span class="line"></span><br><span class="line">... (析构函数调用) ...</span><br><span class="line">Book &#39;The Hobbit&#39; destructed.</span><br><span class="line">Book &#39;The Lord of the Rings&#39; destructed.</span><br><span class="line">Book &#39;The Lord of the Rings&#39; destructed.</span><br></pre></td></tr></table></figure></div><br>你的实现应该能得到类似这样的正确结果。</p>
<hr>
<h2 id="8-建议与扩展问题"><a href="#8-建议与扩展问题" class="headerlink" title="8. 建议与扩展问题"></a>8. 建议与扩展问题</h2><ol>
<li><p><strong>拷贝赋值运算符 (<code>operator=</code>)</strong>：</p>
<ul>
<li>你已经正确实现了拷贝构造函数和析构函数。根据 <strong>“Rule of Three” (三法则)</strong>（在现代C++中更倾向于 “Rule of Five” 或 “Rule of Zero”），当你手动管理资源并定义了这两者之一（或拷贝构造函数）时，通常也需要定义<strong>拷贝赋值运算符 (<code>operator=</code>)</strong>。</li>
<li><strong>思考：</strong> <code>Book</code> 类如何实现拷贝赋值运算符？它需要处理哪些额外的情况（例如，自我赋值 <code>bookA = bookA;</code>，以及释放目标对象已有的 <code>title</code> 内存）？<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Book.h 中声明</span></span><br><span class="line"><span class="comment">// Book&amp; operator=(const Book&amp; other);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Book.cpp 中可能的实现框架</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Book&amp; Book::operator=(const Book&amp; other) &#123;</span></span><br><span class="line"><span class="comment">    if (this == &amp;other) &#123; // 1. 检查自赋值</span></span><br><span class="line"><span class="comment">        return *this;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 2. 释放当前对象的资源</span></span><br><span class="line"><span class="comment">    delete[] title;</span></span><br><span class="line"><span class="comment">    title = nullptr; // 置为nullptr，即使下一步new失败，状态也是安全的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 3. 复制源对象的简单成员</span></span><br><span class="line"><span class="comment">    pages = other.pages;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 4. 深拷贝动态分配的资源</span></span><br><span class="line"><span class="comment">    if (other.title) &#123;</span></span><br><span class="line"><span class="comment">        title = new char[std::strlen(other.title) + 1];</span></span><br><span class="line"><span class="comment">        std::strcpy(title, other.title);</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        title = new char[1];</span></span><br><span class="line"><span class="comment">        title[0] = '\0';</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; "Book assignment operator invoked." &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    return *this; // 返回对当前对象的引用</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li><p><strong>使用 <code>std::string</code></strong>：</p>
<ul>
<li>如果 <code>Book</code> 类的 <code>title</code> 成员使用 <code>std::string</code> 而不是 <code>char*</code>，拷贝构造函数、析构函数和拷贝赋值运算符会变得多么简单？</li>
<li><strong>思考：</strong> 如果 <code>title</code> 是 <code>std::string title;</code>，那么编译器自动生成的拷贝构造函数、析构函数和拷贝赋值运算符是否就能正常工作，不再需要我们手动实现深拷贝？（提示：是的，因为 <code>std::string</code> 内部已经正确处理了它自己的内存管理和深拷贝逻辑。）</li>
</ul>
</li>
<li><p><strong>异常安全 (Exception Safety)</strong>：</p>
<ul>
<li>在你的拷贝构造函数中，<code>new char[...]</code> 可能会抛出 <code>std::bad_alloc</code> 异常（如果内存不足）。你的当前实现是异常安全的：如果 <code>new</code> 抛出异常，对象的构造过程会中断，部分构造的对象会被正确销毁（其成员的析构函数会被调用，但对于原始指针 <code>title</code>，在 <code>new</code> 失败时尚未赋值，所以没有内存泄漏）。</li>
<li>对于拷贝赋值运算符，在 <code>delete[] title;</code> 之后，如果接下来的 <code>new char[...]</code> 失败，对象会处于一个有效的状态（<code>title</code> 为 <code>nullptr</code>，<code>pages</code> 可能已更新）。这通常被认为是提供基本异常保证。</li>
</ul>
</li>
<li><p><strong>移动语义 (Move Semantics) (C++11及以后)</strong>：</p>
<ul>
<li>除了拷贝构造函数和拷贝赋值运算符，现代C++还引入了<strong>移动构造函数 (move constructor)</strong> 和<strong>移动赋值运算符 (move assignment operator)</strong>。它们用于从临时对象或明确标记为可移动的对象“窃取”资源，而不是复制，从而提高效率。</li>
<li><strong>思考：</strong> <code>Book</code> 类是否能从移动语义中受益？移动构造函数会如何实现？</li>
</ul>
</li>
</ol>
<p>这些扩展问题可以帮助你更深入地理解C++中的对象生命周期管理和资源管理。做得非常好，继续努力！</p>
<hr>
<h2 id="🧑‍💻-User-2"><a href="#🧑‍💻-User-2" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>有个问题, 如果一个class中没有指针,  那么是不是自动就能深拷贝</p>
<hr>
<h2 id="🤖-Assistant-2"><a href="#🤖-Assistant-2" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>你说得非常对，这是一个很棒的洞察！</p>
<p>是的，<strong>如果一个类中不包含任何原始指针 (raw pointer) 成员（即你自己用 <code>new</code> 分配并需要用 <code>delete</code> 管理的指针），那么编译器自动生成的拷贝构造函数通常就能实现我们期望的“深拷贝”效果，或者更准确地说，它会创建出一个完全独立的对象副本。</strong></p>
<p>让我们来详细解释一下为什么：</p>
<ol>
<li><p><strong>成员逐一拷贝 (Member-wise Copy) 的行为：</strong><br>编译器生成的默认拷贝构造函数会对类的每个成员执行拷贝。</p>
<ul>
<li><strong>对于基本数据类型成员</strong> (如 <code>int</code>, <code>double</code>, <code>char</code>, <code>bool</code> 等)：直接复制它们的值。这本身就是一种“深拷贝”，因为值被复制了，新对象有自己的独立值。</li>
<li><strong>对于对象类型成员</strong> (如 <code>std::string</code>, <code>std::vector</code>, <code>std::map</code>，或者你自己写的其他没有原始指针的类对象)：编译器会调用这些成员对象<strong>它们自己的拷贝构造函数</strong>。</li>
</ul>
</li>
<li><p><strong>标准库容器和类的行为：</strong><br>像 <code>std::string</code>, <code>std::vector</code>, <code>std::list</code>, <code>std::map</code> 等标准库类，它们内部可能使用了指针来管理动态分配的内存（例如 <code>std::string</code> 内部有指向字符数组的指针，<code>std::vector</code> 内部有指向其元素存储区的指针）。<br><strong>但是，这些标准库类被设计得非常好，它们自己的拷贝构造函数已经正确地实现了深拷贝逻辑。</strong><br>所以，当你拷贝一个包含 <code>std::string</code> 成员的类时：</p>
<ul>
<li>你的类的默认拷贝构造函数被调用。</li>
<li>对于 <code>std::string</code> 成员，它会调用 <code>std::string</code> 的拷贝构造函数。</li>
<li><code>std::string</code> 的拷贝构造函数会分配新的内存，并把源字符串的内容复制到新内存中。<br>结果就是，你的新对象的 <code>std::string</code> 成员拥有了自己独立的字符串数据副本。对于 <code>std::vector</code> 等其他容器也是同理。</li>
</ul>
</li>
<li><p><strong>结论：</strong><br>因此，如果你的类 <code>MyClass</code> 构成为：</p>
<ul>
<li>基本数据类型。</li>
<li>其他类的对象，而这些类本身正确地实现了拷贝语义（比如标准库类，或者你自己写的、遵循了“三/五/零法则”的类）。<br>那么，<code>MyClass</code> 的默认拷贝构造函数通过逐个调用其成员的（正确的）拷贝操作，最终会产生一个与源对象完全独立的新对象。修改源对象不会影响副本，反之亦然。在这种情况下，你通常不需要自己编写拷贝构造函数、析构函数或拷贝赋值运算符（这就是所谓的 <strong>“Rule of Zero” (零法则)</strong> 的精神：如果类不直接管理资源，就让编译器生成默认的特殊成员函数）。</li>
</ul>
</li>
</ol>
<p><strong>例子：</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name; <span class="comment">// std::string handles its own deep copy</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; scores; <span class="comment">// std::vector handles its own deep copy</span></span><br><span class="line"></span><br><span class="line">    Student(<span class="keyword">int</span> i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; n) : id(i), name(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_score</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        scores.push_back(score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ID: "</span> &lt;&lt; id &lt;&lt; <span class="string">", Name: "</span> &lt;&lt; name &lt;&lt; <span class="string">", Scores: "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> score : scores) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; score &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要自定义拷贝构造函数、析构函数、拷贝赋值运算符</span></span><br><span class="line">    <span class="comment">// 编译器生成的版本就足够了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">101</span>, <span class="string">"Alice"</span>)</span></span>;</span><br><span class="line">    s1.add_score(<span class="number">90</span>);</span><br><span class="line">    s1.add_score(<span class="number">85</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"s1: "</span>;</span><br><span class="line">    s1.print();</span><br><span class="line"></span><br><span class="line">    Student s2 = s1; <span class="comment">// 调用编译器生成的拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"s2 (copy of s1): "</span>;</span><br><span class="line">    s2.print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 s2</span></span><br><span class="line">    s2.id = <span class="number">102</span>;</span><br><span class="line">    s2.name = <span class="string">"Bob"</span>;</span><br><span class="line">    s2.add_score(<span class="number">77</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nAfter modifying s2:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"s1: "</span>;</span><br><span class="line">    s1.print(); <span class="comment">// s1 应该不受影响</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"s2: "</span>;</span><br><span class="line">    s2.print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br>在这个例子中，<code>Student</code> 类没有显式定义拷贝构造函数。当你执行 <code>Student s2 = s1;</code> 时：</p>
<ul>
<li><code>s2.id</code> 会得到 <code>s1.id</code> 的值的副本。</li>
<li><code>s2.name</code> 会通过调用 <code>std::string</code> 的拷贝构造函数来初始化，得到 <code>s1.name</code> 的深拷贝。</li>
<li><code>s2.scores</code> 会通过调用 <code>std::vector&lt;int&gt;</code> 的拷贝构造函数来初始化，得到 <code>s1.scores</code> 的深拷贝。</li>
</ul>
<p>因此，<code>s1</code> 和 <code>s2</code> 是完全独立的对象。</p>
<p><strong>总结一下：</strong><br>“深拷贝”这个概念之所以如此重要和被强调，主要是因为当类中包含<strong>原始指针</strong>，并且该类<strong>直接负责这些指针所指向内存的分配和释放</strong>时，默认的成员逐一拷贝（即浅拷贝这些指针）就会出问题。如果类不直接管理这种原始指针资源，而是依赖于像 <code>std::string</code> 或 <code>std::vector</code> 这样的“资源管理类”成员，那么通常就不需要担心深拷贝的问题，因为这些成员类会自己处理好。</p>
<p>所以，你的理解是正确的：<strong>没有（手动管理的）指针，通常默认就能得到功能上等同于深拷贝的独立副本。</strong></p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Function/">Function    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Object/">Object    </a><a class="post-meta__tags" href="/tags/Programming/">Programming    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/281%20-%20cpp%20this%20%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>281 - cpp this 指针详解与应用</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/321%20-%20%E7%B1%BB%E5%86%85%E5%8F%98%E9%87%8F%E8%87%AA%E5%BC%95%E7%94%A8/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>321 - 类内变量自引用</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/299 - 显式构造函数/" title="299 - 显式构造函数"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">299 - 显式构造函数</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/notes/Cpp 默认构造函数创建对象/" title="Cpp 默认构造函数创建对象"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">Cpp 默认构造函数创建对象</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/278 - cpp 指针管理类对象示例/" title="278 - cpp 指针管理类对象示例"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">278 - cpp 指针管理类对象示例</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/283 - cpp 类对象大小探究/" title="283 - cpp 类对象大小探究"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">283 - cpp 类对象大小探究</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/286 - const 对象问题与指针引用访问/" title="286 - const 对象问题与指针引用访问"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">286 - const 对象问题与指针引用访问</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/287 - const 对象作为函数参数的注意事项/" title="287 - const 对象作为函数参数的注意事项"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">287 - const 对象作为函数参数的注意事项</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>