<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>305 - 已删除构造 函数使用 | Bear's dream</title><meta name="description" content="305 - 已删除构造 函数使用"><meta name="keywords" content="Cpp,Coding,Development,Class,Constructor"><meta name="author" content="supersheepbear"><meta name="copyright" content="supersheepbear"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon_1.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="p43hXBn3_dLvbyxUzx0eo5eYmj9OVYOV52pdrhBa2sw"><meta name="baidu-site-verification" content="EXLlfLv2pV"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="305 - 已删除构造 函数使用"><meta name="twitter:description" content="305 - 已删除构造 函数使用"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta property="og:type" content="article"><meta property="og:title" content="305 - 已删除构造 函数使用"><meta property="og:url" content="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/305%20-%20%E5%B7%B2%E5%88%A0%E9%99%A4%E6%9E%84%E9%80%A0%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"><meta property="og:site_name" content="Bear's dream"><meta property="og:description" content="305 - 已删除构造 函数使用"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/305%20-%20%E5%B7%B2%E5%88%A0%E9%99%A4%E6%9E%84%E9%80%A0%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"><link rel="prev" title="304 - 移动构造函数窃取" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/304%20-%20%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%AA%83%E5%8F%96/"><link rel="next" title="306 -  cpp 初始化列表构造函数详解" href="https://yxiong.org/2025/06/08/10-projects/cplusplus/lectures/306%20-%20%20cpp%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><link rel="stylesheet" href="hfttps://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Bear's dream" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bear's dream</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200520153141.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">151</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 音乐照片</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 学习计划</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#已删除构造-函数使用"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">已删除构造 函数使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#C-进阶：深入理解已删除的构造函数-delete"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">C++ 进阶：深入理解已删除的构造函数 (&#x3D; delete)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-什么是已删除的构造函数？-What-Are-Deleted-Constructors"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">1. 什么是已删除的构造函数？(What Are Deleted Constructors?)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-为什么需要已删除的构造函数？-Why-Do-We-Need-Deleted-Constructors"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">2. 为什么需要已删除的构造函数？(Why Do We Need Deleted Constructors?)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-如何使用已删除的构造函数？-How-To-Use-Deleted-Constructors"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">3. 如何使用已删除的构造函数？(How To Use Deleted Constructors?)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-代码示例-Code-Example"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">4. 代码示例 (Code Example)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-QA-闪卡-QA-Flashcards"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">5. QA 闪卡 (QA Flashcards)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-常见误解或错误-Common-Misunderstandings-or-Mistakes"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">6. 常见误解或错误 (Common Misunderstandings or Mistakes)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-编程练习-Coding-Exercise"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">7. 编程练习 (Coding Exercise)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🧑‍💻-User-1"><span class="toc_mobile_items-number">1.11.</span> <span class="toc_mobile_items-text">🧑‍💻 User</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#🤖-Assistant-1"><span class="toc_mobile_items-number">1.12.</span> <span class="toc_mobile_items-text">🤖 Assistant</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-解决方案评级与讲解-Solution-Rating-and-Explanation"><span class="toc_mobile_items-number">1.13.</span> <span class="toc_mobile_items-text">8. 解决方案评级与讲解 (Solution Rating and Explanation)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-进一步思考和扩展问题-Suggestions-for-Extended-Questions"><span class="toc_mobile_items-number">1.14.</span> <span class="toc_mobile_items-text">9. 进一步思考和扩展问题 (Suggestions for Extended Questions)</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#已删除构造-函数使用"><span class="toc-number">1.</span> <span class="toc-text">已删除构造 函数使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User"><span class="toc-number">1.1.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant"><span class="toc-number">1.2.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-进阶：深入理解已删除的构造函数-delete"><span class="toc-number">1.3.</span> <span class="toc-text">C++ 进阶：深入理解已删除的构造函数 (&#x3D; delete)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是已删除的构造函数？-What-Are-Deleted-Constructors"><span class="toc-number">1.4.</span> <span class="toc-text">1. 什么是已删除的构造函数？(What Are Deleted Constructors?)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-为什么需要已删除的构造函数？-Why-Do-We-Need-Deleted-Constructors"><span class="toc-number">1.5.</span> <span class="toc-text">2. 为什么需要已删除的构造函数？(Why Do We Need Deleted Constructors?)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-如何使用已删除的构造函数？-How-To-Use-Deleted-Constructors"><span class="toc-number">1.6.</span> <span class="toc-text">3. 如何使用已删除的构造函数？(How To Use Deleted Constructors?)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-代码示例-Code-Example"><span class="toc-number">1.7.</span> <span class="toc-text">4. 代码示例 (Code Example)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-QA-闪卡-QA-Flashcards"><span class="toc-number">1.8.</span> <span class="toc-text">5. QA 闪卡 (QA Flashcards)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-常见误解或错误-Common-Misunderstandings-or-Mistakes"><span class="toc-number">1.9.</span> <span class="toc-text">6. 常见误解或错误 (Common Misunderstandings or Mistakes)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-编程练习-Coding-Exercise"><span class="toc-number">1.10.</span> <span class="toc-text">7. 编程练习 (Coding Exercise)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🧑‍💻-User-1"><span class="toc-number">1.11.</span> <span class="toc-text">🧑‍💻 User</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#🤖-Assistant-1"><span class="toc-number">1.12.</span> <span class="toc-text">🤖 Assistant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-解决方案评级与讲解-Solution-Rating-and-Explanation"><span class="toc-number">1.13.</span> <span class="toc-text">8. 解决方案评级与讲解 (Solution Rating and Explanation)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-进一步思考和扩展问题-Suggestions-for-Extended-Questions"><span class="toc-number">1.14.</span> <span class="toc-text">9. 进一步思考和扩展问题 (Suggestions for Extended Questions)</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)"><div id="post-info"><div id="post-title"><div class="posttitle">305 - 已删除构造 函数使用</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2025-06-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2025-06-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/">10-projects</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/">cplusplus</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/10-projects/cplusplus/lectures/">lectures</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2025/06/08/10-projects/cplusplus/lectures/305%20-%20%E5%B7%B2%E5%88%A0%E9%99%A4%E6%9E%84%E9%80%A0%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2025/06/08/10-projects/cplusplus/lectures/305%20-%20%E5%B7%B2%E5%88%A0%E9%99%A4%E6%9E%84%E9%80%A0%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="已删除构造-函数使用"><a href="#已删除构造-函数使用" class="headerlink" title="已删除构造 函数使用"></a>已删除构造 函数使用</h1><h2 id="🧑‍💻-User"><a href="#🧑‍💻-User" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><p>In this lecture, we’re going to learn about the leading constructors.And this is a feature we have in C plus plus to disable some constructors and prevent them from beingused to build objects.And the syntax to do that is ridiculously easy.All you have to do is say equals and say delete and put a semicolon at the end.And from this point on you won’t have to implement this constructor.And anytime somebody tries to use a syntax that is going to call this constructor, they are going toget a compiler error saying that they can’t use this constructor because it was deleted.So for example, here we have disabled the default non parameter constructor.We have disabled the copy constructor and we have disabled the Move constructor.If we try to use them, we’re going to get a compiler error.So let’s head over to Visual Studio code and try this on some real code.Okay, so here we are in our working folder.The current project is deleted constructors.We are going to grab our template files like we always do and we’re going to paste that in our lecture,which is deleted constructors and we’re going to grab the class from the last lecture, which is thepoint class here, and we’re going to reuse it in this lecture because we don’t want to redesign it.So let’s paste that in here and then we’re going to open this in Visual Studio code.By dragging and dropping here, this is going to open our project.We can open the Main.cpp file, we can open our class, we can open the files for our class point eightand point CP, and then we’re going to close the sidebar here.So what we want to do is to mark a few constructors as deleted, so we want to delete the default nonparameter constructor.So what we’re going to do in this class is say point, and then we’re going to say that this constructorwas deleted by using this syntax here we’re going to say equals and say delete.And this constructor from this point on will be prevented from being used in this class here.We’re going to go down and delete all the other constructors we don’t need.We are just going to leave in this constructor.That’s what we want people to use to build our objects.Here we have this much control so we can disable the copy constructor.We’re going to delete it and we’re going to disable the Move constructor.We’re also going to delete it.And after you delete the constructor, you don’t have to implement that anymore in the CPP file.So what we’re going to do is comment out all these constructors we don’t want, so we’re going to commentout the Move constructor, we’re going to comment out the copy constructor and we’re not going to implementthe non parameter default constructor.And you see that in our header files.We don’t have any squiggly lines because this constructors are not implemented.Let’s go back in main and use our point class.We’re going to include that, we’re going to include point and then we’re going to set up an objectof point using the constructor that we support now.So we’re going to say point and say P one and we’re going to use two parameters or two arguments.We’re going to put in a few numbers here.And we’re going to build an object and for example, print information about this object.So we’re going to say P one print info and you’re going to see that this is going to work just fine.If we build, the world is going to be good, as you see here, and we kind of bring up a terminal andactually try this out, we can clear and run Rooster.We’re going to see that we have the information about our point and everything is as we expect.But if we try to use other constructors, let’s try to do that and use a non parameter constructor.By setting up our point like this.We’re going to get a compiler error here because we’re not allowed to use this constructor.If we go in, we’re going to say the default constructor of point cannot be referenced.It is a deleted function.We have deleted it and people can’t use it to build the objects.And this is what you achieve with deleted constructors.We have also deleted a couple of other constructors.For example, the copy constructor is deleted.So if we try to build an object from the copy constructor, we’re going to get a compiler error.Let’s do that.We’re going to set up another point and we’re going to say p zero, for example, and we’re going toput in some data.Let’s put in 4.6 and 5.2.We can do this and then we’re going to try and construct P one from P zero and we’re going to do somethinglike this.This is going to call the copy constructor.We need to use a dot here, not a comma for p zero to be valid here.But you see that if we try to call the copy constructor, we’re going to be prevented from doing this.Because point the.Copy constructor has been deleted.Okay, so we don’t see the entire thing here, but if we hover over here, we see that the functionthat we are trying to call is a deleted function.Okay, so we can’t call this.And if we try to build our program and ignore what we see from Visual Studio code, we’re going to geta compiler error and it is going to say use of deleted function.The copy constructor was deleted.You can’t build objects using the copy constructor.We can also see that the Move constructor was deleted.We’re going to set up a syntax which is going to build an object in place and it is essentially goingto be a temporary.So we’re going to grab what we have here and we’re going to cut it out and then we’re going to say Stdmoveand we’re going to pass in our temporary here.And this is a setup that is going to call the Move constructor.But again, this is not going to work because the Move constructor has been deleted.If we go in our class, we’re going to see that it has been deleted, so we can’t really build objectsfrom our Move constructor.Let’s see what Visual Studio code is saying here.Use of deleted function const point reference.This is not very clear, but we can try to build and see what we get.We’re going to get a compiler error and we’re going to see that we are trying to use a function thathas been deleted and that function is the Move constructor.So it has been deleted and we cannot use it.So and you see that Visual Studio code has came to its senses.It is saying that it is the Move constructor, but this is really all this lecture is about.If you don’t want a constructor to be used to build objects, you can delete it and people are goingto get a compiler error if they try to use it.Okay.Some of you might be asking why would I want to delete my constructor?Because what we want as developers is to give people more flexibility in using what we develop.But sometimes it really doesn’t make sense to do some things.For example, sometimes you don’t want your object copied because copying objects is going to make yourdesign really shaky and sometimes you really want this.Unfortunately, I don’t have an easy example I can give you right now and you are definitely going tocome across this in your career as a C plus plus developer.So note that you can delete your constructors and disable people from using them to build objects ofyour classes.This is really all we set out to do in this lecture.I hope you found it interesting.We are going to stop here in this one and the next one we’re going to learn about initializer List constructors.Go ahead and finish up here and meet me there.</p>
<hr>
<h2 id="🤖-Assistant"><a href="#🤖-Assistant" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>好的，C++学习者你好！很高兴能成为你的C++导师。今天我们将深入探讨一个非常重要的C++特性：<strong>已删除的构造函数</strong>。这个概念能让你更好地控制类的行为和对象的创建。</p>
<hr>
<h2 id="C-进阶：深入理解已删除的构造函数-delete"><a href="#C-进阶：深入理解已删除的构造函数-delete" class="headerlink" title="C++ 进阶：深入理解已删除的构造函数 (= delete)"></a><strong>C++ 进阶：深入理解已删除的构造函数 (<code>= delete</code>)</strong></h2><p><strong>摘要：</strong> 本节课将详细讲解C++中如何使用<code>= delete</code>语法来禁用（删除）特定构造函数，从而阻止用户通过这些方式创建对象。我们将探讨其目的、语法、应用场景以及相关注意事项，并通过代码示例加深理解。</p>
<hr>
<h2 id="1-什么是已删除的构造函数？-What-Are-Deleted-Constructors"><a href="#1-什么是已删除的构造函数？-What-Are-Deleted-Constructors" class="headerlink" title="1. 什么是已删除的构造函数？(What Are Deleted Constructors?)"></a><strong>1. 什么是已删除的构造函数？(What Are Deleted Constructors?)</strong></h2><p>在C++中，<code>= delete</code> 语法是一种强大的机制，允许我们显式地禁用（或者说“删除”）类的特定成员函数，最常见的应用就是删除构造函数 (constructor) 和赋值运算符 (assignment operator)。当一个构造函数被标记为“已删除”后，任何试图调用该构造函数来创建对象的代码都将在编译时 (compile time) 收到错误，从而有效阻止了此类对象的生成。</p>
<p><strong>核心思想：</strong><br>想象一下你设计了一个复杂的类，你希望使用者只能通过某种特定方式来创建这个类的对象，而禁止其他方式（比如不允许拷贝、不允许默认构造等）。这时，你就可以使用“已删除的构造函数”来实现这种限制。</p>
<h2 id="2-为什么需要已删除的构造函数？-Why-Do-We-Need-Deleted-Constructors"><a href="#2-为什么需要已删除的构造函数？-Why-Do-We-Need-Deleted-Constructors" class="headerlink" title="2. 为什么需要已删除的构造函数？(Why Do We Need Deleted Constructors?)"></a><strong>2. 为什么需要已删除的构造函数？(Why Do We Need Deleted Constructors?)</strong></h2><p>你可能会问：“为什么我要禁用构造函数呢？作为开发者，不是应该提供更多灵活性吗？” 这通常出于以下几个重要的设计考虑：</p>
<ol>
<li><p><strong>资源管理与唯一性 (Resource Management and Uniqueness):</strong></p>
<ul>
<li><strong>示例：管理唯一资源</strong> 假设你的类管理着一个独占性的资源，比如一个文件句柄、一个网络连接或者一个硬件设备接口。这类资源通常是唯一的，不能被随意拷贝或移动。如果允许拷贝，可能会导致多个对象试图管理同一个资源，造成双重释放 (double free) 或资源竞争 (resource contention) 等问题。通过删除拷贝构造函数 (copy constructor) 和移动构造函数 (move constructor)，你可以强制确保对象是独一无二的，从而避免这些复杂的资源管理问题。<code>std::unique_ptr</code>就是一个很好的例子，它就是通过删除拷贝构造函数来实现其独占性语义的。</li>
</ul>
</li>
<li><p><strong>强制特定构造方式 (Enforcing Specific Construction Methods):</strong></p>
<ul>
<li>你可能希望用户只能通过提供特定参数来初始化对象，而不是使用默认构造函数。例如，一个<code>Point</code>类可能要求必须提供X和Y坐标才能创建，不允许默认构造一个未定义坐标的点。</li>
</ul>
</li>
<li><p><strong>防止不合理的操作 (Preventing Illogical Operations):</strong></p>
<ul>
<li>有些类的概念设计上就不应该被拷贝。例如，一个表示“线程”的类，拷贝一个运行中的线程是没有意义的，甚至可能导致程序崩溃。</li>
</ul>
</li>
<li><p><strong>接口设计与控制 (Interface Design and Control):</strong></p>
<ul>
<li>通过禁用某些构造函数，你可以在API层面就明确告诉用户：“这个类的对象不能这样创建。”这有助于开发者更好地理解和正确使用你的类。</li>
</ul>
</li>
</ol>
<h2 id="3-如何使用已删除的构造函数？-How-To-Use-Deleted-Constructors"><a href="#3-如何使用已删除的构造函数？-How-To-Use-Deleted-Constructors" class="headerlink" title="3. 如何使用已删除的构造函数？(How To Use Deleted Constructors?)"></a><strong>3. 如何使用已删除的构造函数？(How To Use Deleted Constructors?)</strong></h2><p>使用已删除的构造函数非常简单，只需要在构造函数的声明 (declaration) 后加上 <code>= delete;</code> 即可。</p>
<p><strong>语法：</strong><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassName() = <span class="keyword">delete</span>; <span class="comment">// 禁用默认构造函数</span></span><br><span class="line">ClassName(<span class="keyword">const</span> ClassName&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">ClassName(ClassName&amp;&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁用移动构造函数</span></span><br></pre></td></tr></table></figure></div></p>
<p><strong>关键点：</strong></p>
<ul>
<li><strong>声明处禁用：</strong> <code>= delete;</code> 必须放在函数的声明处，通常在类的头文件 (.h 或 .hpp) 中。</li>
<li><strong>无需实现：</strong> 一旦一个函数被标记为 <code>= delete;</code>，你就 <strong>不需要</strong> (也无法) 在对应的 .cpp 文件中提供它的定义 (definition) 或实现 (implementation)。如果尝试提供实现，编译器会报错。</li>
<li><strong>编译时错误：</strong> 任何尝试调用已删除构造函数的代码都会在编译阶段被拦截，生成清晰的编译器错误信息，告知用户该函数已被删除，不能使用。</li>
</ul>
<p>接下来，我们将通过具体的代码示例来展示如何删除不同类型的构造函数。</p>
<h2 id="4-代码示例-Code-Example"><a href="#4-代码示例-Code-Example" class="headerlink" title="4. 代码示例 (Code Example)"></a><strong>4. 代码示例 (Code Example)</strong></h2><p>我们以一个简单的 <code>Point</code> 类为例，演示如何删除其默认构造函数、拷贝构造函数和移动构造函数。我们只允许通过提供X和Y坐标来创建 <code>Point</code> 对象。</p>
<p><strong><code>Point.h</code> (头文件):</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> POINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 允许的构造函数：必须提供x和y坐标</span></span><br><span class="line">    Point(<span class="keyword">double</span> x, <span class="keyword">double</span> y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==========================================================</span></span><br><span class="line">    <span class="comment">// 已删除的构造函数示例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 删除默认构造函数 (Default Constructor):</span></span><br><span class="line">    <span class="comment">//    阻止用户使用 Point p; 或 Point p&#123;&#125;; 这样的语法来创建对象。</span></span><br><span class="line">    Point() = <span class="keyword">delete</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 删除拷贝构造函数 (Copy Constructor):</span></span><br><span class="line">    <span class="comment">//    阻止用户使用 Point p2 = p1; 或 Point p2(p1); 这样的语法来创建对象。</span></span><br><span class="line">    <span class="comment">//    这对于管理独占资源（如文件句柄）的类非常有用，可以防止资源被多重管理。</span></span><br><span class="line">    Point(<span class="keyword">const</span> Point&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 删除移动构造函数 (Move Constructor):</span></span><br><span class="line">    <span class="comment">//    阻止用户使用 Point p2 = std::move(p1); 这样的语法来创建对象。</span></span><br><span class="line">    <span class="comment">//    通常与拷贝构造函数一起删除，以彻底禁止对象的拷贝和移动。</span></span><br><span class="line">    Point(Point&amp;&amp; other) = <span class="keyword">delete</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==========================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数：打印点的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数 (Destructor): 演示对象的销毁</span></span><br><span class="line">    ~Point();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_x;</span><br><span class="line">    <span class="keyword">double</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// POINT_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>Point.cpp</code> (源文件):</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现允许的构造函数</span></span><br><span class="line">Point::Point(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : m_x(x), m_y(y) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point 构造函数: ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">") 被调用."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现析构函数</span></span><br><span class="line">Point::~Point() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point 析构函数: ("</span> &lt;&lt; m_x &lt;&lt; <span class="string">", "</span> &lt;&lt; m_y &lt;&lt; <span class="string">") 被调用."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现打印信息函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Point 信息: X = "</span> &lt;&lt; m_x &lt;&lt; <span class="string">", Y = "</span> &lt;&lt; m_y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这里不需要为已删除的构造函数提供任何实现！</span></span><br><span class="line"><span class="comment">// 如果你尝试实现它们，编译器会报错。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 错误的示例：尝试实现已删除的默认构造函数</span></span><br><span class="line"><span class="comment">Point::Point() &#123;</span></span><br><span class="line"><span class="comment">    // 错误：已删除的函数不能有定义</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 错误的示例：尝试实现已删除的拷贝构造函数</span></span><br><span class="line"><span class="comment">Point::Point(const Point&amp; other) &#123;</span></span><br><span class="line"><span class="comment">    // 错误：已删除的函数不能有定义</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 错误的示例：尝试实现已删除的移动构造函数</span></span><br><span class="line"><span class="comment">Point::Point(Point&amp;&amp; other) &#123;</span></span><br><span class="line"><span class="comment">    // 错误：已删除的函数不能有定义</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code> (主程序文件):</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Point.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 引入iostream for std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;  // 引入utility for std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 测试已删除的构造函数 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 成功创建对象 (使用允许的构造函数)</span></span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10.0</span>, <span class="number">20.0</span>)</span></span>;</span><br><span class="line">    p1.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 尝试使用已删除的构造函数，这些都将导致编译错误 ---</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尝试使用默认构造函数 (将导致编译错误)</span></span><br><span class="line">    <span class="comment">// Point p_default; // 错误：试图使用已删除的默认构造函数</span></span><br><span class="line">    <span class="comment">// Point p_default_curly&#123;&#125;; // 错误：试图使用已删除的默认构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 尝试使用拷贝构造函数 (将导致编译错误)</span></span><br><span class="line">    <span class="comment">// Point p_copy = p1; // 错误：试图使用已删除的拷贝构造函数</span></span><br><span class="line">    <span class="comment">// Point p_copy_paren(p1); // 错误：试图使用已删除的拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 尝试使用移动构造函数 (将导致编译错误)</span></span><br><span class="line">    <span class="comment">// Point p_move = std::move(p1); // 错误：试图使用已删除的移动构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保持程序运行，观察析构函数调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 程序结束 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>编译和运行：</strong></p>
<p>当你尝试编译上述 <code>main.cpp</code> 文件时，如果你解除了注释那些尝试调用已删除构造函数的行，编译器会立即报错。</p>
<p>例如，对于 <code>Point p_default;</code>，你可能会看到类似如下的错误信息（具体信息可能因编译器而异，但大意相同）：<br><code>error: call to deleted constructor of &#39;Point&#39;</code><br>或者<br><code>error: use of deleted function &#39;Point::Point()&#39;</code></p>
<p>这正是我们想要的效果：在程序运行之前，就阻止了不符合设计意图的对象创建。</p>
<h2 id="5-QA-闪卡-QA-Flashcards"><a href="#5-QA-闪卡-QA-Flashcards" class="headerlink" title="5. QA 闪卡 (QA Flashcards)"></a><strong>5. QA 闪卡 (QA Flashcards)</strong></h2><p><strong>Q1:</strong> <code>Point() = delete;</code> 这行代码在C++中有什么作用？<br><strong>A1:</strong> 它声明 <code>Point</code> 类的默认构造函数被显式删除，这意味着你不能再通过 <code>Point obj;</code> 或 <code>Point obj{};</code> 这样的方式来创建 <code>Point</code> 类的对象。任何尝试都会导致编译错误。</p>
<p><strong>Q2:</strong> 如果一个构造函数被标记为 <code>= delete;</code>，我还需要在 <code>.cpp</code> 文件中为它提供实现吗？<br><strong>A2:</strong> <strong>不需要。</strong> 恰恰相反，如果一个函数被标记为 <code>= delete;</code>，你不能为它提供实现。尝试这样做会导致编译错误。</p>
<p><strong>Q3:</strong> 尝试使用已删除的构造函数会发生什么？<br><strong>A3:</strong> 编译器会立即报错，阻止程序编译成功。这是一种编译时错误，能有效避免运行时出现意外行为。</p>
<p><strong>Q4:</strong> 除了构造函数，<code>= delete;</code> 还可以用来删除哪些C++类的成员函数？<br><strong>A4:</strong> <code>= delete;</code> 不仅可以删除各种构造函数（默认、拷贝、移动），还可以删除拷贝赋值运算符 (copy assignment operator)、移动赋值运算符 (move assignment operator) 以及其他成员函数（包括非特殊成员函数）。</p>
<p><strong>Q5:</strong> 请举一个删除构造函数的实际应用场景。<br><strong>A5:</strong> 最常见的场景是设计一个管理独占性资源（如文件句柄、数据库连接）的类。为了防止资源被多重管理导致问题，我们会删除其拷贝构造函数和拷贝赋值运算符，甚至移动构造函数，以确保每个资源实例都是唯一的。例如，<code>std::unique_ptr</code> 就是通过删除拷贝构造函数和拷贝赋值运算符来实现其独占所有权语义的。</p>
<h2 id="6-常见误解或错误-Common-Misunderstandings-or-Mistakes"><a href="#6-常见误解或错误-Common-Misunderstandings-or-Mistakes" class="headerlink" title="6. 常见误解或错误 (Common Misunderstandings or Mistakes)"></a><strong>6. 常见误解或错误 (Common Misunderstandings or Mistakes)</strong></h2><ol>
<li><p><strong>混淆 <code>delete</code> 关键字：</strong></p>
<ul>
<li><strong>误解：</strong> 认为 <code>Point() = delete;</code> 中的 <code>delete</code> 和 <code>new</code>/<code>delete</code> 运算符中的 <code>delete</code> 是一回事。</li>
<li><strong>纠正：</strong> 两者完全不同。<code>new</code>/<code>delete</code> 是用于动态内存分配和释放的运算符。而 <code>= delete;</code> 是一种函数声明语法，用于禁用特定的函数。它们在C++中的作用和语义是截然不同的。</li>
</ul>
</li>
<li><p><strong>为已删除的函数提供实现：</strong></p>
<ul>
<li><strong>误解：</strong> 在头文件声明 <code>= delete;</code> 后，仍然在 <code>.cpp</code> 文件中提供了该函数的定义。</li>
<li><strong>纠正：</strong> 这是错误的。一旦函数被标记为 <code>= delete;</code>，就意味着它不应该被实现，编译器会因此报错。</li>
</ul>
</li>
<li><p><strong>不理解删除构造函数的目的：</strong></p>
<ul>
<li><strong>误解：</strong> 认为删除构造函数是为了“节省内存”或“优化性能”。</li>
<li><strong>纠正：</strong> 删除构造函数的主要目的是为了<strong>控制对象创建行为</strong>和<strong>加强类设计语义</strong>。它与内存或性能优化通常没有直接关系（尽管可以间接帮助避免不必要的拷贝带来的性能开销，但这不是主要目的）。其核心在于强制执行特定的设计规则，例如确保资源独占或对象必须通过特定方式初始化。</li>
</ul>
</li>
<li><p><strong>过度删除导致可用性问题：</strong></p>
<ul>
<li><strong>误解：</strong> 觉得所有构造函数都删除会更“安全”。</li>
<li><strong>纠正：</strong> 如果删除了所有可用的构造函数，那么你的类将无法被实例化，这通常不是你想要的结果。你需要确保至少有一个构造函数是可用的，以便用户能够创建对象。同时，如果一个类没有显式声明拷贝构造函数和拷贝赋值运算符，C++会自动为其生成（如果满足条件）。如果你想阻止它们，你需要显式地 <code>= delete;</code> 它们。</li>
</ul>
</li>
<li><p><strong>忘记隐式生成规则：</strong></p>
<ul>
<li><strong>误解：</strong> 认为只要不显式声明拷贝构造函数，就不会发生拷贝。</li>
<li><strong>纠正：</strong> 如果你不显式声明拷贝构造函数，C++编译器会在需要时为你<strong>隐式生成</strong>一个默认的拷贝构造函数。要真正禁用拷贝，你必须<strong>显式地</strong>将其 <code>= delete;</code>。对于移动构造函数和移动赋值运算符也是类似的。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="7-编程练习-Coding-Exercise"><a href="#7-编程练习-Coding-Exercise" class="headerlink" title="7. 编程练习 (Coding Exercise)"></a><strong>7. 编程练习 (Coding Exercise)</strong></h2><p>现在，轮到你来动手实践了！</p>
<p>请根据以下要求，完善 <code>Book</code> 类的定义：</p>
<p><strong>目标：</strong></p>
<ol>
<li><strong>禁用默认构造函数：</strong> 确保每本书在创建时都必须提供书名和作者。</li>
<li><strong>禁用拷贝构造函数：</strong> 确保 <code>Book</code> 对象不能被拷贝，每本书都是独特的。</li>
<li><strong>允许通过书名和作者构造：</strong> 保持现有的带参数构造函数。</li>
<li><strong>提供一个打印信息的方法。</strong></li>
</ol>
<p><strong><code>Book.h</code>:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOOK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 允许的构造函数：通过书名和作者创建书籍</span></span><br><span class="line">    Book(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; title, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; author);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1: 在这里禁用默认构造函数，确保每本书都有书名和作者。</span></span><br><span class="line">    <span class="comment">// 提示：使用 `= delete;` 语法。</span></span><br><span class="line">    <span class="comment">// Book(); // 在这里添加你的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2: 在这里禁用拷贝构造函数，确保Book对象不能被拷贝。</span></span><br><span class="line">    <span class="comment">// 提示：使用 `= delete;` 语法。</span></span><br><span class="line">    <span class="comment">// Book(const Book&amp; other); // 在这里添加你的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印书籍信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_title;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_author;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// BOOK_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>Book.cpp</code>:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Book.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">Book::Book(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; title, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; author)</span><br><span class="line">    : m_title(title), m_author(author) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Book 构造函数: \""</span> &lt;&lt; m_title &lt;&lt; <span class="string">"\" by "</span> &lt;&lt; m_author &lt;&lt; <span class="string">" 被调用."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Book::print_info</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"书籍信息：标题 = \""</span> &lt;&lt; m_title &lt;&lt; <span class="string">"\", 作者 = "</span> &lt;&lt; m_author &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO 3: 注意：对于已删除的构造函数，你不需要在这里提供实现！</span></span><br><span class="line"><span class="comment">// 如果你添加了实现，编译器会报错。</span></span><br></pre></td></tr></table></figure></div>
<p><strong><code>main.cpp</code>:</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Book.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 书籍类测试 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 成功创建一本书 (使用允许的构造函数)</span></span><br><span class="line">    <span class="function">Book <span class="title">book1</span><span class="params">(<span class="string">"The Hitchhiker's Guide to the Galaxy"</span>, <span class="string">"Douglas Adams"</span>)</span></span>;</span><br><span class="line">    book1.print_info();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尝试使用默认构造函数 (预期：编译错误)</span></span><br><span class="line">    <span class="comment">// Book book_default; // 编译时，尝试取消此行注释，观察错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 尝试使用拷贝构造函数 (预期：编译错误)</span></span><br><span class="line">    <span class="comment">// Book book_copy = book1; // 编译时，尝试取消此行注释，观察错误</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--- 测试完成 ---"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>请你完成 <code>Book.h</code> 中 <code>TODO 1</code> 和 <code>TODO 2</code> 的部分，然后运行代码，验证你的修改是否达到了预期的编译错误效果。完成后请将你的解决方案提供给我。</p>
<hr>
<h2 id="🧑‍💻-User-1"><a href="#🧑‍💻-User-1" class="headerlink" title="🧑‍💻 User"></a>🧑‍💻 User</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOOK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 允许的构造函数：通过书名和作者创建书籍</span></span><br><span class="line">    Book(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; title, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; author);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1: 在这里禁用默认构造函数，确保每本书都有书名和作者。</span></span><br><span class="line">    <span class="comment">// 提示：使用 `= delete;` 语法。</span></span><br><span class="line">    <span class="comment">// Book(); // 在这里添加你的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2: 在这里禁用拷贝构造函数，确保Book对象不能被拷贝。</span></span><br><span class="line">    <span class="comment">// 提示：使用 `= delete;` 语法。</span></span><br><span class="line">    <span class="comment">// Book(const Book&amp; other); // 在这里添加你的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印书籍信息</span></span><br><span class="line">    Book() = <span class="keyword">delete</span>;</span><br><span class="line">    Book(<span class="keyword">const</span> Book&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_title;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_author;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// BOOK_H</span></span></span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="🤖-Assistant-1"><a href="#🤖-Assistant-1" class="headerlink" title="🤖 Assistant"></a>🤖 Assistant</h2><p>太棒了！你的解决方案完全正确！</p>
<hr>
<h2 id="8-解决方案评级与讲解-Solution-Rating-and-Explanation"><a href="#8-解决方案评级与讲解-Solution-Rating-and-Explanation" class="headerlink" title="8. 解决方案评级与讲解 (Solution Rating and Explanation)"></a><strong>8. 解决方案评级与讲解 (Solution Rating and Explanation)</strong></h2><p><strong>你的评级：</strong> 满分 (Excellent)!</p>
<p>你完美地完成了任务，正确地在 <code>Book.h</code> 文件中禁用了默认构造函数和拷贝构造函数。</p>
<p><strong>实际答案和解释：</strong></p>
<p>你的 <code>Book.h</code> 文件应该如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOOK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 允许的构造函数：通过书名和作者创建书籍</span></span><br><span class="line">    Book(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; title, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; author);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1: 在这里禁用默认构造函数，确保每本书都有书名和作者。</span></span><br><span class="line">    <span class="comment">// 提示：使用 `= delete;` 语法。</span></span><br><span class="line">    Book() = <span class="keyword">delete</span>; <span class="comment">// &lt;-- 这就是正确答案！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2: 在这里禁用拷贝构造函数，确保Book对象不能被拷贝。</span></span><br><span class="line">    <span class="comment">// 提示：使用 `= delete;` 语法。</span></span><br><span class="line">    Book(<span class="keyword">const</span> Book&amp; other) = <span class="keyword">delete</span>; <span class="comment">// &lt;-- 这也是正确答案！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印书籍信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_title;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_author;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// BOOK_H</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong>你的修改：</strong></p>
<p>你把这两行代码：<br><code>Book() = delete;</code><br><code>Book(const Book&amp; other) = delete;</code><br>正确地放置在了 <code>public</code> 访问说明符下，并且使用了正确的 <code>= delete;</code> 语法。</p>
<p><strong>为什么这是正确的？</strong></p>
<ul>
<li><strong><code>Book() = delete;</code></strong>: 通过这行代码，你明确告诉编译器，<code>Book</code> 类的无参数（默认）构造函数是被“删除”的。这意味着任何尝试通过 <code>Book myBook;</code> 或 <code>Book myBook{};</code> 这样的语法来创建 <code>Book</code> 对象的代码，都会在编译时立即报错。这成功地强制了每本 <code>Book</code> 都必须在创建时提供书名和作者。</li>
<li><strong><code>Book(const Book&amp; other) = delete;</code></strong>: 通过这行代码，你明确禁用了 <code>Book</code> 类的拷贝构造函数。这意味着任何尝试通过 <code>Book book2 = book1;</code> 或 <code>Book book2(book1);</code> 这样的语法来拷贝 <code>Book</code> 对象的代码，也会在编译时收到错误。这确保了每本书籍实例的独一无二性，防止了不必要的复制行为。</li>
</ul>
<p>当你在 <code>main.cpp</code> 中尝试取消注释 <code>Book book_default;</code> 或 <code>Book book_copy = book1;</code> 时，你将得到清晰的编译错误，这正是我们想要达到的效果。</p>
<p>恭喜你！你已经掌握了 <code>= delete;</code> 的基本用法和重要性。</p>
<hr>
<h2 id="9-进一步思考和扩展问题-Suggestions-for-Extended-Questions"><a href="#9-进一步思考和扩展问题-Suggestions-for-Extended-Questions" class="headerlink" title="9. 进一步思考和扩展问题 (Suggestions for Extended Questions)"></a><strong>9. 进一步思考和扩展问题 (Suggestions for Extended Questions)</strong></h2><p>你已经学会了如何使用 <code>= delete;</code> 来禁用构造函数，这是一个非常强大的工具。为了更深入地理解这个概念，我建议你探索以下几个问题：</p>
<ol>
<li><strong>移动构造函数和移动赋值运算符的删除：</strong> 我们今天只删除了默认构造函数和拷贝构造函数。那么，C++11引入的<strong>移动构造函数</strong> (<code>Move Constructor</code>) 和<strong>移动赋值运算符</strong> (<code>Move Assignment Operator</code>) 如何禁用？它们的删除通常意味着什么？（提示：回顾 <code>Point</code> 类的例子中，我们也删除了移动构造函数）。</li>
<li><strong>拷贝赋值运算符的删除：</strong> 除了构造函数，<code>= delete;</code> 还能用来删除<strong>拷贝赋值运算符</strong> (<code>Copy Assignment Operator</code>)，即 <code>operator=</code>。请思考一下，如果你希望一个类是不可拷贝的，除了删除拷贝构造函数，你还需要删除拷贝赋值运算符吗？为什么？</li>
<li><strong>通用函数删除：</strong> <code>= delete;</code> 是否只能用于特殊的成员函数（如构造函数、析构函数、赋值运算符）？它能否用于删除任何普通的成员函数或者甚至非成员函数？如果可以，这有什么实际应用场景？</li>
<li><strong><code>= delete;</code> 与 <code>private</code> 的区别：</strong> 假设你想要禁用一个类的某个构造函数或赋值运算符。除了 <code>= delete;</code>，你是否可以将其声明为 <code>private</code> 来达到类似的目的？这两种方法有什么区别？在什么情况下你会选择 <code>= delete;</code> 而不是 <code>private</code>？（这是一个C++面试中非常常见的问题！）</li>
<li><strong>隐式生成的特殊成员函数：</strong> 如果一个类没有显式声明任何构造函数、析构函数、拷贝构造函数/赋值运算符、移动构造函数/赋值运算符，C++编译器会自动为它生成这些函数。了解这些<strong>隐式生成规则</strong>对于理解何时需要显式使用 <code>= delete;</code> 来禁用它们至关重要。你能查阅资料，总结一下C++中特殊成员函数的隐式生成规则吗？</li>
</ol>
<p>这些问题将帮助你更全面地理解 <code>= delete;</code> 的用途以及C++中对象生命周期和资源管理的复杂性。期待你未来在C++学习中的进步！</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Cpp/">Cpp    </a><a class="post-meta__tags" href="/tags/Coding/">Coding    </a><a class="post-meta__tags" href="/tags/Development/">Development    </a><a class="post-meta__tags" href="/tags/Class/">Class    </a><a class="post-meta__tags" href="/tags/Constructor/">Constructor    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2025/06/08/10-projects/cplusplus/lectures/304%20-%20%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%AA%83%E5%8F%96/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>304 - 移动构造函数窃取</span></div></a></div><div class="next-post pull_right"><a href="/2025/06/08/10-projects/cplusplus/lectures/306%20-%20%20cpp%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>306 -  cpp 初始化列表构造函数详解</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/273 - constructor/" title="273 - constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">273 - constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/300 - cpp构造函数委托/" title="300 - cpp构造函数委托"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">300 - cpp构造函数委托</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/272 - first class/" title="272 - first class"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">272 - first class</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/274 - default constructor/" title="274 - default constructor"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">274 - default constructor</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/275 - getter and setter/" title="275 - getter and setter"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">275 - getter and setter</div></div></a></div><div class="relatedPosts_item"><a href="/2025/06/08/10-projects/cplusplus/lectures/277 - IDE 创建 cpp 类方法/" title="277 - IDE 创建 cpp 类方法"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2025-06-08</div><div class="relatedPosts_title">277 - IDE 创建 cpp 类方法</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = true == true ? true : false;
var verify = true == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xvMxbws16Erd8WUfqxkvHmb5-gzGzoHsz',
  appKey:'4U0Vo7NQIUL0eJzHdkPzdCDr',
  placeholder:'不说话的人会疯掉吗?',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/supersheepbear/blog_source@master/blog/image/20200202103940.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By supersheepbear</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="external nofollow noopener noreferrer"><span>Butterfly</span></a></div><div class="footer_custom_text">外向孤独者患者</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="canvas_nest" color="255,240,245" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>